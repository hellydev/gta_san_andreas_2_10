RD *)*v4;
        if ( v4 == v5 - 2 )
          goto LABEL_13;
      }
      goto LABEL_17;
    }
  }
LABEL_14:
  v6 = *(_QWORD *)((char *)RwEngineInstance + rpMultiTextureModule.globalsOffset + 16);
  (*((void (__fastcall **)(_DWORD, _DWORD))RwEngineInstance + 62))(
    *(_DWORD *)((char *)RwEngineInstance + rpMultiTextureModule.globalsOffset + 20),
    v6);
  (*((void (__fastcall **)(_DWORD, RwChar *, int))RwEngineInstance + 65))(HIDWORD(v6), name, 31);
  v7 = RwStreamOpen(rwSTREAMFILENAME, rwSTREAMREAD, (const void *)HIDWORD(v6));
  v8 = v7;
  if ( !v7 )
    return 0;
  if ( RwStreamFindChunk(v7, 0x20u, 0, 0) )
    v9 = RpMTEffectStreamRead(v8);
  else
    v9 = 0;
  RwStreamClose(v8, 0);
  return v9;
}

//----- (001C5F2C) --------------------------------------------------------
const RpMTEffect_0 *__fastcall RpMTEffectWrite(const RpMTEffect_0 *effect)
{
  RwStream_0 *v2; // r5
  const RpMTEffect_0 *v3; // r4

  v2 = RwStreamOpen(rwSTREAMFILENAME, rwSTREAMWRITE, effect->name);
  if ( !v2 )
    return 0;
  v3 = RpMTEffectStreamWrite(effect, v2);
  RwStreamClose(v2, 0);
  return v3;
}

//----- (001C5F5C) --------------------------------------------------------
RwChar *__fastcall RpMTEffectGetName(RpMTEffect_0 *effect)
{
  return effect->name;
}

//----- (001C5F60) --------------------------------------------------------
void __fastcall RpMatFXMaterialDataSetFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rpMatFXMaterialDataFreeListPreallocBlocks = numBlocksToPrealloc;
  _rpMatFXMaterialDataFreeListBlockSize = blockSize;
}

//----- (001C5F78) --------------------------------------------------------
RwStream_0 *__fastcall _rpMatFXStreamWriteTexture(RwStream_0 *stream, const RwTexture_0 *texture)
{
  const RwTexture_0 *v4; // r0
  RwInt32 ints[3]; // [sp+4h] [bp-Ch] BYREF

  v4 = texture;
  if ( texture )
    v4 = (const RwTexture_0 *)(&dword_0 + 1);
  ints[0] = (RwInt32)v4;
  if ( !RwStreamWriteInt32(stream, ints, 4u) )
    return 0;
  if ( ints[0] && !RwTextureStreamWrite(texture, stream) )
    return 0;
  return stream;
}
// 0: using guessed type int dword_0;
// 1C5F78: using guessed type RwInt32 ints[3];

//----- (001C5FB4) --------------------------------------------------------
RwStream_0 *__fastcall _rpMatFXStreamReadTexture(RwStream_0 *stream, RwTexture_0 **texture)
{
  RwStream_0 *v3; // r4
  RwTexture_0 *v4; // r0
  bool v5; // zf
  RwError_0 code; // [sp+4h] [bp-14h] BYREF
  RwInt32 ints[3]; // [sp+Ch] [bp-Ch] BYREF

  v3 = stream;
  if ( !RwStreamReadInt32(stream, ints, 4u) )
    return 0;
  if ( !ints[0] )
  {
    *texture = 0;
    return v3;
  }
  if ( !RwStreamFindChunk(v3, 6u, 0, 0) )
    return 0;
  RwErrorGet(&code);
  v4 = RwTextureStreamRead(v3);
  *texture = v4;
  if ( !v4 )
  {
    RwErrorGet(&code);
    v5 = code.errorCode == 0x80000000;
    if ( code.errorCode != 0x80000000 )
      v5 = code.errorCode == 22;
    if ( !v5 )
    {
      RwErrorSet(&code);
      return 0;
    }
  }
  return v3;
}
// 1C5FB4: using guessed type RwInt32 ints[3];

//----- (001C6012) --------------------------------------------------------
RwUInt32 __fastcall _rpMatFXStreamSizeTexture(const RwTexture_0 *texture)
{
  if ( texture )
    return RwTextureStreamGetSize(texture) + 16;
  else
    return (RwUInt32)byte_4;
}

//----- (001C6028) --------------------------------------------------------
RwTexture_0 *__fastcall _rpMatFXTextureMaskCreate(const RwTexture_0 *baseTexture, const RwTexture_0 *maskTexture)
{
  RwRaster_0 *raster; // r9
  RwImage_0 *v5; // r10
  RwRaster_0 *v6; // r8
  int v7; // r5
  int v8; // r11
  RwImage_0 *v9; // r6
  int i; // r0
  int j; // r2
  bool v12; // zf
  RwImage_0 *v13; // r11
  RwRaster_0 *v14; // r4
  RwTexture_0 *v15; // r8
  RwUInt32 filterAddressing; // r0
  int v17; // r2
  int v18; // r1
  const RwTexture_0 *v19; // r4
  RwInt32 name; // r0
  int v21; // r1
  __int64 *v22; // r0
  int k; // r1
  char v24; // r2
  RwChar *v25; // r3
  RwChar v26; // r2
  RwInt32 width; // [sp+8h] [bp-60h]
  RwInt32 height; // [sp+Ch] [bp-5Ch]
  const RwTexture_0 *v30; // [sp+10h] [bp-58h]
  const RwTexture_0 *v31; // [sp+14h] [bp-54h]
  RwInt32 v32; // [sp+18h] [bp-50h] BYREF
  RwInt32 npDepth; // [sp+1Ch] [bp-4Ch] BYREF
  RwInt32 npHeight; // [sp+20h] [bp-48h] BYREF
  RwChar *v35; // [sp+24h] [bp-44h]
  __int64 npWidth[4]; // [sp+28h] [bp-40h] BYREF

  raster = maskTexture->raster;
  width = maskTexture->raster->width;
  height = maskTexture->raster->height;
  v5 = RwImageCreate(width, height, 32);
  RwImageAllocatePixels(v5);
  RwImageSetFromRaster(v5, raster);
  v30 = baseTexture;
  v31 = maskTexture;
  if ( baseTexture )
  {
    v6 = baseTexture->raster;
    v7 = baseTexture->raster->height;
    v8 = baseTexture->raster->width;
    v9 = RwImageCreate(v8, v7, 32);
    RwImageAllocatePixels(v9);
    RwImageSetFromRaster(v9, v6);
  }
  else
  {
    v7 = raster->height;
    v8 = raster->width;
    v9 = RwImageCreate(v8, v7, 32);
    RwImageAllocatePixels(v9);
    if ( v7 >= 1 )
    {
      for ( i = 0; i != v7; ++i )
      {
        if ( v8 >= 1 )
        {
          for ( j = 0; j != v8; ++j )
            *(_DWORD *)&v9->cpPixels[4 * j + i * v9->stride] = -1;
        }
      }
    }
    v6 = 0;
  }
  v12 = v7 == height;
  if ( v7 == height )
    v12 = v8 == width;
  if ( v12 )
  {
    v13 = v5;
  }
  else
  {
    v13 = RwImageCreate(v8, v7, 32);
    RwImageAllocatePixels(v13);
    RwImageResample(v13, v5);
    RwImageDestroy(v5);
  }
  RwImageMakeMask(v13);
  RwImageApplyMask(v9, v13);
  RwImageFindRasterFormat(v9, 4, (RwInt32 *)npWidth, &npHeight, &npDepth, &v32);
  if ( baseTexture )
    raster = v6;
  v32 |= (raster->cFormat << 8) & 0x9000;
  v14 = RwRasterCreate(npWidth[0], npHeight, npDepth, v32);
  RwRasterSetFromImage(v14, v9);
  v15 = RwTextureCreate(v14);
  if ( v30 )
  {
    filterAddressing = v30->filterAddressing;
    v17 = 0;
    v18 = (unsigned __int16)filterAddressing >> 12;
    if ( ((filterAddressing >> 8) & 0xF) == v18 )
      v17 = 1;
    v19 = v31;
  }
  else
  {
    v19 = v31;
    v17 = 0;
    filterAddressing = v31->filterAddressing;
    v18 = (unsigned __int16)filterAddressing >> 12;
    if ( ((filterAddressing >> 8) & 0xF) == v18 )
      v17 = 1;
  }
  filterAddressing = (unsigned __int8)filterAddressing;
  if ( !v17 )
    v18 = 0;
  v15->filterAddressing = filterAddressing | (v18 << 8) | (v18 << 12) | v15->filterAddressing & 0xFFFF0000;
  RwImageDestroy(v9);
  RwImageDestroy(v13);
  memset(npWidth, 0, sizeof(npWidth));
  if ( v30 )
  {
    npHeight = (RwInt32)v30->name;
    name = (RwInt32)v19->name;
    v21 = 1;
  }
  else
  {
    name = (RwInt32)v19->name;
    v21 = 0;
    v35 = v19->name;
  }
  *(&npHeight + v21) = name;
  v22 = npWidth;
  for ( k = 0; k < 30; ++k )
  {
    while ( 1 )
    {
      v24 = *(_BYTE *)npHeight;
      if ( !*(_BYTE *)npHeight )
        break;
      ++npHeight;
      v25 = v35;
      ++k;
      *(_BYTE *)v22 = v24;
      v22 = (__int64 *)((char *)v22 + 1);
      v26 = *v25;
      if ( *v25 )
        goto LABEL_34;
      if ( k >= 30 )
        goto LABEL_35;
    }
    v25 = v35;
    v26 = *v35;
    if ( !*v35 )
      break;
LABEL_34:
    *(_BYTE *)v22 = v26;
    v22 = (__int64 *)((char *)v22 + 1);
    v35 = v25 + 1;
  }
LABEL_35:
  *(_BYTE *)v22 = 0;
  RwTextureSetName(v15, (const RwChar *)npWidth);
  return v15;
}

//----- (001C6250) --------------------------------------------------------
bool RpMatFXPluginAttach()
{
  int v0; // r4

  v0 = 0;
  if ( RwEngineRegisterPlugin(0, 0x120u, MatFXOpen, MatFXClose) >= 0 )
  {
    MatFXMaterialDataOffset = RpMaterialRegisterPlugin(
                                4,
                                0x120u,
                                MatFXMaterialConstructor,
                                MatFXMaterialDestructor,
                                MatFXMaterialCopy);
    if ( MatFXMaterialDataOffset < 0 )
      return 0;
    if ( RpMaterialRegisterPluginStream(
           0x120u,
           MatFXMaterialStreamRead,
           MatFXMaterialStreamWrite,
           MatFXMaterialStreamGetSize) < 0 )
      return 0;
    MatFXAtomicDataOffset = RpAtomicRegisterPlugin(
                              4,
                              0x120u,
                              MatFXAtomicConstructor,
                              MatFXAtomicDestructor,
                              MatFXAtomicCopy);
    if ( MatFXAtomicDataOffset < 0 )
      return 0;
    if ( RpAtomicRegisterPluginStream(0x120u, MatFXAtomicStreamRead, MatFXAtomicStreamWrite, MatFXAtomicStreamGetSize) < 0 )
      return 0;
    MatFXWorldSectorDataOffset = RpWorldSectorRegisterPlugin(
                                   4,
                                   0x120u,
                                   MatFXWorldSectorConstructor,
                                   MatFXWorldSectorDestructor,
                                   MatFXWorldSectorCopy);
    return MatFXWorldSectorDataOffset >= 0
        && RpWorldSectorRegisterPluginStream(
             0x120u,
             MatFXWorldSectorStreamRead,
             MatFXWorldSectorStreamWrite,
             MatFXWorldSectorStreamGetSize) >= 0;
  }
  return v0;
}

//----- (001C6388) --------------------------------------------------------
void *__fastcall MatFXOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  RwInt32 numInstances; // r0

  numInstances = MatFXInfo.Module.numInstances;
  if ( !MatFXInfo.Module.numInstances )
  {
    MatFXInfo.MaterialData = RwFreeListCreateAndPreallocateSpace(
                               52,
                               _rpMatFXMaterialDataFreeListBlockSize,
                               4,
                               _rpMatFXMaterialDataFreeListPreallocBlocks,
                               &_rpMatFXMaterialDataFreeList);
    if ( !MatFXInfo.MaterialData || !_rpMatFXPipelinesCreate() )
      return 0;
    numInstances = MatFXInfo.Module.numInstances;
  }
  MatFXInfo.Module.numInstances = numInstances + 1;
  return instance;
}

//----- (001C6400) --------------------------------------------------------
void *__fastcall MatFXClose(void *instance, RwInt32 offset, RwInt32 size)
{
  if ( !--MatFXInfo.Module.numInstances )
    _rpMatFXPipelinesDestroy();
  if ( MatFXInfo.MaterialData )
  {
    RwFreeListDestroy(MatFXInfo.MaterialData);
    MatFXInfo.MaterialData = 0;
  }
  return instance;
}

//----- (001C6440) --------------------------------------------------------
void *__fastcall MatFXMaterialConstructor(void *object, RwInt32 offset, RwInt32 size)
{
  *(_DWORD *)((char *)object + MatFXMaterialDataOffset) = 0;
  return object;
}

//----- (001C6454) --------------------------------------------------------
void *__fastcall MatFXMaterialDestructor(void *object, RwInt32 offset, RwInt32 size)
{
  int v4; // r5

  v4 = *(_DWORD *)((char *)object + MatFXMaterialDataOffset);
  if ( v4 )
  {
    MatFXMaterialDataClean(*(rpMatFXMaterialData_0 **)((char *)object + MatFXMaterialDataOffset));
    (*((void (__fastcall **)(RwFreeList_0 *, int))RwEngineInstance + 80))(MatFXInfo.MaterialData, v4);
    *(_DWORD *)((char *)object + MatFXMaterialDataOffset) = 0;
  }
  return object;
}

//----- (001C64A4) --------------------------------------------------------
void *__fastcall MatFXMaterialCopy(void *dstObject, const void *srcObject, RwInt32 offset, RwInt32 size)
{
  char *v5; // r9
  int v6; // r11
  int v7; // r2
  void *result; // r0
  int v9; // r10
  int v10; // r0
  int v11; // r2
  int v12; // r3
  int v13; // r5
  int v14; // r2
  int v15; // r1
  int v16; // r2
  int v17; // r0
  RwInt32 v18; // r1
  int v19; // r0
  int v20; // r2
  int v21; // r6
  int v22; // r0
  __int64 v23; // kr00_8
  int v24; // r11
  int v25; // r0
  int v26; // r2
  RwInt32 v27; // r0
  int v28; // r1
  int v29; // r2
  RwTexture_0 *v30; // r5
  __int64 v31; // kr08_8
  int v32; // r0
  int v33; // r1
  int v34; // r1
  int v35; // r0
  int v36; // r2
  int v37; // r6
  int v38; // r1
  int v39; // r2
  int v40; // r9
  MatFXDualData_0 *v41; // r6
  RwTexture_0 *v42; // r0
  RwInt32 v43; // r0
  int v44; // r0
  int v45; // r1
  int v46; // r6
  char *v47; // [sp+Ch] [bp-3Ch]
  int v48; // [sp+24h] [bp-24h]
  int v49; // [sp+28h] [bp-20h]

  v5 = (char *)srcObject;
  v6 = *(_DWORD *)((char *)srcObject + MatFXMaterialDataOffset);
  if ( v6 )
  {
    v7 = *(_DWORD *)((char *)dstObject + MatFXMaterialDataOffset);
    if ( !v7 )
    {
      v7 = (*((int (__fastcall **)(RwFreeList_0 *))RwEngineInstance + 79))(MatFXInfo.MaterialData);
      result = 0;
      if ( !v7 )
        return result;
      *(_DWORD *)(v7 + 48) = 0;
      *(_QWORD *)(v7 + 32) = 0LL;
      *(_QWORD *)(v7 + 40) = 0LL;
      *(_QWORD *)v7 = 0LL;
      *(_QWORD *)(v7 + 8) = 0LL;
      *(_QWORD *)(v7 + 16) = 0LL;
      *(_QWORD *)(v7 + 24) = 0LL;
      *(_DWORD *)((char *)dstObject + MatFXMaterialDataOffset) = v7;
    }
    v48 = v7;
    RpMatFXMaterialSetEffects((RpMaterial_0 *)dstObject, *(RpMatFXMaterialFlags_0 *)(v6 + 48));
    v9 = 0;
    v47 = v5;
    v49 = v6;
    while ( 2 )
    {
      v10 = v6 + v9;
      switch ( *(_DWORD *)(v6 + v9 + 20) )
      {
        case 1:
          v11 = *(_DWORD *)&v5[MatFXMaterialDataOffset];
          v12 = (*(_DWORD *)(v11 + 20) != 1) | (2 * (*(_DWORD *)(v11 + 20) != 1));
          v13 = *(_DWORD *)(v11 + 8 * v12);
          v14 = *(_DWORD *)(v11 + 8 * v12 + 12);
          *(_DWORD *)(*(_DWORD *)((char *)dstObject + MatFXMaterialDataOffset)
                    + 8
                    * ((*(_DWORD *)(*(_DWORD *)((char *)dstObject + MatFXMaterialDataOffset) + 20) != 1) | (2 * (*(_DWORD *)(*(_DWORD *)((char *)dstObject + MatFXMaterialDataOffset) + 20) != 1)))) = v13;
          *(_DWORD *)(*(_DWORD *)((char *)dstObject + MatFXMaterialDataOffset)
                    + 8
                    * ((*(_DWORD *)(*(_DWORD *)((char *)dstObject + MatFXMaterialDataOffset) + 20) != 1) | (2 * (*(_DWORD *)(*(_DWORD *)((char *)dstObject + MatFXMaterialDataOffset) + 20) != 1)))
                    + 12) = v14;
          v15 = *(_DWORD *)(v10 + 4);
          v16 = v48 + v9;
          *(_DWORD *)(v16 + 4) = v15;
          v17 = *(_DWORD *)(v10 + 8);
          *(_DWORD *)(v16 + 8) = v17;
          if ( v15 )
          {
            ++*(_DWORD *)(v15 + 84);
            v17 = *(_DWORD *)(v16 + 8);
          }
          if ( v17 )
            ++*(_DWORD *)(v17 + 84);
          goto LABEL_42;
        case 2:
          v18 = MatFXMaterialDataOffset;
          v19 = *(_DWORD *)&v5[MatFXMaterialDataOffset];
          v20 = (*(_DWORD *)(v19 + 20) != 2) | (2 * (*(_DWORD *)(v19 + 20) != 2));
          v21 = *(_DWORD *)(v19 + 8 * v20);
          v22 = v19 + 8 * v20;
          v23 = *(_QWORD *)(v22 + 4);
          v24 = *(_DWORD *)(v22 + 12);
          if ( !(_DWORD)v23 )
            goto LABEL_29;
          v25 = *(_DWORD *)((char *)dstObject + MatFXMaterialDataOffset);
          if ( *(_DWORD *)(v25 + 20) == 2 )
          {
            v26 = 0;
          }
          else
          {
            if ( *(_DWORD *)(v25 + 44) != 2 )
            {
              v40 = 0;
              goto LABEL_26;
            }
            v26 = 1;
          }
          v40 = v25 + 24 * v26;
LABEL_26:
          ++*(_DWORD *)(v23 + 84);
          v42 = *(RwTexture_0 **)(v40 + 4);
          if ( v42 )
          {
            RwTextureDestroy(v42);
            *(_DWORD *)(v40 + 4) = 0;
            v18 = MatFXMaterialDataOffset;
          }
          *(_DWORD *)(v40 + 4) = v23;
          v5 = v47;
LABEL_29:
          *(_DWORD *)(*(_DWORD *)((char *)dstObject + v18)
                    + 8
                    * ((*(_DWORD *)(*(_DWORD *)((char *)dstObject + v18) + 20) != 2) | (2
                                                                                      * (*(_DWORD *)(*(_DWORD *)((char *)dstObject + v18) + 20) != 2)))) = v21;
          v43 = MatFXMaterialDataOffset;
          *(_DWORD *)(*(_DWORD *)((char *)dstObject + MatFXMaterialDataOffset)
                    + 8
                    * ((*(_DWORD *)(*(_DWORD *)((char *)dstObject + MatFXMaterialDataOffset) + 20) != 2) | (2 * (*(_DWORD *)(*(_DWORD *)((char *)dstObject + MatFXMaterialDataOffset) + 20) != 2)))
                    + 12) = v24;
          *(_DWORD *)(*(_DWORD *)((char *)dstObject + v43)
                    + 8
                    * ((*(_DWORD *)(*(_DWORD *)((char *)dstObject + v43) + 20) != 2) | (2
                                                                                      * (*(_DWORD *)(*(_DWORD *)((char *)dstObject + v43) + 20) != 2)))
                    + 8) = HIDWORD(v23);
          goto LABEL_41;
        case 4:
          v27 = MatFXMaterialDataOffset;
          v28 = *(_DWORD *)&v5[MatFXMaterialDataOffset];
          v29 = (*(_DWORD *)(v28 + 20) != 4) | (2 * (*(_DWORD *)(v28 + 20) != 4));
          v30 = *(RwTexture_0 **)(v28 + 8 * v29);
          v31 = *(_QWORD *)(v28 + 8 * v29 + 4);
          if ( !v30 )
            goto LABEL_34;
          v32 = *(_DWORD *)((char *)dstObject + MatFXMaterialDataOffset);
          if ( *(_DWORD *)(v32 + 20) == 4 )
          {
            v33 = 0;
LABEL_24:
            v41 = (MatFXDualData_0 *)(v32 + 24 * v33);
            goto LABEL_31;
          }
          if ( *(_DWORD *)(v32 + 44) == 4 )
          {
            v33 = 1;
            goto LABEL_24;
          }
          v41 = 0;
LABEL_31:
          ++v30->refCount;
          if ( v41->texture )
          {
            RwTextureDestroy(v41->texture);
            v41->texture = 0;
          }
          v41->texture = v30;
          _rpMatFXSetupDualRenderState(v41, rwRENDERSTATETEXTUREADDRESS);
          _rpMatFXSetupDualRenderState(v41, rwRENDERSTATETEXTURERASTER);
          v27 = MatFXMaterialDataOffset;
LABEL_34:
          v44 = *(_DWORD *)((char *)dstObject + v27);
          if ( *(_DWORD *)(v44 + 20) == 4 )
          {
            v45 = 0;
LABEL_38:
            v46 = v44 + 24 * v45;
            goto LABEL_40;
          }
          if ( *(_DWORD *)(v44 + 44) == 4 )
          {
            v45 = 1;
            goto LABEL_38;
          }
          v46 = 0;
LABEL_40:
          *(_QWORD *)(v46 + 4) = v31;
          _rpMatFXSetupDualRenderState((MatFXDualData_0 *)v46, rwRENDERSTATESRCBLEND);
          _rpMatFXSetupDualRenderState((MatFXDualData_0 *)v46, rwRENDERSTATEDESTBLEND);
LABEL_41:
          v6 = v49;
LABEL_42:
          v9 += 24;
          if ( v9 == 48 )
            return dstObject;
          continue;
        case 5:
          v34 = *(_DWORD *)&v5[MatFXMaterialDataOffset];
          v35 = *(_DWORD *)((char *)dstObject + MatFXMaterialDataOffset);
          v36 = (*(_DWORD *)(v34 + 20) != 5) | (2 * (*(_DWORD *)(v34 + 20) != 5));
          v37 = *(_DWORD *)(v34 + 8 * v36);
          v38 = *(_DWORD *)(v34 + 8 * v36 + 4);
          v39 = (*(_DWORD *)(v35 + 20) != 5) | (2 * (*(_DWORD *)(v35 + 20) != 5));
          *(_DWORD *)(v35 + 8 * v39) = v37;
          *(_DWORD *)(v35 + 8 * v39 + 4) = v38;
          goto LABEL_42;
        default:
          goto LABEL_42;
      }
    }
  }
  return 0;
}

//----- (001C67F4) --------------------------------------------------------
RwStream_0 *__fastcall MatFXMaterialStreamRead(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  int v7; // r5
  int v8; // r0
  RwStream_0 *v9; // r6
  float *v10; // r9
  unsigned int v11; // r8
  RwStream_0 *v12; // r1
  RwInt32 v13; // r0
  RwTexture_0 *v14; // r11
  int v15; // r0
  int v16; // r1
  RwTexture_0 *v17; // r5
  int v18; // r0
  int v19; // r1
  RwTexture_0 *v20; // r5
  MatFXDualData_0 *v21; // r5
  int v22; // r6
  int v23; // r2
  int v24; // r3
  int v25; // r5
  RwTexture_0 *v26; // r0
  RwInt32 v27; // r0
  __int64 reals; // [sp+18h] [bp-40h] BYREF
  RwTexture_0 *v30; // [sp+20h] [bp-38h] BYREF
  RwInt32 v31; // [sp+24h] [bp-34h] BYREF
  RwInt32 v32; // [sp+28h] [bp-30h] BYREF
  RwInt32 ints[11]; // [sp+2Ch] [bp-2Ch] BYREF

  v7 = *(_DWORD *)((char *)object + MatFXMaterialDataOffset);
  if ( !v7 )
  {
    v8 = (*((int (__fastcall **)(RwFreeList_0 *))RwEngineInstance + 79))(MatFXInfo.MaterialData);
    v7 = v8;
    v9 = 0;
    if ( !v8 )
      return v9;
    *(_DWORD *)(v8 + 48) = 0;
    *(_QWORD *)(v8 + 32) = 0LL;
    *(_QWORD *)(v8 + 40) = 0LL;
    *(_QWORD *)v8 = 0LL;
    *(_QWORD *)(v8 + 8) = 0LL;
    *(_QWORD *)(v8 + 16) = 0LL;
    *(_QWORD *)(v8 + 24) = 0LL;
    *(_DWORD *)((char *)object + MatFXMaterialDataOffset) = v8;
  }
  v9 = 0;
  if ( RwStreamReadInt32(stream, ints, 4u) )
  {
    RpMatFXMaterialSetEffects((RpMaterial_0 *)object, (RpMatFXMaterialFlags_0)ints[0]);
    v10 = (float *)(v7 + 16);
    v11 = 0;
    while ( 1 )
    {
      if ( !RwStreamReadInt32(stream, &v32, 4u) )
        return 0;
      if ( v32 == 4 )
        break;
      if ( v32 == 2 )
      {
        v30 = 0;
        if ( !RwStreamReadReal(stream, (RwReal *)&reals, 4u)
          || !RwStreamReadInt32(stream, &v31, 4u)
          || !_rpMatFXStreamReadTexture(stream, &v30) )
        {
          return 0;
        }
        v17 = v30;
        if ( v30 )
        {
          v18 = *(_DWORD *)((char *)object + MatFXMaterialDataOffset);
          if ( *(_DWORD *)(v18 + 20) == 2 )
          {
            v19 = 0;
            goto LABEL_33;
          }
          if ( *(_DWORD *)(v18 + 44) == 2 )
          {
            v19 = 1;
LABEL_33:
            v22 = v18 + 24 * v19;
          }
          else
          {
            v22 = 0;
          }
          ++v30->refCount;
          v26 = *(RwTexture_0 **)(v22 + 4);
          if ( v26 )
          {
            RwTextureDestroy(v26);
            *(_DWORD *)(v22 + 4) = 0;
          }
          *(_DWORD *)(v22 + 4) = v17;
          RwTextureDestroy(v17);
        }
        v27 = MatFXMaterialDataOffset;
        *(_DWORD *)(*(_DWORD *)((char *)object + MatFXMaterialDataOffset)
                  + 8
                  * ((*(_DWORD *)(*(_DWORD *)((char *)object + MatFXMaterialDataOffset) + 20) != 2) | (2 * (*(_DWORD *)(*(_DWORD *)((char *)object + MatFXMaterialDataOffset) + 20) != 2)))
                  + 8) = reals;
        *(_DWORD *)(*(_DWORD *)((char *)object + v27)
                  + 8
                  * ((*(_DWORD *)(*(_DWORD *)((char *)object + v27) + 20) != 2) | (2
                                                                                 * (*(_DWORD *)(*(_DWORD *)((char *)object + v27)
                                                                                              + 20) != 2)))
                  + 12) = v31;
        goto LABEL_52;
      }
      if ( v32 == 1 )
      {
        v30 = 0;
        v31 = 0;
        if ( !RwStreamReadReal(stream, (RwReal *)&reals, 4u) || !_rpMatFXStreamReadTexture(stream, (RwTexture_0 **)&v31) )
          return 0;
        v12 = _rpMatFXStreamReadTexture(stream, &v30);
        v13 = v31;
        if ( !v12 )
        {
          if ( v31 )
            RwTextureDestroy((RwTexture_0 *)v31);
          return 0;
        }
        if ( v31 )
        {
          *((_DWORD *)v10 - 3) = v31;
          *((_DWORD *)v10 - 2) = v30;
          *v10 = 1.0 / (float)*(int *)(*(_DWORD *)v13 + 12);
        }
        else
        {
          v20 = v30;
          if ( v30 )
          {
            RpMatFXMaterialSetBumpMapTexture((RpMaterial_0 *)object, v30);
            RwTextureDestroy(v20);
          }
          else
          {
            *(v10 - 3) = 0.0;
            *(v10 - 2) = 0.0;
          }
        }
        *(float *)(*(_DWORD *)((char *)object + MatFXMaterialDataOffset)
                 + 8
                 * ((*(_DWORD *)(*(_DWORD *)((char *)object + MatFXMaterialDataOffset) + 20) != 1) | (2 * (*(_DWORD *)(*(_DWORD *)((char *)object + MatFXMaterialDataOffset) + 20) != 1)))
                 + 12) = -*(float *)&reals;
      }
LABEL_52:
      ++v11;
      v10 += 6;
      if ( v11 >= 2 )
        return stream;
    }
    v31 = 0;
    if ( !RwStreamReadInt32(stream, (RwInt32 *)&reals, 8u) || !_rpMatFXStreamReadTexture(stream, (RwTexture_0 **)&v31) )
      return 0;
    v14 = (RwTexture_0 *)v31;
    if ( !v31 )
    {
LABEL_38:
      v23 = *(_DWORD *)((char *)object + MatFXMaterialDataOffset);
      if ( *(_DWORD *)(v23 + 20) == 4 )
      {
        v24 = 0;
      }
      else
      {
        if ( *(_DWORD *)(v23 + 44) != 4 )
        {
          v25 = 0;
          goto LABEL_44;
        }
        v24 = 1;
      }
      v25 = v23 + 24 * v24;
LABEL_44:
      *(_QWORD *)(v25 + 4) = reals;
      _rpMatFXSetupDualRenderState((MatFXDualData_0 *)v25, rwRENDERSTATESRCBLEND);
      _rpMatFXSetupDualRenderState((MatFXDualData_0 *)v25, rwRENDERSTATEDESTBLEND);
      goto LABEL_52;
    }
    v15 = *(_DWORD *)((char *)object + MatFXMaterialDataOffset);
    if ( *(_DWORD *)(v15 + 20) == 4 )
    {
      v16 = 0;
    }
    else
    {
      if ( *(_DWORD *)(v15 + 44) != 4 )
      {
        v21 = 0;
        goto LABEL_35;
      }
      v16 = 1;
    }
    v21 = (MatFXDualData_0 *)(v15 + 24 * v16);
LABEL_35:
    ++*(_DWORD *)(v31 + 84);
    if ( v21->texture )
    {
      RwTextureDestroy(v21->texture);
      v21->texture = 0;
    }
    v21->texture = v14;
    _rpMatFXSetupDualRenderState(v21, rwRENDERSTATETEXTUREADDRESS);
    _rpMatFXSetupDualRenderState(v21, rwRENDERSTATETEXTURERASTER);
    RwTextureDestroy(v14);
    goto LABEL_38;
  }
  return v9;
}
// 1C67F4: using guessed type RwInt32 ints[11];

//----- (001C6B40) --------------------------------------------------------
RwStream_0 *__fastcall MatFXMaterialStreamWrite(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        const void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  RwStream_0 *v5; // r4
  int v6; // r5
  RwInt32 *v7; // r5
  unsigned int v8; // r9
  const RwTexture_0 *v9; // r6
  RwInt32 v10; // r0
  const RwTexture_0 *v11; // r6
  RwInt32 v12; // r0
  const RwTexture_0 *v13; // r6
  RwInt32 v14; // r0
  RwReal reals; // [sp+4h] [bp-2Ch] BYREF
  RwInt32 v17; // [sp+8h] [bp-28h] BYREF
  RwInt32 ints; // [sp+Ch] [bp-24h] BYREF
  RwInt32 v19[8]; // [sp+10h] [bp-20h] BYREF

  v5 = stream;
  v6 = *(_DWORD *)((char *)object + MatFXMaterialDataOffset);
  ints = *(_DWORD *)(v6 + 48);
  if ( RwStreamWriteInt32(stream, &ints, 4u) )
  {
    v7 = (RwInt32 *)(v6 + 20);
    v8 = 0;
    while ( 1 )
    {
      v17 = *v7;
      if ( !RwStreamWriteInt32(v5, &v17, 4u) )
        return 0;
      if ( v17 == 4 )
      {
        ints = *(v7 - 4);
        if ( !RwStreamWriteInt32(v5, &ints, 4u) )
          return 0;
        ints = *(v7 - 3);
        if ( !RwStreamWriteInt32(v5, &ints, 4u) )
          return 0;
        v13 = (const RwTexture_0 *)*(v7 - 5);
      }
      else
      {
        if ( v17 != 2 )
        {
          if ( v17 == 1 )
          {
            reals = -*((float *)v7 - 2);
            if ( !RwStreamWriteReal(v5, &reals, 4u) )
              return 0;
            v9 = (const RwTexture_0 *)*(v7 - 4);
            v10 = (RwInt32)v9;
            if ( v9 )
              v10 = 1;
            v19[0] = v10;
            if ( !RwStreamWriteInt32(v5, v19, 4u) || v19[0] && !RwTextureStreamWrite(v9, v5) )
              return 0;
            if ( !v5 )
              return 0;
            v11 = (const RwTexture_0 *)*(v7 - 3);
            v12 = (RwInt32)v11;
            if ( v11 )
              v12 = 1;
            v19[0] = v12;
            if ( !RwStreamWriteInt32(v5, v19, 4u) || v19[0] && !RwTextureStreamWrite(v11, v5) )
              return 0;
          }
          goto LABEL_32;
        }
        if ( !RwStreamWriteReal(v5, (const RwReal *)v7 - 3, 4u) )
          return 0;
        ints = *(v7 - 2);
        if ( !RwStreamWriteInt32(v5, &ints, 4u) )
          return 0;
        v13 = (const RwTexture_0 *)*(v7 - 4);
      }
      v14 = (RwInt32)v13;
      if ( v13 )
        v14 = 1;
      v19[0] = v14;
      if ( !RwStreamWriteInt32(v5, v19, 4u) || v19[0] && !RwTextureStreamWrite(v13, v5) || !v5 )
        return 0;
LABEL_32:
      ++v8;
      v7 += 6;
      if ( v8 >= 2 )
        return v5;
    }
  }
  return 0;
}

//----- (001C6CAC) --------------------------------------------------------
RwInt32 __fastcall MatFXMaterialStreamGetSize(const void *object, RwInt32 offsetInObject, RwInt32 sizeInObject)
{
  const RwTexture_0 **v3; // r4
  bool v4; // zf
  const RwTexture_0 *v5; // r0
  const RwTexture_0 *v6; // r0
  RwUInt32 v7; // r5
  const RwTexture_0 **v9; // r0
  int v10; // r1
  const RwTexture_0 *v11; // r0
  RwUInt32 v12; // r0
  const RwTexture_0 *v13; // r0
  const RwTexture_0 **v14; // r0
  const RwTexture_0 *v15; // r0
  int v16; // r5
  RwUInt32 v17; // r0
  int v18; // r5
  const RwTexture_0 *v19; // r0

  v3 = *(const RwTexture_0 ***)((char *)object + MatFXMaterialDataOffset);
  v4 = v3 == 0;
  if ( v3 )
    v4 = v3[12] == 0;
  if ( v4 )
    return 0;
  v5 = v3[5];
  if ( v5 == (const RwTexture_0 *)byte_4 )
  {
    v7 = 16;
    v9 = v3;
  }
  else if ( v5 == (const RwTexture_0 *)((char *)&dword_0 + 2) )
  {
    v9 = v3 + 1;
    v7 = 16;
  }
  else
  {
    if ( v5 != (const RwTexture_0 *)((char *)&dword_0 + 1) )
    {
      v10 = 8;
      goto LABEL_19;
    }
    v6 = v3[1];
    if ( v6 )
      v7 = RwTextureStreamGetSize(v6) + 28;
    else
      v7 = 16;
    v9 = v3 + 2;
  }
  v11 = *v9;
  if ( v11 )
    v12 = RwTextureStreamGetSize(v11) + 16;
  else
    v12 = 4;
  v10 = v12 + v7;
LABEL_19:
  v13 = v3[11];
  if ( v13 == (const RwTexture_0 *)((char *)&dword_0 + 1) )
  {
    v15 = v3[7];
    v16 = v10 + 8;
    if ( v15 )
      v17 = RwTextureStreamGetSize(v15) + 16;
    else
      v17 = 4;
    v18 = v16 + v17;
    v14 = v3 + 8;
  }
  else
  {
    if ( v13 == (const RwTexture_0 *)((char *)&dword_0 + 2) )
    {
      v14 = v3 + 7;
    }
    else
    {
      if ( v13 != (const RwTexture_0 *)byte_4 )
        return v10 + 4;
      v14 = v3 + 6;
    }
    v18 = v10 + 12;
  }
  v19 = *v14;
  if ( v19 )
    return RwTextureStreamGetSize(v19) + 16 + v18;
  else
    return v18 + 4;
}
// 0: using guessed type int dword_0;

//----- (001C6D5C) --------------------------------------------------------
void *__fastcall MatFXAtomicConstructor(void *object, RwInt32 offset, RwInt32 size)
{
  *(_DWORD *)((char *)object + MatFXAtomicDataOffset) = 0;
  return object;
}

//----- (001C6D6C) --------------------------------------------------------
void *__fastcall MatFXAtomicDestructor(void *object, RwInt32 offset, RwInt32 size)
{
  *(_DWORD *)((char *)object + MatFXAtomicDataOffset) = 0;
  return object;
}

//----- (001C6D7C) --------------------------------------------------------
void *__fastcall MatFXAtomicCopy(void *dstObject, const void *srcObject, RwInt32 offset, RwInt32 size)
{
  if ( *(_DWORD *)((char *)srcObject + MatFXAtomicDataOffset) )
    *(_DWORD *)((char *)dstObject + MatFXAtomicDataOffset) = 1;
  return dstObject;
}

//----- (001C6D94) --------------------------------------------------------
RwStream_0 *__fastcall MatFXAtomicStreamRead(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  RwStream_0 *v6; // r4
  RwInt32 v7; // r6
  RwInt32 ints[5]; // [sp+4h] [bp-14h] BYREF

  v6 = stream;
  if ( !RwStreamReadInt32(stream, ints, 4u) )
    return 0;
  if ( ints[0] )
  {
    v7 = MatFXAtomicDataOffset;
    if ( !*(_DWORD *)((char *)object + MatFXAtomicDataOffset) )
    {
      if ( _rpMatFXPipelineAtomicSetup((RpAtomic_0 *)object) )
        *(_DWORD *)((char *)object + v7) = 1;
    }
  }
  return v6;
}
// 1C6D94: using guessed type RwInt32 ints[5];

//----- (001C6DDC) --------------------------------------------------------
RwStream_0 *__fastcall MatFXAtomicStreamWrite(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        const void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  RwInt32 ints[3]; // [sp+4h] [bp-Ch] BYREF

  ints[0] = *(_DWORD *)((char *)object + MatFXAtomicDataOffset);
  return RwStreamWriteInt32(stream, ints, 4u);
}
// 1C6DDC: using guessed type RwInt32 ints[3];

//----- (001C6DFC) --------------------------------------------------------
RwInt32 __fastcall MatFXAtomicStreamGetSize(const void *object, RwInt32 offsetInObject, RwInt32 sizeInObject)
{
  RwInt32 result; // r0

  result = *(_DWORD *)((char *)object + MatFXAtomicDataOffset);
  if ( result )
    return 4;
  return result;
}

//----- (001C6E10) --------------------------------------------------------
void *__fastcall MatFXWorldSectorConstructor(void *object, RwInt32 offset, RwInt32 size)
{
  *(_DWORD *)((char *)object + MatFXWorldSectorDataOffset) = 0;
  return object;
}

//----- (001C6E20) --------------------------------------------------------
void *__fastcall MatFXWorldSectorDestructor(void *object, RwInt32 offset, RwInt32 size)
{
  *(_DWORD *)((char *)object + MatFXWorldSectorDataOffset) = 0;
  return object;
}

//----- (001C6E30) --------------------------------------------------------
void *__fastcall MatFXWorldSectorCopy(void *dstObject, const void *srcObject, RwInt32 offset, RwInt32 size)
{
  if ( *(_DWORD *)((char *)srcObject + MatFXWorldSectorDataOffset) )
    *(_DWORD *)((char *)dstObject + MatFXWorldSectorDataOffset) = 1;
  return dstObject;
}

//----- (001C6E48) --------------------------------------------------------
RwStream_0 *__fastcall MatFXWorldSectorStreamRead(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  RwStream_0 *v6; // r4
  RwInt32 v7; // r6
  RwInt32 ints[5]; // [sp+4h] [bp-14h] BYREF

  v6 = stream;
  if ( !RwStreamReadInt32(stream, ints, 4u) )
    return 0;
  if ( ints[0] )
  {
    v7 = MatFXWorldSectorDataOffset;
    if ( !*(_DWORD *)((char *)object + MatFXWorldSectorDataOffset) )
    {
      if ( _rpMatFXPipelineWorldSectorSetup((RpWorldSector_0 *)object) )
        *(_DWORD *)((char *)object + v7) = 1;
    }
  }
  return v6;
}
// 1C6E48: using guessed type RwInt32 ints[5];

//----- (001C6E90) --------------------------------------------------------
RwStream_0 *__fastcall MatFXWorldSectorStreamWrite(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        const void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  RwInt32 ints[3]; // [sp+4h] [bp-Ch] BYREF

  ints[0] = *(_DWORD *)((char *)object + MatFXWorldSectorDataOffset);
  return RwStreamWriteInt32(stream, ints, 4u);
}
// 1C6E90: using guessed type RwInt32 ints[3];

//----- (001C6EB0) --------------------------------------------------------
RwInt32 __fastcall MatFXWorldSectorStreamGetSize(const void *object, RwInt32 offsetInObject, RwInt32 sizeInObject)
{
  RwInt32 result; // r0

  result = *(_DWORD *)((char *)object + MatFXWorldSectorDataOffset);
  if ( result )
    return 4;
  return result;
}

//----- (001C6EC4) --------------------------------------------------------
RpAtomic_0 *__fastcall RpMatFXAtomicEnableEffects(RpAtomic_0 *atomic)
{
  RpAtomic_0 *v1; // r4
  RwInt32 v2; // r5

  v1 = atomic;
  v2 = MatFXAtomicDataOffset;
  if ( !*(_DWORD *)(&atomic->object.object.type + MatFXAtomicDataOffset) )
  {
    if ( _rpMatFXPipelineAtomicSetup(atomic) )
    {
      *(_DWORD *)(&v1->object.object.type + v2) = 1;
      return v1;
    }
    else
    {
      return 0;
    }
  }
  return atomic;
}

//----- (001C6EF4) --------------------------------------------------------
RwBool __fastcall RpMatFXAtomicQueryEffects(RpAtomic_0 *atomic)
{
  return *(_DWORD *)(&atomic->object.object.type + MatFXAtomicDataOffset);
}

//----- (001C6F04) --------------------------------------------------------
RpWorldSector_0 *__fastcall RpMatFXWorldSectorEnableEffects(RpWorldSector_0 *worldSector)
{
  RpWorldSector_0 *v1; // r4
  RwInt32 v2; // r5

  v1 = worldSector;
  v2 = MatFXWorldSectorDataOffset;
  if ( !*(RwInt32 *)((char *)&worldSector->type + MatFXWorldSectorDataOffset) )
  {
    if ( _rpMatFXPipelineWorldSectorSetup(worldSector) )
    {
      *(RwInt32 *)((char *)&v1->type + v2) = 1;
      return v1;
    }
    else
    {
      return 0;
    }
  }
  return worldSector;
}

//----- (001C6F34) --------------------------------------------------------
RwBool __fastcall RpMatFXWorldSectorQueryEffects(RpWorldSector_0 *worldSector)
{
  return *(RwInt32 *)((char *)&worldSector->type + MatFXWorldSectorDataOffset);
}

//----- (001C6F44) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMatFXMaterialSetEffects(RpMaterial_0 *material, RpMatFXMaterialFlags_0 flags)
{
  RpMaterial_0 *v2; // r4
  int v4; // r5
  int v5; // r0
  bool v6; // zf
  int v7; // r0
  int v9; // r0
  int v10; // r1
  int v11; // r5

  v2 = material;
  v4 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( v4 )
  {
    if ( flags == rpMATFXEFFECTNULL )
    {
LABEL_9:
      MatFXMaterialDataClean((rpMatFXMaterialData_0 *)v4);
      goto LABEL_10;
    }
  }
  else
  {
    v4 = (*((int (__fastcall **)(RwFreeList_0 *))RwEngineInstance + 79))(MatFXInfo.MaterialData);
    if ( !v4 )
      return 0;
    *(_DWORD *)(v4 + 48) = 0;
    *(_QWORD *)(v4 + 32) = 0LL;
    *(_QWORD *)(v4 + 40) = 0LL;
    *(_QWORD *)v4 = 0LL;
    *(_QWORD *)(v4 + 8) = 0LL;
    *(_QWORD *)(v4 + 16) = 0LL;
    *(_QWORD *)(v4 + 24) = 0LL;
    *(RwTexture_0 **)((char *)&v2->texture + MatFXMaterialDataOffset) = (RwTexture_0 *)v4;
    if ( flags == rpMATFXEFFECTNULL )
      goto LABEL_9;
  }
  v5 = *(_DWORD *)(v4 + 48);
  v6 = v5 == 0;
  if ( v5 )
    v6 = v5 == flags;
  if ( !v6 )
    goto LABEL_9;
LABEL_10:
  *(_DWORD *)(v4 + 48) = flags;
  switch ( flags )
  {
    case rpMATFXEFFECTBUMPMAP:
      goto LABEL_13;
    case rpMATFXEFFECTENVMAP:
      v7 = 2;
      goto LABEL_15;
    case rpMATFXEFFECTBUMPENVMAP:
      *(_DWORD *)(v4 + 44) = 2;
LABEL_13:
      v7 = 1;
      goto LABEL_15;
    case rpMATFXEFFECTDUAL:
      *(_DWORD *)(v4 + 20) = 4;
      v9 = *(int *)((char *)&v2->texture + MatFXMaterialDataOffset);
      if ( *(_DWORD *)(v9 + 20) == 4 )
      {
        v10 = 0;
LABEL_22:
        v11 = v9 + 24 * v10;
        goto LABEL_24;
      }
      if ( *(_DWORD *)(v9 + 44) == 4 )
      {
        v10 = 1;
        goto LABEL_22;
      }
      v11 = 0;
LABEL_24:
      *(_DWORD *)(v11 + 4) = 5;
      *(_DWORD *)(v11 + 8) = 6;
      _rpMatFXSetupDualRenderState((MatFXDualData_0 *)v11, rwRENDERSTATESRCBLEND);
      _rpMatFXSetupDualRenderState((MatFXDualData_0 *)v11, rwRENDERSTATEDESTBLEND);
      break;
    case rpMATFXEFFECTUVTRANSFORM:
      v7 = 5;
LABEL_15:
      *(_DWORD *)(v4 + 20) = v7;
      return v2;
    default:
      return v2;
  }
  return v2;
}

//----- (001C7038) --------------------------------------------------------
rpMatFXMaterialData_0 *__fastcall MatFXMaterialDataClean(rpMatFXMaterialData_0 *materialData)
{
  RwTexture_0 *texture; // r0
  RwTexture_0 *bumpTexture; // r0
  RwTexture_0 *v4; // r0
  RwTexture_0 *v5; // r0
  rpMatFXMaterialData_0 *result; // r0
  RwReal *p_invBumpWidth; // r4

  switch ( materialData->data[0].flag )
  {
    case rpMATFXEFFECTBUMPMAP:
      texture = materialData->data[0].data.bumpMap.texture;
      if ( texture )
        RwTextureDestroy(texture);
      bumpTexture = materialData->data[0].data.bumpMap.bumpTexture;
      if ( bumpTexture )
        goto LABEL_9;
      break;
    case rpMATFXEFFECTENVMAP:
      bumpTexture = materialData->data[0].data.bumpMap.texture;
      if ( bumpTexture )
        goto LABEL_9;
      break;
    case rpMATFXEFFECTDUAL:
      bumpTexture = (RwTexture_0 *)materialData->data[0].data.bumpMap.frame;
      if ( materialData->data[0].data.bumpMap.frame )
LABEL_9:
        RwTextureDestroy(bumpTexture);
      break;
    case rpMATFXEFFECTUVTRANSFORM:
      *(_QWORD *)&materialData->data[0].data.bumpMap.frame = 0LL;
      break;
    default:
      break;
  }
  switch ( materialData->data[1].flag )
  {
    case rpMATFXEFFECTBUMPMAP:
      v4 = materialData->data[1].data.bumpMap.texture;
      if ( v4 )
        RwTextureDestroy(v4);
      v5 = materialData->data[1].data.bumpMap.bumpTexture;
      if ( v5 )
        goto LABEL_19;
      break;
    case rpMATFXEFFECTENVMAP:
      v5 = materialData->data[1].data.bumpMap.texture;
      if ( v5 )
        goto LABEL_19;
      break;
    case rpMATFXEFFECTDUAL:
      v5 = materialData->data[1].data.dual.texture;
      if ( v5 )
LABEL_19:
        RwTextureDestroy(v5);
      break;
    case rpMATFXEFFECTUVTRANSFORM:
      materialData->data[1].data.bumpMap.frame = 0;
      materialData->data[1].data.bumpMap.texture = 0;
      break;
    default:
      break;
  }
  materialData->flags = rpMATFXEFFECTNULL;
  result = (rpMatFXMaterialData_0 *)(&materialData->data[1].data.uvAnim + 1);
  *((_QWORD *)&materialData->data[1].data.uvAnim + 1) = 0LL;
  *((_QWORD *)&materialData->data[1].data.uvAnim + 2) = 0LL;
  *(_QWORD *)&materialData->data[0].data.bumpMap.frame = 0LL;
  *((_QWORD *)&materialData->data[0].data.uvAnim + 1) = 0LL;
  p_invBumpWidth = &materialData->data[0].data.bumpMap.invBumpWidth;
  *(_QWORD *)p_invBumpWidth = 0LL;
  *((_QWORD *)p_invBumpWidth + 1) = 0LL;
  return result;
}

//----- (001C70C8) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMatFXMaterialSetDualBlendModes(
        RpMaterial_0 *material,
        RwBlendFunction_0 srcBlendMode,
        RwBlendFunction_0 dstBlendMode)
{
  int v4; // r0
  int v5; // r3
  int v6; // r5

  v4 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v4 + 20) == 4 )
  {
    v5 = 0;
  }
  else
  {
    if ( *(_DWORD *)(v4 + 44) != 4 )
    {
      v6 = 0;
      goto LABEL_7;
    }
    v5 = 1;
  }
  v6 = v4 + 24 * v5;
LABEL_7:
  *(_DWORD *)(v6 + 4) = srcBlendMode;
  *(_DWORD *)(v6 + 8) = dstBlendMode;
  _rpMatFXSetupDualRenderState((MatFXDualData_0 *)v6, rwRENDERSTATESRCBLEND);
  _rpMatFXSetupDualRenderState((MatFXDualData_0 *)v6, rwRENDERSTATEDESTBLEND);
  return material;
}

//----- (001C7114) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMatFXMaterialSetupBumpMap(
        RpMaterial_0 *material,
        RwTexture_0 *texture,
        RwFrame_0 *frame,
        RwReal coef)
{
  RpMaterial_0 *v7; // r1
  RpMaterial_0 *result; // r0
  int v9; // r2
  int v10; // r0

  v7 = RpMatFXMaterialSetBumpMapTexture(material, texture);
  result = 0;
  if ( v7 )
  {
    *((_DWORD *)&(*(RwTexture_0 **)((char *)&material->texture + MatFXMaterialDataOffset))->raster
    + 2
    * ((*(_DWORD *)&(*(RwTexture_0 **)((char *)&material->texture + MatFXMaterialDataOffset))->name[4] != 1) | (2 * (*(_DWORD *)&(*(RwTexture_0 **)((char *)&material->texture + MatFXMaterialDataOffset))->name[4] != 1)))) = frame;
    if ( material )
    {
      v9 = 0;
      v10 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
      if ( *(_DWORD *)(v10 + 20) != 1 )
        v9 = 1;
      *(float *)(v10 + 8 * (v9 | (2 * v9)) + 12) = -coef;
      return material;
    }
  }
  return result;
}

//----- (001C7188) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMatFXMaterialSetBumpMapTexture(RpMaterial_0 *material, RwTexture_0 *bumpTexture)
{
  RpMaterial_0 *v2; // r8
  int v4; // r5
  int v5; // r6
  int v6; // r4
  RwTexture_0 *v7; // r0
  RwTexture_0 **v8; // r4
  RwTexture_0 *v9; // t1
  int v10; // r9
  RwTexture_0 *v11; // r0
  RwTexture_0 **v12; // r6
  RwRaster_0 *raster; // r0
  const RwTexture_0 *v14; // r10
  RwInt32 width; // r0
  RwChar *v16; // r0
  int v17; // r1
  RwTexture_0 *texture; // r0
  __int64 *v19; // r0
  int v20; // r1
  RwChar v21; // r2
  RwChar *v22; // r3
  RwChar v23; // r2
  RwTexDictionary_0 *Current; // r0
  RwTexDictionary_0 *v25; // r4
  RwTexture_0 *NamedTexture; // r0
  RwTexture_0 *v27; // r1
  RwChar *v29; // [sp+0h] [bp-48h]
  RwChar *v30; // [sp+4h] [bp-44h]
  __int64 name[4]; // [sp+8h] [bp-40h] BYREF

  v2 = material;
  v4 = 0;
  v5 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v5 + 20) != 1 )
    v4 = 1;
  v6 = v5 + 8 * (v4 | (2 * v4));
  v9 = *(RwTexture_0 **)(v6 + 8);
  v8 = (RwTexture_0 **)(v6 + 8);
  v7 = v9;
  if ( v9 )
  {
    RwTextureDestroy(v7);
    *v8 = 0;
  }
  v10 = v5 + 24 * v4;
  v12 = (RwTexture_0 **)(v10 + 4);
  v11 = *(RwTexture_0 **)(v10 + 4);
  if ( v11 )
  {
    RwTextureDestroy(v11);
    *v12 = 0;
    *(_DWORD *)(v10 + 16) = 0;
  }
  if ( !bumpTexture )
  {
    texture = v2->texture;
    goto LABEL_30;
  }
  *v8 = bumpTexture;
  raster = bumpTexture->raster;
  ++bumpTexture->refCount;
  v14 = v2->texture;
  width = raster->width;
  if ( v2->texture && width )
    width = v14->raster->width;
  if ( width )
  {
    memset(name, 0, sizeof(name));
    if ( v14 )
    {
      v29 = v14->name;
      v16 = bumpTexture->name;
      v17 = 1;
    }
    else
    {
      v16 = bumpTexture->name;
      v17 = 0;
      v30 = bumpTexture->name;
    }
    (&v29)[v17] = v16;
    v19 = name;
    v20 = 0;
    while ( 1 )
    {
      v21 = *v29;
      if ( !*v29 )
        break;
      ++v29;
      v22 = v30;
      ++v20;
      *(_BYTE *)v19 = v21;
      v19 = (__int64 *)((char *)v19 + 1);
      v23 = *v22;
      if ( *v22 )
      {
LABEL_22:
        *(_BYTE *)v19 = v23;
        v19 = (__int64 *)((char *)v19 + 1);
        ++v20;
        v30 = v22 + 1;
        if ( v20 >= 30 )
        {
LABEL_23:
          *(_BYTE *)v19 = 0;
          Current = RwTexDictionaryGetCurrent();
          v25 = Current;
          *v12 = 0;
          if ( Current )
          {
            NamedTexture = RwTexDictionaryFindNamedTexture(Current, (const RwChar *)name);
            *v12 = NamedTexture;
            if ( NamedTexture )
            {
              ++NamedTexture->refCount;
              goto LABEL_29;
            }
          }
          v27 = _rpMatFXSetupBumpMapTexture(v14, bumpTexture);
          *v12 = v27;
          if ( !v27 )
            return 0;
          if ( v25 )
            RwTexDictionaryAddTexture(v25, v27);
LABEL_29:
          texture = *v12;
LABEL_30:
          *(float *)(v10 + 16) = 1.0 / (float)texture->raster->width;
          return v2;
        }
      }
      else if ( v20 >= 30 )
      {
        goto LABEL_23;
      }
    }
    v22 = v30;
    v23 = *v30;
    if ( !*v30 )
      goto LABEL_23;
    goto LABEL_22;
  }
  return v2;
}

//----- (001C730C) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMatFXMaterialSetBumpMapFrame(RpMaterial_0 *material, RwFrame_0 *frame)
{
  int v2; // r3
  int v3; // r2

  v2 = 0;
  v3 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v3 + 20) != 1 )
    v2 = 1;
  *(_DWORD *)(v3 + 8 * (v2 | (2 * v2))) = frame;
  return material;
}

//----- (001C7334) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMatFXMaterialSetBumpMapCoefficient(RpMaterial_0 *material, RwReal coef)
{
  int v2; // r3
  unsigned int v3; // r1
  int v4; // r2

  v2 = 0;
  v3 = LODWORD(coef) ^ 0x80000000;
  v4 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v4 + 20) != 1 )
    v2 = 1;
  *(_DWORD *)(v4 + 8 * (v2 | (2 * v2)) + 12) = v3;
  return material;
}

//----- (001C7360) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMatFXMaterialSetupEnvMap(
        RpMaterial_0 *material,
        RwTexture_0 *texture,
        RwFrame_0 *frame,
        RwBool useFrameBufferAlpha,
        RwReal coef)
{
  RwInt32 v9; // r1
  int v10; // r0
  int v11; // r2
  int v12; // r6
  RwTexture_0 *v13; // r0
  int v14; // r3
  RwInt32 v15; // r0
  int v16; // r0

  v9 = MatFXMaterialDataOffset;
  v10 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v10 + 20) == 2 )
  {
    v11 = 0;
LABEL_5:
    v12 = v10 + 24 * v11;
    goto LABEL_7;
  }
  if ( *(_DWORD *)(v10 + 44) == 2 )
  {
    v11 = 1;
    goto LABEL_5;
  }
  v12 = 0;
LABEL_7:
  ++texture->refCount;
  v13 = *(RwTexture_0 **)(v12 + 4);
  if ( v13 )
  {
    RwTextureDestroy(v13);
    *(_DWORD *)(v12 + 4) = 0;
    v9 = MatFXMaterialDataOffset;
  }
  *(_DWORD *)(v12 + 4) = texture;
  v14 = 0;
  *((_DWORD *)&(*(RwTexture_0 **)((char *)&material->texture + v9))->raster
  + 2
  * ((*(_DWORD *)&(*(RwTexture_0 **)((char *)&material->texture + v9))->name[4] != 2) | (2
                                                                                       * (*(_DWORD *)&(*(RwTexture_0 **)((char *)&material->texture + v9))->name[4] != 2)))) = frame;
  v15 = MatFXMaterialDataOffset;
  (&(*(RwTexture_0 **)((char *)&material->texture + MatFXMaterialDataOffset))->lInDictionary.prev)[2
                                                                                                 * ((*(_DWORD *)&(*(RwTexture_0 **)((char *)&material->texture + MatFXMaterialDataOffset))->name[4] != 2) | (2 * (*(_DWORD *)&(*(RwTexture_0 **)((char *)&material->texture + MatFXMaterialDataOffset))->name[4] != 2)))] = (RwLLLink *)useFrameBufferAlpha;
  v16 = *(int *)((char *)&material->texture + v15);
  if ( *(_DWORD *)(v16 + 20) != 2 )
    v14 = 1;
  *(RwReal *)(v16 + 8 * (v14 | (2 * v14)) + 8) = coef;
  return material;
}

//----- (001C7424) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMatFXMaterialSetEnvMapTexture(RpMaterial_0 *material, RwTexture_0 *texture)
{
  int v4; // r0
  int v5; // r1
  int v6; // r6
  RwTexture_0 *v7; // r0

  v4 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v4 + 20) == 2 )
  {
    v5 = 0;
LABEL_5:
    v6 = v4 + 24 * v5;
    goto LABEL_7;
  }
  if ( *(_DWORD *)(v4 + 44) == 2 )
  {
    v5 = 1;
    goto LABEL_5;
  }
  v6 = 0;
LABEL_7:
  ++texture->refCount;
  v7 = *(RwTexture_0 **)(v6 + 4);
  if ( v7 )
  {
    RwTextureDestroy(v7);
    *(_DWORD *)(v6 + 4) = 0;
  }
  *(_DWORD *)(v6 + 4) = texture;
  return material;
}

//----- (001C7478) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMatFXMaterialSetEnvMapFrame(RpMaterial_0 *material, RwFrame_0 *frame)
{
  int v2; // r3
  int v3; // r2

  v2 = 0;
  v3 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v3 + 20) != 2 )
    v2 = 1;
  *(_DWORD *)(v3 + 8 * (v2 | (2 * v2))) = frame;
  return material;
}

//----- (001C74A0) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMatFXMaterialSetEnvMapFrameBufferAlpha(RpMaterial_0 *material, RwBool useFrameBufferAlpha)
{
  int v2; // r3
  int v3; // r2

  v2 = 0;
  v3 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v3 + 20) != 2 )
    v2 = 1;
  *(_DWORD *)(v3 + 8 * (v2 | (2 * v2)) + 12) = useFrameBufferAlpha;
  return material;
}

//----- (001C74C8) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMatFXMaterialSetEnvMapCoefficient(RpMaterial_0 *material, RwReal coef)
{
  int v2; // r3
  int v3; // r2

  v2 = 0;
  v3 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v3 + 20) != 2 )
    v2 = 1;
  *(RwReal *)(v3 + 8 * (v2 | (2 * v2)) + 8) = coef;
  return material;
}

//----- (001C74F0) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMatFXMaterialSetupDualTexture(
        RpMaterial_0 *material,
        RwTexture_0 *texture,
        RwBlendFunction_0 srcBlendMode,
        RwBlendFunction_0 dstBlendMode)
{
  int v8; // r0
  int v9; // r1
  MatFXDualData_0 *v10; // r6
  int v11; // r0
  int v12; // r1
  int v13; // r5

  v8 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v8 + 20) == 4 )
  {
    v9 = 0;
LABEL_5:
    v10 = (MatFXDualData_0 *)(v8 + 24 * v9);
    goto LABEL_7;
  }
  if ( *(_DWORD *)(v8 + 44) == 4 )
  {
    v9 = 1;
    goto LABEL_5;
  }
  v10 = 0;
LABEL_7:
  ++texture->refCount;
  if ( v10->texture )
  {
    RwTextureDestroy(v10->texture);
    v10->texture = 0;
  }
  v10->texture = texture;
  _rpMatFXSetupDualRenderState(v10, rwRENDERSTATETEXTUREADDRESS);
  _rpMatFXSetupDualRenderState(v10, rwRENDERSTATETEXTURERASTER);
  v11 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v11 + 20) == 4 )
  {
    v12 = 0;
  }
  else
  {
    if ( *(_DWORD *)(v11 + 44) != 4 )
    {
      v13 = 0;
      goto LABEL_15;
    }
    v12 = 1;
  }
  v13 = v11 + 24 * v12;
LABEL_15:
  *(_DWORD *)(v13 + 4) = srcBlendMode;
  *(_DWORD *)(v13 + 8) = dstBlendMode;
  _rpMatFXSetupDualRenderState((MatFXDualData_0 *)v13, rwRENDERSTATESRCBLEND);
  _rpMatFXSetupDualRenderState((MatFXDualData_0 *)v13, rwRENDERSTATEDESTBLEND);
  return material;
}

//----- (001C7598) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMatFXMaterialSetDualTexture(RpMaterial_0 *material, RwTexture_0 *texture)
{
  int v4; // r0
  int v5; // r1
  MatFXDualData_0 *v6; // r6

  v4 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v4 + 20) == 4 )
  {
    v5 = 0;
LABEL_5:
    v6 = (MatFXDualData_0 *)(v4 + 24 * v5);
    goto LABEL_7;
  }
  if ( *(_DWORD *)(v4 + 44) == 4 )
  {
    v5 = 1;
    goto LABEL_5;
  }
  v6 = 0;
LABEL_7:
  ++texture->refCount;
  if ( v6->texture )
  {
    RwTextureDestroy(v6->texture);
    v6->texture = 0;
  }
  v6->texture = texture;
  _rpMatFXSetupDualRenderState(v6, rwRENDERSTATETEXTUREADDRESS);
  _rpMatFXSetupDualRenderState(v6, rwRENDERSTATETEXTURERASTER);
  return material;
}

//----- (001C75FC) --------------------------------------------------------
RpMatFXMaterialFlags_0 __fastcall RpMatFXMaterialGetEffects(const RpMaterial_0 *material)
{
  int v1; // r0

  v1 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( v1 )
    return *(_DWORD *)(v1 + 48);
  else
    return 0;
}

//----- (001C7614) --------------------------------------------------------
RwTexture_0 *__fastcall RpMatFXMaterialGetBumpMapBumpedTexture(const RpMaterial_0 *material)
{
  int v1; // r2
  int v2; // r0

  v1 = 0;
  v2 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v2 + 20) != 1 )
    v1 = 1;
  return *(RwTexture_0 **)(v2 + 8 * (v1 | (2 * v1)) + 4);
}

//----- (001C7638) --------------------------------------------------------
RwTexture_0 *__fastcall RpMatFXMaterialGetBumpMapTexture(const RpMaterial_0 *material)
{
  int v1; // r2
  int v2; // r0

  v1 = 0;
  v2 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v2 + 20) != 1 )
    v1 = 1;
  return *(RwTexture_0 **)(v2 + 8 * (v1 | (2 * v1)) + 8);
}

//----- (001C765C) --------------------------------------------------------
RwFrame_0 *__fastcall RpMatFXMaterialGetBumpMapFrame(const RpMaterial_0 *material)
{
  int v1; // r2
  int v2; // r0

  v1 = 0;
  v2 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v2 + 20) != 1 )
    v1 = 1;
  return *(RwFrame_0 **)(v2 + 8 * (v1 | (2 * v1)));
}

//----- (001C7680) --------------------------------------------------------
RwReal __fastcall RpMatFXMaterialGetBumpMapCoefficient(const RpMaterial_0 *material)
{
  int v1; // r2
  int v2; // r0
  RwReal result; // r0

  v1 = 0;
  v2 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v2 + 20) != 1 )
    v1 = 1;
  LODWORD(result) = *(_DWORD *)(v2 + 8 * (v1 | (2 * v1)) + 12) ^ 0x80000000;
  return result;
}

//----- (001C76A8) --------------------------------------------------------
RwTexture_0 *__fastcall RpMatFXMaterialGetEnvMapTexture(const RpMaterial_0 *material)
{
  int v1; // r2
  int v2; // r0

  v1 = 0;
  v2 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v2 + 20) != 2 )
    v1 = 1;
  return *(RwTexture_0 **)(v2 + 8 * (v1 | (2 * v1)) + 4);
}

//----- (001C76CC) --------------------------------------------------------
RwFrame_0 *__fastcall RpMatFXMaterialGetEnvMapFrame(const RpMaterial_0 *material)
{
  int v1; // r2
  int v2; // r0

  v1 = 0;
  v2 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v2 + 20) != 2 )
    v1 = 1;
  return *(RwFrame_0 **)(v2 + 8 * (v1 | (2 * v1)));
}

//----- (001C76F0) --------------------------------------------------------
RwBool __fastcall RpMatFXMaterialGetEnvMapFrameBufferAlpha(const RpMaterial_0 *material)
{
  int v1; // r2
  int v2; // r0

  v1 = 0;
  v2 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v2 + 20) != 2 )
    v1 = 1;
  return *(_DWORD *)(v2 + 8 * (v1 | (2 * v1)) + 12);
}

//----- (001C7714) --------------------------------------------------------
RwReal __fastcall RpMatFXMaterialGetEnvMapCoefficient(const RpMaterial_0 *material)
{
  int v1; // r2
  int v2; // r0

  v1 = 0;
  v2 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v2 + 20) != 2 )
    v1 = 1;
  return *(float *)(v2 + 8 * (v1 | (2 * v1)) + 8);
}

//----- (001C7738) --------------------------------------------------------
RwTexture_0 *__fastcall RpMatFXMaterialGetDualTexture(const RpMaterial_0 *material)
{
  int v1; // r2
  int v2; // r0

  v1 = 0;
  v2 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v2 + 20) != 4 )
    v1 = 1;
  return *(RwTexture_0 **)(v2 + 8 * (v1 | (2 * v1)));
}

//----- (001C775C) --------------------------------------------------------
const RpMaterial_0 *__fastcall RpMatFXMaterialGetDualBlendModes(
        const RpMaterial_0 *material,
        RwBlendFunction_0 *srcBlendMode,
        RwBlendFunction_0 *dstBlendMode)
{
  RwBlendFunction_0 *v3; // r12

  v3 = (RwBlendFunction_0 *)(*(char **)((char *)&material->texture + MatFXMaterialDataOffset)
                           + 8
                           * ((*(_DWORD *)&(*(RwTexture_0 **)((char *)&material->texture + MatFXMaterialDataOffset))->name[4] != 4) | (2 * (*(_DWORD *)&(*(RwTexture_0 **)((char *)&material->texture + MatFXMaterialDataOffset))->name[4] != 4))));
  *srcBlendMode = v3[1];
  *dstBlendMode = v3[2];
  return material;
}

//----- (001C7794) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMatFXMaterialSetUVTransformMatrices(
        RpMaterial_0 *material,
        RwMatrix *baseTransform,
        RwMatrix *dualTransform)
{
  int v3; // lr
  int v4; // r3

  v3 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  v4 = (*(_DWORD *)(v3 + 20) != 5) | (2 * (*(_DWORD *)(v3 + 20) != 5));
  *(_DWORD *)(v3 + 8 * v4) = baseTransform;
  *(_DWORD *)(v3 + 8 * v4 + 4) = dualTransform;
  return material;
}

//----- (001C77C8) --------------------------------------------------------
const RpMaterial_0 *__fastcall RpMatFXMaterialGetUVTransformMatrices(
        const RpMaterial_0 *material,
        RwMatrix **baseTransform,
        RwMatrix **dualTransform)
{
  int v3; // lr
  int v4; // r12
  RwMatrix **v5; // r12

  v3 = *(int *)((char *)&material->texture + MatFXMaterialDataOffset);
  if ( *(_DWORD *)(v3 + 20) == 5 )
  {
    v4 = 0;
LABEL_5:
    v5 = (RwMatrix **)(v3 + 24 * v4);
    goto LABEL_7;
  }
  if ( *(_DWORD *)(v3 + 44) == 5 )
  {
    v4 = 1;
    goto LABEL_5;
  }
  v5 = 0;
LABEL_7:
  if ( baseTransform )
    *baseTransform = *v5;
  if ( dualTransform )
    *dualTransform = v5[1];
  return material;
}

//----- (001C781C) --------------------------------------------------------
RwUInt8 *__fastcall rpSkinGetMeshBoneRemapIndices(RpSkin_0 *skin)
{
  return skin->skinSplitData.matrixRemapIndices;
}

//----- (001C7820) --------------------------------------------------------
RwUInt8 *__fastcall rpSkinGetMeshBoneRLECount(RpSkin_0 *skin)
{
  return skin->skinSplitData.meshRLECount;
}

//----- (001C7824) --------------------------------------------------------
RwUInt8 *__fastcall rpSkinGetMeshBoneRLE(RpSkin_0 *skin)
{
  return skin->skinSplitData.meshRLE;
}

//----- (001C7828) --------------------------------------------------------
RpSkin_0 *__fastcall rpSkinSplitDataCreate(
        RpSkin_0 *skin,
        RwUInt32 boneLimit,
        RwUInt32 numMatrices,
        RwUInt32 numMeshes,
        RwUInt32 a5)
{
  RpSkin_0 *v9; // r5
  RwUInt8 *v10; // r0
  RwUInt8 *matrixRemapIndices; // r0
  __int64 v12; // r0

  if ( skin->skinSplitData.matrixRemapIndices )
    (*((void (**)(void))RwEngineInstance + 76))();
  v9 = 0;
  skin->skinSplitData.meshRLECount = 0;
  skin->skinSplitData.meshRLE = 0;
  *(_QWORD *)&skin->skinSplitData.boneLimit = 0LL;
  *(_QWORD *)&skin->skinSplitData.numRLE = 0LL;
  v10 = (RwUInt8 *)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(numMatrices + 2 * numMeshes + 2 * a5);
  skin->skinSplitData.matrixRemapIndices = v10;
  if ( v10 )
  {
    memset(v10, 0, numMatrices + 2 * numMeshes + 2 * a5);
    matrixRemapIndices = skin->skinSplitData.matrixRemapIndices;
    skin->skinSplitData.boneLimit = boneLimit;
    skin->skinSplitData.numMeshes = numMeshes;
    skin->skinSplitData.numRLE = a5;
    LODWORD(v12) = &matrixRemapIndices[numMatrices];
    HIDWORD(v12) = v12 + 2 * numMeshes;
    v9 = skin;
    *(_QWORD *)&skin->skinSplitData.meshRLECount = v12;
  }
  return v9;
}

//----- (001C78B0) --------------------------------------------------------
RwBool __fastcall rpSkinSplitDataDestroy(RpSkin_0 *skin)
{
  if ( skin->skinSplitData.matrixRemapIndices )
    (*((void (**)(void))RwEngineInstance + 76))();
  skin->skinSplitData.meshRLECount = 0;
  skin->skinSplitData.meshRLE = 0;
  *(_QWORD *)&skin->skinSplitData.boneLimit = 0LL;
  *(_QWORD *)&skin->skinSplitData.numRLE = 0LL;
  return 1;
}

//----- (001C78E4) --------------------------------------------------------
RwStream_0 *__fastcall _rpSkinSplitDataStreamWrite(RwStream_0 *stream, const RpSkin_0 *skin)
{
  RwStream_0 *v3; // r4
  RwUInt32 *p_numMeshes; // r6

  v3 = stream;
  if ( !RwStreamWriteInt32(stream, (const RwInt32 *)&skin->skinSplitData, 4u) )
    return 0;
  p_numMeshes = &skin->skinSplitData.numMeshes;
  if ( !RwStreamWriteInt32(v3, (const RwInt32 *)&skin->skinSplitData.numMeshes, 4u)
    || !RwStreamWriteInt32(v3, (const RwInt32 *)&skin->skinSplitData.numRLE, 4u) )
  {
    return 0;
  }
  if ( *p_numMeshes
    && !RwStreamWrite(
          v3,
          skin->skinSplitData.matrixRemapIndices,
          skin->boneData.numBones + 2 * (*p_numMeshes + skin->skinSplitData.numRLE)) )
  {
    return 0;
  }
  return v3;
}

//----- (001C7944) --------------------------------------------------------
RwStream_0 *__fastcall _rpSkinSplitDataStreamRead(RwStream_0 *stream, RpSkin_0 *skin)
{
  RwStream_0 *v3; // r4
  RwInt32 v4; // r6
  RwInt32 v5; // r10
  RwUInt32 numBones; // r11
  RwUInt8 *v7; // r0
  RwUInt8 *matrixRemapIndices; // r1
  RwUInt32 v9; // r0
  __int64 v10; // r2
  RwInt32 v12; // [sp+4h] [bp-2Ch]
  RwInt32 ints; // [sp+8h] [bp-28h] BYREF
  RwInt32 v14; // [sp+Ch] [bp-24h] BYREF
  RwInt32 v15[8]; // [sp+10h] [bp-20h] BYREF

  v3 = stream;
  if ( !RwStreamReadInt32(stream, &ints, 4u) || !RwStreamReadInt32(v3, v15, 4u) || !RwStreamReadInt32(v3, &v14, 4u) )
    return 0;
  v4 = v15[0];
  if ( v15[0] >= 1 )
  {
    v5 = v14;
    v12 = ints;
    numBones = skin->boneData.numBones;
    if ( skin->skinSplitData.matrixRemapIndices )
      (*((void (**)(void))RwEngineInstance + 76))();
    skin->skinSplitData.meshRLECount = 0;
    skin->skinSplitData.meshRLE = 0;
    *(_QWORD *)&skin->skinSplitData.boneLimit = 0LL;
    *(_QWORD *)&skin->skinSplitData.numRLE = 0LL;
    v7 = (RwUInt8 *)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(numBones + 2 * v4 + 2 * v5);
    skin->skinSplitData.matrixRemapIndices = v7;
    if ( !v7 )
      return 0;
    memset(v7, 0, numBones + 2 * v4 + 2 * v5);
    matrixRemapIndices = skin->skinSplitData.matrixRemapIndices;
    v9 = skin->boneData.numBones;
    skin->skinSplitData.boneLimit = v12;
    skin->skinSplitData.numMeshes = v4;
    skin->skinSplitData.numRLE = v5;
    LODWORD(v10) = &matrixRemapIndices[numBones];
    HIDWORD(v10) = &matrixRemapIndices[2 * v4 + numBones];
    *(_QWORD *)&skin->skinSplitData.meshRLECount = v10;
    if ( !RwStreamRead(v3, matrixRemapIndices, v9 + 2 * (v5 + v4)) )
    {
      (*((void (__fastcall **)(SkinSplitData_0 *))RwEngineInstance + 76))(&skin->skinSplitData);
      return 0;
    }
  }
  return v3;
}
// 1C7944: using guessed type RwInt32 var_20[8];

//----- (001C7A2C) --------------------------------------------------------
RwInt32 __fastcall _rpSkinSplitDataStreamGetSize(const RpSkin_0 *skin)
{
  RwUInt32 numMeshes; // r1

  numMeshes = skin->skinSplitData.numMeshes;
  if ( numMeshes )
    return skin->boneData.numBones + 2 * (skin->skinSplitData.numRLE + numMeshes) + 12;
  else
    return 12;
}

//----- (001C7A48) --------------------------------------------------------
bool __fastcall UseSkinning(const RpGeometry_0 *geometry)
{
  RpSkin_0 *Skin; // r0
  bool result; // r0

  Skin = j_RpSkinGeometryGetSkin((RpGeometry_0 *)geometry);
  if ( !Skin || (signed int)Skin->boneData.numBones > RQMaxBones )
    return 0;
  result = UseGpuSkinning;
  if ( UseGpuSkinning )
    return 1;
  return result;
}

//----- (001C7A7C) --------------------------------------------------------
RwBool _rpSkinPipelinesDestroy()
{
  if ( rpSkinGlobals.platform.pipelines[0] )
  {
    _rxPipelineDestroy(rpSkinGlobals.platform.pipelines[0]);
    rpSkinGlobals.platform.pipelines[0] = 0;
  }
  if ( rpSkinGlobals.platform.pipelines[1] )
  {
    _rxPipelineDestroy(rpSkinGlobals.platform.pipelines[1]);
    rpSkinGlobals.platform.pipelines[1] = 0;
  }
  if ( rpSkinGlobals.platform.pipelines[2] )
  {
    _rxPipelineDestroy(rpSkinGlobals.platform.pipelines[2]);
    rpSkinGlobals.platform.pipelines[2] = 0;
  }
  if ( rpSkinGlobals.platform.pipelines[3] )
  {
    _rxPipelineDestroy(rpSkinGlobals.platform.pipelines[3]);
    rpSkinGlobals.platform.pipelines[3] = 0;
  }
  return 1;
}

//----- (001C7B04) --------------------------------------------------------
RpGeometry_0 *__fastcall rpSkinInitialize(RpGeometry_0 *geometry)
{
  _DWORD *v1; // r10
  int *v2; // r3
  int v3; // r12
  RwInt32 v4; // r2
  int v5; // r5
  char *v6; // r6
  char v7; // r1
  int v8; // r4
  char v9; // r1
  int v10; // r1
  int v11; // r5
  char v12; // r1
  int v13; // r4
  unsigned int v14; // r1

  v1 = *(_DWORD **)(&geometry->object.type + rpSkinGlobals.geometryOffset);
  if ( v1 )
  {
    if ( !(HIBYTE(geometry->flags) << 31) )
    {
      v2 = (int *)v1[6];
      v3 = v1[5];
      v1[7] = 1;
      if ( geometry->numVertices >= 1 )
      {
        v4 = 0;
        do
        {
          v5 = *v2;
          if ( *v2 < 1065353216 )
          {
            v6 = (char *)(v3 + 4 * v4);
            while ( 1 )
            {
              while ( 1 )
              {
                v8 = v2[1];
                if ( v5 >= v8 )
                {
                  v10 = 0;
                }
                else
                {
                  v9 = *v6;
                  *v6 = v6[1];
                  v8 = v5;
                  v6[1] = v9;
                  *v2 = v2[1];
                  v2[1] = v5;
                  v10 = 1;
                }
                v11 = v2[2];
                if ( v8 < v11 )
                {
                  v12 = v6[1];
                  v6[1] = v6[2];
                  v11 = v8;
                  v6[2] = v12;
                  v2[1] = v2[2];
                  v2[2] = v8;
                  v10 = 1;
                }
                v13 = v2[3];
                if ( v11 >= v13 )
                  break;
                v7 = v6[2];
                v6[2] = v6[3];
                v6[3] = v7;
                v2[2] = v2[3];
                v2[3] = v11;
                v5 = *v2;
              }
              if ( !v10 )
                break;
              v5 = *v2;
            }
            if ( v13 < 1 )
            {
              v14 = v1[7];
              if ( v11 < 1 )
              {
                if ( v14 <= 1 )
                  v1[7] = 2;
              }
              else if ( v14 <= 2 )
              {
                v1[7] = 3;
              }
            }
            else
            {
              v1[7] = 4;
            }
          }
          ++v4;
          v2 += 4;
        }
        while ( v4 < geometry->numVertices );
      }
    }
  }
  return geometry;
}

//----- (001C7BD8) --------------------------------------------------------
RpGeometry_0 *__fastcall rpSkinDeinitialize(RpGeometry_0 *geometry)
{
  int v2; // r5

  if ( HIBYTE(geometry->flags) << 31 )
  {
    v2 = *(_DWORD *)(&geometry->object.type + rpSkinGlobals.geometryOffset);
    free(*(void **)(v2 + 12));
    *(_DWORD *)(v2 + 12) = 0;
  }
  return geometry;
}

//----- (001C7C00) --------------------------------------------------------
RwInt32 __fastcall _rpSkinGeometryNativeSize(const RpGeometry_0 *geometry)
{
  return (**(_DWORD **)(&geometry->object.type + rpSkinGlobals.geometryOffset) << 6) | 0x14;
}

//----- (001C7C18) --------------------------------------------------------
RwStream_0 *__fastcall _rpSkinGeometryNativeWrite(RwStream_0 *stream, const RpGeometry_0 *geometry)
{
  int v4; // r5
  RwStream_0 *result; // r0
  RwInt32 ints[3]; // [sp+4h] [bp-Ch] BYREF

  ints[0] = 2;
  if ( !_rwStreamWriteVersionedChunkHeader(
          stream,
          1,
          ((**(_DWORD **)(&geometry->object.type + rpSkinGlobals.geometryOffset) << 6) | 0x14) - 12,
          (RwUInt32)&stru_35FFC.st_value + 3,
          0xFFFFu) )
    return 0;
  if ( !RwStreamWriteInt32(stream, ints, 4u) )
    return 0;
  v4 = *(_DWORD *)(&geometry->object.type + rpSkinGlobals.geometryOffset);
  if ( !RwStreamWriteInt32(stream, (const RwInt32 *)v4, 4u) )
    return 0;
  result = RwStreamWrite(stream, *(const void **)(v4 + 12), *(_DWORD *)v4 << 6);
  if ( result )
    return stream;
  return result;
}
// 35FFC: using guessed type Elf32_Sym stru_35FFC;
// 1C7C18: using guessed type RwInt32 ints[3];

//----- (001C7C9C) --------------------------------------------------------
RwStream_0 *__fastcall _rpSkinGeometryNativeRead(RwStream_0 *stream, RpGeometry_0 *geometry)
{
  RwStream_0 *v4; // r6
  int v5; // r6
  void *v6; // r1
  int v7; // r0
  RwError_0 v9; // [sp+0h] [bp-20h] BYREF
  RwUInt32 lengthOut; // [sp+8h] [bp-18h] BYREF
  RwUInt32 versionOut[5]; // [sp+Ch] [bp-14h] BYREF

  if ( !RwStreamFindChunk(stream, 1u, &lengthOut, versionOut) )
    return 0;
  if ( versionOut[0] - 212992 >= 0x2004 )
  {
    v4 = 0;
    v9.pluginID = 0;
    v9.errorCode = _rwerror(-2147483644);
    RwErrorSet(&v9);
    return v4;
  }
  v4 = 0;
  if ( RwStreamReadInt32(stream, &v9.pluginID, 4u) && v9.pluginID == 2 )
  {
    v5 = (*((int (__fastcall **)(RwFreeList_0 *))RwEngineInstance + 79))(rpSkinGlobals.freeList);
    *(_QWORD *)(v5 + 44) = 0LL;
    *(_QWORD *)(v5 + 52) = 0LL;
    *(_QWORD *)(v5 + 32) = 0LL;
    *(_QWORD *)(v5 + 40) = 0LL;
    *(_QWORD *)v5 = 0LL;
    *(_QWORD *)(v5 + 8) = 0LL;
    *(_QWORD *)(v5 + 16) = 0LL;
    *(_QWORD *)(v5 + 24) = 0LL;
    if ( RwStreamReadInt32(stream, (RwInt32 *)v5, 4u) )
    {
      v6 = malloc(*(_DWORD *)v5 << 6);
      v7 = *(_DWORD *)v5;
      *(_DWORD *)(v5 + 12) = v6;
      if ( RwStreamRead(stream, v6, v7 << 6) )
      {
        RwMemNative32(*(void **)(v5 + 12), *(_DWORD *)v5 << 6);
        j_RpSkinGeometrySetSkin(geometry, (RpSkin_0 *)v5);
        return stream;
      }
    }
    return 0;
  }
  return v4;
}
// 1C7C9C: using guessed type RwUInt32 versionOut[5];

//----- (001C7D78) --------------------------------------------------------
RxPipeline_0 *__fastcall _rpSkinOpenGLPipelineCreate(const RpSkinType_0 type, RxOpenGLAllInOneRenderCallBack renderCB)
{
  RxPipeline_0 *v4; // r0
  RxPipeline_0 *v5; // r4
  RxPipeline_0 *v6; // r5
  RxNodeDefinition_0 *OpenGLAtomicAllInOne; // r6
  RxPipeline_0 *v8; // r0
  RxPipelineNode_0 *NodeByName; // r6

  v4 = RxPipelineCreate();
  v5 = v4;
  if ( !v4 )
    return 0;
  v4->pluginId = 278;
  v4->pluginData = type;
  v6 = RxPipelineLock(v4);
  if ( !v6
    || (OpenGLAtomicAllInOne = RxNodeDefinitionGetOpenGLAtomicAllInOne(),
        v8 = RxLockedPipeAddFragment(v6, 0, OpenGLAtomicAllInOne, 0),
        !RxLockedPipeUnlock(v8)) )
  {
    _rxPipelineDestroy(v5);
    return 0;
  }
  NodeByName = RxPipelineFindNodeByName(v5, OpenGLAtomicAllInOne->name, 0, 0);
  RxOpenGLAllInOneSetInstanceCallBack(NodeByName, openglSkinAllInOneAtomicInstanceCB);
  openglDefaultReinstanceCB = RxOpenGLAllInOneGetReinstanceCallBack(NodeByName);
  RxOpenGLAllInOneSetReinstanceCallBack(NodeByName, openglSkinAllInOneAtomicReinstanceCB);
  if ( renderCB )
    RxOpenGLAllInOneSetRenderCallBack(NodeByName, renderCB);
  return v5;
}

//----- (001C7E10) --------------------------------------------------------
RwBool __fastcall openglSkinAllInOneAtomicInstanceCB(
        void *object,
        RxOpenGLMeshInstanceData_0 *instanceData,
        const RwBool instanceDLandVA,
        const RwBool reinstance)
{
  float32x4_t v4; // q0
  RpAtomic_0 *i; // r8
  RwBool v6; // r5
  RpGeometry_0 *v7; // r9
  signed int flags; // r11
  RwInt32 numTexCoordSets; // r10
  RwUInt8 *v11; // r4
  RpSkin_0 *Skin; // r0
  RwUInt32 offset; // r0
  RwInt32 v14; // r4
  char v15; // r10
  RwInt32 v16; // r1
  RpSkin_0 *v17; // r0
  RpSkin_0 *v18; // r0
  const RwMatrixWeights_0 *VertexBoneWeights; // r0
  RwUInt32 v20; // r3
  RwUInt32 numVertices; // r1
  int8x16_t v22; // q8
  const RwMatrixWeights_0 *v23; // r2
  const float *p_w3; // r0
  const float *v25; // r0
  float32x4_t v26; // q9
  _BOOL4 v27; // r1
  unsigned __int32 *v28; // r0
  GLint v29; // r10
  _BOOL4 v30; // r5
  RpSkin_0 *v31; // r0
  RpAtomic_0 *v32; // r5
  RwUInt32 v33; // r10
  RpSkin_0 *v34; // r4
  const RwMatrixWeights_0 *v35; // r11
  RwUInt32 minVertexIdx; // r8
  const RwUInt32 *v37; // r0
  RwUInt8 *v38; // r1
  float *p_w0; // r2
  float v40; // s2
  char v41; // r3
  float *v42; // r3
  float v43; // s4
  float v44; // s2
  float *v45; // r4
  float v46; // s4
  unsigned int v47; // s2
  char v48; // r5
  RpSkin_0 *v49; // r0
  char v50; // r3
  bool v51; // r0
  GLboolean v52; // r0
  RpSkin_0 *v53; // r0
  RpHAnimHierarchy_0 *HAnimHierarchy; // r4
  RpSkin_0 *v55; // r1
  RwInt32 v56; // r2
  RwUInt32 *p_flags; // r0
  RwUInt32 vertexStride; // [sp+14h] [bp-2Ch]
  _BOOL4 v60; // [sp+18h] [bp-28h]
  RwUInt8 *vertexData; // [sp+1Ch] [bp-24h]

  i = (RpAtomic_0 *)object;
  v6 = reinstance;
  v7 = (RpGeometry_0 *)*((_DWORD *)object + 6);
  flags = v7->flags;
  numTexCoordSets = v7->numTexCoordSets;
  instanceData->vertexDesc = flags;
  if ( (flags & 0x1000000) != 0 )
  {
    instanceData->emuArrayRef = 0;
    instanceData->vertexBufferRef = v7->vertexBuffer;
    goto LABEL_64;
  }
  if ( !reinstance || (v7->lockedSinceLastInst & 0xFFF) != 0 )
  {
    if ( reinstance )
    {
      v11 = (RwUInt8 *)emu_ArraysLock(instanceData->emuArrayRef);
      Skin = j_RpSkinGeometryGetSkin(v7);
      if ( Skin && (signed int)Skin->boneData.numBones <= RQMaxBones && UseGpuSkinning )
      {
        vertexStride = instanceData->vertexStride - 8;
        v60 = 0;
      }
      else
      {
        v60 = 0;
        vertexStride = 0;
      }
      goto LABEL_43;
    }
    emu_ArraysReset();
    emu_ArraysVertexAttrib(0, 3, 0x1406u, 0, 0);
    offset = 12;
    instanceData->vertexStride = 12;
    if ( (flags & 0x10) != 0 )
    {
      emu_ArraysVertexAttrib(2u, 3, 0x1406u, 0, 12);
      offset = instanceData->vertexStride + 12;
      instanceData->vertexStride = offset;
    }
    if ( (flags & 8) != 0 )
    {
      emu_ArraysVertexAttrib(3u, 4, 0x1401u, 1u, offset);
      offset = instanceData->vertexStride + 4;
      instanceData->vertexStride = offset;
    }
    v14 = numTexCoordSets;
    if ( RwHackNoCompressedTexCoords )
    {
      emu_ArraysVertexAttrib(1u, 2, 0x1406u, 0, offset);
      v15 = 3;
    }
    else
    {
      v15 = 2;
      emu_ArraysVertexAttrib(1u, 2, 0x1403u, 0, offset);
    }
    v16 = v14 << v15;
    numTexCoordSets = v14;
    instanceData->vertexStride += v16;
    v17 = j_RpSkinGeometryGetSkin(v7);
    if ( v17 )
    {
      v6 = 0;
      if ( (signed int)v17->boneData.numBones <= RQMaxBones )
      {
        v60 = 0;
        vertexStride = 0;
        if ( UseGpuSkinning )
        {
          if ( j_RpSkinGeometryGetSkin(v7)->vertexMaps.maxWeights == 4
            && (v18 = j_RpSkinGeometryGetSkin(v7),
                VertexBoneWeights = j_RpSkinGetVertexBoneWeights(v18),
                (v20 = instanceData->numVertices) != 0) )
          {
            v4.n128_u32[0] = 0;
            if ( v20 < 4 )
              goto LABEL_35;
            numVertices = instanceData->numVertices & 3;
            if ( (v20 & 3) == 0 )
              numVertices = 4;
            if ( v20 == numVertices )
            {
LABEL_35:
              numVertices = instanceData->numVertices;
              v23 = VertexBoneWeights;
            }
            else
            {
              v22 = 0uLL;
              v23 = &VertexBoneWeights[v20 - numVertices];
              p_w3 = &VertexBoneWeights->w3;
              do
              {
                v26.n128_u64[0] = (unsigned __int64)vld4_f32(p_w3);
                v25 = p_w3 + 8;
                v20 -= 4;
                v26.n128_u64[1] = (unsigned __int64)vld4_f32(v25);
                p_w3 = v25 + 8;
                v22 = vmaxq_f32(v26, v22);
              }
              while ( numVertices != v20 );
              v4 = vmaxq_f32(v22, vextq_s8(v22, v22, 8u));
              if ( vmovn_s32(vcgtq_f32(v4, vdupq_lane_s32((int32x2_t)v4.n128_u64[0], 1))).n64_u16[0] << 31 )
                v4.n128_u32[1] = v4.n128_u32[0];
              v4.n128_u32[0] = v4.n128_u32[1];
            }
            v28 = (unsigned __int32 *)&v23->w3;
            do
            {
              v4.n128_u32[2] = *v28;
              v28 += 4;
              --numVertices;
              v4.n128_u64[0] = vmax_f32(*(float32x2_t *)&v4.n128_i8[8], (float32x2_t)v4.n128_u64[0]).n64_u64[0];
            }
            while ( numVertices );
            v27 = v4.n128_f32[0] >= 0.07;
          }
          else
          {
            v27 = 0;
          }
          v29 = 3;
          v30 = v27;
          if ( v27 )
            v29 = 4;
          emu_ArraysVertexAttrib(4u, v29, (2 * v27) | 0x1401, 1u, instanceData->vertexStride);
          v60 = v30;
          vertexStride = instanceData->vertexStride;
          instanceData->vertexStride = vertexStride + 4 * v30 + 4;
          emu_ArraysVertexAttrib(5u, v29, 0x1401u, 0, vertexStride + 4 * v30 + 4);
          numTexCoordSets = v14;
          instanceData->vertexStride += 4;
          v6 = 0;
        }
        goto LABEL_42;
      }
    }
    else
    {
      v6 = 0;
    }
    v60 = 0;
    vertexStride = 0;
LABEL_42:
    instanceData->vertexDataSize = instanceData->vertexStride * instanceData->numVertices;
    v11 = (RwUInt8 *)(*((int (**)(void))RwEngineInstance + 75))();
LABEL_43:
    vertexData = v11;
    _rxOpenGLAllInOneAtomicInstanceVertexArray(
      instanceData,
      i,
      v7,
      (RpGeometryFlag_0)flags,
      numTexCoordSets,
      v6,
      v11,
      0,
      0);
    v31 = j_RpSkinGeometryGetSkin(v7);
    if ( v31 && (signed int)v31->boneData.numBones <= RQMaxBones && UseGpuSkinning )
    {
      v32 = i;
      v33 = instanceData->numVertices;
      v34 = j_RpSkinGeometryGetSkin(v7);
      v35 = j_RpSkinGetVertexBoneWeights(v34);
      minVertexIdx = instanceData->minVertexIdx;
      v37 = &j_RpSkinGetVertexBoneIndices(v34)[minVertexIdx];
      v38 = &vertexData[vertexStride];
      p_w0 = &v35[minVertexIdx].w0;
      if ( v60 )
      {
        for ( i = v32; v33; v38 += instanceData->vertexStride )
        {
          --v33;
          *(_WORD *)v38 = (unsigned int)(float)(*p_w0 * 65535.0);
          *((_WORD *)v38 + 1) = (unsigned int)(float)(p_w0[1] * 65535.0);
          *((_WORD *)v38 + 2) = (unsigned int)(float)(p_w0[2] * 65535.0);
          v40 = p_w0[3];
          p_w0 += 4;
          *((_WORD *)v38 + 3) = (unsigned int)(float)(v40 * 65535.0);
          *((_WORD *)v38 + 4) = *v37;
          v38[10] = *((_WORD *)v37 + 1);
          v41 = *((_BYTE *)v37++ + 3);
          v38[11] = v41;
        }
      }
      else
      {
        i = v32;
        if ( v33 )
        {
          v42 = p_w0 + 3;
          do
          {
            --v33;
            v43 = *(v42 - 3);
            if ( *v42 == 0.0 )
            {
              *v38 = (unsigned int)(float)(v43 * 255.0);
              v45 = p_w0 + 2;
              v46 = *(v42 - 2) * 255.0;
              v44 = 255.0;
            }
            else
            {
              v44 = 255.0 / (float)((float)(v43 + *(v42 - 2)) + *(v42 - 1));
              *v38 = (unsigned int)(float)(v43 * v44);
              v45 = v42 - 1;
              v46 = *(v42 - 2) * v44;
            }
            v42 += 4;
            p_w0 += 4;
            v38[1] = (unsigned int)v46;
            v47 = (unsigned int)(float)(v44 * *v45);
            v38[3] = 0;
            v38[2] = v47;
            *((_WORD *)v38 + 2) = *v37;
            v38[6] = *((_WORD *)v37 + 1);
            v48 = *((_BYTE *)v37++ + 3);
            v38[7] = v48;
            v38 += instanceData->vertexStride;
          }
          while ( v33 );
        }
      }
    }
    if ( reinstance )
    {
      emu_ArraysUnlock(instanceData->emuArrayRef);
    }
    else
    {
      emu_ArraysVertex(vertexData, instanceData->vertexDataSize, instanceData->numVertices, instanceData->vertexStride);
      emu_ArraysIndices(instanceData->indexData, 0x1403u, instanceData->numIndices);
      v49 = j_RpSkinGeometryGetSkin(v7);
      if ( v49 )
      {
        v50 = 0;
        v51 = (signed int)v49->boneData.numBones > RQMaxBones;
        if ( !UseGpuSkinning )
          v50 = 1;
        v52 = v51 | v50;
      }
      else
      {
        v52 = 1;
      }
      instanceData->emuArrayRef = emu_ArraysStore(v52, 1u);
    }
  }
LABEL_64:
  v53 = j_RpSkinGeometryGetSkin(v7);
  if ( v53 && (signed int)v53->boneData.numBones <= RQMaxBones && UseGpuSkinning )
  {
    HAnimHierarchy = j_RpSkinAtomicGetHAnimHierarchy(i);
    v55 = j_RpSkinGeometryGetSkin(v7);
    if ( rpSkinGlobals.platform.lastHierarchyUsed != HAnimHierarchy
      || rpSkinGlobals.platform.lastRenderFrame != *((unsigned __int16 *)RwEngineInstance + 4) )
    {
      _rpSkinPrepareAtomicMatrix(i, v55, HAnimHierarchy);
      if ( HAnimHierarchy->numNodes >= 1 )
      {
        v56 = 0;
        p_flags = &rpSkinGlobals.matrixCache.aligned->flags;
        do
        {
          *p_flags = 0;
          p_flags += 16;
          ++v56;
        }
        while ( v56 < HAnimHierarchy->numNodes );
      }
      rpSkinGlobals.platform.lastHierarchyUsed = HAnimHierarchy;
      rpSkinGlobals.platform.lastRenderFrame = *((unsigned __int16 *)RwEngineInstance + 4);
    }
    SetBones(HAnimHierarchy, rpSkinGlobals.matrixCache.aligned);
  }
  return 1;
}
// 1C7FF8: variable 'v4' is possibly undefined

//----- (001C838C) --------------------------------------------------------
RwBool __fastcall openglSkinAllInOneAtomicReinstanceCB(
        void *object,
        RwResEntry_0 *resEntry,
        const RpMeshHeader_0 *meshHeader,
        const RwBool instanceDLandVA,
        RxOpenGLAllInOneInstanceCallBack instanceCB)
{
  RpGeometry_0 *v7; // r10
  RpSkin_0 *Skin; // r0
  RwLLLink **p_prev; // r2
  RpSkin_0 *v12; // r9
  RpHAnimHierarchy_0 *HAnimHierarchy; // r6
  RwInt32 v14; // r2
  RwUInt32 *p_flags; // r0
  RwMatrix *aligned; // r4
  RpSkin_0 *v17; // r0
  const RwMatrixWeights_0 *VertexBoneWeights; // r8
  const RwUInt32 *VertexBoneIndices; // r5
  int v20; // r9
  int *v21; // r6
  const RwMatrixWeights_0 *v22; // r5
  RpGeometry_0 *v23; // r8
  int v24; // r4
  __int64 v25; // r10
  RwUInt8 *vertices; // r0
  int v27; // r4
  const RwV3d_0 *v28; // r4
  RwUInt8 *v29; // r3
  RwLLLink **v31; // [sp+18h] [bp-28h]
  const RwUInt32 *v32; // [sp+1Ch] [bp-24h]
  RwMatrix *v33; // [sp+20h] [bp-20h]

  v7 = (RpGeometry_0 *)*((_DWORD *)object + 6);
  Skin = j_RpSkinGeometryGetSkin(v7);
  if ( Skin && (signed int)Skin->boneData.numBones <= RQMaxBones )
  {
    p_prev = &resEntry[1].link.prev;
    if ( UseGpuSkinning )
      p_prev = 0;
    v31 = p_prev;
  }
  else
  {
    v31 = &resEntry[1].link.prev;
  }
  openglDefaultReinstanceCB(object, resEntry, meshHeader, instanceDLandVA, instanceCB);
  v12 = j_RpSkinGeometryGetSkin(v7);
  if ( v12 )
  {
    HAnimHierarchy = j_RpSkinAtomicGetHAnimHierarchy((const RpAtomic_0 *)object);
    if ( HAnimHierarchy )
    {
      if ( rpSkinGlobals.platform.lastHierarchyUsed != HAnimHierarchy
        || rpSkinGlobals.platform.lastRenderFrame != *((unsigned __int16 *)RwEngineInstance + 4) )
      {
        _rpSkinPrepareAtomicMatrix((RpAtomic_0 *)object, v12, HAnimHierarchy);
        if ( HAnimHierarchy->numNodes >= 1 )
        {
          v14 = 0;
          p_flags = &rpSkinGlobals.matrixCache.aligned->flags;
          do
          {
            *p_flags = 0;
            p_flags += 16;
            ++v14;
          }
          while ( v14 < HAnimHierarchy->numNodes );
        }
        rpSkinGlobals.platform.lastHierarchyUsed = HAnimHierarchy;
        rpSkinGlobals.platform.lastRenderFrame = *((unsigned __int16 *)RwEngineInstance + 4);
      }
      aligned = rpSkinGlobals.matrixCache.aligned;
      v17 = j_RpSkinGeometryGetSkin(v7);
      if ( v17 && (signed int)v17->boneData.numBones <= RQMaxBones && UseGpuSkinning )
      {
        SetBones(HAnimHierarchy, aligned);
      }
      else
      {
        VertexBoneWeights = j_RpSkinGetVertexBoneWeights(v12);
        VertexBoneIndices = j_RpSkinGetVertexBoneIndices(v12);
        if ( meshHeader->numMeshes )
        {
          v20 = -meshHeader->numMeshes;
          v32 = VertexBoneIndices;
          v33 = aligned;
          v21 = (int *)(v31 + 6);
          do
          {
            v22 = VertexBoneWeights;
            v23 = v7;
            v24 = *v21;
            v25 = *(_QWORD *)&v7->morphTarget->verts;
            vertices = (RwUInt8 *)emu_ArraysLock(*(v21 - 1));
            v27 = 3 * v24;
            if ( HIDWORD(v25) )
              HIDWORD(v25) += 4 * v27;
            v28 = (const RwV3d_0 *)(v25 + 4 * v27);
            v29 = (RwUInt8 *)HIDWORD(v25);
            v7 = v23;
            if ( HIDWORD(v25) )
              v29 = vertices + 12;
            VertexBoneWeights = v22;
            _rpSkinGenericMatrixBlend(
              *(v21 - 3),
              &v22[*v21],
              &v32[*v21],
              v33,
              vertices,
              v28,
              v29,
              (const RwV3d_0 *)HIDWORD(v25),
              *(v21 - 4));
            emu_ArraysUnlock(*(v21 - 1));
            ++v20;
            v21 += 14;
          }
          while ( v20 );
        }
      }
    }
  }
  return 1;
}

//----- (001C8564) --------------------------------------------------------
RwMatrix *__fastcall _rpSkinOpenGLPrepareAtomicMatrix(
        RpAtomic_0 *atomic,
        RpSkin_0 *skin,
        RpHAnimHierarchy_0 *hierarchy)
{
  RwInt32 v4; // r2
  RwUInt32 *p_flags; // r0

  if ( rpSkinGlobals.platform.lastHierarchyUsed != hierarchy
    || rpSkinGlobals.platform.lastRenderFrame != *((unsigned __int16 *)RwEngineInstance + 4) )
  {
    _rpSkinPrepareAtomicMatrix(atomic, skin, hierarchy);
    if ( hierarchy->numNodes >= 1 )
    {
      v4 = 0;
      p_flags = &rpSkinGlobals.matrixCache.aligned->flags;
      do
      {
        *p_flags = 0;
        p_flags += 16;
        ++v4;
      }
      while ( v4 < hierarchy->numNodes );
    }
    rpSkinGlobals.platform.lastHierarchyUsed = hierarchy;
    rpSkinGlobals.platform.lastRenderFrame = *((unsigned __int16 *)RwEngineInstance + 4);
  }
  return rpSkinGlobals.matrixCache.aligned;
}

//----- (001C85EC) --------------------------------------------------------
RwUInt32 __fastcall _rpSkinOpenGLSkinPlatformGetMaxWeights(const RpSkin_0 *skin)
{
  return skin->platformData.maxWeights;
}

//----- (001C85F0) --------------------------------------------------------
void __fastcall SetBones(const RpHAnimHierarchy_0 *hierarchy, const RwMatrix *matrixArray)
{
  RwInt32 numNodes; // r12
  RwInt32 v3; // lr
  float (*v4)[12]; // r3
  RwReal z; // r2

  numNodes = hierarchy->numNodes;
  if ( numNodes >= 1 )
  {
    v3 = 0;
    v4 = SetBones(RpHAnimHierarchy const*,RwMatrixTag const*)::staticMatrices;
    do
    {
      ++v3;
      (*v4)[0] = matrixArray->right.x;
      (*v4)[1] = matrixArray->up.x;
      (*v4)[2] = matrixArray->at.x;
      (*v4)[3] = matrixArray->pos.x;
      (*v4)[4] = matrixArray->right.y;
      (*v4)[5] = matrixArray->up.y;
      (*v4)[6] = matrixArray->at.y;
      (*v4)[7] = matrixArray->pos.y;
      (*v4)[8] = matrixArray->right.z;
      (*v4)[9] = matrixArray->up.z;
      (*v4)[10] = matrixArray->at.z;
      z = matrixArray->pos.z;
      ++matrixArray;
      (*v4++)[11] = z;
      numNodes = hierarchy->numNodes;
    }
    while ( v3 < numNodes );
  }
  sub_19EA0C(SetBones(RpHAnimHierarchy const*,RwMatrixTag const*)::staticMatrices[0], numNodes);
}

//----- (001C865C) --------------------------------------------------------
RwBool __fastcall _rpSkinPipelinesCreate(RwUInt32 pipes)
{
  *(_QWORD *)rpSkinGlobals.platform.pipelines = 0LL;
  *(_QWORD *)&rpSkinGlobals.platform.pipelines[2] = 0LL;
  rpSkinGlobals.platform.pipelines[0] = _rpSkinOpenGLPipelineCreate(rpSKINTYPEGENERIC, 0);
  rpSkinGlobals.platform.pipelines[1] = _rpSkinOpenGLPipelineCreate(rpSKINTYPEMATFX, _rpMatFXOpenGLAllInOneRenderCB);
  return 1;
}

//----- (001C8698) --------------------------------------------------------
RpAtomic_0 *__fastcall _rpSkinPipelinesAttach(RpAtomic_0 *atomic, RpSkinType_0 type)
{
  _BOOL4 v3; // r0

  v3 = type != rpSKINTYPEGENERIC
    && (type == rpSKINTYPEMATFX || RpAtomicGetPluginOffset(0x120u) >= 1 && RpMatFXAtomicQueryEffects(atomic));
  atomic->pipeline = rpSkinGlobals.platform.pipelines[v3];
  return atomic;
}

//----- (001C86D8) --------------------------------------------------------
RxPipeline_0 *__fastcall RpSkinGetOpenGLPipeline(RpSkinOpenGLPipeline_0 openglPipeline)
{
  return (RxPipeline_0 *)*(&rpSkinGlobals.module.numInstances + openglPipeline);
}

//----- (001C86EC) --------------------------------------------------------
RwMatrix *__fastcall _rpSkinPrepareAtomicMatrix(RpAtomic_0 *atomic, RpSkin_0 *skin, RpHAnimHierarchy_0 *hierarchy)
{
  RwMatrix *aligned; // r10
  const RwMatrix *SkinToBoneMatrices; // r6
  RwMatrix *v7; // r0
  int v8; // r5
  RwInt32 v9; // r4
  RwMatrix *LTM; // r0
  RwMatrix *v11; // r4
  RwInt32 v12; // r5
  int v13; // r8
  RwMatrix *v14; // r0
  int v15; // r4
  RwInt32 v16; // r5
  RwMatrix v18; // [sp+4h] [bp-9Ch] BYREF
  RwMatrix dst; // [sp+44h] [bp-5Ch] BYREF

  if ( !hierarchy )
    return 0;
  aligned = rpSkinGlobals.matrixCache.aligned;
  SkinToBoneMatrices = j_RpSkinGetSkinToBoneMatrices(skin);
  if ( (hierarchy->flags & 2) != 0 )
  {
    LTM = RwFrameGetLTM((RwFrame_0 *)atomic->object.object.parent);
    RwMatrixInvert(&dst, LTM);
    if ( hierarchy->numNodes >= 1 )
    {
      v11 = aligned;
      v12 = 0;
      v13 = 12;
      do
      {
        v14 = RwFrameGetLTM(*(RwFrame_0 **)((char *)&hierarchy->pNodeInfo->nodeID + v13));
        RwMatrixMultiply(&v18, SkinToBoneMatrices, v14);
        RwMatrixMultiply(v11, &v18, &dst);
        ++v12;
        v13 += 16;
        ++v11;
        ++SkinToBoneMatrices;
      }
      while ( v12 < hierarchy->numNodes );
    }
  }
  else if ( (hierarchy->flags & 0x4000) != 0 )
  {
    if ( hierarchy->numNodes >= 1 )
    {
      v15 = 0;
      v16 = 0;
      do
      {
        RwMatrixMultiply(&aligned[v15], &SkinToBoneMatrices[v15], &hierarchy->pMatrixArray[v15]);
        ++v16;
        ++v15;
      }
      while ( v16 < hierarchy->numNodes );
    }
  }
  else
  {
    v7 = RwFrameGetLTM((RwFrame_0 *)atomic->object.object.parent);
    RwMatrixInvert(&dst, v7);
    if ( hierarchy->numNodes >= 1 )
    {
      v8 = 0;
      v9 = 0;
      do
      {
        RwMatrixMultiply(&v18, &SkinToBoneMatrices[v8], &hierarchy->pMatrixArray[v8]);
        RwMatrixMultiply(&aligned[v8], &v18, &dst);
        ++v9;
        ++v8;
      }
      while ( v9 < hierarchy->numNodes );
    }
  }
  return aligned;
}

//----- (001C8808) --------------------------------------------------------
RwMatrix *__fastcall _rpSkinPrepareAtomicMatrixWorldSpace(
        RpAtomic_0 *atomic,
        RpSkin_0 *skin,
        RpHAnimHierarchy_0 *hierarchy)
{
  RwMatrix *aligned; // r10
  const RwMatrix *SkinToBoneMatrices; // r11
  int v7; // r4
  RwInt32 v8; // r5
  int v9; // r4
  int v10; // r6
  RwInt32 v11; // r5
  RwMatrix *LTM; // r0
  RwMatrix *v13; // r5
  int v14; // r4
  RwInt32 v15; // r6
  RwMatrix dst; // [sp+4h] [bp-5Ch] BYREF

  if ( !hierarchy )
    return 0;
  aligned = rpSkinGlobals.matrixCache.aligned;
  SkinToBoneMatrices = j_RpSkinGetSkinToBoneMatrices(skin);
  if ( (hierarchy->flags & 2) != 0 )
  {
    if ( hierarchy->numNodes >= 1 )
    {
      v9 = 0;
      v10 = 12;
      v11 = 0;
      do
      {
        LTM = RwFrameGetLTM(*(RwFrame_0 **)((char *)&hierarchy->pNodeInfo->nodeID + v10));
        RwMatrixMultiply(&aligned[v9], &SkinToBoneMatrices[v9], LTM);
        ++v11;
        v10 += 16;
        ++v9;
      }
      while ( v11 < hierarchy->numNodes );
    }
  }
  else if ( (hierarchy->flags & 0x4000) != 0 )
  {
    v13 = RwFrameGetLTM((RwFrame_0 *)atomic->object.object.parent);
    if ( hierarchy->numNodes >= 1 )
    {
      v14 = 0;
      v15 = 0;
      do
      {
        RwMatrixMultiply(&dst, &SkinToBoneMatrices[v14], &hierarchy->pMatrixArray[v14]);
        RwMatrixMultiply(&aligned[v14], &dst, v13);
        ++v15;
        ++v14;
      }
      while ( v15 < hierarchy->numNodes );
    }
  }
  else if ( hierarchy->numNodes >= 1 )
  {
    v7 = 0;
    v8 = 0;
    do
    {
      RwMatrixMultiply(&aligned[v7], &SkinToBoneMatrices[v7], &hierarchy->pMatrixArray[v7]);
      ++v8;
      ++v7;
    }
    while ( v8 < hierarchy->numNodes );
  }
  return aligned;
}

//----- (001C88F4) --------------------------------------------------------
void __fastcall _rpSkinGenericMatrixBlend(
        RwInt32 numVertices,
        const RwMatrixWeights_0 *matrixWeightsMap,
        const RwUInt32 *matrixIndexMap,
        const RwMatrix *matrixArray,
        RwUInt8 *vertices,
        const RwV3d_0 *originalVertices,
        RwUInt8 *normals,
        const RwV3d_0 *originalNormals,
        RwUInt32 stride)
{
  int v9; // r3
  int v10; // lr
  RwReal *p_z; // r5
  RwReal *p_y; // r6
  const RwMatrixWeights_0 *v13; // r8
  const RwMatrix *v14; // r4
  float *v15; // r10
  float *v16; // r12
  float *v17; // r1
  float *v18; // r0
  float v19; // s0
  float *v20; // r2
  float v21; // s2
  float x; // s6
  float *v23; // r4
  float *v24; // r12
  float *v25; // r1
  float v26; // s4
  float *v27; // r4
  float *v28; // r1
  float v29; // s4
  float *v30; // r4
  float *v31; // r10
  float v32; // s0
  float *v33; // r11
  float v34; // s2
  float *v35; // r9
  float v36; // s4
  float *v37; // r2
  float *v38; // r12
  float *v39; // r4
  float v40; // s0
  float v41; // s4
  float *v43; // [sp+4h] [bp-34h]
  float *v44; // [sp+8h] [bp-30h]
  RwUInt32 v46; // [sp+10h] [bp-28h]
  float *v47; // [sp+10h] [bp-28h]

  if ( numVertices >= 1 )
  {
    v9 = 0;
    v10 = 0;
    p_z = &originalNormals->z;
    p_y = &originalVertices->y;
    do
    {
      if ( SLODWORD(matrixWeightsMap[v10].w0) >= 1 )
      {
        v13 = &matrixWeightsMap[v10];
        v46 = matrixIndexMap[v10];
        v14 = &matrixArray[(unsigned __int8)v46];
        v15 = (float *)&vertices[v9];
        *v15 = (float)(v14->pos.x
                     + (float)((float)((float)(v14->right.x * *(p_y - 1)) + (float)(v14->up.x * *p_y))
                             + (float)(v14->at.x * p_y[1])))
             * v13->w0;
        v15[1] = v13->w0
               * (float)(v14->pos.y
                       + (float)((float)((float)(v14->right.y * *(p_y - 1)) + (float)(v14->up.y * *p_y))
                               + (float)(v14->at.y * p_y[1])));
        v15[2] = v13->w0
               * (float)(v14->pos.z
                       + (float)((float)((float)(v14->right.z * *(p_y - 1)) + (float)(v14->up.z * *p_y))
                               + (float)(v14->at.z * p_y[1])));
        if ( originalNormals )
        {
          v44 = &v14->at.z;
          v43 = &v14->up.z;
          v16 = &v14->right.z;
          v17 = &v14->at.y;
          v18 = &v14->up.y;
          v19 = v14->right.x * *(p_z - 2);
          v20 = &v14->right.y;
          v21 = v14->up.x * *(p_z - 1);
          x = v14->at.x;
          v23 = (float *)&normals[v9];
          *v23 = v13->w0 * (float)((float)(v19 + v21) + (float)(x * *p_z));
          v23[1] = v13->w0
                 * (float)((float)((float)(*v20 * *(p_z - 2)) + (float)(*v18 * *(p_z - 1))) + (float)(*v17 * *p_z));
          v23[2] = v13->w0
                 * (float)((float)((float)(*v16 * *(p_z - 2)) + (float)(*v43 * *(p_z - 1))) + (float)(*v44 * *p_z));
        }
        if ( SLODWORD(v13->w1) >= 1 )
        {
          v24 = (float *)((char *)&matrixArray->right.x + ((v46 >> 2) & 0x3FC0));
          *v15 = *v15
               + (float)((float)(v24[12]
                               + (float)((float)((float)(*v24 * *(p_y - 1)) + (float)(v24[4] * *p_y))
                                       + (float)(v24[8] * p_y[1])))
                       * v13->w1);
          v15[1] = v15[1]
                 + (float)(v13->w1
                         * (float)(v24[13]
                                 + (float)((float)((float)(v24[1] * *(p_y - 1)) + (float)(v24[5] * *p_y))
                                         + (float)(v24[9] * p_y[1]))));
          v15[2] = v15[2]
                 + (float)(v13->w1
                         * (float)(v24[14]
                                 + (float)((float)((float)(v24[2] * *(p_y - 1)) + (float)(v24[6] * *p_y))
                                         + (float)(v24[10] * p_y[1]))));
          if ( originalNormals )
          {
            v25 = (float *)&normals[v9];
            v26 = *(float *)&normals[v9 + 4];
            *v25 = *(float *)&normals[v9]
                 + (float)(v13->w1
                         * (float)((float)((float)(*v24 * *(p_z - 2)) + (float)(v24[4] * *(p_z - 1)))
                                 + (float)(v24[8] * *p_z)));
            v25[1] = v26
                   + (float)(v13->w1
                           * (float)((float)((float)(v24[1] * *(p_z - 2)) + (float)(v24[5] * *(p_z - 1)))
                                   + (float)(v24[9] * *p_z)));
            v25[2] = *(float *)&normals[v9 + 8]
                   + (float)(v13->w1
                           * (float)((float)((float)(v24[2] * *(p_z - 2)) + (float)(v24[6] * *(p_z - 1)))
                                   + (float)(v24[10] * *p_z)));
          }
          if ( SLODWORD(v13->w2) >= 1 )
          {
            v27 = (float *)((char *)&matrixArray->right.x + ((v46 >> 10) & 0x3FC0));
            *v15 = *v15
                 + (float)((float)(v27[12]
                                 + (float)((float)((float)(*v27 * *(p_y - 1)) + (float)(v27[4] * *p_y))
                                         + (float)(v27[8] * p_y[1])))
                         * v13->w2);
            v15[1] = v15[1]
                   + (float)(v13->w2
                           * (float)(v27[13]
                                   + (float)((float)((float)(v27[1] * *(p_y - 1)) + (float)(v27[5] * *p_y))
                                           + (float)(v27[9] * p_y[1]))));
            v15[2] = v15[2]
                   + (float)(v13->w2
                           * (float)(v27[14]
                                   + (float)((float)((float)(v27[2] * *(p_y - 1)) + (float)(v27[6] * *p_y))
                                           + (float)(v27[10] * p_y[1]))));
            if ( originalNormals )
            {
              v28 = (float *)&normals[v9];
              v29 = *(float *)&normals[v9 + 4];
              *v28 = *(float *)&normals[v9]
                   + (float)(v13->w2
                           * (float)((float)((float)(*v27 * *(p_z - 2)) + (float)(v27[4] * *(p_z - 1)))
                                   + (float)(v27[8] * *p_z)));
              v28[1] = v29
                     + (float)(v13->w2
                             * (float)((float)((float)(v27[1] * *(p_z - 2)) + (float)(v27[5] * *(p_z - 1)))
                                     + (float)(v27[9] * *p_z)));
              v28[2] = *(float *)&normals[v9 + 8]
                     + (float)(v13->w2
                             * (float)((float)((float)(v27[2] * *(p_z - 2)) + (float)(v27[6] * *(p_z - 1)))
                                     + (float)(v27[10] * *p_z)));
            }
            if ( SLODWORD(v13->w3) >= 1 )
            {
              v30 = (float *)((char *)&matrixArray->right.x + ((v46 >> 18) & 0x3FC0));
              *v15 = *v15
                   + (float)((float)(v30[12]
                                   + (float)((float)((float)(*v30 * *(p_y - 1)) + (float)(v30[4] * *p_y))
                                           + (float)(v30[8] * p_y[1])))
                           * v13->w3);
              v15[1] = v15[1]
                     + (float)(v13->w3
                             * (float)(v30[13]
                                     + (float)((float)((float)(v30[1] * *(p_y - 1)) + (float)(v30[5] * *p_y))
                                             + (float)(v30[9] * p_y[1]))));
              v15[2] = v15[2]
                     + (float)(v13->w3
                             * (float)(v30[14]
                                     + (float)((float)((float)(v30[2] * *(p_y - 1)) + (float)(v30[6] * *p_y))
                                             + (float)(v30[10] * p_y[1]))));
              if ( originalNormals )
              {
                v47 = v30 + 10;
                v31 = v30 + 6;
                v32 = *v30 * *(p_z - 2);
                v33 = v30 + 2;
                v34 = v30[4] * *(p_z - 1);
                v35 = v30 + 9;
                v36 = v30[8] * *p_z;
                v37 = v30 + 5;
                v38 = v30 + 1;
                v39 = (float *)&normals[v9];
                v40 = (float)(v32 + v34) + v36;
                v41 = *(float *)&normals[v9 + 4];
                *v39 = *(float *)&normals[v9] + (float)(v13->w3 * v40);
                v39[1] = v41
                       + (float)(v13->w3
                               * (float)((float)((float)(*v38 * *(p_z - 2)) + (float)(*v37 * *(p_z - 1)))
                                       + (float)(*v35 * *p_z)));
                v39[2] = *(float *)&normals[v9 + 8]
                       + (float)(v13->w3
                               * (float)((float)((float)(*v33 * *(p_z - 2)) + (float)(*v31 * *(p_z - 1)))
                                       + (float)(*v47 * *p_z)));
              }
            }
          }
        }
      }
      p_y += 3;
      p_z += 3;
      ++v10;
      v9 += stride;
    }
    while ( numVertices != v10 );
  }
}

//----- (001C909C) --------------------------------------------------------
void __fastcall RpSkinSetFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rpSkinFreeListPreallocBlocks = numBlocksToPrealloc;
  _rpSkinFreeListBlockSize = blockSize;
}

//----- (001C90B4) --------------------------------------------------------
RwMatrix *_rpSkinGetAlignedMatrixCache()
{
  return rpSkinGlobals.matrixCache.aligned;
}

//----- (001C90C4) --------------------------------------------------------
RwBool RpSkinPluginAttach()
{
  rpSkinGlobals.engineOffset = RwEngineRegisterPlugin(0, 0x116u, SkinOpen, SkinClose);
  rpSkinGlobals.atomicOffset = RpAtomicRegisterPlugin(
                                 4,
                                 0x116u,
                                 SkinAtomicConstructor,
                                 SkinAtomicDestructor,
                                 SkinAtomicCopy);
  RpAtomicRegisterPluginStream(0x116u, SkinAtomicRead, SkinAtomicWrite, SkinAtomicGetSize);
  RpAtomicSetStreamAlwaysCallBack(0x116u, SkinAtomicAlways);
  RpAtomicSetStreamRightsCallBack(0x116u, SkinAtomicRights);
  rpSkinGlobals.geometryOffset = RpGeometryRegisterPlugin(
                                   4,
                                   0x116u,
                                   SkinGeometryConstructor,
                                   SkinGeometryDestructor,
                                   SkinGeometryCopy);
  RpGeometryRegisterPluginStream(0x116u, SkinGeometryRead, SkinGeometryWrite, SkinGeometrySize);
  return 1;
}

//----- (001C91A4) --------------------------------------------------------
void *__fastcall SkinOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  RwInt32 numInstances; // r0
  RwUInt32 v5; // r5

  numInstances = rpSkinGlobals.module.numInstances;
  if ( !rpSkinGlobals.module.numInstances )
  {
    v5 = 1;
    if ( RwEngineGetPluginOffset(0x120u) != -1 )
      v5 = 3;
    if ( RwEngineGetPluginOffset(0x12Eu) != -1 )
      v5 |= 4u;
    _rpSkinPipelinesCreate(v5);
    rpSkinGlobals.freeList = RwFreeListCreateAndPreallocateSpace(
                               60,
                               _rpSkinFreeListBlockSize,
                               4,
                               _rpSkinFreeListPreallocBlocks,
                               &_rpSkinFreeList);
    rpSkinGlobals.matrixCache.unaligned = (SkinUnaligned)(*((int (__fastcall **)(int))RwEngineInstance + 75))(16399);
    memset(rpSkinGlobals.matrixCache.unaligned, 0, 0x400Fu);
    numInstances = rpSkinGlobals.module.numInstances;
    rpSkinGlobals.matrixCache.aligned = (RwMatrix *)(((int)rpSkinGlobals.matrixCache.unaligned + 15) & 0xFFFFFFF0);
  }
  rpSkinGlobals.module.numInstances = numInstances + 1;
  return instance;
}

//----- (001C9254) --------------------------------------------------------
void *__fastcall SkinClose(void *instance, RwInt32 offset, RwInt32 size)
{
  if ( !--rpSkinGlobals.module.numInstances )
  {
    _rpSkinPipelinesDestroy();
    RwFreeListDestroy(rpSkinGlobals.freeList);
    rpSkinGlobals.freeList = 0;
    (*((void (__fastcall **)(SkinUnaligned))RwEngineInstance + 76))(rpSkinGlobals.matrixCache.unaligned);
    rpSkinGlobals.matrixCache.unaligned = 0;
  }
  return instance;
}

//----- (001C92A8) --------------------------------------------------------
void *__fastcall SkinAtomicConstructor(void *object, RwInt32 offset, RwInt32 size)
{
  *(_DWORD *)((char *)object + rpSkinGlobals.atomicOffset) = 0;
  return object;
}

//----- (001C92BC) --------------------------------------------------------
void *__fastcall SkinAtomicDestructor(void *object, RwInt32 offset, RwInt32 size)
{
  if ( *(_DWORD *)((char *)object + rpSkinGlobals.atomicOffset) )
    *(_DWORD *)((char *)object + rpSkinGlobals.atomicOffset) = 0;
  return object;
}

//----- (001C92D4) --------------------------------------------------------
void *__fastcall SkinAtomicCopy(void *dstObject, const void *srcObject, RwInt32 offset, RwInt32 size)
{
  *(_DWORD *)((char *)dstObject + rpSkinGlobals.atomicOffset) = *(_DWORD *)((char *)srcObject
                                                                          + rpSkinGlobals.atomicOffset);
  return dstObject;
}

//----- (001C92E8) --------------------------------------------------------
RwStream_0 *__fastcall SkinAtomicRead(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  RwStream_0 *v5; // r10
  RpGeometry_0 *v6; // r6
  RpSkin_0 *v7; // r11
  int v8; // r4
  RwUInt32 v9; // r5
  RwMatrixWeights_0 *matrixWeights; // r2
  RwUInt32 v11; // r0
  unsigned int maxWeights; // r1
  RwUInt8 *usedBoneList; // r2
  unsigned int v15; // r0
  RwUInt32 *matrixIndices; // lr
  unsigned int v17; // r6
  int v18; // r8
  unsigned int v19; // r3
  RwUInt32 v20; // r6
  int v21; // r12
  RwInt32 geometryOffset; // r0
  RpSkin_0 *v23; // r1
  RpGeometry_0 *v24; // [sp+Ch] [bp-2Ch]
  RwMatrixWeights_0 *v25; // [sp+10h] [bp-28h]
  RwUInt32 numVertices; // [sp+14h] [bp-24h]
  RwInt32 ints[8]; // [sp+18h] [bp-20h] BYREF

  v5 = stream;
  v6 = (RpGeometry_0 *)*((_DWORD *)object + 6);
  if ( *(_DWORD *)(&v6->object.type + rpSkinGlobals.geometryOffset) )
  {
    if ( !RwStreamSkip(stream, sizeInObject) )
      return 0;
    return v5;
  }
  if ( !RwStreamReadInt32(stream, ints, 4u) )
    return 0;
  numVertices = v6->numVertices;
  v7 = SkinCreate(numVertices, ints[0], ints[0], 4u, 0, 0, 0);
  if ( !RwStreamSkip(v5, 4u)
    || !RwStreamReadInt32(v5, (RwInt32 *)v7->vertexMaps.matrixIndices, 4 * numVertices)
    || !RwStreamReadReal(v5, &v7->vertexMaps.matrixWeights->w0, 16 * numVertices) )
  {
    return 0;
  }
  if ( v7->boneData.numBones )
  {
    v8 = 0;
    v9 = 0;
    while ( RwStreamSkip(v5, 0xCu) && RwStreamReadReal(v5, &v7->boneData.invBoneToSkinMat[v8].right.x, 0x40u) )
    {
      ++v9;
      ++v8;
      if ( v9 >= v7->boneData.numBones )
        goto LABEL_14;
    }
    return 0;
  }
LABEL_14:
  v24 = v6;
  matrixWeights = v7->vertexMaps.matrixWeights;
  v7->vertexMaps.maxWeights = 1;
  if ( numVertices )
  {
    v11 = 0;
    maxWeights = 1;
    v25 = matrixWeights;
    do
    {
      if ( maxWeights <= 3 )
      {
        while ( *((_DWORD *)&matrixWeights->w0 + maxWeights) )
        {
          v7->vertexMaps.maxWeights = ++maxWeights;
          if ( maxWeights == 4 )
          {
            maxWeights = 4;
            goto LABEL_24;
          }
        }
      }
      ++v11;
      ++matrixWeights;
    }
    while ( v11 < numVertices );
LABEL_24:
    usedBoneList = v7->boneData.usedBoneList;
    v15 = 0;
    matrixIndices = v7->vertexMaps.matrixIndices;
    v17 = maxWeights;
    v18 = 0;
    v7->boneData.numUsedBones = 0;
    do
    {
      if ( v17 )
      {
        v19 = 0;
        do
        {
          if ( *((_DWORD *)&v25[v18].w0 + v19) )
          {
            v20 = matrixIndices[v18] >> (8 * v19);
            if ( v15 )
            {
              v21 = 0;
              while ( usedBoneList[v21] != (unsigned __int8)v20 )
              {
                if ( ++v21 >= v15 )
                  goto LABEL_34;
              }
            }
            else
            {
              v15 = 0;
LABEL_34:
              usedBoneList[v15] = v20;
              maxWeights = v7->vertexMaps.maxWeights;
              v15 = v7->boneData.numUsedBones + 1;
              v7->boneData.numUsedBones = v15;
            }
          }
          ++v19;
          v17 = maxWeights;
        }
        while ( v19 < maxWeights );
      }
      else
      {
        v17 = 0;
      }
      ++v18;
    }
    while ( v18 != numVertices );
  }
  else
  {
    v7->boneData.numUsedBones = 0;
  }
  geometryOffset = rpSkinGlobals.geometryOffset;
  v23 = *(RpSkin_0 **)(&v24->object.type + rpSkinGlobals.geometryOffset);
  if ( v23 != v7 )
  {
    if ( v23 )
    {
      j__rpSkinDeinitialize(v24);
      geometryOffset = rpSkinGlobals.geometryOffset;
    }
    *(_DWORD *)(&v24->object.type + geometryOffset) = v7;
    if ( v7 )
      j__rpSkinInitialize(v24);
  }
  return v5;
}
// 1C92E8: using guessed type RwInt32 ints[8];

//----- (001C94A2) --------------------------------------------------------
RwInt32 __fastcall SkinAtomicGetSize(const void *object, RwInt32 offsetInObject, RwInt32 sizeInObject)
{
  return 0;
}

//----- (001C94A8) --------------------------------------------------------
RwBool __fastcall SkinAtomicAlways(void *object, RwInt32 offset, RwInt32 size)
{
  RpSkinType_0 v4; // r5
  int v5; // r0
  RwInt32 PluginOffset; // r0
  bool v7; // zf

  if ( RwEngineGetPluginOffset(0x120u) == -1 )
  {
    v4 = rpSKINTYPEGENERIC;
  }
  else
  {
    v4 = rpSKINTYPEMATFX;
    if ( !*((_BYTE *)object + RpAtomicGetPluginOffset(0x120u)) )
      v4 = rpSKINTYPEGENERIC;
  }
  v5 = *((_DWORD *)object + 6);
  if ( v5 && *(_DWORD *)(v5 + rpSkinGlobals.geometryOffset) )
  {
    PluginOffset = RwEngineGetPluginOffset(0x120u);
    v7 = v4 == rpSKINTYPEMATFX;
    if ( v4 == rpSKINTYPEMATFX )
      v7 = PluginOffset == -1;
    if ( v7 )
      v4 = rpSKINTYPEGENERIC;
    else
      RwEngineGetPluginOffset(0x12Eu);
    _rpSkinPipelinesAttach((RpAtomic_0 *)object, v4);
  }
  return 1;
}

//----- (001C9510) --------------------------------------------------------
RwBool __fastcall SkinAtomicRights(void *object, RwInt32 offset, RwInt32 size, RwUInt32 extraData)
{
  int v6; // r0
  RwInt32 PluginOffset; // r0
  bool v8; // zf

  v6 = *((_DWORD *)object + 6);
  if ( v6 && *(_DWORD *)(v6 + rpSkinGlobals.geometryOffset) )
  {
    PluginOffset = RwEngineGetPluginOffset(0x120u);
    v8 = extraData == 2;
    if ( extraData == 2 )
      v8 = PluginOffset == -1;
    if ( v8 )
    {
      extraData = 1;
    }
    else if ( !(extraData ^ 3 | ~RwEngineGetPluginOffset(0x12Eu)) )
    {
      extraData = 1;
    }
    _rpSkinPipelinesAttach((RpAtomic_0 *)object, (RpSkinType_0)extraData);
  }
  return 1;
}

//----- (001C9564) --------------------------------------------------------
void *__fastcall SkinGeometryConstructor(void *object, RwInt32 offset, RwInt32 size)
{
  *(_DWORD *)((char *)object + rpSkinGlobals.geometryOffset) = 0;
  return object;
}

//----- (001C9578) --------------------------------------------------------
void *__fastcall SkinGeometryDestructor(void *object, RwInt32 offset, RwInt32 size)
{
  int v4; // r5

  v4 = *(_DWORD *)((char *)object + rpSkinGlobals.geometryOffset);
  if ( v4 )
  {
    j__rpSkinDeinitialize((RpGeometry_0 *)object);
    if ( *(_DWORD *)(v4 + 56) )
      (*((void (**)(void))RwEngineInstance + 76))();
    (*((void (__fastcall **)(RwFreeList_0 *, int))RwEngineInstance + 80))(rpSkinGlobals.freeList, v4);
    *(_DWORD *)((char *)object + rpSkinGlobals.geometryOffset) = 0;
  }
  return object;
}

//----- (001C95E0) --------------------------------------------------------
RwStream_0 *__fastcall SkinGeometryRead(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  RwStream_0 *v6; // r8
  RwUInt32 v7; // r0
  RwUInt32 v8; // r10
  RwUInt32 v9; // r5
  unsigned int v10; // r6
  RpSkin_0 *v11; // r0
  RpSkin_0 *v12; // r9
  RwStream_0 *Int32; // r11
  bool v14; // zf
  RpGeometry_0 *v15; // r11
  RwUInt32 numBones; // r0
  RwReal *p_x; // r1
  int v18; // r4
  RwUInt32 v19; // r5
  RwMatrixWeights_0 *matrixWeights; // r2
  unsigned int v21; // r0
  unsigned int maxWeights; // r1
  unsigned int v24; // r5
  RwUInt8 *usedBoneList; // r2
  unsigned int v26; // r6
  RwUInt32 *matrixIndices; // lr
  int v28; // r10
  unsigned int v29; // r3
  RwUInt32 v30; // r6
  int v31; // r0
  RwInt32 geometryOffset; // r0
  RpSkin_0 *v33; // r1
  RwMatrixWeights_0 *v34; // [sp+Ch] [bp-2Ch]
  unsigned int v35; // [sp+10h] [bp-28h]
  RpGeometry_0 *v36; // [sp+14h] [bp-24h]
  RwInt32 ints; // [sp+18h] [bp-20h] BYREF

  v6 = stream;
  if ( *((unsigned __int8 *)object + 11) << 31 )
  {
    if ( !_rpSkinGeometryNativeRead(stream, (RpGeometry_0 *)object) )
      return 0;
    return v6;
  }
  if ( !RwStreamReadInt32(stream, &ints, 4u) )
    return 0;
  v7 = *((_DWORD *)object + 5);
  v8 = BYTE2(ints);
  v9 = BYTE1(ints);
  if ( BYTE2(ints) )
  {
    v10 = *((_DWORD *)object + 5);
    v11 = SkinCreate(v7, (unsigned __int8)ints, BYTE1(ints), BYTE2(ints), 0, 0, 0);
    v12 = v11;
    if ( !v11 || RwStreamRead(v6, v11->boneData.usedBoneList, v9) != v9 )
      return 0;
    goto LABEL_11;
  }
  v10 = *((_DWORD *)object + 5);
  v12 = SkinCreate(v7, (unsigned __int8)ints, (unsigned __int8)ints, 4u, 0, 0, 0);
  if ( !v12 )
    return 0;
LABEL_11:
  v36 = (RpGeometry_0 *)object;
  Int32 = RwStreamReadInt32(v6, (RwInt32 *)v12->vertexMaps.matrixIndices, 4 * v10);
  RwMemNative32(v12->vertexMaps.matrixIndices, 4 * v10);
  v14 = Int32 == 0;
  v15 = (RpGeometry_0 *)object;
  if ( v14 || !RwStreamReadReal(v6, &v12->vertexMaps.matrixWeights->w0, 16 * v10) )
    return 0;
  if ( v8 )
  {
    numBones = v12->boneData.numBones;
    p_x = &v12->boneData.invBoneToSkinMat->right.x;
    v12->vertexMaps.maxWeights = v8;
    if ( !RwStreamReadReal(v6, p_x, numBones << 6) || !_rpSkinSplitDataStreamRead(v6, v12) )
      return 0;
  }
  else
  {
    if ( v12->boneData.numBones )
    {
      v18 = 0;
      v19 = 0;
      while ( RwStreamSkip(v6, 4u) && RwStreamReadReal(v6, &v12->boneData.invBoneToSkinMat[v18].right.x, 0x40u) )
      {
        ++v19;
        ++v18;
        if ( v19 >= v12->boneData.numBones )
          goto LABEL_22;
      }
      return 0;
    }
LABEL_22:
    matrixWeights = v12->vertexMaps.matrixWeights;
    v12->vertexMaps.maxWeights = 1;
    v21 = 0;
    if ( v10 )
    {
      maxWeights = 1;
      v34 = matrixWeights;
      do
      {
        if ( maxWeights <= 3 )
        {
          while ( *((_DWORD *)&matrixWeights->w0 + maxWeights) )
          {
            v12->vertexMaps.maxWeights = ++maxWeights;
            if ( maxWeights == 4 )
            {
              maxWeights = 4;
              goto LABEL_32;
            }
          }
        }
        ++v21;
        ++matrixWeights;
      }
      while ( v21 < v10 );
LABEL_32:
      v35 = v10;
      v24 = 0;
      usedBoneList = v12->boneData.usedBoneList;
      v26 = maxWeights;
      matrixIndices = v12->vertexMaps.matrixIndices;
      v28 = 0;
      v12->boneData.numUsedBones = 0;
      do
      {
        if ( v26 )
        {
          v29 = 0;
          do
          {
            if ( *((_DWORD *)&v34[v28].w0 + v29) )
            {
              v30 = matrixIndices[v28] >> (8 * v29);
              if ( v24 )
              {
                v31 = 0;
                while ( usedBoneList[v31] != (unsigned __int8)v30 )
                {
                  if ( ++v31 >= v24 )
                    goto LABEL_42;
                }
              }
              else
              {
                v24 = 0;
LABEL_42:
                usedBoneList[v24] = v30;
                maxWeights = v12->vertexMaps.maxWeights;
                v24 = v12->boneData.numUsedBones + 1;
                v12->boneData.numUsedBones = v24;
              }
            }
            ++v29;
            v26 = maxWeights;
          }
          while ( v29 < maxWeights );
        }
        else
        {
          v26 = 0;
        }
        ++v28;
        v15 = v36;
      }
      while ( v28 != v35 );
    }
    else
    {
      v12->boneData.numUsedBones = 0;
    }
  }
  geometryOffset = rpSkinGlobals.geometryOffset;
  v33 = *(RpSkin_0 **)(&v15->object.type + rpSkinGlobals.geometryOffset);
  if ( v33 != v12 )
  {
    if ( v33 )
    {
      j__rpSkinDeinitialize(v15);
      geometryOffset = rpSkinGlobals.geometryOffset;
    }
    *(_DWORD *)(&v15->object.type + geometryOffset) = v12;
    if ( v12 )
      j__rpSkinInitialize(v15);
  }
  return v6;
}

//----- (001C97FC) --------------------------------------------------------
RwStream_0 *__fastcall SkinGeometryWrite(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        const void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  RwStream_0 *v5; // r4
  const RpSkin_0 *v6; // r5
  int v7; // r6
  RwStream_0 *v14; // r0
  RwInt32 ints[5]; // [sp+4h] [bp-14h] BYREF

  v5 = stream;
  v6 = *(const RpSkin_0 **)((char *)object + rpSkinGlobals.geometryOffset);
  if ( v6 )
  {
    if ( *((unsigned __int8 *)object + 11) << 31 )
    {
      v14 = _rpSkinGeometryNativeWrite(stream, (const RpGeometry_0 *)object);
    }
    else
    {
      v7 = *((_DWORD *)object + 5);
      _R0 = v6->vertexMaps.maxWeights << 16;
      __asm { UXTB16.W        R0, R0 }
      ints[0] = _R0 & 0xFFFF00FF | ((unsigned __int8)v6->boneData.numUsedBones << 8) | LOBYTE(v6->boneData.numBones);
      if ( !RwStreamWriteInt32(v5, ints, 4u)
        || !RwStreamWrite(v5, v6->boneData.usedBoneList, v6->boneData.numUsedBones)
        || !RwStreamWriteInt32(v5, (const RwInt32 *)v6->vertexMaps.matrixIndices, 4 * v7)
        || !RwStreamWriteReal(v5, &v6->vertexMaps.matrixWeights->w0, 16 * v7)
        || !RwStreamWriteReal(v5, &v6->boneData.invBoneToSkinMat->right.x, v6->boneData.numBones << 6) )
      {
        return 0;
      }
      v14 = _rpSkinSplitDataStreamWrite(v5, v6);
    }
    if ( !v14 )
      return 0;
  }
  return v5;
}
// 1C97FC: using guessed type RwInt32 ints[5];

//----- (001C9898) --------------------------------------------------------
RwInt32 __fastcall SkinGeometrySize(const void *object, RwInt32 offset, RwInt32 bytes)
{
  const RpSkin_0 *v4; // r0
  int v6; // r4

  v4 = *(const RpSkin_0 **)((char *)object + rpSkinGlobals.geometryOffset);
  if ( !v4 )
    return 0;
  if ( *((unsigned __int8 *)object + 11) << 31 )
    return sub_1A0804((const RpGeometry_0 *)object);
  v6 = v4->boneData.numUsedBones + 20 * *((_DWORD *)object + 5) + (v4->boneData.numBones << 6);
  return _rpSkinSplitDataStreamGetSize(v4) + v6 + 4;
}

//----- (001C98DC) --------------------------------------------------------
RpAtomic_0 *__fastcall RpSkinAtomicSetHAnimHierarchy(RpAtomic_0 *atomic, RpHAnimHierarchy_0 *hierarchy)
{
  *(_DWORD *)(&atomic->object.object.type + rpSkinGlobals.atomicOffset) = hierarchy;
  return atomic;
}

//----- (001C98EC) --------------------------------------------------------
RpHAnimHierarchy_0 *__fastcall RpSkinAtomicGetHAnimHierarchy(const RpAtomic_0 *atomic)
{
  return *(RpHAnimHierarchy_0 **)(&atomic->object.object.type + rpSkinGlobals.atomicOffset);
}

//----- (001C98FC) --------------------------------------------------------
RpSkin_0 *__fastcall RpSkinGeometryGetSkin(RpGeometry_0 *geometry)
{
  return *(RpSkin_0 **)(&geometry->object.type + rpSkinGlobals.geometryOffset);
}

//----- (001C990C) --------------------------------------------------------
RpGeometry_0 *__fastcall RpSkinGeometrySetSkin(RpGeometry_0 *geometry, RpSkin_0 *skin)
{
  RwInt32 geometryOffset; // r0
  RpSkin_0 *v5; // r1

  geometryOffset = rpSkinGlobals.geometryOffset;
  v5 = *(RpSkin_0 **)(&geometry->object.type + rpSkinGlobals.geometryOffset);
  if ( v5 != skin )
  {
    if ( v5 )
    {
      j__rpSkinDeinitialize(geometry);
      geometryOffset = rpSkinGlobals.geometryOffset;
    }
    *(_DWORD *)(&geometry->object.type + geometryOffset) = skin;
    if ( skin && !j__rpSkinInitialize(geometry) )
      return 0;
  }
  return geometry;
}

//----- (001C9950) --------------------------------------------------------
RpSkin_0 *__fastcall RpSkinCreate(
        RwUInt32 numVertices,
        RwUInt32 numBones,
        RwMatrixWeights_0 *vertexWeights,
        RwUInt32 *vertexIndices,
        RwMatrix *inverseMatrices)
{
  return SkinCreate(numVertices, numBones, 0, 0, vertexWeights, vertexIndices, inverseMatrices);
}

//----- (001C996C) --------------------------------------------------------
RpSkin_0 *__fastcall SkinCreate(
        RwUInt32 numVertices,
        RwUInt32 numBones,
        RwUInt32 numBonesUsed,
        RwUInt32 maxWeights,
        RwMatrixWeights_0 *vertexWeights,
        RwUInt32 *vertexIndices,
        RwMatrix *inverseMatrices)
{
  int v11; // r8
  RwMatrixWeights_0 *v12; // r2
  unsigned int v13; // r11
  RwUInt32 v14; // r5
  RwUInt32 v15; // r1
  RwUInt32 v16; // r3
  unsigned int v17; // r0
  int v18; // r12
  unsigned int v19; // r5
  RwUInt32 v20; // r0
  int v21; // r2
  void *v22; // r0
  __int64 v23; // r0
  bool v24; // zf
  __int64 *v25; // r5
  __int64 *v26; // r3
  __int64 v27; // d16
  __int64 v28; // d17
  __int64 v29; // d22
  __int64 v30; // d23
  _QWORD *v31; // r2
  __int64 v32; // d20
  __int64 v33; // d21
  __int64 v34; // d18
  __int64 v35; // d19
  RwUInt32 v37; // [sp+4h] [bp-124h]
  char v38[256]; // [sp+8h] [bp-120h] BYREF

  v11 = (*((int (__fastcall **)(RwFreeList_0 *))RwEngineInstance + 79))(rpSkinGlobals.freeList);
  v12 = vertexWeights;
  *(_QWORD *)(v11 + 44) = 0LL;
  *(_QWORD *)(v11 + 52) = 0LL;
  *(_QWORD *)(v11 + 32) = 0LL;
  *(_QWORD *)(v11 + 40) = 0LL;
  *(_QWORD *)v11 = 0LL;
  *(_QWORD *)(v11 + 8) = 0LL;
  *(_QWORD *)(v11 + 16) = 0LL;
  *(_QWORD *)(v11 + 24) = 0LL;
  if ( maxWeights )
  {
    v13 = 0;
    v14 = numVertices;
  }
  else
  {
    v13 = 1;
    v14 = numVertices;
    *(_DWORD *)(v11 + 16) = 1;
    if ( numVertices )
    {
      v15 = 0;
      v13 = 1;
      do
      {
        if ( v13 <= 3 )
        {
          while ( *((_DWORD *)&v12->w0 + v13) )
          {
            *(_DWORD *)(v11 + 16) = ++v13;
            if ( v13 == 4 )
            {
              v13 = 4;
              goto LABEL_10;
            }
          }
        }
        ++v15;
        ++v12;
      }
      while ( v15 < numVertices );
    }
  }
LABEL_10:
  v37 = v14;
  if ( !numBonesUsed )
  {
    numBonesUsed = 0;
    if ( v14 )
    {
      v16 = 0;
      v17 = v13;
      v18 = 0;
      do
      {
        if ( v17 )
        {
          v19 = 0;
          do
          {
            if ( *((_DWORD *)&vertexWeights[v18].w0 + v19) )
            {
              v20 = vertexIndices[v18] >> (8 * v19);
              if ( v16 )
              {
                v21 = 0;
                while ( (unsigned __int8)v38[v21] != (unsigned __int8)v20 )
                {
                  if ( ++v21 >= v16 )
                    goto LABEL_22;
                }
              }
              else
              {
                v16 = 0;
LABEL_22:
                ++numBonesUsed;
                v38[v16] = v20;
                v16 = numBonesUsed;
              }
            }
            ++v19;
            v17 = v13;
          }
          while ( v19 < v13 );
        }
        else
        {
          v17 = 0;
        }
        v14 = v37;
        ++v18;
      }
      while ( v18 != v37 );
    }
  }
  v22 = (void *)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(((numBones << 6) | 0xF) + 20 * v14 + numBonesUsed);
  *(_DWORD *)(v11 + 56) = v22;
  if ( v22 )
  {
    memset(v22, 0, ((numBones << 6) | 0xF) + 20 * v14 + numBonesUsed);
    LODWORD(v23) = *(_DWORD *)(v11 + 56);
    *(_DWORD *)v11 = numBones;
    *(_DWORD *)(v11 + 4) = numBonesUsed;
    HIDWORD(v23) = (v23 + numBonesUsed + 15) & 0xFFFFFFF0;
    *(_QWORD *)(v11 + 8) = v23;
    HIDWORD(v23) += numBones << 6;
    *(_DWORD *)(v11 + 20) = HIDWORD(v23);
    *(_DWORD *)(v11 + 24) = HIDWORD(v23) + 4 * v14;
    if ( numBonesUsed )
      qmemcpy((void *)v23, v38, numBonesUsed);
    v24 = inverseMatrices == 0;
    if ( inverseMatrices )
    {
      LODWORD(v23) = *(_DWORD *)v11;
      v24 = *(_DWORD *)v11 == 0;
    }
    if ( !v24 )
    {
      HIDWORD(v23) = ((_DWORD)v23 << 6) - 64;
      do
      {
        v25 = (__int64 *)((char *)&inverseMatrices->at + HIDWORD(v23));
        LODWORD(v23) = v23 - 1;
        v27 = *(_QWORD *)((char *)&inverseMatrices->right.x + HIDWORD(v23));
        v28 = *(_QWORD *)((char *)&inverseMatrices->right.z + HIDWORD(v23));
        v26 = (__int64 *)((char *)&inverseMatrices->up + HIDWORD(v23));
        v29 = *(_QWORD *)((char *)&inverseMatrices->pos.x + HIDWORD(v23));
        v30 = *(_QWORD *)((char *)&inverseMatrices->pos.z + HIDWORD(v23));
        v31 = (_QWORD *)(*(_DWORD *)(v11 + 12) + HIDWORD(v23));
        HIDWORD(v23) -= 64;
        v32 = *v26;
        v33 = v26[1];
        v34 = *v25;
        v35 = v25[1];
        v31[6] = v29;
        v31[7] = v30;
        v31[4] = v34;
        v31[5] = v35;
        *v31 = v27;
        v31[1] = v28;
        v31 += 2;
        *v31 = v32;
        v31[1] = v33;
      }
      while ( (_DWORD)v23 );
    }
    if ( vertexIndices )
      qmemcpy(*(void **)(v11 + 20), vertexIndices, 4 * v37);
    if ( vertexWeights )
      qmemcpy(*(void **)(v11 + 24), vertexWeights, 16 * v37);
  }
  else
  {
    (*((void (__fastcall **)(RwFreeList_0 *, int))RwEngineInstance + 80))(rpSkinGlobals.freeList, v11);
    return 0;
  }
  return (RpSkin_0 *)v11;
}
// 1C9AF0: variable 'v23' is possibly undefined
// 1C996C: using guessed type char var_120[256];

//----- (001C9BB0) --------------------------------------------------------
RpSkin_0 *__fastcall RpSkinDestroy(RpSkin_0 *skin)
{
  if ( skin->unaligned )
    (*((void (**)(void))RwEngineInstance + 76))();
  (*((void (__fastcall **)(RwFreeList_0 *, RpSkin_0 *))RwEngineInstance + 80))(rpSkinGlobals.freeList, skin);
  return 0;
}

//----- (001C9BF0) --------------------------------------------------------
RwUInt32 __fastcall RpSkinGetNumBones(RpSkin_0 *skin)
{
  return skin->boneData.numBones;
}

//----- (001C9BF4) --------------------------------------------------------
const RwMatrixWeights_0 *__fastcall RpSkinGetVertexBoneWeights(RpSkin_0 *skin)
{
  return skin->vertexMaps.matrixWeights;
}

//----- (001C9BF8) --------------------------------------------------------
const RwUInt32 *__fastcall RpSkinGetVertexBoneIndices(RpSkin_0 *skin)
{
  return skin->vertexMaps.matrixIndices;
}

//----- (001C9BFC) --------------------------------------------------------
const RwMatrix *__fastcall RpSkinGetSkinToBoneMatrices(RpSkin_0 *skin)
{
  return skin->boneData.invBoneToSkinMat;
}

//----- (001C9C00) --------------------------------------------------------
RwBool __fastcall RpSkinIsSplit(RpSkin_0 *skin)
{
  return skin->skinSplitData.numMeshes != 0;
}

//----- (001C9C0A) --------------------------------------------------------
RpAtomic_0 *__fastcall RpSkinAtomicSetType(RpAtomic_0 *atomic, RpSkinType_0 type)
{
  RwInt32 PluginOffset; // r0
  bool v5; // zf

  PluginOffset = RwEngineGetPluginOffset(0x120u);
  v5 = type == rpSKINTYPEMATFX;
  if ( type == rpSKINTYPEMATFX )
    v5 = PluginOffset == -1;
  if ( v5 )
  {
    type = rpSKINTYPEGENERIC;
  }
  else if ( !(type ^ 3 | ~RwEngineGetPluginOffset(0x12Eu)) )
  {
    type = rpSKINTYPEGENERIC;
  }
  return sub_18E974(atomic, type);
}

//----- (001C9C4A) --------------------------------------------------------
RpSkinType_0 __fastcall RpSkinAtomicGetType(RpAtomic_0 *atomic)
{
  RxPipeline_0 *pipeline; // r0

  pipeline = atomic->pipeline;
  if ( pipeline->pluginId == 278 )
    return pipeline->pluginData;
  else
    return 0;
}

//----- (001C9C5C) --------------------------------------------------------
void __fastcall RpUVAnimLinearKeyFrameApply(void *pMatrix, void *pVoidIFrame)
{
  __int64 v2; // r2

  *(_DWORD *)pMatrix = *((_DWORD *)pVoidIFrame + 2);
  v2 = *((unsigned int *)pVoidIFrame + 3);
  *(_QWORD *)((char *)pMatrix + 4) = v2;
  *((_DWORD *)pMatrix + 4) = *((_DWORD *)pVoidIFrame + 4);
  LODWORD(v2) = *((_DWORD *)pVoidIFrame + 5);
  *(_QWORD *)((char *)pMatrix + 20) = v2;
  *((_DWORD *)pMatrix + 8) = 0;
  *((_DWORD *)pMatrix + 9) = 0;
  *((_DWORD *)pMatrix + 10) = 0;
  *((_DWORD *)pMatrix + 12) = *((_DWORD *)pVoidIFrame + 6);
  *((_DWORD *)pMatrix + 13) = *((_DWORD *)pVoidIFrame + 7);
  *((_DWORD *)pMatrix + 14) = 0;
  sub_196158((RwMatrix *)pMatrix);
}

//----- (001C9C86) --------------------------------------------------------
void __fastcall RpUVAnimLinearKeyFrameInterpolate(
        void *pVoidOut,
        void *pVoidIn1,
        void *pVoidIn2,
        RwReal time,
        void *customData)
{
  float v5; // s0

  v5 = (float)(time - *((float *)pVoidIn1 + 1)) / (float)(*((float *)pVoidIn2 + 1) - *((float *)pVoidIn1 + 1));
  *((float *)pVoidOut + 2) = *((float *)pVoidIn1 + 2)
                           + (float)(v5 * (float)(*((float *)pVoidIn2 + 2) - *((float *)pVoidIn1 + 2)));
  *((float *)pVoidOut + 3) = *((float *)pVoidIn1 + 3)
                           + (float)(v5 * (float)(*((float *)pVoidIn2 + 3) - *((float *)pVoidIn1 + 3)));
  *((float *)pVoidOut + 4) = *((float *)pVoidIn1 + 4)
                           + (float)(v5 * (float)(*((float *)pVoidIn2 + 4) - *((float *)pVoidIn1 + 4)));
  *((float *)pVoidOut + 5) = *((float *)pVoidIn1 + 5)
                           + (float)(v5 * (float)(*((float *)pVoidIn2 + 5) - *((float *)pVoidIn1 + 5)));
  *((float *)pVoidOut + 6) = *((float *)pVoidIn1 + 6)
                           + (float)(v5 * (float)(*((float *)pVoidIn2 + 6) - *((float *)pVoidIn1 + 6)));
  *((float *)pVoidOut + 7) = *((float *)pVoidIn1 + 7)
                           + (float)(v5 * (float)(*((float *)pVoidIn2 + 7) - *((float *)pVoidIn1 + 7)));
}

//----- (001C9D30) --------------------------------------------------------
void __fastcall RpUVAnimLinearKeyFrameBlend(void *pVoidOut, void *pVoidIn1, void *pVoidIn2, RwReal fAlpha)
{
  *((float *)pVoidOut + 2) = *((float *)pVoidIn1 + 2)
                           + (float)((float)(*((float *)pVoidIn2 + 2) - *((float *)pVoidIn1 + 2)) * fAlpha);
  *((float *)pVoidOut + 3) = *((float *)pVoidIn1 + 3)
                           + (float)((float)(*((float *)pVoidIn2 + 3) - *((float *)pVoidIn1 + 3)) * fAlpha);
  *((float *)pVoidOut + 4) = *((float *)pVoidIn1 + 4)
                           + (float)((float)(*((float *)pVoidIn2 + 4) - *((float *)pVoidIn1 + 4)) * fAlpha);
  *((float *)pVoidOut + 5) = *((float *)pVoidIn1 + 5)
                           + (float)((float)(*((float *)pVoidIn2 + 5) - *((float *)pVoidIn1 + 5)) * fAlpha);
  *((float *)pVoidOut + 6) = *((float *)pVoidIn1 + 6)
                           + (float)((float)(*((float *)pVoidIn2 + 6) - *((float *)pVoidIn1 + 6)) * fAlpha);
  *((float *)pVoidOut + 7) = *((float *)pVoidIn1 + 7)
                           + (float)((float)(*((float *)pVoidIn2 + 7) - *((float *)pVoidIn1 + 7)) * fAlpha);
}

//----- (001C9DC6) --------------------------------------------------------
void __fastcall RpUVAnimLinearKeyFrameMulRecip(void *pVoidFrame, void *pVoidStart)
{
  float v2; // s4
  float v3; // s2
  float v4; // s0
  float v5; // s6
  float v6; // s10
  float v7; // s12
  float v8; // s6
  float v9; // s2
  float v10; // s8
  float v11; // s4
  float v12; // s0
  float v13; // s6
  float v14; // s2

  v2 = *((float *)pVoidStart + 5);
  v3 = *((float *)pVoidStart + 3);
  v4 = *((float *)pVoidStart + 4);
  v5 = (float)(*((float *)pVoidStart + 2) * v2) - (float)(v3 * v4);
  if ( v5 != 0.0 )
  {
    v6 = *((float *)pVoidFrame + 4);
    v7 = *((float *)pVoidFrame + 5);
    v8 = 1.0 / v5;
    v9 = v3 * v8;
    v10 = *((float *)pVoidFrame + 3);
    v11 = v2 * v8;
    v12 = v4 * v8;
    v13 = *((float *)pVoidFrame + 2);
    *((float *)pVoidFrame + 2) = (float)(v11 * v13) - (float)(v6 * v9);
    *((float *)pVoidFrame + 3) = (float)(v11 * v10) - (float)(v7 * v9);
    *((float *)pVoidFrame + 4) = (float)-(float)(v12 * v13) - (float)(v6 * v12);
    *((float *)pVoidFrame + 5) = (float)-(float)(v12 * v10) - (float)(v7 * v12);
  }
  v14 = *((float *)pVoidFrame + 7);
  *((float *)pVoidFrame + 6) = *((float *)pVoidFrame + 6) - *((float *)pVoidStart + 6);
  *((float *)pVoidFrame + 7) = v14 - *((float *)pVoidStart + 7);
}

//----- (001C9E72) --------------------------------------------------------
void __fastcall RpUVAnimLinearKeyFrameAdd(void *pVoidOut, void *pVoidIn1, void *pVoidIn2)
{
  *((float *)pVoidOut + 2) = (float)(*((float *)pVoidIn1 + 2) * *((float *)pVoidIn2 + 2))
                           + (float)(*((float *)pVoidIn1 + 3) * *((float *)pVoidIn2 + 4));
  *((float *)pVoidOut + 3) = (float)(*((float *)pVoidIn1 + 2) * *((float *)pVoidIn2 + 3))
                           + (float)(*((float *)pVoidIn1 + 3) * *((float *)pVoidIn2 + 5));
  *((float *)pVoidOut + 4) = (float)(*((float *)pVoidIn1 + 4) * *((float *)pVoidIn2 + 2))
                           + (float)(*((float *)pVoidIn1 + 5) * *((float *)pVoidIn2 + 4));
  *((float *)pVoidOut + 5) = (float)(*((float *)pVoidIn1 + 4) * *((float *)pVoidIn2 + 3))
                           + (float)(*((float *)pVoidIn1 + 5) * *((float *)pVoidIn2 + 5));
  *((float *)pVoidOut + 6) = *((float *)pVoidIn1 + 6) + *((float *)pVoidIn2 + 6);
  *((float *)pVoidOut + 7) = *((float *)pVoidIn1 + 7) + *((float *)pVoidIn2 + 7);
}

//----- (001C9F14) --------------------------------------------------------
RpUVAnimLinearKeyFrameData_0 *__fastcall RpUVAnimLinearKeyFrameDataInitFromMatrix(
        RpUVAnimLinearKeyFrameData_0 *data,
        const RwMatrix *matrix)
{
  data->uv[0] = matrix->right.x;
  data->uv[1] = matrix->right.y;
  data->uv[2] = matrix->up.x;
  data->uv[3] = matrix->up.y;
  data->uv[4] = matrix->pos.x;
  data->uv[5] = matrix->pos.y;
  return data;
}

//----- (001C9F30) --------------------------------------------------------
void __fastcall RpUVAnimParamKeyFrameApply(void *pMatrix, void *pVoidIFrame)
{
  __int64 v4; // r0
  RwV3d_0 v5; // [sp+0h] [bp-18h] BYREF

  v5.z = 1.0;
  *(_QWORD *)&v5.x = unk_5EA4A0;
  *(_DWORD *)pMatrix = *((_DWORD *)pVoidIFrame + 3);
  v4 = *((unsigned int *)pVoidIFrame + 5);
  *(_QWORD *)((char *)pMatrix + 4) = v4;
  *((_DWORD *)pMatrix + 4) = 0;
  LODWORD(v4) = *((_DWORD *)pVoidIFrame + 4);
  *(_QWORD *)((char *)pMatrix + 20) = v4;
  *((_DWORD *)pMatrix + 8) = 0;
  *((_DWORD *)pMatrix + 9) = 0;
  *((_DWORD *)pMatrix + 10) = 0;
  *((_DWORD *)pMatrix + 12) = *((_DWORD *)pVoidIFrame + 6);
  LODWORD(v4) = *((_DWORD *)pVoidIFrame + 7);
  *(_QWORD *)((char *)pMatrix + 52) = v4;
  RwMatrixUpdate((RwMatrix *)pMatrix);
  RwMatrixTranslate((RwMatrix *)pMatrix, &rpUVAnimPivot, rwCOMBINEPOSTCONCAT);
  RwMatrixRotate((RwMatrix *)pMatrix, &v5, (float)(*((float *)pVoidIFrame + 2) / 3.1416) * 180.0, rwCOMBINEPOSTCONCAT);
  RwMatrixTranslate((RwMatrix *)pMatrix, &rpUVAnimInvPivot, rwCOMBINEPOSTCONCAT);
}

//----- (001C9FCC) --------------------------------------------------------
void __fastcall RpUVAnimParamKeyFrameInterpolate(
        void *pVoidOut,
        void *pVoidIn1,
        void *pVoidIn2,
        RwReal time,
        void *customData)
{
  float v5; // s2
  float v6; // s0
  float v7; // s4
  float v8; // s6

  v5 = *((float *)pVoidIn1 + 2);
  v6 = (float)(time - *((float *)pVoidIn1 + 1)) / (float)(*((float *)pVoidIn2 + 1) - *((float *)pVoidIn1 + 1));
  v7 = *((float *)pVoidIn2 + 2) - v5;
  if ( v7 < -3.1416 )
  {
    v8 = 6.2832;
LABEL_5:
    v7 = v7 + v8;
    goto LABEL_6;
  }
  if ( v7 > 3.1416 )
  {
    v8 = -6.2832;
    goto LABEL_5;
  }
LABEL_6:
  *((float *)pVoidOut + 2) = v5 + (float)(v6 * v7);
  *((float *)pVoidOut + 3) = *((float *)pVoidIn1 + 3)
                           + (float)(v6 * (float)(*((float *)pVoidIn2 + 3) - *((float *)pVoidIn1 + 3)));
  *((float *)pVoidOut + 4) = *((float *)pVoidIn1 + 4)
                           + (float)(v6 * (float)(*((float *)pVoidIn2 + 4) - *((float *)pVoidIn1 + 4)));
  *((float *)pVoidOut + 5) = *((float *)pVoidIn1 + 5)
                           + (float)(v6 * (float)(*((float *)pVoidIn2 + 5) - *((float *)pVoidIn1 + 5)));
  *((float *)pVoidOut + 6) = *((float *)pVoidIn1 + 6)
                           + (float)(v6 * (float)(*((float *)pVoidIn2 + 6) - *((float *)pVoidIn1 + 6)));
  *((float *)pVoidOut + 7) = *((float *)pVoidIn1 + 7)
                           + (float)(v6 * (float)(*((float *)pVoidIn2 + 7) - *((float *)pVoidIn1 + 7)));
}

//----- (001CA0B0) --------------------------------------------------------
void __fastcall RpUVAnimParamKeyFrameBlend(void *pVoidOut, void *pVoidIn1, void *pVoidIn2, RwReal fAlpha)
{
  float v4; // s2
  float v5; // s4
  float v6; // s6

  v4 = *((float *)pVoidIn1 + 2);
  v5 = *((float *)pVoidIn2 + 2) - v4;
  if ( v5 < -3.1416 )
  {
    v6 = 6.2832;
LABEL_5:
    v5 = v5 + v6;
    goto LABEL_6;
  }
  if ( v5 > 3.1416 )
  {
    v6 = -6.2832;
    goto LABEL_5;
  }
LABEL_6:
  *((float *)pVoidOut + 2) = v4 + (float)(v5 * fAlpha);
  *((float *)pVoidOut + 3) = *((float *)pVoidIn1 + 3)
                           + (float)((float)(*((float *)pVoidIn2 + 3) - *((float *)pVoidIn1 + 3)) * fAlpha);
  *((float *)pVoidOut + 4) = *((float *)pVoidIn1 + 4)
                           + (float)((float)(*((float *)pVoidIn2 + 4) - *((float *)pVoidIn1 + 4)) * fAlpha);
  *((float *)pVoidOut + 5) = *((float *)pVoidIn1 + 5)
                           + (float)((float)(*((float *)pVoidIn2 + 5) - *((float *)pVoidIn1 + 5)) * fAlpha);
  *((float *)pVoidOut + 6) = *((float *)pVoidIn1 + 6)
                           + (float)((float)(*((float *)pVoidIn2 + 6) - *((float *)pVoidIn1 + 6)) * fAlpha);
  *((float *)pVoidOut + 7) = *((float *)pVoidIn1 + 7)
                           + (float)((float)(*((float *)pVoidIn2 + 7) - *((float *)pVoidIn1 + 7)) * fAlpha);
}

//----- (001CA184) --------------------------------------------------------
RpUVAnimParamKeyFrameData_0 *__fastcall RpUVAnimParamKeyFrameDataInitFromMatrix(
        RpUVAnimParamKeyFrameData_0 *data,
        const RwMatrix *matrix)
{
  const RwMatrix *v3; // r0
  RwV3d_0 *p_at; // r2
  RwV3d_0 *p_pos; // r1
  __int64 v6; // d23
  __int64 v7; // d16
  __int64 v8; // d17
  __int64 v9; // d18
  __int64 v10; // d19
  __int64 v11; // d20
  __int64 v12; // d21
  RwReal y; // r1
  RwReal v14; // r2
  __int64 v15; // kr00_8
  RwV3d_0 v17; // [sp+0h] [bp-58h] BYREF
  RwMatrix x; // [sp+10h] [bp-48h] BYREF

  v3 = matrix;
  p_at = &matrix->at;
  p_pos = &matrix->pos;
  v6 = *(_QWORD *)&p_pos->z;
  v7 = *(_QWORD *)&v3->right.x;
  v8 = *(_QWORD *)&v3->right.z;
  v3 = (const RwMatrix *)((char *)v3 + 16);
  v9 = *(_QWORD *)&v3->right.x;
  v10 = *(_QWORD *)&v3->right.z;
  v11 = *(_QWORD *)&p_at->x;
  v12 = *(_QWORD *)&p_at->z;
  *(_QWORD *)&x.pos.x = *(_QWORD *)&p_pos->x;
  *(_QWORD *)&x.pos.z = v6;
  *(_QWORD *)&x.at.x = v11;
  *(_QWORD *)&x.at.z = v12;
  *(_QWORD *)&x.right.x = v7;
  *(_QWORD *)&x.right.z = v8;
  *(_QWORD *)&x.up.x = v9;
  *(_QWORD *)&x.up.z = v10;
  *(_QWORD *)&v17.x = unk_5EA4A0;
  v17.z = 1.0;
  data->theta = atan2f(COERCE_FLOAT(v9 ^ 0x80000000), *(float *)&v7);
  RwMatrixTranslate(&x, &rpUVAnimPivot, rwCOMBINEPOSTCONCAT);
  RwMatrixRotate(&x, &v17, (float)(data->theta / 3.1416) * -180.0, rwCOMBINEPOSTCONCAT);
  RwMatrixTranslate(&x, &rpUVAnimInvPivot, rwCOMBINEPOSTCONCAT);
  y = x.right.y;
  v14 = x.up.y;
  v15 = *(_QWORD *)&x.pos.x;
  data->s0 = x.right.x;
  data->s1 = v14;
  data->skew = y;
  *(_QWORD *)&data->x = v15;
  return data;
}

//----- (001CA24C) --------------------------------------------------------
RpUVAnim *__fastcall RpUVAnimAddRef(RpUVAnim *anim)
{
  ++*((_DWORD *)anim->customData + 16);
  return anim;
}

//----- (001CA258) --------------------------------------------------------
RwBool __fastcall RpUVAnimDestroy(RpUVAnim *anim)
{
  _DWORD *customData; // r0
  int v3; // r1

  customData = anim->customData;
  v3 = customData[16] - 1;
  customData[16] = v3;
  if ( !v3 )
  {
    (*((void (__fastcall **)(RwFreeList_0 *, void *))RwEngineInstance + 80))(
      _rpUVAnimCustomDataFreeList,
      anim->customData);
    RtAnimAnimationDestroy(anim);
  }
  return 1;
}

//----- (001CA294) --------------------------------------------------------
const RwChar *__fastcall RpUVAnimGetName(const RpUVAnim *anim)
{
  return (const RwChar *)anim->customData;
}

//----- (001CA298) --------------------------------------------------------
bool RpUVAnimPluginAttach()
{
  int v0; // r4

  v0 = 0;
  if ( RwEngineRegisterPlugin(0, 0x135u, UVAnimOpen, UVAnimClose) >= 0 )
  {
    RpUVAnimMaterialGlobals.engineOffset = RpMaterialRegisterPlugin(
                                             40,
                                             0x135u,
                                             UVAnimConstructor,
                                             UVAnimDestructor,
                                             UVAnimCopy);
    return (RpMaterialRegisterPluginStream(0x135u, UVAnimRead, UVAnimWrite, UVAnimSize) | RpUVAnimMaterialGlobals.engineOffset) >= 0;
  }
  return v0;
}

//----- (001CA320) --------------------------------------------------------
void *__fastcall UVAnimOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  RwFreeList_0 *v4; // r5

  v4 = RwFreeListCreateAndPreallocateSpace(
         68,
         _rpUVAnimCustomDataFreeListBlockSize,
         4,
         _rpUVAnimCustomDataFreeListPreallocBlocks,
         _rpUVAnimCustomDataFreeList);
  _rpUVAnimCustomDataFreeList = v4;
  RtDictSchemaInit(&rpUVAnimDictSchema);
  RtAnimRegisterInterpolationScheme(&rpUVAnimLinearInterpolatorInfo);
  RtAnimRegisterInterpolationScheme(&rpUVAnimParamInterpolatorInfo);
  ++rpUVAnimModule.numInstances;
  if ( !v4 )
    return 0;
  return instance;
}

//----- (001CA3A4) --------------------------------------------------------
void *__fastcall UVAnimClose(void *instance, RwInt32 offset, RwInt32 size)
{
  --rpUVAnimModule.numInstances;
  RtDictSchemaDestruct(&rpUVAnimDictSchema);
  if ( _rpUVAnimCustomDataFreeList )
  {
    RwFreeListDestroy(_rpUVAnimCustomDataFreeList);
    _rpUVAnimCustomDataFreeList = 0;
  }
  return instance;
}

//----- (001CA3E8) --------------------------------------------------------
void *__fastcall UVAnimConstructor(void *object, RwInt32 offset, RwInt32 size)
{
  char *v3; // r1

  v3 = (char *)object + RpUVAnimMaterialGlobals.engineOffset;
  *((_DWORD *)v3 + 8) = 0;
  *((_DWORD *)v3 + 9) = 0;
  *(_QWORD *)v3 = 0LL;
  *((_QWORD *)v3 + 1) = 0LL;
  v3 += 16;
  *(_QWORD *)v3 = 0LL;
  *((_QWORD *)v3 + 1) = 0LL;
  return object;
}

//----- (001CA40C) --------------------------------------------------------
void *__fastcall UVAnimDestructor(void *object, RwInt32 offset, RwInt32 size)
{
  _DWORD *v4; // r5
  RwMatrix *v5; // r0
  RwMatrix *v6; // r0
  int v7; // r4
  _DWORD *v8; // r9
  RtAnimInterpolator_0 *v9; // r5
  RtAnimAnimation_0 *pCurrentAnim; // r6
  _DWORD *customData; // r0
  int v12; // r1

  v4 = (char *)object + RpUVAnimMaterialGlobals.engineOffset;
  v5 = *(RwMatrix **)((char *)object + RpUVAnimMaterialGlobals.engineOffset);
  if ( v5 )
    RwMatrixDestroy(v5);
  v6 = (RwMatrix *)v4[1];
  v7 = 0;
  *v4 = 0;
  if ( v6 )
    RwMatrixDestroy(v6);
  v8 = v4 + 2;
  v4[1] = 0;
  do
  {
    v9 = (RtAnimInterpolator_0 *)v8[v7];
    if ( v9 )
    {
      pCurrentAnim = v9->pCurrentAnim;
      customData = v9->pCurrentAnim->customData;
      v12 = customData[16] - 1;
      customData[16] = v12;
      if ( !v12 )
      {
        (*((void (__fastcall **)(RwFreeList_0 *, void *))RwEngineInstance + 80))(
          _rpUVAnimCustomDataFreeList,
          pCurrentAnim->customData);
        RtAnimAnimationDestroy(pCurrentAnim);
      }
      RtAnimInterpolatorDestroy(v9);
    }
    ++v7;
  }
  while ( v7 != 8 );
  return object;
}

//----- (001CA49C) --------------------------------------------------------
void *__fastcall UVAnimCopy(void *dstObject, const void *srcObject, RwInt32 offset, RwInt32 size)
{
  __int64 *v4; // r3
  __int64 v5; // d20
  char *v6; // r1
  __int64 v7; // d16
  __int64 v8; // d17
  __int64 v9; // d18
  __int64 v10; // d19
  _QWORD *v11; // r3
  int v12; // r2
  int v13; // r2
  int v14; // r2
  int v15; // r2
  int v16; // r2
  int v17; // r2
  int v18; // r2
  int v19; // r1

  v4 = (__int64 *)((char *)srcObject + RpUVAnimMaterialGlobals.engineOffset);
  v5 = *(_QWORD *)((char *)srcObject + RpUVAnimMaterialGlobals.engineOffset + 32);
  v6 = (char *)dstObject + RpUVAnimMaterialGlobals.engineOffset;
  v7 = *v4;
  v8 = v4[1];
  v4 += 2;
  v9 = *v4;
  v10 = v4[1];
  v11 = (char *)dstObject + RpUVAnimMaterialGlobals.engineOffset;
  *v11 = v7;
  v11[1] = v8;
  v11 += 2;
  v12 = *((_DWORD *)v6 + 2);
  *((_QWORD *)v6 + 4) = v5;
  *v11 = v9;
  v11[1] = v10;
  if ( v12 )
    ++*(_DWORD *)(*(_DWORD *)(*(_DWORD *)v12 + 20) + 64);
  v13 = *((_DWORD *)v6 + 3);
  if ( v13 )
    ++*(_DWORD *)(*(_DWORD *)(*(_DWORD *)v13 + 20) + 64);
  v14 = *((_DWORD *)v6 + 4);
  if ( v14 )
    ++*(_DWORD *)(*(_DWORD *)(*(_DWORD *)v14 + 20) + 64);
  v15 = *((_DWORD *)v6 + 5);
  if ( v15 )
    ++*(_DWORD *)(*(_DWORD *)(*(_DWORD *)v15 + 20) + 64);
  v16 = *((_DWORD *)v6 + 6);
  if ( v16 )
    ++*(_DWORD *)(*(_DWORD *)(*(_DWORD *)v16 + 20) + 64);
  v17 = *((_DWORD *)v6 + 7);
  if ( v17 )
    ++*(_DWORD *)(*(_DWORD *)(*(_DWORD *)v17 + 20) + 64);
  v18 = *((_DWORD *)v6 + 8);
  if ( v18 )
    ++*(_DWORD *)(*(_DWORD *)(*(_DWORD *)v18 + 20) + 64);
  v19 = *((_DWORD *)v6 + 9);
  if ( v19 )
    ++*(_DWORD *)(*(_DWORD *)(*(_DWORD *)v19 + 20) + 64);
  return dstObject;
}

//----- (001CA55C) --------------------------------------------------------
RwStream_0 *__fastcall UVAnimRead(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  RwStream_0 *v5; // r4
  int v7; // r5
  RwInt32 engineOffset; // r6
  char *v9; // r10
  int v10; // r6
  RtDict_0 *CurrentDict; // r0
  RpUVAnim *NamedEntry; // r0
  RpUVAnim *DummyAnim; // r5
  RwInt32 NumNodes; // r0
  RtAnimInterpolator_0 *v15; // r0
  _DWORD *customData; // r0
  int v17; // r1
  RpUVAnimMaterialExtension_0 *matExt; // [sp+0h] [bp-48h]
  RwInt32 ints; // [sp+4h] [bp-44h] BYREF
  RwChar buffer[32]; // [sp+8h] [bp-40h] BYREF

  v5 = stream;
  v7 = 0;
  engineOffset = RpUVAnimMaterialGlobals.engineOffset;
  if ( RwStreamFindChunk(stream, 1u, 0, 0) )
  {
    if ( RwStreamReadInt32(v5, &ints, 4u) )
    {
      matExt = (RpUVAnimMaterialExtension_0 *)((char *)object + engineOffset);
      v9 = (char *)object + engineOffset + 8;
      v10 = 0;
      while ( 1 )
      {
        if ( (ints & (1 << v10)) != 0 )
        {
          if ( !RwStreamRead(v5, buffer, 0x20u) )
            return 0;
          CurrentDict = RtDictSchemaGetCurrentDict(&rpUVAnimDictSchema);
          if ( CurrentDict
            && (NamedEntry = (RpUVAnim *)RtDictFindNamedEntry(CurrentDict, buffer), (DummyAnim = NamedEntry) != 0) )
          {
            ++*((_DWORD *)NamedEntry->customData + 16);
            if ( !v5 )
              return 0;
          }
          else
          {
            DummyAnim = CreateDummyAnim(buffer);
            if ( !DummyAnim || !v5 )
              return 0;
          }
          if ( DummyAnim )
          {
            NumNodes = RtAnimAnimationGetNumNodes(DummyAnim);
            v15 = RtAnimInterpolatorCreate(NumNodes, DummyAnim->interpInfo->interpKeyFrameSize);
            *(_DWORD *)&v9[4 * v10] = v15;
            if ( !v15 || !RtAnimInterpolatorSetCurrentAnim(v15, DummyAnim) )
              break;
          }
        }
        if ( (unsigned int)++v10 >= 8 )
        {
          if ( !_rpUVAnimCreateConsistantMatrices(matExt) )
            return 0;
          return v5;
        }
      }
      customData = DummyAnim->customData;
      v17 = customData[16] - 1;
      customData[16] = v17;
      if ( !v17 )
      {
        (*((void (__fastcall **)(RwFreeList_0 *, void *))RwEngineInstance + 80))(
          _rpUVAnimCustomDataFreeList,
          DummyAnim->customData);
        RtAnimAnimationDestroy(DummyAnim);
      }
    }
    return 0;
  }
  return (RwStream_0 *)v7;
}

//----- (001CA690) --------------------------------------------------------
RwStream_0 *__fastcall UVAnimWrite(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        const void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  char *v6; // r5
  RwInt32 v7; // r2
  bool v8; // zf
  __int64 v9; // r0
  int v10; // r0
  int v11; // r0
  int v12; // r0
  int v13; // r0
  int v14; // r0
  int v15; // r0
  int v16; // r0
  int v17; // r0
  RwInt32 ints[3]; // [sp+4h] [bp-Ch] BYREF

  ints[0] = 0;
  v6 = (char *)object + RpUVAnimMaterialGlobals.engineOffset;
  v7 = 36;
  v9 = *((_QWORD *)v6 + 1);
  v8 = (_DWORD)v9 == 0;
  LODWORD(v9) = v9 != 0;
  ints[0] = v9;
  if ( v8 )
    v7 = 4;
  if ( HIDWORD(v9) )
  {
    LODWORD(v9) = v9 | 2;
    ints[0] = v9;
    v7 += 32;
  }
  if ( *((_DWORD *)v6 + 4) )
  {
    LODWORD(v9) = v9 | 4;
    ints[0] = v9;
    v7 += 32;
  }
  if ( *((_DWORD *)v6 + 5) )
  {
    LODWORD(v9) = v9 | 8;
    ints[0] = v9;
    v7 += 32;
  }
  if ( *((_DWORD *)v6 + 6) )
  {
    LODWORD(v9) = v9 | 0x10;
    ints[0] = v9;
    v7 += 32;
  }
  if ( *((_DWORD *)v6 + 7) )
  {
    LODWORD(v9) = v9 | 0x20;
    ints[0] = v9;
    v7 += 32;
  }
  if ( *((_DWORD *)v6 + 8) )
  {
    LODWORD(v9) = v9 | 0x40;
    ints[0] = v9;
    v7 += 32;
  }
  if ( *((_DWORD *)v6 + 9) )
  {
    ints[0] = v9 | 0x80;
    v7 += 32;
  }
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 1, v7, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu)
    || !RwStreamWriteInt32(stream, ints, 4u) )
  {
    return 0;
  }
  v10 = *((_DWORD *)v6 + 2);
  if ( v10 )
    RwStreamWrite(stream, *(const void **)(*(_DWORD *)v10 + 20), 0x20u);
  v11 = *((_DWORD *)v6 + 3);
  if ( v11 )
    RwStreamWrite(stream, *(const void **)(*(_DWORD *)v11 + 20), 0x20u);
  v12 = *((_DWORD *)v6 + 4);
  if ( v12 )
    RwStreamWrite(stream, *(const void **)(*(_DWORD *)v12 + 20), 0x20u);
  v13 = *((_DWORD *)v6 + 5);
  if ( v13 )
    RwStreamWrite(stream, *(const void **)(*(_DWORD *)v13 + 20), 0x20u);
  v14 = *((_DWORD *)v6 + 6);
  if ( v14 )
    RwStreamWrite(stream, *(const void **)(*(_DWORD *)v14 + 20), 0x20u);
  v15 = *((_DWORD *)v6 + 7);
  if ( v15 )
    RwStreamWrite(stream, *(const void **)(*(_DWORD *)v15 + 20), 0x20u);
  v16 = *((_DWORD *)v6 + 8);
  if ( v16 )
    RwStreamWrite(stream, *(const void **)(*(_DWORD *)v16 + 20), 0x20u);
  v17 = *((_DWORD *)v6 + 9);
  if ( v17 )
    RwStreamWrite(stream, *(const void **)(*(_DWORD *)v17 + 20), 0x20u);
  return stream;
}
// 35FFC: using guessed type Elf32_Sym stru_35FFC;
// 1CA690: using guessed type RwInt32 ints[3];

//----- (001CA7D0) --------------------------------------------------------
RwInt32 __fastcall UVAnimSize(const void *object, RwInt32 offsetInObject, RwInt32 sizeInObject)
{
  _DWORD *v3; // r1
  int v4; // r3
  __int64 v5; // kr00_8
  int v6; // r0
  bool v7; // zf
  __int64 v8; // kr08_8
  RwInt32 result; // r0
  int v10; // r4
  int v11; // r5
  int v12; // r6
  int v13; // r1
  int v14; // r0
  bool v15; // zf

  v3 = (char *)object + RpUVAnimMaterialGlobals.engineOffset;
  v5 = *(_QWORD *)((char *)object + RpUVAnimMaterialGlobals.engineOffset + 8);
  v4 = HIDWORD(v5);
  if ( !v5 )
  {
    v6 = v3[4];
    v7 = v6 == 0;
    if ( !v6 )
      v7 = v3[5] == 0;
    if ( !v7 || v3[6] )
      goto LABEL_5;
    v14 = v3[7];
    v15 = v14 == 0;
    if ( !v14 )
      v15 = v3[8] == 0;
    if ( v15 )
    {
      v4 = 0;
      if ( !v3[9] )
        return 0;
    }
    else
    {
LABEL_5:
      v4 = 0;
    }
  }
  v8 = *((_QWORD *)v3 + 2);
  result = 48;
  v10 = v3[6];
  v11 = v3[7];
  v12 = v3[8];
  v13 = v3[9];
  if ( !(_DWORD)v5 )
    result = 16;
  if ( v4 )
    result += 32;
  if ( (_DWORD)v8 )
    result += 32;
  if ( HIDWORD(v8) )
    result += 32;
  if ( v10 )
    result += 32;
  if ( v11 )
    result += 32;
  if ( v12 )
    result += 32;
  if ( v13 )
    result += 32;
  return result;
}

//----- (001CA868) --------------------------------------------------------
void __fastcall RpUVAnimSetFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rpUVAnimCustomDataFreeListPreallocBlocks = numBlocksToPrealloc;
  _rpUVAnimCustomDataFreeListBlockSize = blockSize;
}

//----- (001CA880) --------------------------------------------------------
_rpUVAnimCustomData_0 *__fastcall _rpUVAnimCustomDataStreamRead(RwStream_0 *stream)
{
  _rpUVAnimCustomData_0 *v2; // r4

  v2 = (_rpUVAnimCustomData_0 *)(*((int (__fastcall **)(RwFreeList_0 *))RwEngineInstance + 79))(_rpUVAnimCustomDataFreeList);
  if ( !v2 || !RwStreamRead(stream, v2, 0x20u) || !RwStreamReadInt32(stream, (RwInt32 *)v2->nodeToUVChannelMap, 0x20u) )
    return 0;
  v2->refCount = 1;
  return v2;
}

//----- (001CA8D0) --------------------------------------------------------
const _rpUVAnimCustomData_0 *__fastcall _rpUVAnimCustomDataStreamWrite(
        const _rpUVAnimCustomData_0 *customData,
        RwStream_0 *stream)
{
  const _rpUVAnimCustomData_0 *result; // r0

  if ( !RwStreamWrite(stream, customData, 0x20u) )
    return 0;
  result = (const _rpUVAnimCustomData_0 *)RwStreamWriteInt32(
                                            stream,
                                            (const RwInt32 *)customData->nodeToUVChannelMap,
                                            0x20u);
  if ( result )
    return customData;
  return result;
}

//----- (001CA8FC) --------------------------------------------------------
RwUInt32 __fastcall _rpUVAnimCustomDataStreamGetSize(const _rpUVAnimCustomData_0 *customData)
{
  return 64;
}

//----- (001CA900) --------------------------------------------------------
RpUVAnim *__fastcall RpUVAnimCreate(
        const RwChar *name,
        RwUInt32 numNodes,
        RwUInt32 numFrames,
        RwReal duration,
        RwUInt32 *nodeIndexToUVChannelMap,
        RpUVAnimKeyFrameType_0 keyframeType)
{
  RtAnimInterpolatorInfo_0 **v8; // r0
  RtAnimAnimation_0 *v9; // r4
  RtAnimAnimation_0 *v10; // r6
  char *v11; // r0
  char *v12; // r5

  if ( keyframeType == rpUVANIMPARAMKEYFRAMES )
  {
    v8 = &rpUVAnimParamInterpolatorInfo_ptr;
  }
  else
  {
    if ( keyframeType )
      return 0;
    v8 = &rpUVAnimLinearInterpolatorInfo_ptr;
  }
  v9 = 0;
  v10 = RtAnimAnimationCreate((*v8)->typeID, numFrames, 0, duration);
  if ( v10 )
  {
    v11 = (char *)(*((int (__fastcall **)(RwFreeList_0 *))RwEngineInstance + 79))(_rpUVAnimCustomDataFreeList);
    v12 = v11;
    v9 = 0;
    if ( v11 )
    {
      strncpy(v11, (const char *)name, 0x20u);
      v12[31] = 0;
      qmemcpy(v12 + 32, nodeIndexToUVChannelMap, 4 * numNodes);
      v9 = v10;
      *((_DWORD *)v12 + 16) = 1;
      v10->customData = v12;
    }
  }
  return v9;
}
// 678358: using guessed type RtAnimInterpolatorInfo_0 *rpUVAnimLinearInterpolatorInfo_ptr;
// 6792AC: using guessed type RtAnimInterpolatorInfo_0 *rpUVAnimParamInterpolatorInfo_ptr;

//----- (001CA98C) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMaterialUVAnimApplyUpdate(RpMaterial_0 *material)
{
  _DWORD *v1; // r1
  int v2; // r3
  RwMatrix *v3; // r1
  RwUInt32 flags; // r3
  int i; // r11
  RwReal *p_x; // r9
  int v7; // r0
  RwReal *v8; // r6
  int v9; // r10
  void (__fastcall *v10)(void *, void *); // r8
  int v11; // r5
  unsigned int v12; // r1
  RwMatrix *v13; // r4
  int v16; // [sp+18h] [bp-88h]
  RwMatrix **v17; // [sp+1Ch] [bp-84h]
  RwV3d_0 axis; // [sp+20h] [bp-80h] BYREF
  RwMatrix transform; // [sp+30h] [bp-70h] BYREF

  v17 = (RwMatrix **)((char *)material + RpUVAnimMaterialGlobals.engineOffset);
  v1 = *(RwTexture_0 **)((char *)&material->texture + RpUVAnimMaterialGlobals.engineOffset);
  if ( v1 )
  {
    v1[5] = 1065353216;
    v2 = v1[3];
    v1[4] = 0;
    v1[2] = 0;
    *v1 = 1065353216;
    v1[1] = 0;
    v1[6] = 0;
    v1[8] = 0;
    v1[9] = 0;
    v1[10] = 1065353216;
    v1[12] = 0;
    v1[13] = 0;
    v1[14] = 0;
    v1[3] = v2 | 0x20003;
  }
  v3 = v17[1];
  if ( v3 )
  {
    v3->up.y = 1.0;
    flags = v3->flags;
    v3->up.x = 0.0;
    v3->right.z = 0.0;
    v3->right.x = 1.0;
    v3->right.y = 0.0;
    v3->up.z = 0.0;
    v3->at.x = 0.0;
    v3->at.y = 0.0;
    v3->at.z = 1.0;
    v3->pos.x = 0.0;
    v3->pos.y = 0.0;
    v3->pos.z = 0.0;
    v3->flags = flags | 0x20003;
  }
  for ( i = 0; i != 8; ++i )
  {
    p_x = &v17[i + 2]->right.x;
    if ( p_x )
    {
      v7 = *((_DWORD *)p_x + 11);
      if ( v7 >= 1 )
      {
        v8 = p_x + 19;
        v9 = 0;
        v16 = *((_DWORD *)p_x + 9);
        v10 = (void (__fastcall *)(void *, void *))*((_DWORD *)p_x + 15);
        v11 = *(_DWORD *)(*(_DWORD *)p_x + 20) + 32;
        do
        {
          v12 = *(_DWORD *)(v11 + 4 * v9);
          if ( v12 <= 1 )
          {
            v13 = v17[v12];
            if ( v13 )
            {
              if ( v10 == RpUVAnimLinearKeyFrameApply )
              {
                transform.right.x = v8[2];
                transform.right.y = v8[3];
                transform.right.z = 0.0;
                transform.up.x = v8[4];
                transform.up.y = v8[5];
                transform.up.z = 0.0;
                memset(&transform.at, 0, sizeof(transform.at));
                transform.pos.x = v8[6];
                transform.pos.y = v8[7];
                transform.pos.z = 0.0;
                RwMatrixUpdate(&transform);
              }
              else if ( v10 == RpUVAnimParamKeyFrameApply )
              {
                axis.z = 1.0;
                *(_QWORD *)&axis.x = unk_5EA4C8;
                transform.right.x = v8[3];
                transform.right.y = v8[5];
                transform.right.z = 0.0;
                transform.up.x = 0.0;
                transform.up.y = v8[4];
                transform.up.z = 0.0;
                memset(&transform.at, 0, sizeof(transform.at));
                transform.pos.x = v8[6];
                transform.pos.y = v8[7];
                transform.pos.z = 0.0;
                RwMatrixUpdate(&transform);
                RwMatrixTranslate(&transform, &rpUVAnimPivot, rwCOMBINEPOSTCONCAT);
                RwMatrixRotate(&transform, &axis, (float)(v8[2] / 3.1416) * 180.0, rwCOMBINEPOSTCONCAT);
                RwMatrixTranslate(&transform, &rpUVAnimInvPivot, rwCOMBINEPOSTCONCAT);
              }
              else
              {
                v10(&transform, v8);
              }
              RwMatrixTransform(v13, &transform, rwCOMBINEPRECONCAT);
              v8 = (RwReal *)((char *)v8 + v16);
            }
            v7 = *((_DWORD *)p_x + 11);
          }
          ++v9;
        }
        while ( v9 < v7 );
      }
    }
  }
  RpMatFXMaterialSetUVTransformMatrices(material, *v17, v17[1]);
  return material;
}

//----- (001CAB8C) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMaterialSetUVAnim(RpMaterial_0 *material, RpUVAnim *anim, RwUInt32 slot)
{
  RwInt32 engineOffset; // r5
  RwInt32 NumNodes; // r0
  RpUVAnimMaterialExtension_0 *v8; // r5
  RtAnimInterpolator_0 *v9; // r0

  engineOffset = RpUVAnimMaterialGlobals.engineOffset;
  NumNodes = RtAnimAnimationGetNumNodes(anim);
  v8 = (RpUVAnimMaterialExtension_0 *)((char *)material + engineOffset);
  v9 = RtAnimInterpolatorCreate(NumNodes, anim->interpInfo->interpKeyFrameSize);
  v8->interp[slot] = v9;
  if ( !v9 )
    return 0;
  RtAnimInterpolatorSetCurrentAnim(v9, anim);
  if ( !_rpUVAnimCreateConsistantMatrices(v8) )
  {
    RtAnimInterpolatorDestroy(v8->interp[slot]);
    return 0;
  }
  ++*((_DWORD *)anim->customData + 16);
  return material;
}

//----- (001CABEC) --------------------------------------------------------
RpUVAnimMaterialExtension_0 *__fastcall _rpUVAnimCreateConsistantMatrices(RpUVAnimMaterialExtension_0 *matExt)
{
  unsigned int v2; // r1
  unsigned int v3; // r2
  RtAnimInterpolator_0 *v4; // r3
  unsigned int numNodes; // r0
  int v6; // r3
  RwMatrix *v7; // r0
  unsigned int v8; // r1
  unsigned int v9; // r2
  RtAnimInterpolator_0 *v10; // r3
  unsigned int v11; // r0
  int v12; // r3
  RwMatrix *v13; // r0
  RwMatrix *v15; // r0

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = matExt->interp[v3];
    if ( v4 )
      break;
    v6 = 1;
LABEL_8:
    v3 += v6;
    if ( v3 >= 8 )
    {
      if ( matExt->uv[0] )
      {
        RwMatrixDestroy(matExt->uv[0]);
        matExt->uv[0] = 0;
      }
      goto LABEL_13;
    }
  }
  if ( *((_DWORD *)v4->pCurrentAnim->customData + v2 + 8) )
  {
    numNodes = v4->numNodes;
    ++v2;
    v6 = 0;
    if ( v2 >= numNodes )
    {
      v6 = 1;
      v2 = 0;
    }
    goto LABEL_8;
  }
  if ( !matExt->uv[0] )
  {
    v7 = RwMatrixCreate();
    matExt->uv[0] = v7;
    if ( !v7 )
      return 0;
  }
LABEL_13:
  v8 = 0;
  v9 = 0;
  while ( 2 )
  {
    v10 = matExt->interp[v9];
    if ( !v10 )
    {
      v12 = 1;
      goto LABEL_20;
    }
    if ( *((_DWORD *)v10->pCurrentAnim->customData + v8 + 8) != 1 )
    {
      v11 = v10->numNodes;
      ++v8;
      v12 = 0;
      if ( v8 >= v11 )
      {
        v12 = 1;
        v8 = 0;
      }
LABEL_20:
      v9 += v12;
      if ( v9 >= 8 )
      {
        v13 = matExt->uv[1];
        if ( v13 )
        {
          RwMatrixDestroy(v13);
          matExt->uv[1] = 0;
          return matExt;
        }
        return matExt;
      }
      continue;
    }
    break;
  }
  if ( matExt->uv[1] )
    return matExt;
  v15 = RwMatrixCreate();
  matExt->uv[1] = v15;
  if ( !v15 )
    return 0;
  return matExt;
}

//----- (001CACA8) --------------------------------------------------------
RpUVAnimInterpolator *__fastcall RpMaterialUVAnimGetInterpolator(RpMaterial_0 *material, RwUInt32 slot)
{
  return *(RpUVAnimInterpolator **)((char *)&material->pipeline + 4 * slot + RpUVAnimMaterialGlobals.engineOffset);
}

//----- (001CACC0) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMaterialUVAnimSetInterpolator(
        RpMaterial_0 *material,
        RpUVAnimInterpolator *interp,
        RwUInt32 slot)
{
  *(RxPipeline_0 **)((char *)&material->pipeline + 4 * slot + RpUVAnimMaterialGlobals.engineOffset) = (RxPipeline_0 *)interp;
  return material;
}

//----- (001CACD8) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMaterialUVAnimSetCurrentTime(RpMaterial_0 *material, RwReal time)
{
  _DWORD *v4; // r6
  RtAnimInterpolator_0 *v5; // r0
  RtAnimInterpolator_0 *v6; // r0
  RtAnimInterpolator_0 *v7; // r0
  RtAnimInterpolator_0 *v8; // r0
  RtAnimInterpolator_0 *v9; // r0
  RtAnimInterpolator_0 *v10; // r0
  RtAnimInterpolator_0 *v11; // r0
  RtAnimInterpolator_0 *v12; // r0

  v4 = (RwTexture_0 **)((char *)&material->texture + RpUVAnimMaterialGlobals.engineOffset);
  v5 = *(RtAnimInterpolator_0 **)((char *)&material->pipeline + RpUVAnimMaterialGlobals.engineOffset);
  if ( v5 )
    RtAnimInterpolatorSetCurrentTime(v5, time);
  v6 = (RtAnimInterpolator_0 *)v4[3];
  if ( v6 )
    RtAnimInterpolatorSetCurrentTime(v6, time);
  v7 = (RtAnimInterpolator_0 *)v4[4];
  if ( v7 )
    RtAnimInterpolatorSetCurrentTime(v7, time);
  v8 = (RtAnimInterpolator_0 *)v4[5];
  if ( v8 )
    RtAnimInterpolatorSetCurrentTime(v8, time);
  v9 = (RtAnimInterpolator_0 *)v4[6];
  if ( v9 )
    RtAnimInterpolatorSetCurrentTime(v9, time);
  v10 = (RtAnimInterpolator_0 *)v4[7];
  if ( v10 )
    RtAnimInterpolatorSetCurrentTime(v10, time);
  v11 = (RtAnimInterpolator_0 *)v4[8];
  if ( v11 )
    RtAnimInterpolatorSetCurrentTime(v11, time);
  v12 = (RtAnimInterpolator_0 *)v4[9];
  if ( v12 )
    RtAnimInterpolatorSetCurrentTime(v12, time);
  return material;
}

//----- (001CAD5C) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMaterialUVAnimAddAnimTime(RpMaterial_0 *material, RwReal deltaTime)
{
  _DWORD *v4; // r6
  RtAnimInterpolator_0 *v5; // r0
  RtAnimInterpolator_0 *v6; // r0
  RtAnimInterpolator_0 *v7; // r0
  RtAnimInterpolator_0 *v8; // r0
  RtAnimInterpolator_0 *v9; // r0
  RtAnimInterpolator_0 *v10; // r0
  RtAnimInterpolator_0 *v11; // r0
  RtAnimInterpolator_0 *v12; // r0

  v4 = (RwTexture_0 **)((char *)&material->texture + RpUVAnimMaterialGlobals.engineOffset);
  v5 = *(RtAnimInterpolator_0 **)((char *)&material->pipeline + RpUVAnimMaterialGlobals.engineOffset);
  if ( v5 )
    RtAnimInterpolatorAddAnimTime(v5, deltaTime);
  v6 = (RtAnimInterpolator_0 *)v4[3];
  if ( v6 )
    RtAnimInterpolatorAddAnimTime(v6, deltaTime);
  v7 = (RtAnimInterpolator_0 *)v4[4];
  if ( v7 )
    RtAnimInterpolatorAddAnimTime(v7, deltaTime);
  v8 = (RtAnimInterpolator_0 *)v4[5];
  if ( v8 )
    RtAnimInterpolatorAddAnimTime(v8, deltaTime);
  v9 = (RtAnimInterpolator_0 *)v4[6];
  if ( v9 )
    RtAnimInterpolatorAddAnimTime(v9, deltaTime);
  v10 = (RtAnimInterpolator_0 *)v4[7];
  if ( v10 )
    RtAnimInterpolatorAddAnimTime(v10, deltaTime);
  v11 = (RtAnimInterpolator_0 *)v4[8];
  if ( v11 )
    RtAnimInterpolatorAddAnimTime(v11, deltaTime);
  v12 = (RtAnimInterpolator_0 *)v4[9];
  if ( v12 )
    RtAnimInterpolatorAddAnimTime(v12, deltaTime);
  return material;
}

//----- (001CADE0) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMaterialUVAnimSubAnimTime(RpMaterial_0 *material, RwReal deltaTime)
{
  _DWORD *v4; // r6
  RtAnimInterpolator_0 *v5; // r0
  RtAnimInterpolator_0 *v6; // r0
  RtAnimInterpolator_0 *v7; // r0
  RtAnimInterpolator_0 *v8; // r0
  RtAnimInterpolator_0 *v9; // r0
  RtAnimInterpolator_0 *v10; // r0
  RtAnimInterpolator_0 *v11; // r0
  RtAnimInterpolator_0 *v12; // r0

  v4 = (RwTexture_0 **)((char *)&material->texture + RpUVAnimMaterialGlobals.engineOffset);
  v5 = *(RtAnimInterpolator_0 **)((char *)&material->pipeline + RpUVAnimMaterialGlobals.engineOffset);
  if ( v5 )
    RtAnimInterpolatorSubAnimTime(v5, deltaTime);
  v6 = (RtAnimInterpolator_0 *)v4[3];
  if ( v6 )
    RtAnimInterpolatorSubAnimTime(v6, deltaTime);
  v7 = (RtAnimInterpolator_0 *)v4[4];
  if ( v7 )
    RtAnimInterpolatorSubAnimTime(v7, deltaTime);
  v8 = (RtAnimInterpolator_0 *)v4[5];
  if ( v8 )
    RtAnimInterpolatorSubAnimTime(v8, deltaTime);
  v9 = (RtAnimInterpolator_0 *)v4[6];
  if ( v9 )
    RtAnimInterpolatorSubAnimTime(v9, deltaTime);
  v10 = (RtAnimInterpolator_0 *)v4[7];
  if ( v10 )
    RtAnimInterpolatorSubAnimTime(v10, deltaTime);
  v11 = (RtAnimInterpolator_0 *)v4[8];
  if ( v11 )
    RtAnimInterpolatorSubAnimTime(v11, deltaTime);
  v12 = (RtAnimInterpolator_0 *)v4[9];
  if ( v12 )
    RtAnimInterpolatorSubAnimTime(v12, deltaTime);
  return material;
}

//----- (001CAE64) --------------------------------------------------------
RwBool __fastcall RpMaterialUVAnimExists(const RpMaterial_0 *material)
{
  _DWORD *v1; // r0
  int v2; // r1
  bool v3; // zf
  int v5; // r1
  bool v6; // zf
  int v7; // r1
  bool v8; // zf

  v1 = (RwTexture_0 **)((char *)&material->texture + RpUVAnimMaterialGlobals.engineOffset);
  if ( v1[2] )
    return 1;
  v2 = v1[3];
  v3 = v2 == 0;
  if ( !v2 )
    v3 = v1[4] == 0;
  if ( !v3 )
    return 1;
  v5 = v1[5];
  v6 = v5 == 0;
  if ( !v5 )
    v6 = v1[6] == 0;
  if ( !v6 )
    return 1;
  v7 = v1[7];
  v8 = v7 == 0;
  if ( !v7 )
    v8 = v1[8] == 0;
  return !v8 || v1[9] != 0;
}

//----- (001CAEA8) --------------------------------------------------------
RpUVAnim *__fastcall CreateDummyAnim(const RwChar *name)
{
  RpUVAnim *v2; // r5
  RtAnimAnimation_0 *v3; // r4
  char *v4; // r0
  char *v5; // r6
  RtAnimInterpolatorInfo_0 *interpInfo; // r0
  RpUVAnimKeyFrame_0 *pFrames; // r8
  RwInt32 animKeyFrameSize; // r6
  RwMatrix matrix; // [sp+8h] [bp-50h] BYREF

  v2 = 0;
  v3 = RtAnimAnimationCreate(rpUVAnimLinearInterpolatorInfo.typeID, 2, 0, 1.0);
  if ( v3 )
  {
    v4 = (char *)(*((int (__fastcall **)(RwFreeList_0 *))RwEngineInstance + 79))(_rpUVAnimCustomDataFreeList);
    v5 = v4;
    v2 = 0;
    if ( v4 )
    {
      strncpy(v4, (const char *)name, 0x20u);
      v5[31] = 0;
      *((_DWORD *)v5 + 8) = 0;
      *((_DWORD *)v5 + 16) = 1;
      interpInfo = v3->interpInfo;
      pFrames = (RpUVAnimKeyFrame_0 *)v3->pFrames;
      v3->customData = v5;
      animKeyFrameSize = interpInfo->animKeyFrameSize;
      matrix.at.z = 1.0;
      matrix.up.x = 0.0;
      matrix.up.y = 1.0;
      matrix.right.z = 0.0;
      matrix.right.x = 1.0;
      matrix.right.y = 0.0;
      matrix.up.z = 0.0;
      matrix.at.x = 0.0;
      matrix.at.y = 0.0;
      matrix.flags = -1;
      memset(&matrix.pos, 0, sizeof(matrix.pos));
      RpUVAnimKeyFrameInit(v3, pFrames, 0LL, &matrix);
      RpUVAnimKeyFrameInit(
        v3,
        (RpUVAnimKeyFrame_0 *)((char *)pFrames + animKeyFrameSize),
        (unsigned int)pFrames | 0x3F80000000000000LL,
        &matrix);
      return v3;
    }
  }
  return v2;
}

//----- (001CAF60) --------------------------------------------------------
RpUVAnimKeyFrame_0 *__fastcall RpUVAnimKeyFrameInit(
        const RtAnimAnimation_0 *animation,
        RpUVAnimKeyFrame_0 *keyFrame,
        __int64 prevFrame,
        RwMatrix *a4)
{
  RwInt32 typeID; // r0

  *(_QWORD *)&keyFrame->prevFrame = prevFrame;
  typeID = animation->interpInfo->typeID;
  if ( typeID == rpUVAnimLinearInterpolatorInfo.typeID )
  {
    if ( RpUVAnimLinearKeyFrameDataInitFromMatrix(&keyFrame->data.linear, a4) )
      return 0;
    typeID = animation->interpInfo->typeID;
  }
  if ( typeID == rpUVAnimParamInterpolatorInfo.typeID )
    RpUVAnimParamKeyFrameDataInitFromMatrix((RpUVAnimParamKeyFrameData_0 *)&keyFrame->data, a4);
  return 0;
}

//----- (001CAFB8) --------------------------------------------------------
RtAnimAnimation_0 *__fastcall RpUVAnimKeyFrameStreamRead(RwStream_0 *stream, RtAnimAnimation_0 *pAnimation)
{
  _rpUVAnimCustomData_0 *v4; // r0
  RwInt32 numFrames; // r1
  char *pFrames; // r9
  RwReal *v7; // r6
  RwInt32 v8; // r4
  RwInt32 v10; // [sp+0h] [bp-20h] BYREF
  RwInt32 ints[7]; // [sp+4h] [bp-1Ch] BYREF

  if ( !RwStreamReadInt32(stream, ints, 4u) )
    return 0;
  v4 = _rpUVAnimCustomDataStreamRead(stream);
  if ( !v4 )
    return 0;
  numFrames = pAnimation->numFrames;
  pFrames = (char *)pAnimation->pFrames;
  pAnimation->customData = v4;
  if ( numFrames >= 1 )
  {
    v7 = (RwReal *)(pFrames + 4);
    v8 = 0;
    while ( RwStreamReadReal(stream, v7, 0x1Cu) && RwStreamReadInt32(stream, &v10, 4u) )
    {
      ++v8;
      *((_DWORD *)v7 - 1) = &pFrames[32 * v10];
      v7 += 8;
      if ( v8 >= pAnimation->numFrames )
        return pAnimation;
    }
    return 0;
  }
  return pAnimation;
}
// 1CAFB8: using guessed type RwInt32 ints[7];

//----- (001CB02E) --------------------------------------------------------
RwBool __fastcall RpUVAnimKeyFrameStreamWrite(const RtAnimAnimation_0 *pAnimation, RwStream_0 *stream)
{
  RwBool v4; // r6
  char *pFrames; // r9
  int v6; // r5
  const RwReal *i; // r6
  RwInt32 v9; // [sp+0h] [bp-20h] BYREF
  RwInt32 ints[7]; // [sp+4h] [bp-1Ch] BYREF

  v4 = 0;
  ints[0] = 0;
  if ( RwStreamWriteInt32(stream, ints, 4u) )
  {
    if ( !_rpUVAnimCustomDataStreamWrite((const _rpUVAnimCustomData_0 *)pAnimation->customData, stream) )
      return 0;
    if ( pAnimation->numFrames >= 1 )
    {
      pFrames = (char *)pAnimation->pFrames;
      v6 = 0;
      for ( i = (const RwReal *)(pFrames + 4); RwStreamWriteReal(stream, i, 0x1Cu); i += 8 )
      {
        v9 = (*((_DWORD *)i - 1) - (int)pFrames) >> 5;
        if ( !RwStreamWriteInt32(stream, &v9, 4u) )
          break;
        if ( ++v6 >= pAnimation->numFrames )
          return 1;
      }
      return 0;
    }
    return 1;
  }
  return v4;
}
// 1CB02E: using guessed type RwInt32 ints[7];

//----- (001CB0AE) --------------------------------------------------------
RwInt32 __fastcall RpUVAnimKeyFrameStreamGetSize(const RtAnimAnimation_0 *animation)
{
  return _rpUVAnimCustomDataStreamGetSize((const _rpUVAnimCustomData_0 *)animation->customData)
       + 32 * animation->numFrames
       + 4;
}

//----- (001CB0C4) --------------------------------------------------------
void __fastcall ATCConvertFromDXT1(int width, int height, void *imgData)
{
  bool v4; // cf
  signed int v5; // r0
  int v6; // r3
  unsigned int v7; // r1
  int v8; // r0
  int v9; // r8
  _BYTE *v10; // r1
  unsigned int v11; // r5
  unsigned int v12; // r6
  unsigned int v13; // r10
  unsigned int v14; // r4
  int v15; // r9
  char v16; // r0
  int v17; // r3
  int v18; // r5
  char v19; // r0
  int v20; // r3
  int v21; // r6
  int v22; // r9
  int v23; // r4

  v4 = (unsigned int)(width + 3) >= 7;
  v5 = height + ((unsigned int)(height >> 31) >> 30);
  v6 = width / 4;
  v7 = height + 3;
  if ( !v4 )
    v6 = 1;
  v8 = v5 >> 2;
  if ( v7 < 7 )
    v8 = 1;
  v9 = v8 * v6;
  if ( v8 * v6 >= 1 )
  {
    v10 = (char *)imgData + 4;
    do
    {
      v11 = (unsigned __int8)*v10;
      --v9;
      v12 = (unsigned __int8)v10[1];
      v13 = (unsigned __int8)v10[2];
      v14 = (unsigned __int8)v10[3];
      v15 = *(_DWORD *)((char *)&unk_5E8528 + (v11 & 0xC));
      *((_WORD *)v10 - 2) = *((_WORD *)v10 - 2) & 0x1F | (*((_WORD *)v10 - 2) >> 1) & 0x7FE0;
      v16 = *((_DWORD *)&unk_5E8528 + (v11 & 3)) | (4 * v15) | (16 * *((_BYTE *)&unk_5E8528 + ((v11 >> 2) & 0xC)));
      v17 = (unsigned __int8)v11 >> 6;
      v18 = *(_DWORD *)((char *)&unk_5E8528 + ((v14 >> 2) & 0xC));
      *v10 = v16 | (*((_BYTE *)&unk_5E8528 + 4 * v17) << 6);
      v19 = *((_DWORD *)&unk_5E8528 + (v12 & 3)) | (4 * *((_BYTE *)&unk_5E8528 + (v12 & 0xC))) | (16
                                                                                                * *((_BYTE *)&unk_5E8528
                                                                                                  + ((v12 >> 2) & 0xC)));
      v20 = (unsigned __int8)v12 >> 6;
      v21 = *(_DWORD *)((char *)&unk_5E8528 + (v14 & 0xC));
      v10[1] = v19 | (*((_BYTE *)&unk_5E8528 + 4 * v20) << 6);
      v22 = *((_DWORD *)&unk_5E8528 + ((unsigned __int8)v14 >> 6));
      v23 = *((_DWORD *)&unk_5E8528 + (v14 & 3));
      v10[2] = *((_BYTE *)&unk_5E8528 + 4 * (v13 & 3)) | (4 * *((_BYTE *)&unk_5E8528 + (v13 & 0xC))) | (16 * *((_BYTE *)&unk_5E8528 + ((v13 >> 2) & 0xC))) | ((unsigned __int8)*((_DWORD *)&unk_5E8528 + ((unsigned __int8)v13 >> 6)) << 6);
      v10[3] = v23 | (4 * v21) | (16 * v18) | ((_BYTE)v22 << 6);
      v10 += 8;
    }
    while ( v9 );
  }
}

//----- (001CB1E8) --------------------------------------------------------
void *__fastcall ATCConvertFromDXT1A(int width, int height, void *imgData)
{
  bool v4; // cf
  signed int v5; // r0
  int v6; // r2
  unsigned int v7; // r1
  int v8; // r0
  int v9; // r4
  char *v10; // r0
  char *v11; // r10
  int v12; // r12
  int v13; // r11
  char *v14; // r6
  char *v15; // r5
  unsigned int v16; // r2
  int v17; // r1
  char v18; // r0
  char v19; // lr
  char v20; // r9
  char v21; // r8
  char v22; // r2
  char v23; // r5
  char v24; // r4
  char v25; // r1
  char v26; // r10
  char v27; // lr
  char v28; // r3
  char v29; // r5
  unsigned int v30; // r3
  unsigned int v31; // r5
  unsigned int v32; // r0
  unsigned int v33; // r0
  char *v35; // [sp+4h] [bp-2Ch]
  unsigned int v37; // [sp+Ch] [bp-24h]
  int v38; // [sp+10h] [bp-20h]

  v4 = (unsigned int)(width + 3) >= 7;
  v5 = height + ((unsigned int)(height >> 31) >> 30);
  v6 = width / 4;
  v7 = height + 3;
  if ( !v4 )
    v6 = 1;
  v8 = v5 >> 2;
  if ( v7 < 7 )
    v8 = 1;
  v9 = v8 * v6;
  v10 = (char *)malloc(16 * v8 * v6);
  v11 = v10;
  if ( v9 >= 1 )
  {
    v12 = 15;
    v13 = 0;
    v35 = v10;
    do
    {
      v14 = &v11[2 * v13];
      v15 = (char *)imgData + v13;
      v16 = *(_DWORD *)((char *)imgData + v13);
      v17 = *(_DWORD *)((char *)imgData + v13 + 4);
      *((_DWORD *)v14 + 2) = v16;
      *((_DWORD *)v14 + 3) = v17;
      v37 = v16;
      v38 = v9;
      if ( *((unsigned __int16 *)v14 + 5) >= (unsigned int)(unsigned __int16)v16 )
      {
        v26 = v15[4];
        v25 = 0;
        v27 = v15[5];
        v22 = 0;
        v28 = v15[6];
        v21 = 0;
        v29 = v15[7];
        v20 = 0;
        if ( (v29 & 0xC0) != 192 )
          v25 = -16;
        if ( (v29 & 0x30) != 48 )
          v25 |= 0xFu;
        v24 = 0;
        if ( (v29 & 0xC) != 12 )
          v24 = -16;
        if ( (v29 & 3) != 3 )
          v24 |= 0xFu;
        v23 = 0;
        if ( (v28 & 0xC0) != 192 )
          v23 = -16;
        if ( (v28 & 0x30) != 48 )
          v23 |= 0xFu;
        if ( (v28 & 0xC) != 12 )
          v22 = -16;
        if ( (v28 & 3) != 3 )
          v22 |= 0xFu;
        if ( (v27 & 0xC0) != 192 )
          v21 = -16;
        if ( (v27 & 0x30) != 48 )
          v21 |= 0xFu;
        if ( (v27 & 0xC) != 12 )
          v20 = -16;
        if ( (v27 & 3) != 3 )
          v20 |= 0xFu;
        v19 = 0;
        if ( (v26 & 0xC0) != 192 )
          v19 = -16;
        if ( (v26 & 0x30) != 48 )
          v19 |= 0xFu;
        v18 = 0;
        if ( (v26 & 0xC) != 12 )
          v18 = -16;
        if ( (v26 & 3) != 3 )
          v18 |= 0xFu;
      }
      else
      {
        v18 = -1;
        v19 = -1;
        v20 = -1;
        v21 = -1;
        v22 = -1;
        v23 = -1;
        v24 = -1;
        v25 = -1;
      }
      v11 = v35;
      v13 += 8;
      v35[v12 - 15] = v18;
      v14[2] = v20;
      v14[1] = v19;
      v14[3] = v21;
      v14[4] = v22;
      v14[5] = v23;
      v14[6] = v24;
      v14[7] = v25;
      *((_WORD *)v14 + 4) = (v37 >> 1) & 0x7FE0 | v37 & 0x1F;
      v30 = (unsigned __int8)v14[12];
      v31 = (unsigned __int8)v14[13];
      v32 = (unsigned __int8)v14[14];
      v14[12] = *((_DWORD *)&unk_5E8528 + (v30 & 3)) | (4 * *((_BYTE *)&unk_5E8528 + (v30 & 0xC))) | (16 * *((_BYTE *)&unk_5E8528 + ((v30 >> 2) & 0xC))) | (*((_BYTE *)&unk_5E8528 + 4 * ((unsigned __int8)v30 >> 6)) << 6);
      v14[13] = *((_DWORD *)&unk_5E8528 + (v31 & 3)) | (4 * *((_BYTE *)&unk_5E8528 + (v31 & 0xC))) | (16 * *((_BYTE *)&unk_5E8528 + ((v31 >> 2) & 0xC))) | (*((_BYTE *)&unk_5E8528 + 4 * ((unsigned __int8)v31 >> 6)) << 6);
      v14[14] = *((_DWORD *)&unk_5E8528 + (v32 & 3)) | (4 * *((_BYTE *)&unk_5E8528 + (v32 & 0xC))) | (16 * *((_BYTE *)&unk_5E8528 + ((v32 >> 2) & 0xC))) | (*((_BYTE *)&unk_5E8528 + 4 * ((unsigned __int8)v32 >> 6)) << 6);
      v33 = (unsigned __int8)v35[v12];
      v35[v12] = *((_BYTE *)&unk_5E8528 + 4 * (v33 & 3)) | (4 * *((_BYTE *)&unk_5E8528 + (v33 & 0xC))) | (16 * *((_BYTE *)&unk_5E8528 + ((v33 >> 2) & 0xC))) | (*((_BYTE *)&unk_5E8528 + 4 * ((unsigned __int8)v33 >> 6)) << 6);
      v9 = v38 - 1;
      v12 += 16;
    }
    while ( v38 != 1 );
  }
  return v11;
}

//----- (001CB45C) --------------------------------------------------------
void __fastcall ATCConvertFromDXT3(int width, int height, void *imgData)
{
  bool v4; // cf
  signed int v5; // r0
  int v6; // r3
  unsigned int v7; // r1
  int v8; // r0
  int v9; // r8
  char *v10; // r1
  unsigned int v11; // r5
  unsigned int v12; // r6
  unsigned int v13; // r10
  unsigned int v14; // r4
  int v15; // r9
  char v16; // r0
  int v17; // r3
  int v18; // r5
  char v19; // r0
  int v20; // r3
  int v21; // r6
  int v22; // r9
  int v23; // r4

  v4 = (unsigned int)(width + 3) >= 7;
  v5 = height + ((unsigned int)(height >> 31) >> 30);
  v6 = width / 4;
  v7 = height + 3;
  if ( !v4 )
    v6 = 1;
  v8 = v5 >> 2;
  if ( v7 < 7 )
    v8 = 1;
  v9 = v8 * v6;
  if ( v8 * v6 >= 1 )
  {
    v10 = (char *)imgData + 8;
    do
    {
      v11 = (unsigned __int8)v10[4];
      --v9;
      v12 = (unsigned __int8)v10[5];
      v13 = (unsigned __int8)v10[6];
      v14 = (unsigned __int8)v10[7];
      v15 = *(_DWORD *)((char *)&unk_5E8528 + (v11 & 0xC));
      *(_WORD *)v10 = *(_WORD *)v10 & 0x1F | (*(_WORD *)v10 >> 1) & 0x7FE0;
      v16 = *((_DWORD *)&unk_5E8528 + (v11 & 3)) | (4 * v15) | (16 * *((_BYTE *)&unk_5E8528 + ((v11 >> 2) & 0xC)));
      v17 = (unsigned __int8)v11 >> 6;
      v18 = *(_DWORD *)((char *)&unk_5E8528 + ((v14 >> 2) & 0xC));
      v10[4] = v16 | (*((_BYTE *)&unk_5E8528 + 4 * v17) << 6);
      v19 = *((_DWORD *)&unk_5E8528 + (v12 & 3)) | (4 * *((_BYTE *)&unk_5E8528 + (v12 & 0xC))) | (16
                                                                                                * *((_BYTE *)&unk_5E8528
                                                                                                  + ((v12 >> 2) & 0xC)));
      v20 = (unsigned __int8)v12 >> 6;
      v21 = *(_DWORD *)((char *)&unk_5E8528 + (v14 & 0xC));
      v10[5] = v19 | (*((_BYTE *)&unk_5E8528 + 4 * v20) << 6);
      v22 = *((_DWORD *)&unk_5E8528 + ((unsigned __int8)v14 >> 6));
      v23 = *((_DWORD *)&unk_5E8528 + (v14 & 3));
      v10[6] = *((_BYTE *)&unk_5E8528 + 4 * (v13 & 3)) | (4 * *((_BYTE *)&unk_5E8528 + (v13 & 0xC))) | (16 * *((_BYTE *)&unk_5E8528 + ((v13 >> 2) & 0xC))) | ((unsigned __int8)*((_DWORD *)&unk_5E8528 + ((unsigned __int8)v13 >> 6)) << 6);
      v10[7] = v23 | (4 * v21) | (16 * v18) | ((_BYTE)v22 << 6);
      v10 += 16;
    }
    while ( v9 );
  }
}

//----- (001CB57C) --------------------------------------------------------
void __fastcall ATCConvertFromDXT5(int width, int height, void *imgData)
{
  bool v4; // cf
  signed int v5; // r0
  int v6; // r3
  unsigned int v7; // r1
  int v8; // r0
  int v9; // r8
  char *v10; // r1
  unsigned int v11; // r5
  unsigned int v12; // r6
  unsigned int v13; // r10
  unsigned int v14; // r4
  int v15; // r9
  char v16; // r0
  int v17; // r3
  int v18; // r5
  char v19; // r0
  int v20; // r3
  int v21; // r6
  int v22; // r9
  int v23; // r4

  v4 = (unsigned int)(width + 3) >= 7;
  v5 = height + ((unsigned int)(height >> 31) >> 30);
  v6 = width / 4;
  v7 = height + 3;
  if ( !v4 )
    v6 = 1;
  v8 = v5 >> 2;
  if ( v7 < 7 )
    v8 = 1;
  v9 = v8 * v6;
  if ( v8 * v6 >= 1 )
  {
    v10 = (char *)imgData + 8;
    do
    {
      v11 = (unsigned __int8)v10[4];
      --v9;
      v12 = (unsigned __int8)v10[5];
      v13 = (unsigned __int8)v10[6];
      v14 = (unsigned __int8)v10[7];
      v15 = *(_DWORD *)((char *)&unk_5E8528 + (v11 & 0xC));
      *(_WORD *)v10 = *(_WORD *)v10 & 0x1F | (*(_WORD *)v10 >> 1) & 0x7FE0;
      v16 = *((_DWORD *)&unk_5E8528 + (v11 & 3)) | (4 * v15) | (16 * *((_BYTE *)&unk_5E8528 + ((v11 >> 2) & 0xC)));
      v17 = (unsigned __int8)v11 >> 6;
      v18 = *(_DWORD *)((char *)&unk_5E8528 + ((v14 >> 2) & 0xC));
      v10[4] = v16 | (*((_BYTE *)&unk_5E8528 + 4 * v17) << 6);
      v19 = *((_DWORD *)&unk_5E8528 + (v12 & 3)) | (4 * *((_BYTE *)&unk_5E8528 + (v12 & 0xC))) | (16
                                                                                                * *((_BYTE *)&unk_5E8528
                                                                                                  + ((v12 >> 2) & 0xC)));
      v20 = (unsigned __int8)v12 >> 6;
      v21 = *(_DWORD *)((char *)&unk_5E8528 + (v14 & 0xC));
      v10[5] = v19 | (*((_BYTE *)&unk_5E8528 + 4 * v20) << 6);
      v22 = *((_DWORD *)&unk_5E8528 + ((unsigned __int8)v14 >> 6));
      v23 = *((_DWORD *)&unk_5E8528 + (v14 & 3));
      v10[6] = *((_BYTE *)&unk_5E8528 + 4 * (v13 & 3)) | (4 * *((_BYTE *)&unk_5E8528 + (v13 & 0xC))) | (16 * *((_BYTE *)&unk_5E8528 + ((v13 >> 2) & 0xC))) | ((unsigned __int8)*((_DWORD *)&unk_5E8528 + ((unsigned __int8)v13 >> 6)) << 6);
      v10[7] = v23 | (4 * v21) | (16 * v18) | ((_BYTE)v22 << 6);
      v10 += 16;
    }
    while ( v9 );
  }
}

//----- (001CB69C) --------------------------------------------------------
GLenum __fastcall RQVertexAttrFormatToGL(RQVertexAttributeFormat f)
{
  if ( (unsigned int)f <= VAF_UShort )
    return dword_5EA4E0[f];
  else
    return 0;
}
// 5EA4E0: using guessed type _DWORD dword_5EA4E0[5];

//----- (001CB6B4) --------------------------------------------------------
RQVertexBuffer *__fastcall RQVertexBuffer::Create(const void *data, unsigned int size)
{
  RQVertexBuffer *v4; // r6
  RenderQueue *v5; // r1
  unsigned __int8 *mainWorkPointer; // r2
  RenderQueue *v7; // r1
  RenderQueue *v8; // r4
  __int64 v9; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v11; // r2

  v4 = (RQVertexBuffer *)operator new(0xCu);
  v4[1]._vptr$RQVertexBuffer = 0;
  v4[2]._vptr$RQVertexBuffer = 0;
  v4->_vptr$RQVertexBuffer = (int (**)(void))&off_660870;
  v5 = renderQueue;
  RQVertexBuffer::curBuffer = v4;
  mainWorkPointer = renderQueue->mainWorkPointer;
  renderQueue->curQueueingCommand = rqVertexBufferCreate;
  *(_DWORD *)mainWorkPointer = 1;
  v5->mainWorkPointer += 4;
  v7 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = v4;
  v7->mainWorkPointer += 4;
  v8 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v9 = *(_QWORD *)&v8->mainPointer;
  p_mainPointer = (unsigned int *)&v8->mainPointer;
  __dmb(0xBu);
  do
    v11 = __ldrex(p_mainPointer);
  while ( __strex(v11 + HIDWORD(v9) - v9, p_mainPointer) );
  __dmb(0xBu);
  if ( v8->useMutex )
    OS_MutexRelease(v8->commandMutex);
  if ( !v8->multiThread )
    RenderQueue::Process(v8);
  if ( v8->mainPointer + 1024 > v8->queueEnd )
    RenderQueue::Flush(v8);
  RQVertexBuffer::Update(v4, data, size);
  return v4;
}
// 660870: using guessed type void *;

//----- (001CB794) --------------------------------------------------------
void RQVertexBuffer::SetSafe()
{
  const void *v0; // r4
  void *v1; // r0
  size_t v2; // r5

  v0 = ES2VertexBuffer::curCPUBuffer;
  if ( ES2VertexBuffer::curCPUBuffer )
  {
    v1 = ES2VertexBuffer::safeCPUBuffer;
    v2 = ES2VertexBuffer::curCPUSize;
    if ( ES2VertexBuffer::safeCPUSize < ES2VertexBuffer::curCPUSize )
    {
      if ( ES2VertexBuffer::safeCPUBuffer )
      {
        free(ES2VertexBuffer::safeCPUBuffer);
        v0 = ES2VertexBuffer::curCPUBuffer;
        v2 = ES2VertexBuffer::curCPUSize;
      }
      ES2VertexBuffer::safeCPUSize = 4 * v2 / 3;
      v1 = malloc(ES2VertexBuffer::safeCPUSize);
      ES2VertexBuffer::safeCPUBuffer = v1;
    }
    qmemcpy(v1, v0, v2);
    ES2VertexBuffer::curCPUBuffer = ES2VertexBuffer::safeCPUBuffer;
  }
}

//----- (001CB840) --------------------------------------------------------
void __fastcall RQ_Command_rqVertexBufferCreate(unsigned __int8 **qData)
{
  int v1; // r4

  v1 = *(_DWORD *)*qData;
  *qData += 4;
  glGenBuffers(1, v1 + 8);
  sub_18A9EC(34962, *(_DWORD *)(v1 + 8));
}
// 18A9EC: using guessed type int __fastcall sub_18A9EC(_DWORD, _DWORD);
// 18F038: using guessed type int __fastcall glGenBuffers(_DWORD, _DWORD);

//----- (001CB864) --------------------------------------------------------
void __fastcall RQ_Command_rqVertexBufferSelect(unsigned __int8 **qData)
{
  int v1; // r1

  v1 = *(_DWORD *)*qData;
  *qData += 4;
  if ( v1 )
  {
    glBindBuffer(34962, *(_DWORD *)(v1 + 8));
    ES2VertexBuffer::curCPUBuffer = 0;
  }
  else
  {
    sub_18A9EC(34962, 0);
  }
}
// 18A9EC: using guessed type int __fastcall sub_18A9EC(_DWORD, _DWORD);
// 18A9F0: using guessed type int __fastcall glBindBuffer(_DWORD, _DWORD);

//----- (001CB898) --------------------------------------------------------
void __fastcall RQ_Command_rqVertexBufferUpdate(unsigned __int8 **qData)
{
  unsigned __int8 *v1; // r1
  unsigned __int8 *v2; // r2
  int v3; // r12
  unsigned int v4; // r1
  unsigned int v5; // r2
  unsigned int v6; // r3
  unsigned int v7; // r2

  v1 = *qData;
  v2 = *qData + 8;
  v3 = *(_DWORD *)*qData;
  *qData += 4;
  v4 = *((_DWORD *)v1 + 1);
  *qData = v2;
  if ( v4 )
  {
    v5 = (unsigned int)(v2 + 3);
    v6 = v4;
    if ( (v4 & 3) != 0 )
      v6 = (v4 + 3) & 0xFFFFFFFC;
    v7 = v5 & 0xFFFFFFFC;
    *qData = (unsigned __int8 *)(v6 + v7);
    *(_DWORD *)(v3 + 4) = v4;
    sub_198280(34962, v4, v7, 35044);
  }
}
// 198280: using guessed type int __fastcall sub_198280(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (001CB8E0) --------------------------------------------------------
void __fastcall RQ_Command_rqVertexBufferCPU(unsigned __int8 **qData)
{
  unsigned int v1; // r1
  char *v2; // r2
  unsigned int v3; // r4

  v1 = *(_DWORD *)*qData;
  v2 = (char *)((unsigned int)(*qData + 7) & 0xFFFFFFFC);
  v3 = v1;
  if ( (v1 & 3) != 0 )
    v3 = (v1 + 3) & 0xFFFFFFFC;
  *qData = (unsigned __int8 *)&v2[v3];
  ES2VertexBuffer::curCPUSize = v1;
  ES2VertexBuffer::curCPUBuffer = v2;
}

//----- (001CB928) --------------------------------------------------------
void __fastcall RQ_Command_rqVertexBufferDelete(unsigned __int8 **qData)
{
  _DWORD *v1; // r4

  v1 = *(_DWORD **)*qData;
  *qData += 4;
  glDeleteBuffers(1, v1 + 2);
  v1[2] = 0;
  if ( v1 )
    (*(void (__fastcall **)(_DWORD *))(*v1 + 4))(v1);
}
// 19F4F4: using guessed type int __fastcall glDeleteBuffers(_DWORD, _DWORD);

//----- (001CB954) --------------------------------------------------------
RQIndexBuffer *__fastcall RQIndexBuffer::Create(RQIndexBufferFormat format, const void *data, unsigned int size)
{
  int v6; // r6
  RenderQueue *v7; // r1
  unsigned __int8 *mainWorkPointer; // r2
  RenderQueue *v9; // r1
  RenderQueue *v10; // r4
  __int64 v11; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v13; // r2

  v6 = operator new(0x10u);
  *(_DWORD *)(v6 + 4) = format;
  *(_DWORD *)(v6 + 8) = 0;
  *(_DWORD *)(v6 + 12) = 0;
  *(_DWORD *)v6 = &off_660880;
  v7 = renderQueue;
  RQIndexBuffer::curBuffer = (RQIndexBuffer *)v6;
  mainWorkPointer = renderQueue->mainWorkPointer;
  renderQueue->curQueueingCommand = rqIndexBufferCreate;
  *(_DWORD *)mainWorkPointer = 6;
  v7->mainWorkPointer += 4;
  v9 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = v6;
  v9->mainWorkPointer += 4;
  v10 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v11 = *(_QWORD *)&v10->mainPointer;
  p_mainPointer = (unsigned int *)&v10->mainPointer;
  __dmb(0xBu);
  do
    v13 = __ldrex(p_mainPointer);
  while ( __strex(v13 + HIDWORD(v11) - v11, p_mainPointer) );
  __dmb(0xBu);
  if ( v10->useMutex )
    OS_MutexRelease(v10->commandMutex);
  if ( !v10->multiThread )
    RenderQueue::Process(v10);
  if ( v10->mainPointer + 1024 > v10->queueEnd )
    RenderQueue::Flush(v10);
  RQIndexBuffer::Update((RQIndexBuffer *)v6, data, size);
  return (RQIndexBuffer *)v6;
}
// 660880: using guessed type void *;

//----- (001CBA38) --------------------------------------------------------
void RQIndexBuffer::SetSafe()
{
  const void *v0; // r4
  void *v1; // r0
  size_t v2; // r5

  v0 = ES2IndexBuffer::curCPUBuffer;
  if ( ES2IndexBuffer::curCPUBuffer )
  {
    v1 = ES2IndexBuffer::safeCPUBuffer;
    v2 = ES2IndexBuffer::curCPUSize;
    if ( ES2IndexBuffer::safeCPUSize < ES2IndexBuffer::curCPUSize )
    {
      if ( ES2IndexBuffer::safeCPUBuffer )
      {
        free(ES2IndexBuffer::safeCPUBuffer);
        v0 = ES2IndexBuffer::curCPUBuffer;
        v2 = ES2IndexBuffer::curCPUSize;
      }
      ES2IndexBuffer::safeCPUSize = 4 * v2 / 3;
      v1 = malloc(ES2IndexBuffer::safeCPUSize);
      ES2IndexBuffer::safeCPUBuffer = v1;
    }
    qmemcpy(v1, v0, v2);
    ES2IndexBuffer::curCPUBuffer = ES2IndexBuffer::safeCPUBuffer;
  }
}

//----- (001CBAE4) --------------------------------------------------------
void __fastcall RQ_Command_rqIndexBufferCreate(unsigned __int8 **qData)
{
  int v1; // r4

  v1 = *(_DWORD *)*qData;
  *qData += 4;
  glGenBuffers(1, v1 + 12);
  sub_18A9EC(34963, *(_DWORD *)(v1 + 12));
}
// 18A9EC: using guessed type int __fastcall sub_18A9EC(_DWORD, _DWORD);
// 18F038: using guessed type int __fastcall glGenBuffers(_DWORD, _DWORD);

//----- (001CBB08) --------------------------------------------------------
void __fastcall RQ_Command_rqIndexBufferSelect(unsigned __int8 **qData)
{
  int v1; // r1
  int v2; // r1

  v1 = *(_DWORD *)*qData;
  *qData += 4;
  if ( v1 )
    v2 = *(_DWORD *)(v1 + 12);
  else
    v2 = 0;
  glBindBuffer(34963, v2);
  ES2IndexBuffer::curCPUBuffer = 0;
}
// 18A9F0: using guessed type int __fastcall glBindBuffer(_DWORD, _DWORD);

//----- (001CBB38) --------------------------------------------------------
void __fastcall RQ_Command_rqIndexBufferUpdate(unsigned __int8 **qData)
{
  unsigned __int8 *v1; // r1
  unsigned __int8 *v2; // r2
  int v3; // r12
  unsigned int v4; // r1
  unsigned int v5; // r2
  unsigned int v6; // r3
  unsigned int v7; // r2

  v1 = *qData;
  v2 = *qData + 8;
  v3 = *(_DWORD *)*qData;
  *qData += 4;
  v4 = *((_DWORD *)v1 + 1);
  *qData = v2;
  if ( v4 )
  {
    v5 = (unsigned int)(v2 + 3);
    v6 = v4;
    if ( (v4 & 3) != 0 )
      v6 = (v4 + 3) & 0xFFFFFFFC;
    v7 = v5 & 0xFFFFFFFC;
    *qData = (unsigned __int8 *)(v6 + v7);
    *(_DWORD *)(v3 + 8) = v4;
    sub_198280(34963, v4, v7, 35044);
  }
}
// 198280: using guessed type int __fastcall sub_198280(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (001CBB80) --------------------------------------------------------
void __fastcall RQ_Command_rqIndexBufferCPU(unsigned __int8 **qData)
{
  unsigned int v1; // r1
  char *v2; // r2
  unsigned int v3; // r4

  v1 = *(_DWORD *)*qData;
  v2 = (char *)((unsigned int)(*qData + 7) & 0xFFFFFFFC);
  v3 = v1;
  if ( (v1 & 3) != 0 )
    v3 = (v1 + 3) & 0xFFFFFFFC;
  *qData = (unsigned __int8 *)&v2[v3];
  ES2IndexBuffer::curCPUSize = v1;
  ES2IndexBuffer::curCPUBuffer = v2;
}

//----- (001CBBC8) --------------------------------------------------------
void __fastcall RQ_Command_rqIndexBufferDelete(unsigned __int8 **qData)
{
  _DWORD *v1; // r4

  v1 = *(_DWORD **)*qData;
  *qData += 4;
  glDeleteBuffers(1, v1 + 3);
  v1[3] = 0;
  if ( v1 )
    (*(void (__fastcall **)(_DWORD *))(*v1 + 4))(v1);
}
// 19F4F4: using guessed type int __fastcall glDeleteBuffers(_DWORD, _DWORD);

//----- (001CBBF4) --------------------------------------------------------
RQVertexState *__fastcall RQVertexState::Create(
        RQVertexBuffer *vBuffer,
        RQIndexBuffer *iBuffer,
        RQVertexBufferDescription *usingDesc)
{
  RQVertexState *v6; // r4
  RenderQueue *v7; // r0
  unsigned __int8 *mainWorkPointer; // r1
  RenderQueue *v9; // r0
  RenderQueue *v10; // r0
  RenderQueue *v11; // r0
  RenderQueue *v12; // r5
  RenderQueue *v13; // r5
  __int64 v14; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v16; // r2

  v6 = (RQVertexState *)operator new(8u);
  *(_QWORD *)&v6->_vptr$RQVertexState = (unsigned int)&off_660890;
  v7 = renderQueue;
  mainWorkPointer = renderQueue->mainWorkPointer;
  renderQueue->curQueueingCommand = rqVertexStateCreate;
  *(_DWORD *)mainWorkPointer = 10;
  v7->mainWorkPointer += 4;
  v9 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = v6;
  v9->mainWorkPointer += 4;
  v10 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = vBuffer;
  v10->mainWorkPointer += 4;
  v11 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = iBuffer;
  v11->mainWorkPointer += 4;
  v12 = renderQueue;
  qmemcpy(renderQueue->mainWorkPointer, usingDesc, 0x8Cu);
  v12->mainWorkPointer += 140;
  v13 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v14 = *(_QWORD *)&v13->mainPointer;
  p_mainPointer = (unsigned int *)&v13->mainPointer;
  __dmb(0xBu);
  do
    v16 = __ldrex(p_mainPointer);
  while ( __strex(v16 + HIDWORD(v14) - v14, p_mainPointer) );
  __dmb(0xBu);
  if ( v13->useMutex )
    OS_MutexRelease(v13->commandMutex);
  if ( !v13->multiThread )
    RenderQueue::Process(v13);
  if ( v13->mainPointer + 1024 > v13->queueEnd )
    RenderQueue::Flush(v13);
  return v6;
}
// 660890: using guessed type void *;

//----- (001CBCFC) --------------------------------------------------------
void __fastcall RQ_Command_rqVertexStateCreate(unsigned __int8 **qData)
{
  *qData += 152;
}

//----- (001CBD04) --------------------------------------------------------
void __fastcall RQ_Command_rqVertexStateApply(unsigned __int8 **qData)
{
  *qData += 4;
}

//----- (001CBD0C) --------------------------------------------------------
void __fastcall RQ_Command_rqVertexStateDelete(unsigned __int8 **qData)
{
  int v2; // r0
  unsigned __int8 *v3; // r2

  v3 = *qData + 4;
  v2 = *(_DWORD *)*qData;
  *qData = v3;
  if ( v2 )
    (*(void (__fastcall **)(int))(*(_DWORD *)v2 + 4))(v2);
}

//----- (001CBD24) --------------------------------------------------------
void __fastcall RQ_Command_rqSetVertexDescription(unsigned __int8 **qData)
{
  int v1; // r8
  unsigned __int8 *v2; // r9
  int v3; // r5
  int v4; // r1
  unsigned __int8 *v5; // r11
  int v6; // r0
  bool v7; // zf
  unsigned int v8; // r0
  int v9; // r2
  int v10; // [sp+1Ch] [bp-24h]
  int v11; // [sp+20h] [bp-20h]

  v1 = 0;
  v2 = *qData;
  v3 = 0;
  v11 = *(_DWORD *)*qData;
  v4 = invalidateActiveAttribs;
  *qData += 144;
  v10 = -v4;
  do
  {
    v5 = &v2[v1 * 20];
    if ( v2[v1 * 20 + 4] )
    {
      if ( !activeDesc.attributes[v1].enabled || invalidateActiveAttribs )
        glEnableVertexAttribArray(v3);
      v6 = memcmp((char *)&activeDesc + v1 * 20, &v2[v1 * 20 + 4], 0x14u);
      v7 = v11 == v10;
      if ( v11 == v10 )
        v7 = v6 == 0;
      if ( !v7 || ES2VertexBuffer::curCPUBuffer )
      {
        v8 = *((_DWORD *)v5 + 5);
        if ( v8 > 4 )
          v9 = 0;
        else
          v9 = dword_5EA4E0[v8];
        glVertexAttribPointer(
          v3,
          *((_DWORD *)v5 + 2),
          v9,
          v5[5],
          *((_DWORD *)v5 + 3),
          (char *)ES2VertexBuffer::curCPUBuffer + *((_DWORD *)v5 + 4));
      }
    }
    else if ( (activeDesc.attributes[v1].enabled || invalidateActiveAttribs) << 24 )
    {
      glDisableVertexAttribArray(v3);
    }
    ++v1;
    ++v3;
  }
  while ( v1 != 7 );
  qmemcpy(&activeDesc, v2 + 4, sizeof(activeDesc));
  invalidateActiveAttribs = 0;
}
// 18BE50: using guessed type int __fastcall glEnableVertexAttribArray(_DWORD);
// 19E824: using guessed type int __fastcall glVertexAttribPointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 19FAAC: using guessed type int __fastcall glDisableVertexAttribArray(_DWORD);
// 5EA4E0: using guessed type _DWORD dword_5EA4E0[5];

//----- (001CBE3C) --------------------------------------------------------
void __fastcall RQ_Command_rqDrawIndexed(unsigned __int8 **qData)
{
  unsigned __int8 *v1; // r2
  unsigned __int8 *v2; // r1
  int v3; // r10
  unsigned int v4; // r9
  int v5; // r4
  char *v6; // r6
  char *v7; // r8
  unsigned int stride; // r6
  GLenum v9; // r0
  unsigned int i; // r6

  v1 = *qData;
  v2 = *qData + 12;
  v3 = *(_DWORD *)*qData;
  *qData += 4;
  v4 = *((_DWORD *)v1 + 1);
  *qData = v1 + 8;
  v5 = *((_DWORD *)v1 + 2);
  *qData = v2;
  v6 = (char *)ES2IndexBuffer::curCPUBuffer;
  ES2BindActiveTextures();
  v7 = &v6[v5];
  if ( v3 == 1 && ES2IndexBuffer::curCPUBuffer && ES2VertexBuffer::curCPUBuffer )
  {
    if ( RQCaps[13] )
    {
      stride = activeDesc.attributes[0].stride;
      if ( !activeDesc.attributes[0].enabled )
      {
        glVertexAttribPointer(0, 3, 5126, 0, activeDesc.attributes[0].stride, ES2VertexBuffer::curCPUBuffer);
        glDisableVertexAttribArray(0);
      }
      if ( !activeDesc.attributes[1].enabled )
      {
        glVertexAttribPointer(1, 3, 5126, 0, stride, ES2VertexBuffer::curCPUBuffer);
        glDisableVertexAttribArray(1);
      }
      if ( !activeDesc.attributes[2].enabled )
      {
        glVertexAttribPointer(2, 3, 5126, 0, stride, ES2VertexBuffer::curCPUBuffer);
        glDisableVertexAttribArray(2);
      }
      if ( !activeDesc.attributes[3].enabled )
      {
        glVertexAttribPointer(3, 3, 5126, 0, stride, ES2VertexBuffer::curCPUBuffer);
        glDisableVertexAttribArray(3);
      }
      if ( !activeDesc.attributes[4].enabled )
      {
        glVertexAttribPointer(4, 3, 5126, 0, stride, ES2VertexBuffer::curCPUBuffer);
        glDisableVertexAttribArray(4);
      }
      if ( !activeDesc.attributes[5].enabled )
      {
        glVertexAttribPointer(5, 3, 5126, 0, stride, ES2VertexBuffer::curCPUBuffer);
        glDisableVertexAttribArray(5);
      }
      if ( !activeDesc.attributes[6].enabled )
      {
        glVertexAttribPointer(6, 3, 5126, 0, stride, ES2VertexBuffer::curCPUBuffer);
        glDisableVertexAttribArray(6);
      }
    }
LABEL_21:
    v9 = 5;
LABEL_22:
    sub_19558C(v9, v4, 0x1403u, v7);
  }
  else
  {
    switch ( v3 )
    {
      case 0:
        v9 = 4;
        goto LABEL_22;
      case 1:
        goto LABEL_21;
      case 2:
        v9 = 6;
        goto LABEL_22;
      case 3:
        if ( v4 )
        {
          for ( i = 0; i < v4; i += 4 )
            glDrawElements(6u, 4, 0x1403u, &v7[v4]);
        }
        break;
      case 4:
        v9 = 1;
        goto LABEL_22;
      case 5:
        v9 = 3;
        goto LABEL_22;
      default:
        return;
    }
  }
}
// 19E824: using guessed type int __fastcall glVertexAttribPointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 19FAAC: using guessed type int __fastcall glDisableVertexAttribArray(_DWORD);

//----- (001CC068) --------------------------------------------------------
void __fastcall RQ_Command_rqDrawNonIndexed(unsigned __int8 **qData)
{
  unsigned __int8 *v1; // r1
  unsigned __int8 *v2; // r2
  int v3; // r6
  GLint v4; // r5
  unsigned int v5; // r4
  GLenum v6; // r0
  unsigned int i; // r6

  v1 = *qData;
  v2 = *qData + 12;
  v3 = *(_DWORD *)*qData;
  *qData += 4;
  v4 = *((_DWORD *)v1 + 1);
  *qData = v1 + 8;
  v5 = *((_DWORD *)v1 + 2);
  *qData = v2;
  ES2BindActiveTextures();
  switch ( v3 )
  {
    case 0:
      v6 = 4;
      goto LABEL_11;
    case 1:
      v6 = 5;
      goto LABEL_11;
    case 2:
      v6 = 6;
      goto LABEL_11;
    case 3:
      if ( v5 )
      {
        for ( i = 0; i < v5; i += 4 )
          glDrawArrays(6u, v4 + i, 4);
      }
      return;
    case 4:
      v6 = 1;
      goto LABEL_11;
    case 5:
      v6 = 3;
LABEL_11:
      sub_18A00C(v6, v4, v5);
      break;
    default:
      return;
  }
}

//----- (001CC0E8) --------------------------------------------------------
const unsigned __int8 *__fastcall GetGLErrorString(GLenum errorCode)
{
  const unsigned __int8 *result; // r0

  switch ( errorCode )
  {
    case 0x500u:
      result = "GL_INVALID_ENUM";
      break;
    case 0x501u:
      result = "GL_INVALID_VALUE";
      break;
    case 0x502u:
      result = "GL_INVALID_OPERATION";
      break;
    case 0x503u:
    case 0x504u:
      goto LABEL_5;
    case 0x505u:
      result = "GL_OUT_OF_MEMORY";
      break;
    default:
      if ( errorCode )
LABEL_5:
        result = "UNKNOWN";
      else
        result = "GL_NO_ERROR";
      break;
  }
  return result;
}

//----- (001CC17C) --------------------------------------------------------
void __fastcall RQ_CheckError(const unsigned __int8 *functionName, const unsigned __int8 *file, int line)
{
  if ( glGetError() )
    OS_DebugBreak();
}

//----- (001CC190) --------------------------------------------------------
void __fastcall RQ_Command_rqInit(unsigned __int8 **qData)
{
  const unsigned __int8 *String; // r0
  const unsigned __int8 *v2; // r4
  const char *v3; // r5
  _BOOL4 v4; // r0
  int v5; // r5
  int v6; // r0
  int v7; // r1
  GLint params[3]; // [sp+4h] [bp-Ch] BYREF

  glGetError();
  glFrontFace(0x901u);
  String = glGetString(0x1F00u);
  rqVendor = j_strdup(String);
  v2 = glGetString(0x1F01u);
  rqRenderer = j_strdup(v2);
  v3 = (const char *)glGetString(0x1F03u);
  if ( !strcmp((const char *)v2, "Adreno (TM) 320") )
    RQCaps[12] = 1;
  if ( strstr(v3, "GL_OES_depth24") )
    RQCaps[0] = 1;
  if ( strstr(v3, "GL_OES_packed_depth_stencil") )
    RQCaps[1] = 1;
  if ( strstr(v3, "GL_NV_depth_nonlinear") )
    RQCaps[2] = 1;
  if ( strstr(v3, "GL_EXT_texture_compression_dxt1") || strstr(v3, "GL_EXT_texture_compression_s3tc") )
    RQCaps[3] = 1;
  if ( strstr(v3, "GL_AMD_compressed_ATC_texture") )
  {
    RQCaps[12] = 1;
    RQCaps[4] = 1;
  }
  if ( strstr(v3, "GL_IMG_texture_compression_pvrtc") )
  {
    v4 = 1;
    RQCaps[5] = 1;
  }
  else
  {
    v4 = RQCaps[5];
  }
  if ( !((v4 || RQCaps[4] || RQCaps[3]) << 24) )
    RQCaps[13] = 1;
  if ( strstr(v3, "GL_OES_rgb8_rgba8") )
    RQCaps[6] = 1;
  if ( strstr(v3, "GL_EXT_texture_filter_anisotropic") )
    RQCaps[7] = 1;
  if ( strstr(v3, "GL_QCOM_alpha_test") )
    RQCaps[11] = 1;
  if ( strstr(v3, "GL_QCOM_binning_control") )
  {
    glHint(0x8FB0u, 0x8FB1u);
    RQCaps[10] = 1;
  }
  if ( (unsigned int)OS_SystemChip() <= OSDC_A4 )
  {
    RQCaps[14] = 1;
    RQCaps[8] = 1;
  }
  if ( RQCaps[4] && strstr((const char *)v2, (const char *)&dword_1CC4B4) )
    RQCaps[14] = 1;
  if ( RQCaps[5] && strstr((const char *)v2, (const char *)&dword_1CC4C0) )
    RQCaps[14] = 1;
  v5 = 128;
  params[0] = 128;
  RQCaps[9] = 0;
  glGetIntegerv(0x8DFBu, params);
  if ( (params[0] - 32) / 3 < 128 )
    v5 = (params[0] - 32) / 3;
  RQMaxBones = v5;
  if ( !RQCaps[0] || (RQCaps[13] || RQCaps[5]) << 24 )
  {
    v6 = -1054867456;
    v7 = -1082130432;
  }
  else
  {
    v6 = -1105199104;
    v7 = -1132462080;
  }
  glPolygonOffset(*(GLfloat *)&v6, *(GLfloat *)&v7);
  ES2InitTextures();
}
// 1CC4B4: using guessed type int dword_1CC4B4;
// 1CC4C0: using guessed type int dword_1CC4C0;
// 1CC190: using guessed type GLint params[3];

//----- (001CC4D0) --------------------------------------------------------
void __fastcall RQ_Command_rqShutdown(unsigned __int8 **qData)
{
  free((void *)rqVendor);
  j_free((void *)rqRenderer);
}

//----- (001CC4F8) --------------------------------------------------------
const unsigned __int8 *RQGetVendor()
{
  return rqVendor;
}

//----- (001CC508) --------------------------------------------------------
const unsigned __int8 *RQGetRenderer()
{
  return rqRenderer;
}

//----- (001CC518) --------------------------------------------------------
void __fastcall RQ_Command_rqReadPixels(unsigned __int8 **qData)
{
  unsigned __int8 *v1; // lr
  unsigned __int8 *v2; // r2
  unsigned __int8 *v3; // r3
  unsigned __int8 *v4; // r4
  GLint v5; // r12
  unsigned __int8 *v6; // r5
  GLint v7; // r1
  GLsizei v8; // r2
  GLsizei v9; // r3
  GLvoid *pixels; // r5

  v1 = *qData;
  v2 = *qData + 8;
  v3 = *qData + 12;
  v4 = *qData + 20;
  v5 = *(_DWORD *)*qData;
  v6 = *qData + 16;
  *qData += 4;
  v7 = *((_DWORD *)v1 + 1);
  *qData = v2;
  v8 = *((_DWORD *)v1 + 2);
  *qData = v3;
  v9 = *((_DWORD *)v1 + 3);
  *qData = v6;
  pixels = (GLvoid *)*((_DWORD *)v1 + 4);
  *qData = v4;
  glReadPixels(v5, v7, v8, v9, 0x1908u, 0x1401u, pixels);
}

//----- (001CC56E) --------------------------------------------------------
void __fastcall RQ_Command_rqDebugMarker(unsigned __int8 **qData)
{
  sub_1952D4(0x8192u, 0x1100u);
}

//----- (001CC57C) --------------------------------------------------------
void __fastcall ES2RQShaderBinding::Setup(ES2RQShaderBinding *this, GLuint forProgramID, const unsigned __int8 *name)
{
  this->uniformID = glGetUniformLocation(forProgramID, name);
}
// 18F060: using guessed type int __fastcall glGetUniformLocation(_DWORD, _DWORD);

//----- (001CC58E) --------------------------------------------------------
RQCompiledShader *__fastcall GetCompiledShaderWithCode(
        const unsigned __int8 *code,
        TDBArray<RQCompiledShader> *fromArray)
{
  unsigned int v3; // r0
  unsigned int numEntries; // r2
  unsigned int v5; // r1
  RQCompiledShader *result; // r0
  unsigned int v7; // r3

  v3 = HashString(code);
  numEntries = fromArray->numEntries;
  v5 = v3;
  if ( !numEntries )
    return 0;
  result = fromArray->dataPtr;
  v7 = 0;
  while ( result->codeHash != v5 )
  {
    ++v7;
    ++result;
    if ( v7 >= numEntries )
      return 0;
  }
  return result;
}

//----- (001CC5BC) --------------------------------------------------------
void __fastcall OutputShaderCode(const unsigned __int8 *source)
{
  char v2; // r0
  char v3; // r11
  const char *v4; // r1
  int v5; // r4
  const unsigned __int8 *v6; // r4
  const unsigned __int8 *i; // r5
  unsigned int v8; // r1
  bool v9; // zf
  char v10[512]; // [sp+0h] [bp-220h] BYREF

  v2 = 0;
LABEL_5:
  v6 = source;
  for ( i = source; ; ++i )
  {
    v8 = *i;
    if ( v8 <= 0x7A )
      break;
    v9 = v8 == 123;
    if ( v8 != 123 )
      v9 = v8 == 125;
    if ( v9 )
    {
LABEL_2:
      v3 = v2 & (v8 != 125);
      v4 = &byte_61CADE;
      if ( v3 )
        v4 = "    ";
      strcpy(v10, v4);
      source = i + 1;
      strncat(v10, (const char *)v6, i + 1 - v6);
      v5 = *i;
      OS_DebugOut((const unsigned __int8 *)v10);
      v2 = (v5 == 123) | v3;
      goto LABEL_5;
    }
LABEL_6:
    ;
  }
  if ( *i )
  {
    if ( v8 == 59 )
      goto LABEL_2;
    goto LABEL_6;
  }
}
// 61CADE: using guessed type char byte_61CADE;

//----- (001CC670) --------------------------------------------------------
bool __fastcall ES2Shader::CheckCompile(
        ES2Shader *this,
        GLuint shader,
        GLuint shaderType,
        const unsigned __int8 *source)
{
  unsigned __int8 v5; // r6
  const char *v8; // r1
  int v9; // r6
  int v10; // t1
  const unsigned __int8 *v11; // r4
  unsigned int v12; // r0
  bool v13; // zf
  int v14; // [sp+0h] [bp-228h] BYREF
  int v15; // [sp+4h] [bp-224h] BYREF
  char v16[512]; // [sp+8h] [bp-220h] BYREF

  v5 = 0;
  v15 = 0;
  glGetShaderiv(shader, 35713, &v15);
  if ( v15 )
    return 1;
LABEL_7:
  v11 = source;
  while ( 1 )
  {
    v12 = *source;
    if ( v12 <= 0x7A )
      break;
    v13 = v12 == 123;
    if ( v12 != 123 )
      v13 = v12 == 125;
    if ( v13 )
    {
LABEL_4:
      v8 = &byte_61CADE;
      v9 = v5 & (v12 != 125);
      if ( v9 )
        v8 = "    ";
      strcpy(v16, v8);
      strncat(v16, (const char *)v11, (size_t)&source[1 - (_DWORD)v11]);
      v10 = *source++;
      OS_DebugOut((const unsigned __int8 *)v16);
      v5 = v9 | (v10 == 123);
      goto LABEL_7;
    }
LABEL_8:
    ++source;
  }
  if ( *source )
  {
    if ( v12 == 59 )
      goto LABEL_4;
    goto LABEL_8;
  }
  glGetShaderInfoLog(shader, 512, &v14, v16);
  return 0;
}
// 18D3B8: using guessed type int __fastcall glGetShaderInfoLog(_DWORD, _DWORD, _DWORD, _DWORD);
// 1A0890: using guessed type int __fastcall glGetShaderiv(_DWORD, _DWORD, _DWORD);
// 61CADE: using guessed type char byte_61CADE;

//----- (001CC74C) --------------------------------------------------------
void __fastcall ES2Shader::InitializeAfterCompile(ES2Shader *this)
{
  int UniformLocation; // r0
  int v3; // r0
  GLint v4; // r0
  GLuint fullProgram; // r2
  GLint v6; // r0
  GLuint v7; // r2
  GLint v8; // r0
  GLuint v9; // r2
  GLint v10; // r0
  GLuint v11; // r2
  GLint v12; // r0
  GLuint v13; // r2
  GLint v14; // r0
  GLuint v15; // r2
  GLint v16; // r0
  GLuint v17; // r2
  GLint v18; // r0
  GLuint v19; // r2
  GLint v20; // r0
  GLuint v21; // r2
  GLint v22; // r0
  GLuint v23; // r2
  GLint v24; // r0
  GLuint v25; // r2
  GLint v26; // r0
  GLuint v27; // r2
  GLint v28; // r0
  GLuint v29; // r2
  GLint v30; // r0
  GLuint v31; // r2
  GLint v32; // r0
  GLuint v33; // r2
  GLint v34; // r0
  GLuint v35; // r2
  GLint v36; // r0
  GLuint v37; // r2
  GLint v38; // r0
  GLuint v39; // r2
  GLint v40; // r0
  GLuint v41; // r2
  GLint v42; // r0
  GLuint v43; // r2
  GLint v44; // r0
  GLuint v45; // r2
  GLint v46; // r0
  GLuint v47; // r2
  GLint v48; // r0
  GLuint v49; // r2
  GLint v50; // r0
  GLuint v51; // r2
  GLint v52; // r0
  GLuint v53; // r2
  GLint v54; // r0
  GLuint v55; // r2
  GLint v56; // r0
  GLuint v57; // r2
  GLint v58; // r0
  GLuint v59; // r2

  RQ_CheckThread();
  if ( ES2Shader::activeShader != this )
  {
    ES2Shader::activeShader = this;
    glUseProgram(this->fullProgram);
  }
  UniformLocation = glGetUniformLocation(this->fullProgram, "Diffuse");
  if ( UniformLocation != -1 )
    glUniform1i(UniformLocation, 0);
  v3 = glGetUniformLocation(this->fullProgram, "EnvMap");
  if ( v3 != -1 )
    glUniform1i(v3, 1);
  v4 = glGetUniformLocation(this->fullProgram, "ProjMatrix");
  fullProgram = this->fullProgram;
  this->mBindings[0].uniformID = v4;
  v6 = glGetUniformLocation(fullProgram, "ViewMatrix");
  v7 = this->fullProgram;
  this->mBindings[1].uniformID = v6;
  v8 = glGetUniformLocation(v7, "ObjMatrix");
  v9 = this->fullProgram;
  this->mBindings[2].uniformID = v8;
  v10 = glGetUniformLocation(v9, "NormalMatrix");
  v11 = this->fullProgram;
  this->mBindings[3].uniformID = v10;
  v12 = glGetUniformLocation(v11, "AmbientLightColor");
  v13 = this->fullProgram;
  this->vBindings[0].uniformID = v12;
  v14 = glGetUniformLocation(v13, "DirLightDiffuseColor");
  v15 = this->fullProgram;
  this->vBindings[1].uniformID = v14;
  v16 = glGetUniformLocation(v15, "DirLightDirection");
  v17 = this->fullProgram;
  this->vBindings[2].uniformID = v16;
  v18 = glGetUniformLocation(v17, "DirBackLightDirection");
  v19 = this->fullProgram;
  this->vBindings[3].uniformID = v18;
  v20 = glGetUniformLocation(v19, "DirLight2DiffuseColor");
  v21 = this->fullProgram;
  this->vBindings[4].uniformID = v20;
  v22 = glGetUniformLocation(v21, "DirLight2Direction");
  v23 = this->fullProgram;
  this->vBindings[5].uniformID = v22;
  v24 = glGetUniformLocation(v23, "DirLight3DiffuseColor");
  v25 = this->fullProgram;
  this->vBindings[6].uniformID = v24;
  v26 = glGetUniformLocation(v25, "DirLight3Direction");
  v27 = this->fullProgram;
  this->vBindings[7].uniformID = v26;
  v28 = glGetUniformLocation(v27, "MaterialEmissive");
  v29 = this->fullProgram;
  this->vBindings[8].uniformID = v28;
  v30 = glGetUniformLocation(v29, "MaterialAmbient");
  v31 = this->fullProgram;
  this->vBindings[9].uniformID = v30;
  v32 = glGetUniformLocation(v31, "MaterialDiffuse");
  v33 = this->fullProgram;
  this->vBindings[10].uniformID = v32;
  v34 = glGetUniformLocation(v33, "EnvMapCoefficient");
  v35 = this->fullProgram;
  this->vBindings[11].uniformID = v34;
  v36 = glGetUniformLocation(v35, "CameraPosition");
  v37 = this->fullProgram;
  this->vBindings[12].uniformID = v36;
  v38 = glGetUniformLocation(v37, "FogDistances");
  v39 = this->fullProgram;
  this->vBindings[13].uniformID = v38;
  v40 = glGetUniformLocation(v39, "FogColor");
  v41 = this->fullProgram;
  this->vBindings[14].uniformID = v40;
  v42 = glGetUniformLocation(v41, "WaterSpecs");
  v43 = this->fullProgram;
  this->vBindings[23].uniformID = v42;
  v44 = glGetUniformLocation(v43, "ContrastMult");
  v45 = this->fullProgram;
  this->vBindings[15].uniformID = v44;
  v46 = glGetUniformLocation(v45, "ContrastAdd");
  v47 = this->fullProgram;
  this->vBindings[16].uniformID = v46;
  v48 = glGetUniformLocation(v47, "DetailTiling");
  v49 = this->fullProgram;
  this->vBindings[17].uniformID = v48;
  v50 = glGetUniformLocation(v49, "AlphaModulate");
  v51 = this->fullProgram;
  this->vBindings[18].uniformID = v50;
  v52 = glGetUniformLocation(v51, "ColorInterp");
  v53 = this->fullProgram;
  this->vBindings[19].uniformID = v52;
  v54 = glGetUniformLocation(v53, "RedGrade");
  v55 = this->fullProgram;
  this->vBindings[20].uniformID = v54;
  v56 = glGetUniformLocation(v55, "GreenGrade");
  v57 = this->fullProgram;
  this->vBindings[21].uniformID = v56;
  v58 = glGetUniformLocation(v57, "BlueGrade");
  v59 = this->fullProgram;
  this->vBindings[22].uniformID = v58;
  this->bonesLocation = glGetUniformLocation(v59, "Bones");
}
// 18F060: using guessed type int __fastcall glGetUniformLocation(_DWORD, _DWORD);
// 198F70: using guessed type int __fastcall glUseProgram(_DWORD);
// 19B148: using guessed type int __fastcall glUniform1i(_DWORD, _DWORD);

//----- (001CCA80) --------------------------------------------------------
void __fastcall ES2Shader::SetActive(ES2Shader *this)
{
  RQ_CheckThread();
  if ( ES2Shader::activeShader != this )
  {
    ES2Shader::activeShader = this;
    sub_198F6C(this->fullProgram);
  }
}
// 198F6C: using guessed type int __fastcall sub_198F6C(_DWORD);

//----- (001CCAB4) --------------------------------------------------------
void __fastcall ES2Shader::~ES2Shader(ES2Shader *this)
{
  this->_vptr$RQShader = (int (**)(void))&off_6608A0;
  if ( ES2Shader::activeShader == this )
  {
    ES2Shader::activeShader = 0;
    glUseProgram(0);
  }
  glDeleteProgram(this->fullProgram);
  if ( this->ownsPixelShader )
    glDeleteShader(this->pixelShader);
  if ( this->ownsVertexShader )
    glDeleteShader(this->vertexShader);
}
// 18E624: using guessed type int __fastcall glDeleteProgram(_DWORD);
// 195EB4: using guessed type int __fastcall glDeleteShader(_DWORD);
// 198F70: using guessed type int __fastcall glUseProgram(_DWORD);
// 6608A0: using guessed type void *;

//----- (001CCB18) --------------------------------------------------------
void __fastcall ES2Shader::~ES2Shader(ES2Shader *this)
{
  this->_vptr$RQShader = (int (**)(void))&off_6608A0;
  if ( ES2Shader::activeShader == this )
  {
    ES2Shader::activeShader = 0;
    glUseProgram(0);
  }
  glDeleteProgram(this->fullProgram);
  if ( this->ownsPixelShader )
    glDeleteShader(this->pixelShader);
  if ( this->ownsVertexShader )
    glDeleteShader(this->vertexShader);
  sub_191374(this);
}
// 18E624: using guessed type int __fastcall glDeleteProgram(_DWORD);
// 195EB4: using guessed type int __fastcall glDeleteShader(_DWORD);
// 198F70: using guessed type int __fastcall glUseProgram(_DWORD);
// 6608A0: using guessed type void *off_6608A0;

//----- (001CCB84) --------------------------------------------------------
bool __fastcall ES2Shader::Build(ES2Shader *this, const unsigned __int8 *pCode, const unsigned __int8 *vCode)
{
  unsigned int v6; // r0
  unsigned int v7; // r3
  GLuint *p_shaderId; // r2
  GLuint v9; // r1
  GLuint Shader; // r4
  ES2Shader *v11; // r0
  GLuint v12; // r2
  unsigned int v13; // r8
  unsigned int numEntries; // r9
  GLuint pixelShader; // r4
  unsigned int v16; // r10
  RQCompiledShader *v17; // r0
  size_t v18; // r2
  RQCompiledShader *dataPtr; // r9
  RQCompiledShader *v20; // r1
  unsigned int v21; // r0
  unsigned int v22; // r3
  GLuint *v23; // r2
  GLuint v24; // r1
  GLuint v25; // r4
  size_t v26; // r0
  ES2Shader *v27; // r0
  GLuint v28; // r2
  unsigned int v29; // r8
  unsigned int v30; // r9
  GLuint vertexShader; // r4
  unsigned int v32; // r10
  RQCompiledShader *v33; // r0
  size_t v34; // r2
  RQCompiledShader *v35; // r9
  RQCompiledShader *v36; // r1
  char v37; // r4
  char v39; // r10
  const char *v40; // r1
  int v41; // t1
  const unsigned __int8 *v42; // r9
  unsigned int v43; // r0
  bool v44; // zf
  char i; // r0
  char v46; // r4
  const char *v47; // r1
  int v48; // t1
  const unsigned __int8 *v49; // r6
  unsigned int v50; // r1
  bool v51; // zf
  RQCompiledShader *v52; // [sp+0h] [bp-228h]
  RQCompiledShader *v53; // [sp+0h] [bp-228h]
  const unsigned __int8 *v54; // [sp+4h] [bp-224h] BYREF
  char v55[512]; // [sp+8h] [bp-220h] BYREF

  this->fullProgram = glCreateProgram();
  v6 = HashString(pCode);
  if ( !pixelShaders.numEntries )
    goto LABEL_8;
  v7 = 0;
  p_shaderId = &pixelShaders.dataPtr->shaderId;
  while ( *(p_shaderId - 1) != v6 )
  {
    ++v7;
    p_shaderId += 2;
    if ( v7 >= pixelShaders.numEntries )
      goto LABEL_8;
  }
  if ( p_shaderId == (GLuint *)byte_4 )
  {
LABEL_8:
    Shader = glCreateShader(35632);
    this->pixelShader = Shader;
    this->ownsPixelShader = 1;
    v54 = pCode;
    *(_DWORD *)v55 = strlen((const char *)pCode);
    glShaderSource(Shader, 1, &v54, v55);
    v11 = (ES2Shader *)glCompileShader(this->pixelShader);
    if ( !ES2Shader::CheckCompile(v11, this->pixelShader, v12, pCode) )
      return 0;
    v13 = HashString(pCode);
    numEntries = pixelShaders.numEntries;
    pixelShader = this->pixelShader;
    if ( pixelShaders.numAlloced < pixelShaders.numEntries + 1 )
    {
      v16 = ((3 * (pixelShaders.numEntries + 1)) >> 1) + 3;
      if ( v16 != pixelShaders.numAlloced )
      {
        v17 = (RQCompiledShader *)malloc(8 * v16);
        if ( pixelShaders.dataPtr )
        {
          v18 = 8 * numEntries;
          v52 = v17;
          dataPtr = pixelShaders.dataPtr;
          memmove(v17, pixelShaders.dataPtr, v18);
          free(dataPtr);
          v17 = v52;
          numEntries = pixelShaders.numEntries;
        }
        pixelShaders.dataPtr = v17;
        pixelShaders.numAlloced = v16;
      }
    }
    v20 = pixelShaders.dataPtr;
    pixelShaders.dataPtr[numEntries].codeHash = v13;
    v20[numEntries].shaderId = pixelShader;
    ++pixelShaders.numEntries;
  }
  else
  {
    v9 = *p_shaderId;
    this->ownsPixelShader = 0;
    this->pixelShader = v9;
  }
  v21 = HashString(vCode);
  if ( !vertexShaders.numEntries )
    goto LABEL_22;
  v22 = 0;
  v23 = &vertexShaders.dataPtr->shaderId;
  while ( *(v23 - 1) != v21 )
  {
    ++v22;
    v23 += 2;
    if ( v22 >= vertexShaders.numEntries )
      goto LABEL_22;
  }
  if ( v23 == (GLuint *)byte_4 )
  {
LABEL_22:
    v25 = glCreateShader(35633);
    this->vertexShader = v25;
    this->ownsVertexShader = 1;
    v26 = strlen((const char *)vCode);
    v54 = vCode;
    *(_DWORD *)v55 = v26;
    glShaderSource(v25, 1, &v54, v55);
    v27 = (ES2Shader *)glCompileShader(this->vertexShader);
    if ( ES2Shader::CheckCompile(v27, this->vertexShader, v28, vCode) )
    {
      v29 = HashString(vCode);
      v30 = vertexShaders.numEntries;
      vertexShader = this->vertexShader;
      if ( vertexShaders.numAlloced < vertexShaders.numEntries + 1 )
      {
        v32 = ((3 * (vertexShaders.numEntries + 1)) >> 1) + 3;
        if ( v32 != vertexShaders.numAlloced )
        {
          v33 = (RQCompiledShader *)malloc(8 * v32);
          if ( vertexShaders.dataPtr )
          {
            v34 = 8 * v30;
            v53 = v33;
            v35 = vertexShaders.dataPtr;
            memmove(v33, vertexShaders.dataPtr, v34);
            free(v35);
            v33 = v53;
            v30 = vertexShaders.numEntries;
          }
          vertexShaders.dataPtr = v33;
          vertexShaders.numAlloced = v32;
        }
      }
      v36 = vertexShaders.dataPtr;
      vertexShaders.dataPtr[v30].codeHash = v29;
      v36[v30].shaderId = vertexShader;
      ++vertexShaders.numEntries;
      v24 = this->vertexShader;
      goto LABEL_29;
    }
    return 0;
  }
  v24 = *v23;
  this->ownsVertexShader = 0;
  this->vertexShader = v24;
LABEL_29:
  glAttachShader(this->fullProgram, v24);
  glAttachShader(this->fullProgram, this->pixelShader);
  v37 = 0;
  glBindAttribLocation(this->fullProgram, 0, "Position");
  glBindAttribLocation(this->fullProgram, 1, "TexCoord0");
  glBindAttribLocation(this->fullProgram, 2, "Normal");
  glBindAttribLocation(this->fullProgram, 3, "GlobalColor");
  glBindAttribLocation(this->fullProgram, 4, "BoneWeight");
  glBindAttribLocation(this->fullProgram, 5, "BoneIndices");
  glBindAttribLocation(this->fullProgram, 6, "Color2");
  glLinkProgram(this->fullProgram);
  v54 = 0;
  glGetProgramiv(this->fullProgram, 35714, &v54);
  if ( !v54 )
  {
    while ( 1 )
    {
      v42 = pCode;
      while ( 1 )
      {
        v43 = *pCode;
        if ( v43 > 0x7A )
          break;
        if ( !*pCode )
        {
          for ( i = 0; ; i = (v48 == 123) | v46 )
          {
            v49 = vCode;
            while ( 1 )
            {
              v50 = *vCode;
              if ( v50 <= 0x7A )
                break;
              v51 = v50 == 123;
              if ( v50 != 123 )
                v51 = v50 == 125;
              if ( v51 )
                goto LABEL_47;
LABEL_51:
              ++vCode;
            }
            if ( !*vCode )
              goto LABEL_61;
            if ( v50 != 59 )
              goto LABEL_51;
LABEL_47:
            v46 = i & (v50 != 125);
            v47 = &byte_61CADE;
            if ( v46 )
              v47 = "    ";
            strcpy(v55, v47);
            strncat(v55, (const char *)v49, (size_t)&vCode[1 - (_DWORD)v49]);
            v48 = *vCode++;
            OS_DebugOut((const unsigned __int8 *)v55);
          }
        }
        if ( v43 == 59 )
          goto LABEL_32;
LABEL_36:
        ++pCode;
      }
      v44 = v43 == 123;
      if ( v43 != 123 )
        v44 = v43 == 125;
      if ( !v44 )
        goto LABEL_36;
LABEL_32:
      v39 = v37 & (v43 != 125);
      v40 = &byte_61CADE;
      if ( v39 )
        v40 = "    ";
      strcpy(v55, v40);
      strncat(v55, (const char *)v42, (size_t)&pCode[1 - (_DWORD)v42]);
      v41 = *pCode++;
      OS_DebugOut((const unsigned __int8 *)v55);
      v37 = v39 | (v41 == 123);
    }
  }
LABEL_61:
  ES2Shader::InitializeAfterCompile(this);
  return 1;
}
// 1CCC26: variable 'v12' is possibly undefined
// 1CCD28: variable 'v28' is possibly undefined
// 190D44: using guessed type int __fastcall glGetProgramiv(_DWORD, _DWORD, _DWORD);
// 193748: using guessed type int __fastcall glCompileShader(_DWORD);
// 194970: using guessed type int __fastcall glCreateShader(_DWORD);
// 19DFD4: using guessed type int __fastcall glAttachShader(_DWORD, _DWORD);
// 19E1C8: using guessed type int glCreateProgram(void);
// 1A0534: using guessed type int __fastcall glBindAttribLocation(_DWORD, _DWORD, _DWORD);
// 1A0A08: using guessed type int __fastcall glLinkProgram(_DWORD);
// 1A0C18: using guessed type int __fastcall glShaderSource(_DWORD, _DWORD, _DWORD, _DWORD);
// 61CADE: using guessed type char byte_61CADE;

//----- (001CCFDC) --------------------------------------------------------
void __fastcall ES2Shader::SetVectorConstant(
        ES2Shader *this,
        RQShaderVectorConstantID id,
        const float *val,
        int numVals)
{
  float v4; // s0
  char *v5; // r0
  char *v6; // r0
  float *v7; // r1
  __int64 v8; // d17
  int v9; // r1

  switch ( numVals )
  {
    case 1:
      v4 = *val;
      v5 = (char *)this + 28 * id;
      *((_DWORD *)v5 + 7) = 1;
      if ( *((float *)v5 + 3) != v4 )
      {
        *((float *)v5 + 3) = v4;
        goto LABEL_14;
      }
      return;
    case 2:
      v5 = (char *)this + 28 * id;
      *((_DWORD *)v5 + 7) = 2;
      if ( *val != *((float *)v5 + 3) || val[1] != *((float *)v5 + 4) )
      {
        *((float *)v5 + 3) = *val;
        *((float *)v5 + 4) = val[1];
        goto LABEL_14;
      }
      return;
    case 3:
      v6 = (char *)this + 28 * id;
      *((_DWORD *)v6 + 7) = 3;
      if ( *val != *((float *)v6 + 3) )
      {
        v7 = (float *)(v6 + 16);
LABEL_18:
        *((float *)v6 + 3) = *val;
        *v7 = val[1];
        v9 = *((_DWORD *)val + 2);
        v6[8] = 1;
        *((_DWORD *)v6 + 5) = v9;
        return;
      }
      v7 = (float *)(v6 + 16);
      if ( val[1] != *((float *)v6 + 4) || val[2] != *((float *)v6 + 5) )
        goto LABEL_18;
      return;
    case 4:
      v5 = (char *)this + 28 * id;
      *((_DWORD *)v5 + 7) = 4;
      if ( *val != *((float *)v5 + 3)
        || val[1] != *((float *)v5 + 4)
        || val[2] != *((float *)v5 + 5)
        || val[3] != *((float *)v5 + 6) )
      {
        v8 = *((_QWORD *)val + 1);
        *(_QWORD *)(v5 + 12) = *(_QWORD *)val;
        *(_QWORD *)(v5 + 20) = v8;
LABEL_14:
        v5[8] = 1;
      }
      return;
    default:
      return;
  }
}

//----- (001CD124) --------------------------------------------------------
void __fastcall ES2Shader::SetColorAttribute(ES2Shader *this, const float *val)
{
  __int64 v2; // d16
  __int64 v3; // d17

  v2 = *(_QWORD *)val;
  v3 = *((_QWORD *)val + 1);
  ES2Shader::aBindings[0].isDirty = 1;
  *(_QWORD *)ES2Shader::aBindings[0].value._anon_0.arr = v2;
  *(_QWORD *)&ES2Shader::aBindings[0].value._anon_0._anon_1.b = v3;
}

//----- (001CD140) --------------------------------------------------------
void __fastcall ES2Shader::SetMatrixConstant(ES2Shader *this, RQShaderMatrixConstantID id, const float *val)
{
  char *v4; // r6
  __int64 v5; // d16
  __int64 v6; // d17
  __int64 v7; // d20
  __int64 v8; // d21
  __int64 v9; // d23
  __int64 v10; // d18
  __int64 v11; // d19

  v4 = (char *)this + 76 * id;
  if ( operator!=((const RQMatrix *)val, (const RQMatrix *)(v4 + 684)) )
  {
    v5 = *(_QWORD *)val;
    v6 = *((_QWORD *)val + 1);
    v7 = *((_QWORD *)val + 2);
    v8 = *((_QWORD *)val + 3);
    v9 = *((_QWORD *)val + 7);
    v10 = *((_QWORD *)val + 4);
    v11 = *((_QWORD *)val + 5);
    *(_QWORD *)(v4 + 732) = *((_QWORD *)val + 6);
    *(_QWORD *)(v4 + 740) = v9;
    *(_QWORD *)(v4 + 716) = v10;
    *(_QWORD *)(v4 + 724) = v11;
    *(_QWORD *)(v4 + 684) = v5;
    *(_QWORD *)(v4 + 692) = v6;
    *(_QWORD *)(v4 + 700) = v7;
    *(_QWORD *)(v4 + 708) = v8;
    v4[680] = 1;
    v4[748] = 1;
  }
}

//----- (001CD1A4) --------------------------------------------------------
void __fastcall ES2Shader::SetBonesConstant(ES2Shader *this, int boneCount, const float *val)
{
  size_t v6; // r5
  RenderQueue *v7; // r0
  unsigned __int8 *mainWorkPointer; // r2
  RenderQueue *v9; // r0
  RenderQueue *v10; // r0
  RenderQueue *v11; // r0
  RenderQueue *v12; // r6
  unsigned __int8 *v13; // r0
  RenderQueue *v14; // r0
  RenderQueue *v15; // r4
  __int64 v16; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v18; // r2

  v6 = 16 * boneCount;
  v7 = renderQueue;
  if ( &renderQueue->mainPointer[16 * boneCount + 67] > renderQueue->queueEnd )
  {
    RenderQueue::Flush(renderQueue);
    v7 = renderQueue;
  }
  mainWorkPointer = v7->mainWorkPointer;
  v7->curQueueingCommand = rqSelectShader;
  *(_DWORD *)mainWorkPointer = 17;
  v7->mainWorkPointer += 4;
  v9 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = this;
  v9->mainWorkPointer += 4;
  v10 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = 6;
  v10->mainWorkPointer += 4;
  v11 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = boneCount;
  v11->mainWorkPointer += 4;
  v12 = renderQueue;
  v13 = (unsigned __int8 *)((int)(renderQueue->mainWorkPointer + 3) & 0xFFFFFFFC);
  renderQueue->mainWorkPointer = v13;
  qmemcpy(v13, val, v6);
  v12->mainWorkPointer += v6;
  v14 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = 8;
  v14->mainWorkPointer += 4;
  v15 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v16 = *(_QWORD *)&v15->mainPointer;
  p_mainPointer = (unsigned int *)&v15->mainPointer;
  __dmb(0xBu);
  do
    v18 = __ldrex(p_mainPointer);
  while ( __strex(v18 + HIDWORD(v16) - v16, p_mainPointer) );
  __dmb(0xBu);
  if ( v15->useMutex )
    OS_MutexRelease(v15->commandMutex);
  if ( !v15->multiThread )
    RenderQueue::Process(v15);
  if ( v15->mainPointer + 1024 > v15->queueEnd )
    sub_1A148C(v15);
}

//----- (001CD2E8) --------------------------------------------------------
void __fastcall ES2Shader::Select(ES2Shader *this)
{
  RenderQueue *v2; // r0
  unsigned __int8 *mainWorkPointer; // r2
  RenderQueue *v4; // r0
  bool v5; // zf
  RenderQueue *v6; // r1
  RenderQueue *v7; // r1
  RenderQueue *v8; // r0
  unsigned int v9; // r1
  __int64 v10; // d16
  __int64 v11; // d17
  __int64 v12; // d18
  __int64 v13; // d19
  __int64 v14; // d20
  __int64 v15; // d21
  __int64 v16; // d23
  bool v17; // zf
  RenderQueue *v18; // r1
  RenderQueue *v19; // r1
  RenderQueue *v20; // r0
  unsigned int v21; // r1
  __int64 v22; // d16
  __int64 v23; // d17
  __int64 v24; // d18
  __int64 v25; // d19
  __int64 v26; // d20
  __int64 v27; // d21
  __int64 v28; // d23
  bool v29; // zf
  RenderQueue *v30; // r1
  RenderQueue *v31; // r1
  RenderQueue *v32; // r0
  unsigned int v33; // r1
  __int64 v34; // d16
  __int64 v35; // d17
  __int64 v36; // d18
  __int64 v37; // d19
  __int64 v38; // d20
  __int64 v39; // d21
  __int64 v40; // d23
  bool v41; // zf
  RenderQueue *v42; // r1
  RenderQueue *v43; // r1
  RenderQueue *v44; // r0
  unsigned int v45; // r1
  __int64 v46; // d16
  __int64 v47; // d17
  __int64 v48; // d18
  __int64 v49; // d19
  __int64 v50; // d20
  __int64 v51; // d21
  __int64 v52; // d23
  RenderQueue *v53; // r1
  RenderQueue *v54; // r1
  RenderQueue *v55; // r0
  unsigned int v56; // r2
  __int64 v57; // d17
  RenderQueue *v58; // r1
  RenderQueue *v59; // r4
  __int64 v60; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v62; // r2

  v2 = renderQueue;
  if ( renderQueue->mainPointer + 1027 > renderQueue->queueEnd )
  {
    RenderQueue::Flush(renderQueue);
    v2 = renderQueue;
  }
  mainWorkPointer = v2->mainWorkPointer;
  v2->curQueueingCommand = rqSelectShader;
  *(_DWORD *)mainWorkPointer = 17;
  v2->mainWorkPointer += 4;
  v4 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = this;
  v4->mainWorkPointer += 4;
  ES2VectorBinding::Apply(this->vBindings, 0);
  ES2VectorBinding::Apply(&this->vBindings[1], 1u);
  ES2VectorBinding::Apply(&this->vBindings[2], 2u);
  ES2VectorBinding::Apply(&this->vBindings[3], 3u);
  ES2VectorBinding::Apply(&this->vBindings[4], 4u);
  ES2VectorBinding::Apply(&this->vBindings[5], 5u);
  ES2VectorBinding::Apply(&this->vBindings[6], 6u);
  ES2VectorBinding::Apply(&this->vBindings[7], 7u);
  ES2VectorBinding::Apply(&this->vBindings[8], 8u);
  ES2VectorBinding::Apply(&this->vBindings[9], 9u);
  ES2VectorBinding::Apply(&this->vBindings[10], 0xAu);
  ES2VectorBinding::Apply(&this->vBindings[11], 0xBu);
  ES2VectorBinding::Apply(&this->vBindings[12], 0xCu);
  ES2VectorBinding::Apply(&this->vBindings[13], 0xDu);
  ES2VectorBinding::Apply(&this->vBindings[14], 0xEu);
  ES2VectorBinding::Apply(&this->vBindings[15], 0xFu);
  ES2VectorBinding::Apply(&this->vBindings[16], 0x10u);
  ES2VectorBinding::Apply(&this->vBindings[17], 0x11u);
  ES2VectorBinding::Apply(&this->vBindings[18], 0x12u);
  ES2VectorBinding::Apply(&this->vBindings[19], 0x13u);
  ES2VectorBinding::Apply(&this->vBindings[20], 0x14u);
  ES2VectorBinding::Apply(&this->vBindings[21], 0x15u);
  ES2VectorBinding::Apply(&this->vBindings[22], 0x16u);
  ES2VectorBinding::Apply(&this->vBindings[23], 0x17u);
  v5 = !this->mBindings[0].isDirty;
  if ( this->mBindings[0].isDirty )
    v5 = this->mBindings[0].uniformID == -1;
  if ( !v5 )
  {
    v6 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = 5;
    v6->mainWorkPointer += 4;
    v7 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = 0;
    v7->mainWorkPointer += 4;
    v8 = renderQueue;
    v9 = (int)(renderQueue->mainWorkPointer + 3) & 0xFFFFFFFC;
    renderQueue->mainWorkPointer = (unsigned __int8 *)v9;
    v10 = *(_QWORD *)&this->mBindings[0].value._anon_0._anon_0.f13;
    v11 = *(_QWORD *)&this->mBindings[0].value._anon_0._anon_0.f33;
    v12 = *(_QWORD *)this->mBindings[0].value._anon_0.arr;
    v13 = *(_QWORD *)&this->mBindings[0].value._anon_0._anon_0.f31;
    v14 = *(_QWORD *)&this->mBindings[0].value._anon_0._anon_0.f12;
    v15 = *(_QWORD *)&this->mBindings[0].value._anon_0._anon_0.f32;
    v16 = *(_QWORD *)&this->mBindings[0].value._anon_0._anon_0.f34;
    *(_QWORD *)(v9 + 48) = *(_QWORD *)&this->mBindings[0].value._anon_0._anon_0.f14;
    *(_QWORD *)(v9 + 56) = v16;
    *(_QWORD *)(v9 + 32) = v10;
    *(_QWORD *)(v9 + 40) = v11;
    *(_QWORD *)v9 = v12;
    *(_QWORD *)(v9 + 8) = v13;
    v9 += 16;
    *(_QWORD *)v9 = v14;
    *(_QWORD *)(v9 + 8) = v15;
    v8->mainWorkPointer += 64;
    this->mBindings[0].isDirty = 0;
  }
  v17 = !this->mBindings[1].isDirty;
  if ( this->mBindings[1].isDirty )
    v17 = this->mBindings[1].uniformID == -1;
  if ( !v17 )
  {
    v18 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = 5;
    v18->mainWorkPointer += 4;
    v19 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = 1;
    v19->mainWorkPointer += 4;
    v20 = renderQueue;
    v21 = (int)(renderQueue->mainWorkPointer + 3) & 0xFFFFFFFC;
    renderQueue->mainWorkPointer = (unsigned __int8 *)v21;
    v22 = *(_QWORD *)&this->mBindings[1].value._anon_0._anon_0.f13;
    v23 = *(_QWORD *)&this->mBindings[1].value._anon_0._anon_0.f33;
    v24 = *(_QWORD *)this->mBindings[1].value._anon_0.arr;
    v25 = *(_QWORD *)&this->mBindings[1].value._anon_0._anon_0.f31;
    v26 = *(_QWORD *)&this->mBindings[1].value._anon_0._anon_0.f12;
    v27 = *(_QWORD *)&this->mBindings[1].value._anon_0._anon_0.f32;
    v28 = *(_QWORD *)&this->mBindings[1].value._anon_0._anon_0.f34;
    *(_QWORD *)(v21 + 48) = *(_QWORD *)&this->mBindings[1].value._anon_0._anon_0.f14;
    *(_QWORD *)(v21 + 56) = v28;
    *(_QWORD *)(v21 + 32) = v22;
    *(_QWORD *)(v21 + 40) = v23;
    *(_QWORD *)v21 = v24;
    *(_QWORD *)(v21 + 8) = v25;
    v21 += 16;
    *(_QWORD *)v21 = v26;
    *(_QWORD *)(v21 + 8) = v27;
    v20->mainWorkPointer += 64;
    this->mBindings[1].isDirty = 0;
  }
  v29 = !this->mBindings[2].isDirty;
  if ( this->mBindings[2].isDirty )
    v29 = this->mBindings[2].uniformID == -1;
  if ( !v29 )
  {
    v30 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = 5;
    v30->mainWorkPointer += 4;
    v31 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = 2;
    v31->mainWorkPointer += 4;
    v32 = renderQueue;
    v33 = (int)(renderQueue->mainWorkPointer + 3) & 0xFFFFFFFC;
    renderQueue->mainWorkPointer = (unsigned __int8 *)v33;
    v34 = *(_QWORD *)&this->mBindings[2].value._anon_0._anon_0.f13;
    v35 = *(_QWORD *)&this->mBindings[2].value._anon_0._anon_0.f33;
    v36 = *(_QWORD *)this->mBindings[2].value._anon_0.arr;
    v37 = *(_QWORD *)&this->mBindings[2].value._anon_0._anon_0.f31;
    v38 = *(_QWORD *)&this->mBindings[2].value._anon_0._anon_0.f12;
    v39 = *(_QWORD *)&this->mBindings[2].value._anon_0._anon_0.f32;
    v40 = *(_QWORD *)&this->mBindings[2].value._anon_0._anon_0.f34;
    *(_QWORD *)(v33 + 48) = *(_QWORD *)&this->mBindings[2].value._anon_0._anon_0.f14;
    *(_QWORD *)(v33 + 56) = v40;
    *(_QWORD *)(v33 + 32) = v34;
    *(_QWORD *)(v33 + 40) = v35;
    *(_QWORD *)v33 = v36;
    *(_QWORD *)(v33 + 8) = v37;
    v33 += 16;
    *(_QWORD *)v33 = v38;
    *(_QWORD *)(v33 + 8) = v39;
    v32->mainWorkPointer += 64;
    this->mBindings[2].isDirty = 0;
  }
  v41 = !this->mBindings[3].isDirty;
  if ( this->mBindings[3].isDirty )
    v41 = this->mBindings[3].uniformID == -1;
  if ( !v41 )
  {
    v42 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = 4;
    v42->mainWorkPointer += 4;
    v43 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = 3;
    v43->mainWorkPointer += 4;
    v44 = renderQueue;
    v45 = (int)(renderQueue->mainWorkPointer + 3) & 0xFFFFFFFC;
    renderQueue->mainWorkPointer = (unsigned __int8 *)v45;
    v46 = *(_QWORD *)&this->mBindings[3].value._anon_0._anon_0.f13;
    v47 = *(_QWORD *)&this->mBindings[3].value._anon_0._anon_0.f33;
    v48 = *(_QWORD *)this->mBindings[3].value._anon_0.arr;
    v49 = *(_QWORD *)&this->mBindings[3].value._anon_0._anon_0.f31;
    v50 = *(_QWORD *)&this->mBindings[3].value._anon_0._anon_0.f12;
    v51 = *(_QWORD *)&this->mBindings[3].value._anon_0._anon_0.f32;
    v52 = *(_QWORD *)&this->mBindings[3].value._anon_0._anon_0.f34;
    *(_QWORD *)(v45 + 48) = *(_QWORD *)&this->mBindings[3].value._anon_0._anon_0.f14;
    *(_QWORD *)(v45 + 56) = v52;
    *(_QWORD *)(v45 + 32) = v46;
    *(_QWORD *)(v45 + 40) = v47;
    *(_QWORD *)v45 = v48;
    *(_QWORD *)(v45 + 8) = v49;
    v45 += 16;
    *(_QWORD *)v45 = v50;
    *(_QWORD *)(v45 + 8) = v51;
    v44->mainWorkPointer += 64;
    this->mBindings[3].isDirty = 0;
  }
  if ( ES2Shader::aBindings[0].isDirty )
  {
    v53 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = 7;
    v53->mainWorkPointer += 4;
    v54 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = 0;
    v54->mainWorkPointer += 4;
    v55 = renderQueue;
    v56 = (int)(renderQueue->mainWorkPointer + 3) & 0xFFFFFFFC;
    renderQueue->mainWorkPointer = (unsigned __int8 *)v56;
    v57 = *(_QWORD *)&ES2Shader::aBindings[0].value._anon_0._anon_1.b;
    *(_QWORD *)v56 = *(_QWORD *)ES2Shader::aBindings[0].value._anon_0.arr;
    *(_QWORD *)(v56 + 8) = v57;
    v55->mainWorkPointer += 16;
    ES2Shader::aBindings[0].isDirty = 0;
  }
  v58 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = 8;
  v58->mainWorkPointer += 4;
  v59 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v60 = *(_QWORD *)&v59->mainPointer;
  p_mainPointer = (unsigned int *)&v59->mainPointer;
  __dmb(0xBu);
  do
    v62 = __ldrex(p_mainPointer);
  while ( __strex(v62 + HIDWORD(v60) - v60, p_mainPointer) );
  __dmb(0xBu);
  if ( v59->useMutex )
    OS_MutexRelease(v59->commandMutex);
  if ( !v59->multiThread )
    RenderQueue::Process(v59);
  if ( v59->mainPointer + 1024 > v59->queueEnd )
    sub_1A148C(v59);
}

//----- (001CD7A8) --------------------------------------------------------
RQShader *__fastcall RQCreateShader(const unsigned __int8 *pSource, const unsigned __int8 *vSource, unsigned int flags)
{
  ES2Shader *v6; // r4
  RenderQueue *v7; // r1
  unsigned __int8 *mainWorkPointer; // r2
  RenderQueue *v9; // r1
  RenderQueue *v10; // r1
  RenderQueue *v11; // r1
  RenderQueue *v12; // r1
  RenderQueue *v13; // r5
  __int64 v14; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v16; // r2

  v6 = (ES2Shader *)operator new(0x3F0u);
  ES2Shader::ES2Shader(v6);
  v7 = renderQueue;
  mainWorkPointer = renderQueue->mainWorkPointer;
  renderQueue->curQueueingCommand = rqBuildShader;
  *(_DWORD *)mainWorkPointer = 16;
  v7->mainWorkPointer += 4;
  v9 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = v6;
  v9->mainWorkPointer += 4;
  v10 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = pSource;
  v10->mainWorkPointer += 4;
  v11 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = vSource;
  v11->mainWorkPointer += 4;
  v12 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = flags;
  v12->mainWorkPointer += 4;
  v13 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v14 = *(_QWORD *)&v13->mainPointer;
  p_mainPointer = (unsigned int *)&v13->mainPointer;
  __dmb(0xBu);
  do
    v16 = __ldrex(p_mainPointer);
  while ( __strex(v16 + HIDWORD(v14) - v14, p_mainPointer) );
  __dmb(0xBu);
  if ( v13->useMutex )
    OS_MutexRelease(v13->commandMutex);
  if ( !v13->multiThread )
    RenderQueue::Process(v13);
  if ( v13->mainPointer + 1024 > v13->queueEnd )
    RenderQueue::Flush(v13);
  return v6;
}

//----- (001CD8A0) --------------------------------------------------------
void __fastcall RQDeleteShader(RQShader *toDelete)
{
  RenderQueue *v1; // r2
  unsigned __int8 *mainWorkPointer; // r3
  RenderQueue *v3; // r2
  RenderQueue *v4; // r4
  __int64 v5; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v7; // r2

  v1 = renderQueue;
  mainWorkPointer = renderQueue->mainWorkPointer;
  renderQueue->curQueueingCommand = rqDeleteShader;
  *(_DWORD *)mainWorkPointer = 18;
  v1->mainWorkPointer += 4;
  v3 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = toDelete;
  v3->mainWorkPointer += 4;
  v4 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v5 = *(_QWORD *)&v4->mainPointer;
  p_mainPointer = (unsigned int *)&v4->mainPointer;
  __dmb(0xBu);
  do
    v7 = __ldrex(p_mainPointer);
  while ( __strex(v7 + HIDWORD(v5) - v5, p_mainPointer) );
  __dmb(0xBu);
  if ( v4->useMutex )
    OS_MutexRelease(v4->commandMutex);
  if ( !v4->multiThread )
    RenderQueue::Process(v4);
  if ( v4->mainPointer + 1024 > v4->queueEnd )
    sub_1A148C(v4);
}

//----- (001CD944) --------------------------------------------------------
void __fastcall strreplace(unsigned __int8 *str, const unsigned __int8 *find, const unsigned __int8 *with)
{
  size_t i; // r6
  char *v7; // r0

  for ( i = strlen((const char *)with); ; qmemcpy(v7, with, i) )
  {
    v7 = strstr((const char *)str, (const char *)find);
    str = (unsigned __int8 *)v7;
    if ( !v7 )
      break;
  }
}

//----- (001CD97C) --------------------------------------------------------
void __fastcall RQ_Command_rqBuildShader(unsigned __int8 **qData)
{
  unsigned __int8 *v1; // r1
  unsigned __int8 *v2; // r2
  ES2Shader *v3; // r8
  char *v4; // r11
  unsigned __int8 *v5; // r10
  GLuint v6; // r9
  char *i; // r0
  char *j; // r0
  char v9[4096]; // [sp+0h] [bp-1030h] BYREF

  v1 = *qData;
  v2 = *qData + 16;
  v3 = *(ES2Shader **)*qData;
  *qData += 4;
  v4 = (char *)*((_DWORD *)v1 + 1);
  *qData = v1 + 8;
  v5 = (unsigned __int8 *)*((_DWORD *)v1 + 2);
  *qData = v1 + 12;
  v6 = *((_DWORD *)v1 + 3);
  *qData = v2;
  if ( !ES2Shader::Build(v3, (const unsigned __int8 *)v4, v5) )
  {
    strcpy(v9, v4);
    for ( i = strstr(v9, "/*ATBEGIN*/"); i; i = strstr(i, "/*ATBEGIN*/") )
    {
      i[10] = 32;
      *((_WORD *)i + 4) = 8270;
      *(_QWORD *)i = *(_QWORD *)"/*ATBEGIN  ";
    }
    for ( j = strstr(v9, "/*ATEND*/"); j; j = strstr(j, "/*ATEND*/") )
    {
      j[8] = 47;
      *(_QWORD *)j = *(_QWORD *)"  ATEND*/";
    }
    if ( !ES2Shader::Build(v3, (const unsigned __int8 *)v9, v5) )
      __debugbreak();
  }
  free(v4);
  free(v5);
  v3->flags = v6;
}

//----- (001CDA98) --------------------------------------------------------
void __fastcall RQ_Command_rqSelectShader(unsigned __int8 **qData)
{
  unsigned __int8 *v2; // r0
  ES2Shader *v3; // r6
  unsigned __int8 *v4; // r0
  int v5; // r1
  unsigned __int8 *v6; // r2
  int *p_bonesLocation; // r0
  int v8; // r3
  unsigned __int8 *v9; // r0

  v2 = *qData;
  v3 = *(ES2Shader **)v2;
  *qData = v2 + 4;
  RQ_CheckThread();
  if ( ES2Shader::activeShader != v3 )
  {
    ES2Shader::activeShader = v3;
    glUseProgram(v3->fullProgram);
  }
  v4 = *qData;
  v6 = *qData + 4;
  v5 = *(_DWORD *)*qData;
  *qData = v6;
  if ( v5 != 8 )
  {
    while ( 1 )
    {
      if ( v5 == 6 )
      {
        p_bonesLocation = &v3->bonesLocation;
        goto LABEL_10;
      }
      v8 = *(_DWORD *)v6;
      v6 = v4 + 8;
      *qData = v4 + 8;
      if ( (v5 | 1) == 5 )
        break;
      if ( v5 != 7 )
      {
        p_bonesLocation = &v3->vBindings[v8].uniformID;
LABEL_10:
        if ( *p_bonesLocation < 0 )
        {
          switch ( v5 )
          {
            case 0:
              v9 = (unsigned __int8 *)(((unsigned int)(v6 + 3) & 0xFFFFFFFC) + 4);
              goto LABEL_27;
            case 1:
              v9 = (unsigned __int8 *)(((unsigned int)(v6 + 3) & 0xFFFFFFFC) + 8);
              goto LABEL_27;
            case 2:
              v9 = (unsigned __int8 *)(((unsigned int)(v6 + 3) & 0xFFFFFFFC) + 12);
              goto LABEL_27;
            case 3:
              v9 = (unsigned __int8 *)(((unsigned int)(v6 + 3) & 0xFFFFFFFC) + 16);
              goto LABEL_27;
            case 4:
            case 5:
              v9 = (unsigned __int8 *)(((unsigned int)(v6 + 3) & 0xFFFFFFFC) + 64);
              goto LABEL_27;
            case 6:
              v9 = (unsigned __int8 *)(((unsigned int)(v6 + 7) & 0xFFFFFFFC) + 16 * *(_DWORD *)v6);
LABEL_27:
              *qData = v9;
              break;
            default:
              goto LABEL_28;
          }
        }
        else
        {
          switch ( v5 )
          {
            case 0:
              *qData = (unsigned __int8 *)(((unsigned int)(v6 + 3) & 0xFFFFFFFC) + 4);
              glUniform1fv();
              break;
            case 1:
              *qData = (unsigned __int8 *)(((unsigned int)(v6 + 3) & 0xFFFFFFFC) + 8);
              glUniform2fv();
              break;
            case 2:
              *qData = (unsigned __int8 *)(((unsigned int)(v6 + 3) & 0xFFFFFFFC) + 12);
              glUniform3fv();
              break;
            case 3:
              *qData = (unsigned __int8 *)(((unsigned int)(v6 + 3) & 0xFFFFFFFC) + 16);
              glUniform4fv();
              break;
            case 4:
              *qData = (unsigned __int8 *)(((unsigned int)(v6 + 3) & 0xFFFFFFFC) + 64);
              glUniformMatrix3fv();
              break;
            case 5:
              *qData = (unsigned __int8 *)(((unsigned int)(v6 + 3) & 0xFFFFFFFC) + 64);
              glUniformMatrix4fv();
              break;
            case 6:
              *qData = (unsigned __int8 *)(((unsigned int)(v6 + 7) & 0xFFFFFFFC) + 16 * *(_DWORD *)v6);
              glUniform4fv();
              break;
            case 7:
              goto LABEL_15;
            default:
              goto LABEL_28;
          }
        }
        goto LABEL_28;
      }
LABEL_15:
      *qData = (unsigned __int8 *)(((unsigned int)(v6 + 3) & 0xFFFFFFFC) + 16);
      glVertexAttrib4fv(3);
LABEL_28:
      v4 = *qData;
      v6 = *qData + 4;
      v5 = *(_DWORD *)*qData;
      *qData = v6;
      if ( v5 == 8 )
        return;
    }
    p_bonesLocation = &v3->mBindings[v8].uniformID;
    goto LABEL_10;
  }
}
// 18B870: using guessed type int __fastcall glVertexAttrib4fv(_DWORD);
// 1983C8: using guessed type int glUniform1fv(void);
// 1986FC: using guessed type int glUniform2fv(void);
// 198F70: using guessed type int __fastcall glUseProgram(_DWORD);
// 19A6E8: using guessed type int glUniform3fv(void);
// 19A9A0: using guessed type int glUniform4fv(void);
// 19B04C: using guessed type int glUniformMatrix4fv(void);
// 19B4E0: using guessed type int glUniformMatrix3fv(void);

//----- (001CDC6C) --------------------------------------------------------
void __fastcall RQ_Command_rqDeleteShader(unsigned __int8 **qData)
{
  int v2; // r0
  unsigned __int8 *v3; // r2

  v3 = *qData + 4;
  v2 = *(_DWORD *)*qData;
  *qData = v3;
  if ( v2 )
    (*(void (__fastcall **)(int))(*(_DWORD *)v2 + 4))(v2);
}

//----- (001CDC82) --------------------------------------------------------
void __fastcall TDBArray<RQCompiledShader>::~TDBArray(TDBArray<RQCompiledShader> *this)
{
  RQCompiledShader *dataPtr; // r0

  dataPtr = this->dataPtr;
  this->numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->dataPtr = 0;
  }
  this->numAlloced = 0;
}

//----- (001CDC9C) --------------------------------------------------------
void __fastcall ES2VectorBinding::Apply(ES2VectorBinding *this, unsigned int id)
{
  bool v2; // zf
  RenderQueue *v3; // r3
  RenderQueue *v4; // r2
  RenderQueue *v5; // r1
  unsigned __int8 *v6; // r2
  unsigned __int8 **p_mainWorkPointer; // r1
  int v8; // r2
  RenderQueue *v9; // r3
  RenderQueue *v10; // r2
  RenderQueue *v11; // r1
  unsigned int v12; // r2
  float v13; // r12
  RenderQueue *v14; // r3
  RenderQueue *v15; // r2
  RenderQueue *v16; // r1
  unsigned int v17; // r2
  __int64 v18; // d16
  RenderQueue *v19; // r3
  RenderQueue *v20; // r2
  RenderQueue *v21; // r1
  unsigned int v22; // r2
  __int64 v23; // d17

  v2 = !this->isDirty;
  if ( this->isDirty )
    v2 = this->uniformID == -1;
  if ( !v2 )
  {
    switch ( this->numVals )
    {
      case 1u:
        v3 = renderQueue;
        *(_DWORD *)renderQueue->mainWorkPointer = 0;
        v3->mainWorkPointer += 4;
        v4 = renderQueue;
        *(_DWORD *)renderQueue->mainWorkPointer = id;
        v4->mainWorkPointer += 4;
        v5 = renderQueue;
        v6 = (unsigned __int8 *)((int)(renderQueue->mainWorkPointer + 3) & 0xFFFFFFFC);
        renderQueue->mainWorkPointer = v6;
        p_mainWorkPointer = &v5->mainWorkPointer;
        *(float *)v6 = this->value._anon_0.arr[0];
        v8 = 4;
        goto LABEL_9;
      case 2u:
        v9 = renderQueue;
        *(_DWORD *)renderQueue->mainWorkPointer = 1;
        v9->mainWorkPointer += 4;
        v10 = renderQueue;
        *(_DWORD *)renderQueue->mainWorkPointer = id;
        v10->mainWorkPointer += 4;
        v11 = renderQueue;
        v12 = (int)(renderQueue->mainWorkPointer + 3) & 0xFFFFFFFC;
        renderQueue->mainWorkPointer = (unsigned __int8 *)v12;
        v13 = this->value._anon_0.arr[1];
        p_mainWorkPointer = &v11->mainWorkPointer;
        *(float *)v12 = this->value._anon_0.arr[0];
        *(float *)(v12 + 4) = v13;
        v8 = 8;
        goto LABEL_9;
      case 3u:
        v14 = renderQueue;
        *(_DWORD *)renderQueue->mainWorkPointer = 2;
        v14->mainWorkPointer += 4;
        v15 = renderQueue;
        *(_DWORD *)renderQueue->mainWorkPointer = id;
        v15->mainWorkPointer += 4;
        v16 = renderQueue;
        v17 = (int)(renderQueue->mainWorkPointer + 3) & 0xFFFFFFFC;
        renderQueue->mainWorkPointer = (unsigned __int8 *)v17;
        v18 = *(_QWORD *)this->value._anon_0.arr;
        p_mainWorkPointer = &v16->mainWorkPointer;
        *(float *)(v17 + 8) = this->value._anon_0.arr[2];
        *(_QWORD *)v17 = v18;
        v8 = 12;
        goto LABEL_9;
      case 4u:
        v19 = renderQueue;
        *(_DWORD *)renderQueue->mainWorkPointer = 3;
        v19->mainWorkPointer += 4;
        v20 = renderQueue;
        *(_DWORD *)renderQueue->mainWorkPointer = id;
        v20->mainWorkPointer += 4;
        v21 = renderQueue;
        v22 = (int)(renderQueue->mainWorkPointer + 3) & 0xFFFFFFFC;
        renderQueue->mainWorkPointer = (unsigned __int8 *)v22;
        v23 = *(_QWORD *)&this->value._anon_0._anon_1.b;
        p_mainWorkPointer = &v21->mainWorkPointer;
        *(_QWORD *)v22 = *(_QWORD *)this->value._anon_0.arr;
        *(_QWORD *)(v22 + 8) = v23;
        v8 = 16;
LABEL_9:
        *p_mainWorkPointer += v8;
        break;
      default:
        break;
    }
    this->isDirty = 0;
  }
}

//----- (001CDE44) --------------------------------------------------------
void __fastcall ES2Shader::ES2Shader(ES2Shader *this)
{
  __int64 v1; // d18
  __int64 v2; // d19

  *(float *)&v1 = 1.0;
  *((float *)&v1 + 1) = 1.0;
  *(float *)&v2 = 1.0;
  *((float *)&v2 + 1) = 1.0;
  this->vBindings[0].uniformID = -2;
  this->vBindings[0].isDirty = 1;
  this->vBindings[0].numVals = 4;
  this->vBindings[1].uniformID = -2;
  this->vBindings[1].isDirty = 1;
  this->vBindings[2].isDirty = 1;
  this->vBindings[2].numVals = 4;
  this->vBindings[1].numVals = 4;
  this->vBindings[2].uniformID = -2;
  *(_QWORD *)this->vBindings[0].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[0].value._anon_0._anon_1.b = v2;
  *(_QWORD *)this->vBindings[1].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[1].value._anon_0._anon_1.b = v2;
  *(_QWORD *)this->vBindings[2].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[2].value._anon_0._anon_1.b = v2;
  this->vBindings[3].isDirty = 1;
  *(_QWORD *)this->vBindings[3].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[3].value._anon_0._anon_1.b = v2;
  this->vBindings[3].uniformID = -2;
  this->_vptr$RQShader = (int (**)(void))&off_6608A0;
  *(_QWORD *)this->vBindings[4].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[4].value._anon_0._anon_1.b = v2;
  this->vBindings[4].isDirty = 1;
  this->vBindings[3].numVals = 4;
  this->vBindings[4].uniformID = -2;
  *(_QWORD *)this->vBindings[5].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[5].value._anon_0._anon_1.b = v2;
  this->vBindings[5].isDirty = 1;
  this->vBindings[4].numVals = 4;
  this->vBindings[5].uniformID = -2;
  *(_QWORD *)this->vBindings[6].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[6].value._anon_0._anon_1.b = v2;
  this->vBindings[6].isDirty = 1;
  this->vBindings[5].numVals = 4;
  this->vBindings[6].uniformID = -2;
  *(_QWORD *)this->vBindings[7].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[7].value._anon_0._anon_1.b = v2;
  this->vBindings[7].isDirty = 1;
  this->vBindings[6].numVals = 4;
  this->vBindings[7].uniformID = -2;
  *(_QWORD *)this->vBindings[8].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[8].value._anon_0._anon_1.b = v2;
  this->vBindings[8].isDirty = 1;
  this->vBindings[7].numVals = 4;
  this->vBindings[8].uniformID = -2;
  *(_QWORD *)this->vBindings[9].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[9].value._anon_0._anon_1.b = v2;
  this->vBindings[9].isDirty = 1;
  this->vBindings[8].numVals = 4;
  this->vBindings[9].uniformID = -2;
  *(_QWORD *)this->vBindings[10].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[10].value._anon_0._anon_1.b = v2;
  this->vBindings[10].isDirty = 1;
  this->vBindings[9].numVals = 4;
  this->vBindings[10].uniformID = -2;
  *(_QWORD *)this->vBindings[11].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[11].value._anon_0._anon_1.b = v2;
  this->vBindings[11].isDirty = 1;
  this->vBindings[10].numVals = 4;
  this->vBindings[11].uniformID = -2;
  *(_QWORD *)this->vBindings[12].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[12].value._anon_0._anon_1.b = v2;
  this->vBindings[12].isDirty = 1;
  this->vBindings[11].numVals = 4;
  this->vBindings[12].uniformID = -2;
  *(_QWORD *)this->vBindings[13].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[13].value._anon_0._anon_1.b = v2;
  this->vBindings[13].isDirty = 1;
  this->vBindings[12].numVals = 4;
  this->vBindings[13].uniformID = -2;
  *(_QWORD *)this->vBindings[14].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[14].value._anon_0._anon_1.b = v2;
  this->vBindings[14].isDirty = 1;
  this->vBindings[13].numVals = 4;
  this->vBindings[14].uniformID = -2;
  *(_QWORD *)this->vBindings[15].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[15].value._anon_0._anon_1.b = v2;
  this->vBindings[15].isDirty = 1;
  this->vBindings[14].numVals = 4;
  this->vBindings[15].uniformID = -2;
  *(_QWORD *)this->vBindings[16].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[16].value._anon_0._anon_1.b = v2;
  this->vBindings[16].isDirty = 1;
  this->vBindings[15].numVals = 4;
  this->vBindings[16].uniformID = -2;
  *(_QWORD *)this->vBindings[17].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[17].value._anon_0._anon_1.b = v2;
  this->vBindings[17].isDirty = 1;
  this->vBindings[16].numVals = 4;
  this->vBindings[17].uniformID = -2;
  *(_QWORD *)this->vBindings[18].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[18].value._anon_0._anon_1.b = v2;
  this->vBindings[18].isDirty = 1;
  this->vBindings[17].numVals = 4;
  this->vBindings[18].uniformID = -2;
  *(_QWORD *)this->vBindings[19].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[19].value._anon_0._anon_1.b = v2;
  this->vBindings[19].isDirty = 1;
  this->vBindings[18].numVals = 4;
  this->vBindings[19].uniformID = -2;
  *(_QWORD *)this->vBindings[20].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[20].value._anon_0._anon_1.b = v2;
  this->vBindings[20].isDirty = 1;
  this->vBindings[19].numVals = 4;
  this->vBindings[20].uniformID = -2;
  *(_QWORD *)this->vBindings[21].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[21].value._anon_0._anon_1.b = v2;
  this->vBindings[21].isDirty = 1;
  this->vBindings[20].numVals = 4;
  this->vBindings[21].uniformID = -2;
  *(_QWORD *)this->vBindings[22].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[22].value._anon_0._anon_1.b = v2;
  this->vBindings[22].isDirty = 1;
  this->vBindings[21].numVals = 4;
  this->vBindings[22].uniformID = -2;
  *(_QWORD *)this->vBindings[23].value._anon_0.arr = v1;
  *(_QWORD *)&this->vBindings[23].value._anon_0._anon_1.b = v2;
  this->vBindings[23].isDirty = 1;
  this->vBindings[23].numVals = 4;
  this->vBindings[22].numVals = 4;
  this->vBindings[23].uniformID = -2;
  *(_QWORD *)&this->mBindings[0].value._anon_0._anon_0.f21 = 0LL;
  *(_QWORD *)&this->mBindings[0].value._anon_0._anon_0.f41 = 0LL;
  *(_QWORD *)&this->mBindings[0].value._anon_0._anon_0.f32 = 0LL;
  *(_QWORD *)&this->mBindings[0].value._anon_0._anon_0.f13 = 0LL;
  *(_QWORD *)&this->mBindings[0].value._anon_0._anon_0.f43 = 0LL;
  *(_QWORD *)&this->mBindings[0].value._anon_0._anon_0.f24 = 0LL;
  this->mBindings[0].value._anon_0.arr[0] = 1.0;
  this->mBindings[0].isDirty = 1;
  this->mBindings[0].uniformID = -2;
  this->mBindings[0].value._anon_0.arr[5] = 1.0;
  this->mBindings[0].value._anon_0.arr[10] = 1.0;
  this->mBindings[0].value._anon_0.arr[15] = 1.0;
  this->mBindings[0].value.dirty = 1;
  *(_QWORD *)&this->mBindings[1].value._anon_0._anon_0.f21 = 0LL;
  *(_QWORD *)&this->mBindings[1].value._anon_0._anon_0.f41 = 0LL;
  *(_QWORD *)&this->mBindings[1].value._anon_0._anon_0.f32 = 0LL;
  *(_QWORD *)&this->mBindings[1].value._anon_0._anon_0.f13 = 0LL;
  *(_QWORD *)&this->mBindings[1].value._anon_0._anon_0.f43 = 0LL;
  *(_QWORD *)&this->mBindings[1].value._anon_0._anon_0.f24 = 0LL;
  this->mBindings[1].value._anon_0.arr[0] = 1.0;
  this->mBindings[1].isDirty = 1;
  this->mBindings[1].uniformID = -2;
  this->mBindings[1].value._anon_0.arr[5] = 1.0;
  this->mBindings[1].value._anon_0.arr[10] = 1.0;
  this->mBindings[1].value._anon_0.arr[15] = 1.0;
  this->mBindings[1].value.dirty = 1;
  *(_QWORD *)&this->mBindings[2].value._anon_0._anon_0.f21 = 0LL;
  *(_QWORD *)&this->mBindings[2].value._anon_0._anon_0.f41 = 0LL;
  *(_QWORD *)&this->mBindings[2].value._anon_0._anon_0.f32 = 0LL;
  *(_QWORD *)&this->mBindings[2].value._anon_0._anon_0.f13 = 0LL;
  *(_QWORD *)&this->mBindings[2].value._anon_0._anon_0.f43 = 0LL;
  *(_QWORD *)&this->mBindings[2].value._anon_0._anon_0.f24 = 0LL;
  this->mBindings[2].value._anon_0.arr[0] = 1.0;
  this->mBindings[2].isDirty = 1;
  this->mBindings[2].uniformID = -2;
  this->mBindings[2].value._anon_0.arr[5] = 1.0;
  this->mBindings[2].value._anon_0.arr[10] = 1.0;
  this->mBindings[2].value._anon_0.arr[15] = 1.0;
  this->mBindings[2].value.dirty = 1;
  *(_QWORD *)&this->mBindings[3].value._anon_0._anon_0.f21 = 0LL;
  *(_QWORD *)&this->mBindings[3].value._anon_0._anon_0.f41 = 0LL;
  *(_QWORD *)&this->mBindings[3].value._anon_0._anon_0.f32 = 0LL;
  *(_QWORD *)&this->mBindings[3].value._anon_0._anon_0.f13 = 0LL;
  *(_QWORD *)&this->mBindings[3].value._anon_0._anon_0.f43 = 0LL;
  *(_QWORD *)&this->mBindings[3].value._anon_0._anon_0.f24 = 0LL;
  this->mBindings[3].value._anon_0.arr[0] = 1.0;
  this->mBindings[3].isDirty = 1;
  this->mBindings[3].uniformID = -2;
  this->mBindings[3].value._anon_0.arr[5] = 1.0;
  this->mBindings[3].value._anon_0.arr[10] = 1.0;
  this->mBindings[3].value._anon_0.arr[15] = 1.0;
  this->mBindings[3].value.dirty = 1;
  this->bonesLocation = -1;
  this->pixelShader = 0;
  this->vertexShader = 0;
  this->fullProgram = 0;
}
// 6608A0: using guessed type void *off_6608A0;

//----- (001CE0D8) --------------------------------------------------------
void __fastcall BuildPixelSource(unsigned int flags)
{
  unsigned int v2; // r10
  bool v3; // zf
  unsigned int v4; // r11
  bool v5; // zf
  _BOOL4 v6; // r0
  OSDeviceChip v7; // [sp+0h] [bp-230h]
  unsigned __int8 s[512]; // [sp+10h] [bp-220h] BYREF

  v7 = OS_SystemChip();
  snprintf(s, 0x200u, "precision mediump float;");
  strcat((char *)&pixelSrc, (const char *)s);
  if ( (flags & 0x20) != 0 )
  {
    snprintf(s, 0x200u, "uniform sampler2D Diffuse;");
    strcat((char *)&pixelSrc, (const char *)s);
    snprintf(s, 0x200u, "varying mediump vec2 Out_Tex0;");
    strcat((char *)&pixelSrc, (const char *)s);
  }
  if ( (flags & 0x1000040) != 0 )
  {
    snprintf(s, 0x200u, "uniform sampler2D EnvMap;");
    strcat((char *)&pixelSrc, (const char *)s);
    snprintf(s, 0x200u, "uniform lowp float EnvMapCoefficient;");
    strcat((char *)&pixelSrc, (const char *)s);
    if ( (flags & 0x40) != 0 )
      snprintf(s, 0x200u, "varying mediump vec2 Out_Tex1;");
    else
      snprintf(s, 0x200u, "varying mediump vec3 Out_Refl;");
  }
  else
  {
    if ( (flags & 0x10000) == 0 )
      goto LABEL_10;
    snprintf(s, 0x200u, "uniform sampler2D EnvMap;");
    strcat((char *)&pixelSrc, (const char *)s);
    snprintf(s, 0x200u, "uniform float DetailTiling;");
  }
  strcat((char *)&pixelSrc, (const char *)s);
LABEL_10:
  if ( (flags & 0x400) != 0 )
  {
    snprintf(s, 0x200u, "varying mediump float Out_FogAmt;");
    strcat((char *)&pixelSrc, (const char *)s);
    snprintf(s, 0x200u, "uniform lowp vec3 FogColor;");
    strcat((char *)&pixelSrc, (const char *)s);
  }
  if ( (flags & 0x12) != 0 )
  {
    snprintf(s, 0x200u, "varying lowp vec4 Out_Color;");
    strcat((char *)&pixelSrc, (const char *)s);
  }
  v2 = flags & 0x10001C0;
  v3 = (flags & 0x2000) == 0;
  if ( (flags & 0x2000) != 0 )
    v3 = v2 == 0;
  if ( !v3 )
  {
    snprintf(s, 0x200u, "varying lowp vec3 Out_Spec;");
    strcat((char *)&pixelSrc, (const char *)s);
  }
  if ( (flags & 4) != 0 )
  {
    snprintf(s, 0x200u, "uniform lowp float AlphaModulate;");
    strcat((char *)&pixelSrc, (const char *)s);
  }
  v4 = flags & 0x80000;
  if ( (flags & 0x80000) != 0 )
  {
    snprintf(s, 0x200u, "varying mediump vec2 Out_WaterDetail;");
    strcat((char *)&pixelSrc, (const char *)s);
    snprintf(s, 0x200u, "varying mediump vec2 Out_WaterDetail2;");
    strcat((char *)&pixelSrc, (const char *)s);
    snprintf(s, 0x200u, "varying mediump float Out_WaterAlphaBlend;");
    strcat((char *)&pixelSrc, (const char *)s);
  }
  snprintf(s, 0x200u, "void main()");
  strcat((char *)&pixelSrc, (const char *)s);
  snprintf(s, 0x200u, (const unsigned __int8 *)&dword_1CE884);
  strcat((char *)&pixelSrc, (const char *)s);
  snprintf(s, 0x200u, "lowp vec4 fcolor;");
  strcat((char *)&pixelSrc, (const char *)s);
  if ( (flags & 0x20) != 0 )
  {
    if ( (flags & 0x800) != 0 )
    {
      snprintf(s, 0x200u, "lowp vec4 diffuseColor = texture2D(Diffuse, Out_Tex0, -1.5);");
    }
    else if ( RQCaps[14] )
    {
      snprintf(s, 0x200u, "lowp vec4 diffuseColor = texture2D(Diffuse, Out_Tex0);");
    }
    else
    {
      snprintf(s, 0x200u, "lowp vec4 diffuseColor = texture2D(Diffuse, Out_Tex0, -0.5);");
    }
    strcat((char *)&pixelSrc, (const char *)s);
    snprintf(s, 0x200u, "fcolor = diffuseColor;");
    strcat((char *)&pixelSrc, (const char *)s);
    if ( (flags & 0x12) != 0 )
    {
      if ( (flags & 0x10000) != 0 )
      {
        if ( !v4 )
        {
          snprintf(
            s,
            0x200u,
            "fcolor *= vec4(Out_Color.xyz * texture2D(EnvMap, Out_Tex0.xy * DetailTiling, -0.5).xyz * 2.0, Out_Color.w);");
LABEL_43:
          strcat((char *)&pixelSrc, (const char *)s);
          if ( (flags & 0x40) == 0 )
            goto LABEL_45;
          goto LABEL_44;
        }
        snprintf(
          s,
          0x200u,
          "float waterDetail = texture2D(EnvMap, Out_WaterDetail, -1.0).x + texture2D(EnvMap, Out_WaterDetail2, -1.0).x;");
        strcat((char *)&pixelSrc, (const char *)s);
        snprintf(s, 0x200u, "fcolor *= vec4(Out_Color.xyz * waterDetail * 1.1, Out_Color.w);");
        strcat((char *)&pixelSrc, (const char *)s);
LABEL_41:
        snprintf(s, 0x200u, "fcolor.a += Out_WaterAlphaBlend;");
        goto LABEL_43;
      }
      snprintf(s, 0x200u, "fcolor *= Out_Color;");
      strcat((char *)&pixelSrc, (const char *)s);
    }
    if ( !v4 )
    {
      if ( (flags & 0x40) == 0 )
        goto LABEL_45;
LABEL_44:
      snprintf(s, 0x200u, "fcolor.xyz = mix(fcolor.xyz, texture2D(EnvMap, Out_Tex1).xyz, EnvMapCoefficient);");
      strcat((char *)&pixelSrc, (const char *)s);
      goto LABEL_45;
    }
    goto LABEL_41;
  }
  if ( (flags & 0x12) != 0 )
    snprintf(s, 0x200u, "fcolor = Out_Color;");
  else
    snprintf(s, 0x200u, "fcolor = 0.0;");
  strcat((char *)&pixelSrc, (const char *)s);
  if ( (flags & 0x40) != 0 )
    goto LABEL_44;
LABEL_45:
  if ( (flags & 0x1000000) != 0 )
  {
    snprintf(s, 0x200u, "vec2 ReflPos = normalize(Out_Refl.xy) * (Out_Refl.z * 0.5 + 0.5);");
    strcat((char *)&pixelSrc, (const char *)s);
    snprintf(s, 0x200u, "ReflPos = (ReflPos * vec2(0.5,0.5)) + vec2(0.5,0.5);");
    strcat((char *)&pixelSrc, (const char *)s);
    snprintf(s, 0x200u, "lowp vec4 ReflTexture =  texture2D(EnvMap, ReflPos);");
    strcat((char *)&pixelSrc, (const char *)s);
    snprintf(s, 0x200u, "fcolor.xyz = mix(fcolor.xyz,ReflTexture.xyz, EnvMapCoefficient);");
    strcat((char *)&pixelSrc, (const char *)s);
    snprintf(s, 0x200u, "fcolor.w += ReflTexture.b * 0.125;");
    strcat((char *)&pixelSrc, (const char *)s);
  }
  v5 = v2 == 0;
  v6 = RQCaps[8];
  if ( v2 )
    v5 = (flags & 0x2000) == 0;
  if ( !v5 && !RQCaps[8] )
  {
    snprintf(s, 0x200u, "fcolor.xyz += Out_Spec;");
    strcat((char *)&pixelSrc, (const char *)s);
    v6 = RQCaps[8];
  }
  if ( !v6 && (flags & 0x400) != 0 )
  {
    snprintf(s, 0x200u, "fcolor.xyz = mix(fcolor.xyz, FogColor, Out_FogAmt);");
    strcat((char *)&pixelSrc, (const char *)s);
  }
  if ( (flags & 0x4000000) != 0 )
  {
    snprintf(s, 0x200u, "fcolor.xyz += fcolor.xyz * 0.5;");
    strcat((char *)&pixelSrc, (const char *)s);
  }
  snprintf(s, 0x200u, "gl_FragColor = fcolor;");
  strcat((char *)&pixelSrc, (const char *)s);
  if ( flags << 31 )
  {
    snprintf(s, 0x200u, "/*ATBEGIN*/");
    strcat((char *)&pixelSrc, (const char *)s);
    if ( v7 == OSDC_Tegra3 && (flags & 0x20) != 0 )
    {
      if ( (flags & 0x800) != 0 )
      {
        snprintf(s, 0x200u, "if (diffuseColor.a < 0.8) { discard; }");
      }
      else if ( (flags & 0x200) != 0 )
      {
        snprintf(s, 0x200u, "gl_FragColor.a = Out_Color.a;");
        strcat((char *)&pixelSrc, (const char *)s);
        snprintf(s, 0x200u, "if (diffuseColor.a < 0.5) { discard; }");
      }
      else
      {
        snprintf(s, 0x200u, "if (diffuseColor.a < 0.2) { discard; }");
      }
    }
    else if ( (flags & 0x800) != 0 )
    {
      snprintf(s, 0x200u, "if (gl_FragColor.a < 0.8) { discard; }");
    }
    else if ( (flags & 0x200) != 0 )
    {
      snprintf(s, 0x200u, "if (gl_FragColor.a < 0.5) { discard; }");
      strcat((char *)&pixelSrc, (const char *)s);
      snprintf(s, 0x200u, "gl_FragColor.a = Out_Color.a;");
    }
    else
    {
      snprintf(s, 0x200u, "if (gl_FragColor.a < 0.2) { discard; }");
    }
    strcat((char *)&pixelSrc, (const char *)s);
    snprintf(s, 0x200u, "/*ATEND*/");
    strcat((char *)&pixelSrc, (const char *)s);
  }
  if ( (flags & 4) != 0 )
  {
    snprintf(s, 0x200u, "gl_FragColor.a *= AlphaModulate;");
    strcat((char *)&pixelSrc, (const char *)s);
  }
  snprintf(s, 0x200u, (const unsigned __int8 *)&off_1CE984);
  strcat((char *)&pixelSrc, (const char *)s);
}
// 1CE884: using guessed type int dword_1CE884;
// 1CE984: using guessed type void *off_1CE984;

//----- (001CE990) --------------------------------------------------------
void __fastcall BuildVertexSource(unsigned int flags)
{
  Int32 MobileEffectSetting; // r0
  unsigned int v3; // r9
  const char *v4; // r0
  __int64 v5; // d16
  Int32 v6; // r0
  _BOOL4 v7; // r0
  const char *v8; // r2
  unsigned __int8 v9[512]; // [sp+28h] [bp-428h] BYREF
  unsigned __int8 s[8]; // [sp+228h] [bp-228h] BYREF
  int16 *p_m_nextModelOnCd; // [sp+230h] [bp-220h]

  snprintf(s, 0x200u, "#version 100\n");
  strcat((char *)&vertexSrc, (const char *)s);
  snprintf(s, 0x200u, "precision highp float;");
  strcat((char *)&vertexSrc, (const char *)s);
  snprintf(s, 0x200u, "uniform mat4 ProjMatrix;");
  strcat((char *)&vertexSrc, (const char *)s);
  snprintf(s, 0x200u, "uniform mat4 ViewMatrix;");
  strcat((char *)&vertexSrc, (const char *)s);
  snprintf(s, 0x200u, "uniform mat4 ObjMatrix;");
  strcat((char *)&vertexSrc, (const char *)s);
  if ( (flags & 2) != 0 )
  {
    snprintf(s, 0x200u, "uniform lowp vec3 AmbientLightColor;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "uniform lowp vec4 MaterialEmissive;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "uniform lowp vec4 MaterialAmbient;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "uniform lowp vec4 MaterialDiffuse;");
    strcat((char *)&vertexSrc, (const char *)s);
    if ( (flags & 0x2000) != 0 )
    {
      snprintf(s, 0x200u, "uniform lowp vec3 DirLightDiffuseColor;");
      strcat((char *)&vertexSrc, (const char *)s);
      snprintf(s, 0x200u, "uniform vec3 DirLightDirection;");
      strcat((char *)&vertexSrc, (const char *)s);
      MobileEffectSetting = GetMobileEffectSetting();
      if ( (flags & 0x1180) != 0 && MobileEffectSetting == 3 )
      {
        snprintf(s, 0x200u, "uniform vec3 DirBackLightDirection;");
        strcat((char *)&vertexSrc, (const char *)s);
      }
    }
    if ( (flags & 0x4000) != 0 )
    {
      snprintf(s, 0x200u, "uniform lowp vec3 DirLight2DiffuseColor;");
      strcat((char *)&vertexSrc, (const char *)s);
      snprintf(s, 0x200u, "uniform vec3 DirLight2Direction;");
      strcat((char *)&vertexSrc, (const char *)s);
    }
    if ( (flags & 0x8000) != 0 )
    {
      snprintf(s, 0x200u, "uniform lowp vec3 DirLight3DiffuseColor;");
      strcat((char *)&vertexSrc, (const char *)s);
      snprintf(s, 0x200u, "uniform vec3 DirLight3Direction;");
      strcat((char *)&vertexSrc, (const char *)s);
    }
  }
  snprintf(s, 0x200u, "attribute vec3 Position;");
  strcat((char *)&vertexSrc, (const char *)s);
  snprintf(s, 0x200u, "attribute vec3 Normal;");
  strcat((char *)&vertexSrc, (const char *)s);
  if ( (flags & 0x20) != 0 )
  {
    if ( (flags & 0x40000) != 0 )
      snprintf(s, 0x200u, "attribute vec4 TexCoord0;");
    else
      snprintf(s, 0x200u, "attribute vec2 TexCoord0;");
    strcat((char *)&vertexSrc, (const char *)s);
  }
  snprintf(s, 0x200u, "attribute vec4 GlobalColor;");
  strcat((char *)&vertexSrc, (const char *)s);
  if ( (flags & 0x180) != 0 )
  {
    snprintf(s, 0x200u, "attribute vec4 BoneWeight;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "attribute vec4 BoneIndices;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "uniform highp vec4 Bones[%d];", 3 * RQMaxBones);
    strcat((char *)&vertexSrc, (const char *)s);
  }
  if ( (flags & 0x20) != 0 )
  {
    snprintf(s, 0x200u, "varying mediump vec2 Out_Tex0;");
    strcat((char *)&vertexSrc, (const char *)s);
  }
  if ( (flags & 0x2000000) != 0 )
  {
    snprintf(s, 0x200u, "uniform mat3 NormalMatrix;");
    strcat((char *)&vertexSrc, (const char *)s);
  }
  if ( (flags & 0x1000040) != 0 )
  {
    if ( (flags & 0x40) != 0 )
      snprintf(s, 0x200u, "varying mediump vec2 Out_Tex1;");
    else
      snprintf(s, 0x200u, "varying mediump vec3 Out_Refl;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "uniform lowp float EnvMapCoefficient;");
    strcat((char *)&vertexSrc, (const char *)s);
  }
  if ( (flags & 0x18807C0) != 0 )
  {
    snprintf(s, 0x200u, "uniform vec3 CameraPosition;");
    strcat((char *)&vertexSrc, (const char *)s);
  }
  if ( (flags & 0x400) != 0 )
  {
    snprintf(s, 0x200u, "varying mediump float Out_FogAmt;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "uniform vec3 FogDistances;");
    strcat((char *)&vertexSrc, (const char *)s);
  }
  if ( (flags & 0x80000) != 0 )
  {
    snprintf(s, 0x200u, "uniform vec3 WaterSpecs;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "varying mediump vec2 Out_WaterDetail;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "varying mediump vec2 Out_WaterDetail2;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "varying mediump float Out_WaterAlphaBlend;");
    strcat((char *)&vertexSrc, (const char *)s);
  }
  if ( (flags & 0x100000) != 0 )
  {
    snprintf(s, 0x200u, "attribute vec4 Color2;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "uniform lowp float ColorInterp;");
    strcat((char *)&vertexSrc, (const char *)s);
  }
  if ( (flags & 0x12) != 0 )
  {
    snprintf(s, 0x200u, "varying lowp vec4 Out_Color;");
    strcat((char *)&vertexSrc, (const char *)s);
  }
  if ( (flags & 0x10001C0) != 0 && (flags & 0x2000) != 0 )
  {
    snprintf(s, 0x200u, "varying lowp vec3 Out_Spec;");
    strcat((char *)&vertexSrc, (const char *)s);
  }
  snprintf(s, 0x200u, "void main() {");
  strcat((char *)&vertexSrc, (const char *)s);
  if ( (flags & 0x180) != 0 )
  {
    snprintf(s, 0x200u, "\tivec4 BlendIndexArray = ivec4(BoneIndices);");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "\tmat4 BoneToLocal;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "\tBoneToLocal[0] = Bones[BlendIndexArray.x*3] * BoneWeight.x;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "\tBoneToLocal[1] = Bones[BlendIndexArray.x*3+1] * BoneWeight.x;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "\tBoneToLocal[2] = Bones[BlendIndexArray.x*3+2] * BoneWeight.x;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "\tBoneToLocal[3] = vec4(0.0,0.0,0.0,1.0);");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "\tBoneToLocal[0] += Bones[BlendIndexArray.y*3] * BoneWeight.y;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "\tBoneToLocal[1] += Bones[BlendIndexArray.y*3+1] * BoneWeight.y;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "\tBoneToLocal[2] += Bones[BlendIndexArray.y*3+2] * BoneWeight.y;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "\tBoneToLocal[0] += Bones[BlendIndexArray.z*3] * BoneWeight.z;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "\tBoneToLocal[1] += Bones[BlendIndexArray.z*3+1] * BoneWeight.z;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "\tBoneToLocal[2] += Bones[BlendIndexArray.z*3+2] * BoneWeight.z;");
    strcat((char *)&vertexSrc, (const char *)s);
    v3 = flags & 0x1000040;
    if ( (flags & 0x100) != 0 )
    {
      snprintf(s, 0x200u, "\tBoneToLocal[0] += Bones[BlendIndexArray.w*3] * BoneWeight.w;");
      strcat((char *)&vertexSrc, (const char *)s);
      snprintf(s, 0x200u, "\tBoneToLocal[1] += Bones[BlendIndexArray.w*3+1] * BoneWeight.w;");
      strcat((char *)&vertexSrc, (const char *)s);
      snprintf(s, 0x200u, "\tBoneToLocal[2] += Bones[BlendIndexArray.w*3+2] * BoneWeight.w;");
      strcat((char *)&vertexSrc, (const char *)s);
    }
    snprintf(s, 0x200u, "\tvec4 WorldPos = ObjMatrix * (vec4(Position,1.0) * BoneToLocal);");
    strcat((char *)&vertexSrc, (const char *)s);
  }
  else
  {
    snprintf(s, 0x200u, "\tvec4 WorldPos = ObjMatrix * vec4(Position,1.0);");
    strcat((char *)&vertexSrc, (const char *)s);
    v3 = flags & 0x1000040;
  }
  if ( (flags & 0x800000) != 0 )
  {
    snprintf(s, 0x200u, "    vec3 ReflVector = WorldPos.xyz - CameraPosition.xyz;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "\tvec3 ReflPos = normalize(ReflVector);");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "    ReflPos.xy = normalize(ReflPos.xy) * (ReflPos.z * 0.5 + 0.5);");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "\tgl_Position = vec4(ReflPos.xy, length(ReflVector) * 0.002, 1.0);");
  }
  else
  {
    snprintf(s, 0x200u, "\tvec4 ViewPos = ViewMatrix * WorldPos;");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "\tgl_Position = ProjMatrix * ViewPos;");
  }
  strcat((char *)&vertexSrc, (const char *)s);
  if ( (flags & 2) != 0 )
  {
    if ( (flags & 0x201) == 513 && (flags & 0xE000) != 0 )
    {
      snprintf(s, 0x200u, "vec3 WorldNormal = normalize(vec3(WorldPos.xy - CameraPosition.xy, 0.0001)) * 0.85;");
    }
    else if ( (flags & 0x180) != 0 )
    {
      snprintf(s, 0x200u, "vec3 WorldNormal = mat3(ObjMatrix) * (Normal * mat3(BoneToLocal));");
    }
    else
    {
      snprintf(s, 0x200u, "vec3 WorldNormal = (ObjMatrix * vec4(Normal,0.0)).xyz;");
    }
    goto LABEL_56;
  }
  if ( v3 )
  {
    snprintf(s, 0x200u, "vec3 WorldNormal = vec3(0.0, 0.0, 0.0);");
LABEL_56:
    strcat((char *)&vertexSrc, (const char *)s);
  }
  if ( !RQCaps[8] && (flags & 0x400) != 0 )
  {
    snprintf(
      s,
      0x200u,
      "Out_FogAmt = clamp((length(WorldPos.xyz - CameraPosition.xyz) - FogDistances.x) * FogDistances.z, 0.0, 0.90);");
    strcat((char *)&vertexSrc, (const char *)s);
  }
  if ( (flags & 0x20) != 0 )
  {
    if ( (flags & 0x40000) != 0 )
    {
      snprintf(v9, 0x100u, "TexCoord0.xy / TexCoord0.w");
    }
    else if ( (flags & 0x20000) != 0 )
    {
      snprintf(v9, 0x100u, "TexCoord0 / 512.0");
    }
    else
    {
      snprintf(v9, 0x100u, "TexCoord0");
    }
    if ( (flags & 0x2000000) != 0 )
      snprintf(s, 0x200u, "Out_Tex0 = (NormalMatrix * vec3(%s, 1.0)).xy;", (const char *)v9);
    else
      snprintf(s, 0x200u, "Out_Tex0 = %s;", (const char *)v9);
    strcat((char *)&vertexSrc, (const char *)s);
  }
  if ( v3 )
  {
    snprintf(s, 0x200u, "vec3 reflVector = normalize(WorldPos.xyz - CameraPosition.xyz);");
    strcat((char *)&vertexSrc, (const char *)s);
    snprintf(s, 0x200u, "reflVector = reflVector - 2.0 * dot(reflVector, WorldNormal) * WorldNormal;");
    strcat((char *)&vertexSrc, (const char *)s);
    if ( (flags & 0x1000000) != 0 )
      snprintf(s, 0x200u, "Out_Refl = reflVector;");
    else
      snprintf(s, 0x200u, "Out_Tex1 = vec2(length(reflVector.xy), (reflVector.z * 0.5) + 0.25);");
    strcat((char *)&vertexSrc, (const char *)s);
  }
  if ( (flags & 0x100000) != 0 )
  {
    snprintf(s, 0x200u, "lowp vec4 InterpColor = mix(GlobalColor, Color2, ColorInterp);");
    strcat((char *)&vertexSrc, (const char *)s);
    v4 = "InterpColor";
  }
  else
  {
    v4 = "GlobalColor";
  }
  v5 = *(_QWORD *)v4;
  p_m_nextModelOnCd = &CStreaming::ms_aInfoForModel[4252].m_nextModelOnCd;
  *(_QWORD *)s = v5;
  if ( (flags & 2) != 0 )
  {
    snprintf(v9, 0x200u, "vec3 Out_LightingColor;");
    strcat((char *)&vertexSrc, (const char *)v9);
    if ( (flags & 8) != 0 )
    {
      if ( (flags & 0x200) != 0 )
        snprintf(v9, 0x200u, "Out_LightingColor = AmbientLightColor * MaterialAmbient.xyz * 1.5;");
      else
        snprintf(v9, 0x200u, "Out_LightingColor = AmbientLightColor * MaterialAmbient.xyz + %s.xyz;", (const char *)s);
    }
    else
    {
      snprintf(v9, 0x200u, "Out_LightingColor = AmbientLightColor * MaterialAmbient.xyz + MaterialEmissive.xyz;");
    }
    strcat((char *)&vertexSrc, (const char *)v9);
    if ( (flags & 0xE000) != 0 )
    {
      if ( (flags & 0x2000) != 0 )
      {
        v6 = GetMobileEffectSetting();
        if ( (flags & 0x1180) != 0 && v6 == 3 )
          snprintf(
            v9,
            0x200u,
            "Out_LightingColor += (max(dot(DirLightDirection, WorldNormal), 0.0) + max(dot(DirBackLightDirection, WorldNo"
            "rmal), 0.0)) * DirLightDiffuseColor;");
        else
          snprintf(
            v9,
            0x200u,
            "Out_LightingColor += max(dot(DirLightDirection, WorldNormal), 0.0) * DirLightDiffuseColor;");
        strcat((char *)&vertexSrc, (const char *)v9);
        if ( (flags & 0x4000) == 0 )
        {
LABEL_87:
          if ( (flags & 0x8000) == 0 )
            goto LABEL_89;
          goto LABEL_88;
        }
      }
      else if ( (flags & 0x4000) == 0 )
      {
        goto LABEL_87;
      }
      snprintf(
        v9,
        0x200u,
        "Out_LightingColor += max(dot(DirLight2Direction, WorldNormal), 0.0) * DirLight2DiffuseColor;");
      strcat((char *)&vertexSrc, (const char *)v9);
      if ( (flags & 0x8000) != 0 )
      {
LABEL_88:
        snprintf(
          v9,
          0x200u,
          "Out_LightingColor += max(dot(DirLight3Direction, WorldNormal), 0.0) * DirLight3DiffuseColor;");
        strcat((char *)&vertexSrc, (const char *)v9);
      }
    }
  }
LABEL_89:
  if ( (flags & 0x12) != 0 )
  {
    if ( (flags & 2) != 0 )
    {
      if ( (flags & 0x10) != 0 )
        snprintf(
          v9,
          0x200u,
          "Out_Color = vec4((Out_LightingColor.xyz + %s.xyz * 1.5) * MaterialDiffuse.xyz, (MaterialAmbient.w) * %s.w);",
          (const char *)s,
          (const char *)s);
      else
        snprintf(
          v9,
          0x200u,
          "Out_Color = vec4(Out_LightingColor * MaterialDiffuse.xyz, MaterialAmbient.w * %s.w);",
          (const char *)s);
      strcat((char *)&vertexSrc, (const char *)v9);
      snprintf(v9, 0x200u, "Out_Color = clamp(Out_Color, 0.0, 1.0);");
      strcat((char *)&vertexSrc, (const char *)v9);
    }
    else
    {
      snprintf(v9, 0x200u, "Out_Color = %s;", (const char *)s);
      strcat((char *)&vertexSrc, (const char *)v9);
    }
  }
  v7 = RQCaps[8];
  if ( RQCaps[8] )
    v7 = 1;
  if ( !v7 && (flags & 0x2000) != 0 )
  {
    if ( v3 )
    {
      v8 = "float specAmt = max(pow(dot(reflVector, DirLightDirection), %.1f), 0.0) * EnvMapCoefficient * 2.0;";
    }
    else
    {
      if ( (flags & 0x180) == 0 )
        goto LABEL_107;
      snprintf(v9, 0x200u, "vec3 reflVector = normalize(WorldPos.xyz - CameraPosition.xyz);");
      strcat((char *)&vertexSrc, (const char *)v9);
      snprintf(v9, 0x200u, "reflVector = reflVector - 2.0 * dot(reflVector, WorldNormal) * WorldNormal;");
      strcat((char *)&vertexSrc, (const char *)v9);
      v8 = "float specAmt = max(pow(dot(reflVector, DirLightDirection), %.1f), 0.0) * 0.125;";
    }
    snprintf(v9, 0x200u, (const unsigned __int8 *)v8);
    strcat((char *)&vertexSrc, (const char *)v9);
    snprintf(v9, 0x200u, "Out_Spec = specAmt * DirLightDiffuseColor;");
    strcat((char *)&vertexSrc, (const char *)v9);
  }
LABEL_107:
  if ( (flags & 0x80000) != 0 )
  {
    snprintf(v9, 0x200u, "Out_WaterDetail = (Out_Tex0 * 4.0) + vec2(WaterSpecs.x * -0.3, WaterSpecs.x * 0.21);");
    strcat((char *)&vertexSrc, (const char *)v9);
    snprintf(v9, 0x200u, "Out_WaterDetail2 = (Out_Tex0 * -8.0) + vec2(WaterSpecs.x * 0.12, WaterSpecs.x * -0.05);");
    strcat((char *)&vertexSrc, (const char *)v9);
    snprintf(v9, 0x200u, "Out_WaterAlphaBlend = distance(WorldPos.xy, CameraPosition.xy) * WaterSpecs.y;");
    strcat((char *)&vertexSrc, (const char *)v9);
  }
  snprintf(s, 0x200u, (const unsigned __int8 *)&off_1CF9AC);
  strcat((char *)&vertexSrc, (const char *)s);
}
// 1CF9AC: using guessed type void *off_1CF9AC;

//----- (001CF9B8) --------------------------------------------------------
bool __fastcall RQShader::BuildSource(
        unsigned int flags,
        const unsigned __int8 **pixelSource,
        const unsigned __int8 **vertexSource)
{
  bool result; // r0

  vertexSrc.shaderSrc[0] = 0;
  pixelSrc.shaderSrc[0] = 0;
  BuildPixelSource(flags);
  BuildVertexSource(flags);
  *pixelSource = (const unsigned __int8 *)&pixelSrc;
  result = 1;
  *vertexSource = (const unsigned __int8 *)&vertexSrc;
  return result;
}

//----- (001CFA00) --------------------------------------------------------
GLenum __fastcall GLFactorFromRQFactor(RQBlendFactor factor)
{
  if ( (unsigned int)factor <= RBF_InvDstColor )
    return dword_5EC530[factor];
  else
    return 0;
}
// 5EC530: using guessed type _DWORD dword_5EC530[10];

//----- (001CFA18) --------------------------------------------------------
GLenum __fastcall GLDepthFuncFromRQ(RQDepthFunc func)
{
  if ( (unsigned int)func <= RDF_Always )
    return func + 512;
  else
    return 519;
}

//----- (001CFA26) --------------------------------------------------------
GLenum __fastcall GLWOFromRQ(RQWindingOrder order)
{
  GLenum v1; // r1

  v1 = 2305;
  if ( order == WO_CW )
    v1 = 2304;
  if ( order == WO_CCW )
    return 2305;
  return v1;
}

//----- (001CFA3E) --------------------------------------------------------
void __fastcall RQ_Command_rqSetWindingOrder(unsigned __int8 **qData)
{
  int v1; // r2
  GLenum v2; // r0

  v1 = *(_DWORD *)*qData;
  *qData += 4;
  v2 = 2305;
  if ( v1 == 1 )
    v2 = 2304;
  if ( !v1 )
    v2 = 2305;
  sub_18B200(v2);
}

//----- (001CFA5E) --------------------------------------------------------
void __fastcall RQ_Command_rqEnableBlend(unsigned __int8 **qData)
{
  int v1; // r2

  v1 = *(_DWORD *)*qData;
  *qData += 4;
  if ( v1 )
    sub_194A40(0xBE2u);
  else
    sub_18C4C0(0xBE2u);
}

//----- (001CFA76) --------------------------------------------------------
void __fastcall RQ_Command_rqEnableDepthRead(unsigned __int8 **qData)
{
  int v1; // r2

  v1 = *(_DWORD *)*qData;
  *qData += 4;
  if ( v1 )
    sub_194A40(0xB71u);
  else
    sub_18C4C0(0xB71u);
}

//----- (001CFA8E) --------------------------------------------------------
void __fastcall RQ_Command_rqEnableDepthWrite(unsigned __int8 **qData)
{
  int v1; // r2

  v1 = *(_DWORD *)*qData;
  *qData += 4;
  sub_1909BC(v1 != 0);
}

//----- (001CFAA2) --------------------------------------------------------
void __fastcall RQ_Command_rqSetZBias(unsigned __int8 **qData)
{
  int v1; // r2

  v1 = *(_DWORD *)*qData;
  *qData += 4;
  if ( v1 )
    sub_194A40(0x8037u);
  else
    sub_18C4C0(0x8037u);
}

//----- (001CFABC) --------------------------------------------------------
void __fastcall RQ_Command_rqBlendFunc(unsigned __int8 **qData)
{
  unsigned __int8 *v2; // r3
  unsigned int v3; // r0
  unsigned __int8 *v4; // r1
  GLenum v5; // r0
  GLenum v6; // r1

  v2 = *qData;
  v4 = *qData + 4;
  v3 = *(_DWORD *)*qData;
  *qData = v4;
  if ( v3 > 9 )
    v5 = 0;
  else
    v5 = dword_5EC530[v3];
  v6 = *((_DWORD *)v2 + 1);
  *qData = v2 + 8;
  switch ( v6 )
  {
    case 0u:
    case 1u:
      goto LABEL_5;
    case 2u:
      v6 = 768;
      goto LABEL_5;
    case 3u:
      if ( v5 )
      {
        v6 = 769;
LABEL_5:
        j_glBlendFunc(v5, v6);
      }
      else
      {
        sub_196D18(0, 769, 1, 1);
      }
      return;
    case 4u:
      v6 = 770;
      goto LABEL_5;
    case 5u:
      v6 = 771;
      goto LABEL_5;
    case 6u:
      v6 = 772;
      goto LABEL_5;
    case 7u:
      v6 = 773;
      goto LABEL_5;
    case 8u:
      v6 = 774;
      goto LABEL_5;
    case 9u:
      v6 = 775;
      goto LABEL_5;
    default:
      v6 = 0;
      goto LABEL_5;
  }
}
// 196D18: using guessed type int __fastcall sub_196D18(_DWORD, _DWORD, _DWORD, _DWORD);
// 5EC530: using guessed type _DWORD dword_5EC530[10];

//----- (001CFB50) --------------------------------------------------------
void __fastcall RQ_Command_rqDepthFunc(unsigned __int8 **qData)
{
  unsigned int v1; // r2
  GLenum v2; // r0

  v1 = *(_DWORD *)*qData;
  *qData += 4;
  v2 = 519;
  if ( v1 < 8 )
    v2 = v1 + 512;
  sub_1910D8(v2);
}

//----- (001CFB68) --------------------------------------------------------
void __fastcall es2SetCull(RQCullMode mode)
{
  int v2; // r0
  GLenum v3; // r0

  v2 = cullEnabled;
  if ( mode )
  {
    if ( !cullDisabled == cullEnabled )
      goto LABEL_9;
  }
  else if ( !cullEnabled )
  {
    goto LABEL_9;
  }
  if ( cullEnabled )
  {
    glDisable(0xB44u);
    v2 = 0;
  }
  else
  {
    glEnable(0xB44u);
    v2 = 1;
  }
  cullEnabled = v2;
LABEL_9:
  if ( v2 )
  {
    switch ( mode )
    {
      case RCM_All:
        v3 = 1032;
        goto LABEL_16;
      case RCM_Back:
        v3 = 1029;
        goto LABEL_16;
      case RCM_Front:
        v3 = 1028;
LABEL_16:
        glCullFace(v3);
        break;
    }
  }
  curMode = mode;
}

//----- (001CFBF0) --------------------------------------------------------
void __fastcall RQ_Command_rqSetCull(unsigned __int8 **qData)
{
  RQCullMode v1; // r1

  v1 = *(_DWORD *)*qData;
  *qData += 4;
  es2SetCull(v1);
}

//----- (001CFBFC) --------------------------------------------------------
void __fastcall RQ_Command_rqDisableCull(unsigned __int8 **qData)
{
  int v1; // r1
  int v2; // r2

  v1 = *(_DWORD *)*qData;
  *qData += 4;
  v2 = v1;
  if ( v1 )
    v2 = 1;
  if ( cullDisabled != v2 )
  {
    cullDisabled = v1 != 0;
    if ( curMode )
      es2SetCull(curMode);
  }
}

//----- (001CFC44) --------------------------------------------------------
void __fastcall RQ_Command_rqSetAlphaTest(unsigned __int8 **qData)
{
  unsigned __int8 *v1; // r1
  unsigned __int8 *v2; // r3
  unsigned int v3; // r6
  float v4; // r4
  GLenum v5; // r5
  float v6; // s16

  v1 = *qData;
  v2 = *qData + 8;
  v3 = *(_DWORD *)*qData;
  *qData += 4;
  v4 = *((float *)v1 + 1);
  *qData = v2;
  if ( !RQ_Command_rqSetAlphaTest(char *&)::glAlphaFuncQCOM )
    RQ_Command_rqSetAlphaTest(char *&)::glAlphaFuncQCOM = (PFNGLALPHAFUNCQCOMPROC)eglGetProcAddress("glAlphaFuncQCOM");
  v5 = 519;
  v6 = v4;
  if ( v3 < 8 )
    v5 = v3 + 512;
  if ( v5 != RQ_Command_rqSetAlphaTest(char *&)::curFunc )
  {
    if ( v5 == 512 )
    {
      glDisable(0xBC0u);
      v6 = -1.0;
LABEL_12:
      RQ_Command_rqSetAlphaTest(char *&)::curFunc = v5;
      RQ_Command_rqSetAlphaTest(char *&)::curVal = v6;
      return;
    }
LABEL_11:
    glEnable(0xBC0u);
    RQ_Command_rqSetAlphaTest(char *&)::glAlphaFuncQCOM(v5, v4);
    goto LABEL_12;
  }
  if ( v5 != 512 && RQ_Command_rqSetAlphaTest(char *&)::curVal != v4 )
    goto LABEL_11;
}
// 197658: using guessed type int __fastcall eglGetProcAddress(_DWORD);

//----- (001CFD20) --------------------------------------------------------
GLuint __fastcall ES2ResourceContainer::GetResource(ES2ResourceContainer *this, unsigned int size)
{
  unsigned int numEntries; // lr
  ES2Resource *dataPtr; // r2
  unsigned int i; // r3
  ES2Resource *v5; // r12
  int v6; // r2
  unsigned int resourceSize; // r4
  GLuint id; // r12
  GLuint v10; // r1

  numEntries = this->availableResources.numEntries;
  if ( !numEntries )
    return 0;
  dataPtr = this->availableResources.dataPtr;
  for ( i = 0; i < numEntries; ++i )
  {
    if ( dataPtr[i].resourceSize == size )
    {
      id = dataPtr[i].id;
      this->curSize -= size;
      dataPtr[i] = dataPtr[numEntries - 1];
      --this->availableResources.numEntries;
      return id;
    }
  }
  v5 = this->availableResources.dataPtr;
  v6 = 0;
  while ( 1 )
  {
    resourceSize = v5[v6].resourceSize;
    if ( resourceSize > size && resourceSize <= (3 * size) >> 1 )
      break;
    if ( ++v6 >= numEntries )
      return 0;
  }
  v10 = v5[v6].id;
  this->curSize -= resourceSize;
  v5[v6] = v5[numEntries - 1];
  --this->availableResources.numEntries;
  return v10;
}

//----- (001CFDAE) --------------------------------------------------------
void __fastcall ES2ResourceContainer::PutResource(ES2ResourceContainer *this, GLuint id, unsigned int size)
{
  GLuint v4; // r6
  int maxUnusedSize; // r0
  unsigned int numEntries; // r5
  unsigned int v9; // r0
  int (**v10)(void); // r9
  __int64 v11; // kr00_8
  unsigned int v12; // r5
  unsigned int v13; // r0
  unsigned int numAlloced; // r1
  unsigned int v15; // r11
  ES2Resource *v16; // r0
  ES2Resource *v17; // r9
  ES2Resource *dataPtr; // r10

  v4 = id;
  maxUnusedSize = this->maxUnusedSize;
  if ( maxUnusedSize / 4 <= size )
  {
    ((void (__fastcall *)(ES2ResourceContainer *, GLuint))*this->_vptr$ES2ResourceContainer)(this, id);
  }
  else
  {
    numEntries = this->availableResources.numEntries;
    if ( numEntries )
    {
      if ( this->curSize + size > maxUnusedSize )
      {
        while ( 1 )
        {
          v9 = rand();
          v10 = this->_vptr$ES2ResourceContainer;
          v11 = *(_QWORD *)&this->availableResources.numEntries;
          if ( (v9 & 0x80000000) != 0 )
            v9 = -v9;
          v12 = v9 % (unsigned int)v11;
          this->curSize -= *(_DWORD *)(HIDWORD(v11) + 8 * (v9 % (unsigned int)v11));
          ((void (__fastcall *)(ES2ResourceContainer *, _DWORD))*v10)(
            this,
            *(_DWORD *)(HIDWORD(v11) + 8 * (v9 % (unsigned int)v11) + 4));
          this->availableResources.dataPtr[v12] = this->availableResources.dataPtr[this->availableResources.numEntries
                                                                                 - 1];
          v13 = this->availableResources.numEntries;
          numEntries = v13 - 1;
          this->availableResources.numEntries = v13 - 1;
          if ( v13 == 1 )
            break;
          if ( this->curSize + size <= this->maxUnusedSize )
            goto LABEL_12;
        }
        numEntries = 0;
LABEL_12:
        v4 = id;
      }
    }
    else
    {
      numEntries = 0;
    }
    numAlloced = this->availableResources.numAlloced;
    this->curSize += size;
    if ( numAlloced >= numEntries + 1 )
    {
      dataPtr = this->availableResources.dataPtr;
    }
    else
    {
      v15 = 4 * (numEntries + 1) / 3 + 3;
      v16 = (ES2Resource *)malloc(8 * v15);
      v17 = this->availableResources.dataPtr;
      dataPtr = v16;
      if ( v17 )
      {
        qmemcpy(v16, this->availableResources.dataPtr, 8 * numEntries);
        free(v17);
        numEntries = this->availableResources.numEntries;
      }
      this->availableResources.dataPtr = dataPtr;
      this->availableResources.numAlloced = v15;
    }
    dataPtr[numEntries].resourceSize = size;
    dataPtr[numEntries].id = v4;
    ++this->availableResources.numEntries;
  }
}

//----- (001CFEC2) --------------------------------------------------------
void __fastcall ES2ResourceContainer::Cleanup(ES2ResourceContainer *this)
{
  unsigned int numEntries; // r0
  unsigned int v3; // r6

  numEntries = this->availableResources.numEntries;
  this->curSize = 0;
  if ( numEntries )
  {
    v3 = 0;
    do
      ((void (__fastcall *)(ES2ResourceContainer *, GLuint))*this->_vptr$ES2ResourceContainer)(
        this,
        this->availableResources.dataPtr[v3++].id);
    while ( v3 < this->availableResources.numEntries );
  }
  this->availableResources.numEntries = 0;
}

//----- (001CFEF8) --------------------------------------------------------
void __fastcall ES2ResourceContainer::ES2ResourceContainer(ES2ResourceContainer *this, unsigned int maxSize)
{
  this->availableResources.dataPtr = 0;
  this->availableResources.numAlloced = 0;
  this->availableResources.numEntries = 0;
  this->curSize = 0;
  this->maxUnusedSize = maxSize;
  this->_vptr$ES2ResourceContainer = (int (**)(void))&off_6608C4;
}
// 6608C4: using guessed type void *;

//----- (001CFF18) --------------------------------------------------------
void ES2InitTextures()
{
  int v0; // r0
  int v1; // r1

  v0 = IsLowSpecDevice();
  v1 = 0x400000;
  if ( v0 )
    v1 = 0x100000;
  es2TexPool.maxUnusedSize = v1;
}

//----- (001CFF3C) --------------------------------------------------------
void __fastcall RQ_Command_rqCleanup(unsigned __int8 **qData)
{
  unsigned int v1; // r6

  es2TexPool.curSize = 0;
  if ( es2TexPool.availableResources.numEntries )
  {
    v1 = 0;
    do
      ((void (__fastcall *)(ES2TextureContainer *, GLuint))*es2TexPool._vptr$ES2ResourceContainer)(
        &es2TexPool,
        es2TexPool.availableResources.dataPtr[v1++].id);
    while ( v1 < es2TexPool.availableResources.numEntries );
  }
  es2TexPool.availableResources.numEntries = 0;
}

//----- (001CFF8C) --------------------------------------------------------
RQTextureFormat __fastcall GetES2TargetFormat(RQRenderTarget *forTarget)
{
  RQTargetColorType colorType; // r1
  RQTextureFormat result; // r0

  colorType = forTarget->colorType;
  result = TF_RGBA_8888;
  if ( colorType == TCT_RGB_565 )
    return 2;
  return result;
}

//----- (001CFFA0) --------------------------------------------------------
RQTexture *__fastcall RQTexture::Create(RQTextureFormat f, unsigned int w, unsigned int h, bool mips)
{
  int v8; // r4
  RenderQueue *v9; // r0
  unsigned __int8 *mainWorkPointer; // r2
  RenderQueue *v11; // r0
  RenderQueue *v12; // r5
  __int64 v13; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v15; // r2

  v8 = operator new(0x2Cu);
  *(_DWORD *)(v8 + 4) = w;
  *(_DWORD *)(v8 + 8) = h;
  *(_BYTE *)(v8 + 12) = mips;
  *(_DWORD *)(v8 + 16) = f;
  *(_DWORD *)(v8 + 36) = 0;
  *(_QWORD *)(v8 + 20) = 0x100000001LL;
  *(_QWORD *)(v8 + 28) = 0LL;
  *(_DWORD *)(v8 + 40) = 0;
  *(_DWORD *)v8 = &off_6608DC;
  v9 = renderQueue;
  mainWorkPointer = renderQueue->mainWorkPointer;
  renderQueue->curQueueingCommand = rqInitTexture;
  *(_DWORD *)mainWorkPointer = 19;
  v9->mainWorkPointer += 4;
  v11 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = v8;
  v11->mainWorkPointer += 4;
  v12 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v13 = *(_QWORD *)&v12->mainPointer;
  p_mainPointer = (unsigned int *)&v12->mainPointer;
  __dmb(0xBu);
  do
    v15 = __ldrex(p_mainPointer);
  while ( __strex(v15 + HIDWORD(v13) - v13, p_mainPointer) );
  __dmb(0xBu);
  if ( v12->useMutex )
    OS_MutexRelease(v12->commandMutex);
  if ( !v12->multiThread )
    RenderQueue::Process(v12);
  if ( v12->mainPointer + 1024 > v12->queueEnd )
    RenderQueue::Flush(v12);
  return (RQTexture *)v8;
}
// 6608DC: using guessed type void *;

//----- (001D0098) --------------------------------------------------------
void __fastcall RQTexture::Delete(RQTexture *toDelete)
{
  RenderQueue *v1; // r2
  unsigned __int8 *mainWorkPointer; // r3
  RenderQueue *v3; // r2
  RenderQueue *v4; // r4
  __int64 v5; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v7; // r2

  if ( RQTexture::selected[0] == toDelete )
    RQTexture::selected[0] = 0;
  if ( RQTexture::selected[1] == toDelete )
    RQTexture::selected[1] = 0;
  if ( RQTexture::selected[2] == toDelete )
    RQTexture::selected[2] = 0;
  if ( RQTexture::selected[3] == toDelete )
    RQTexture::selected[3] = 0;
  v1 = renderQueue;
  mainWorkPointer = renderQueue->mainWorkPointer;
  renderQueue->curQueueingCommand = rqDeleteTexture;
  *(_DWORD *)mainWorkPointer = 25;
  v1->mainWorkPointer += 4;
  v3 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = toDelete;
  v3->mainWorkPointer += 4;
  v4 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v5 = *(_QWORD *)&v4->mainPointer;
  p_mainPointer = (unsigned int *)&v4->mainPointer;
  __dmb(0xBu);
  do
    v7 = __ldrex(p_mainPointer);
  while ( __strex(v7 + HIDWORD(v5) - v5, p_mainPointer) );
  __dmb(0xBu);
  if ( v4->useMutex )
    OS_MutexRelease(v4->commandMutex);
  if ( !v4->multiThread )
    RenderQueue::Process(v4);
  if ( v4->mainPointer + 1024 > v4->queueEnd )
    sub_1A148C(v4);
}

//----- (001D01B4) --------------------------------------------------------
void __fastcall RQ_Command_rqInitTexture(unsigned __int8 **qData)
{
  int v1; // r6
  unsigned int TextureSize; // r0
  int v3; // r3
  unsigned int resourceSize; // r4
  GLuint *v5; // r6
  GLuint id; // r5

  v1 = *(_DWORD *)*qData;
  *qData += 4;
  TextureSize = RQTexture::GetTextureSize(*(_DWORD *)(v1 + 4), *(_DWORD *)(v1 + 8), *(RQTextureFormat *)(v1 + 16));
  if ( !es2TexPool.availableResources.numEntries )
  {
LABEL_9:
    *(_DWORD *)(v1 + 40) = 0;
    v5 = (GLuint *)(v1 + 40);
LABEL_12:
    glGenTextures(1, v5);
    id = *v5;
    goto LABEL_13;
  }
  v3 = 0;
  while ( es2TexPool.availableResources.dataPtr[v3].resourceSize != TextureSize )
  {
    if ( ++v3 >= es2TexPool.availableResources.numEntries )
    {
      v3 = 0;
      while ( 1 )
      {
        resourceSize = es2TexPool.availableResources.dataPtr[v3].resourceSize;
        if ( resourceSize > TextureSize && resourceSize <= (3 * TextureSize) >> 1 )
          break;
        if ( ++v3 >= es2TexPool.availableResources.numEntries )
          goto LABEL_9;
      }
      TextureSize = es2TexPool.availableResources.dataPtr[v3].resourceSize;
      break;
    }
  }
  id = es2TexPool.availableResources.dataPtr[v3].id;
  es2TexPool.curSize -= TextureSize;
  es2TexPool.availableResources.dataPtr[v3] = es2TexPool.availableResources.dataPtr[--es2TexPool.availableResources.numEntries];
  *(_DWORD *)(v1 + 40) = id;
  v5 = (GLuint *)(v1 + 40);
  if ( !id )
    goto LABEL_12;
LABEL_13:
  if ( ES2Texture::curActiveTexture != 5 )
  {
    glActiveTexture(0x84C5u);
    ES2Texture::curActiveTexture = 5;
  }
  glBindTexture(0xDE1u, id);
  ES2Texture::boundTextures[5] = id;
  glTexParameteri(0xDE1u, 0x2801u, 9729);
  glTexParameteri(0xDE1u, 0x2800u, 9729);
  glTexParameteri(0xDE1u, 0x2802u, 33071);
  glTexParameteri(0xDE1u, 0x2803u, 33071);
  if ( RQCaps[7] )
    sub_190AA0(0xDE1u, 0x84FEu, 2.0);
}

//----- (001D030C) --------------------------------------------------------
void __fastcall RQ_Command_rqDeleteTexture(unsigned __int8 **qData)
{
  int v2; // r0
  unsigned __int8 *v3; // r2

  v3 = *qData + 4;
  v2 = *(_DWORD *)*qData;
  *qData = v3;
  if ( v2 )
    (*(void (__fastcall **)(int))(*(_DWORD *)v2 + 4))(v2);
}

//----- (001D0324) --------------------------------------------------------
void __fastcall RQ_Command_rqSelectTexture(unsigned __int8 **qData)
{
  unsigned __int8 *v1; // r2
  unsigned __int8 *v2; // r3
  int v3; // lr
  int v4; // r1

  v1 = *qData;
  v2 = *qData + 8;
  v3 = *(_DWORD *)*qData;
  *qData += 4;
  v4 = *((_DWORD *)v1 + 1);
  *qData = v2;
  ES2Texture::activeTextures[v4] = *(_DWORD *)(v3 + 40);
}

//----- (001D0350) --------------------------------------------------------
void __fastcall RQ_Command_rqTextureMipMode(unsigned __int8 **qData)
{
  unsigned __int8 *v1; // r2
  unsigned __int8 *v2; // r3
  int v3; // r4
  int v4; // r5
  GLuint v5; // r4
  GLint v6; // r2

  v1 = *qData;
  v2 = *qData + 8;
  v3 = *(_DWORD *)*qData;
  *qData += 4;
  v4 = *((_DWORD *)v1 + 1);
  *qData = v2;
  v5 = *(_DWORD *)(v3 + 40);
  if ( ES2Texture::curActiveTexture != 5 )
  {
    glActiveTexture(0x84C5u);
    ES2Texture::curActiveTexture = 5;
  }
  glBindTexture(0xDE1u, v5);
  ES2Texture::boundTextures[5] = v5;
  if ( v4 == 2 )
  {
    v6 = 9987;
  }
  else if ( v4 == 1 )
  {
    v6 = 9985;
  }
  else
  {
    if ( v4 )
      return;
    v6 = 9729;
  }
  glTexParameteri(0xDE1u, 0x2801u, v6);
  j_glTexParameteri(0xDE1u, 0x2800u, 9729);
}

//----- (001D03F0) --------------------------------------------------------
void __fastcall RQ_Command_rqTextureAniso(unsigned __int8 **qData)
{
  unsigned __int8 *v1; // r2
  unsigned __int8 *v2; // r3
  int v3; // r4
  int v4; // r5
  GLuint v5; // r4

  v1 = *qData;
  v2 = *qData + 8;
  v3 = *(_DWORD *)*qData;
  *qData += 4;
  v4 = *((_DWORD *)v1 + 1);
  *qData = v2;
  v5 = *(_DWORD *)(v3 + 40);
  if ( ES2Texture::curActiveTexture != 5 )
  {
    glActiveTexture(0x84C5u);
    ES2Texture::curActiveTexture = 5;
  }
  glBindTexture(0xDE1u, v5);
  ES2Texture::boundTextures[5] = v5;
  if ( v4 == 1 )
  {
    sub_190AA0(0xDE1u, 0x84FEu, 4.0);
  }
  else if ( !v4 )
  {
    sub_190AA0(0xDE1u, 0x84FEu, 2.0);
  }
}

//----- (001D0474) --------------------------------------------------------
void __fastcall RQ_Command_rqTextureWrap(unsigned __int8 **qData)
{
  unsigned __int8 *v1; // r2
  unsigned __int8 *v2; // r5
  unsigned __int8 *v3; // r3
  int v4; // r4
  int v5; // r6
  int v6; // r5
  GLuint v7; // r4
  GLint v8; // r2
  GLint v9; // r2

  v1 = *qData;
  v2 = *qData + 8;
  v3 = *qData + 12;
  v4 = *(_DWORD *)*qData;
  *qData += 4;
  v5 = *((_DWORD *)v1 + 1);
  *qData = v2;
  v6 = *((_DWORD *)v1 + 2);
  *qData = v3;
  v7 = *(_DWORD *)(v4 + 40);
  if ( ES2Texture::curActiveTexture != 5 )
  {
    glActiveTexture(0x84C5u);
    ES2Texture::curActiveTexture = 5;
  }
  glBindTexture(0xDE1u, v7);
  ES2Texture::boundTextures[5] = v7;
  if ( v5 )
  {
    if ( v5 != 1 )
      goto LABEL_8;
    v8 = 33071;
  }
  else
  {
    v8 = 10497;
  }
  glTexParameteri(0xDE1u, 0x2802u, v8);
LABEL_8:
  if ( v6 )
  {
    if ( v6 != 1 )
      return;
    v9 = 33071;
  }
  else
  {
    v9 = 10497;
  }
  j_glTexParameteri(0xDE1u, 0x2803u, v9);
}

//----- (001D052C) --------------------------------------------------------
void __fastcall RQ_Command_rqTextureMip(unsigned __int8 **qData)
{
  unsigned __int8 *v1; // r1
  unsigned int v2; // r2
  int v3; // r11
  GLint v4; // r9
  unsigned int v5; // r10
  unsigned __int8 *v6; // r3
  int v7; // r6
  unsigned __int8 *v8; // r1
  unsigned int v9; // r2
  unsigned __int8 *pixels; // r8
  GLuint v11; // r4
  GLsizei v12; // r6
  __int64 v13; // r2
  int v14; // r0
  int height; // r5
  unsigned int v16; // r4
  ES2TexFormatInfo *v17; // r1
  bool v18; // cc
  GLenum type; // r2
  unsigned __int8 *v20; // r4
  int v21; // r0
  int v22; // r1

  v1 = *qData;
  v2 = (unsigned int)(*qData + 19);
  v3 = *(_DWORD *)*qData;
  *qData += 4;
  v4 = *((_DWORD *)v1 + 1);
  *qData = v1 + 8;
  v5 = *((_DWORD *)v1 + 2);
  *qData = v1 + 12;
  v6 = v1 + 16;
  v7 = *((_DWORD *)v1 + 3);
  v8 = (unsigned __int8 *)(v2 & 0xFFFFFFFC);
  *qData = v6;
  if ( v7 )
  {
    v9 = v5;
    pixels = v8;
    if ( (v5 & 3) != 0 )
      v9 = (v5 + 3) & 0xFFFFFFFC;
  }
  else
  {
    *qData = v8;
    v9 = 4;
    pixels = *(unsigned __int8 **)v8;
  }
  *qData = &v8[v9];
  v11 = *(_DWORD *)(v3 + 40);
  if ( ES2Texture::curActiveTexture != 5 )
  {
    glActiveTexture(0x84C5u);
    ES2Texture::curActiveTexture = 5;
  }
  glBindTexture(0xDE1u, v11);
  v12 = 1;
  ES2Texture::boundTextures[5] = v11;
  v13 = *(_QWORD *)(v3 + 4);
  v14 = *(_DWORD *)(v3 + 16);
  height = HIDWORD(v13) >> v4;
  if ( HIDWORD(v13) >> v4 <= 1 )
    height = 1;
  v16 = (unsigned int)v13 >> v4;
  v17 = &formatTable[v14];
  v18 = (unsigned int)v13 >> v4 > 1;
  type = v17->type;
  if ( v18 )
    v12 = v16;
  if ( !(v17->isCompressed << 31) )
  {
    glTexImage2D(0xDE1u, v4, v17->format, v12, height, 0, v17->format, type, pixels);
    return;
  }
  if ( RQCaps[4] )
  {
    switch ( v14 )
    {
      case 7:
        ATCConvertFromDXT1(v12, height, pixels);
        type = 35986;
        goto LABEL_21;
      case 8:
        v20 = (unsigned __int8 *)ATCConvertFromDXT1A(v12, height, pixels);
        v5 *= 2;
        type = 35987;
        break;
      case 9:
        ATCConvertFromDXT3(v12, height, pixels);
        type = 35987;
        goto LABEL_21;
      case 10:
        ATCConvertFromDXT5(v12, height, pixels);
        type = 34798;
        goto LABEL_21;
      default:
        goto LABEL_21;
    }
  }
  else
  {
LABEL_21:
    v20 = pixels;
  }
  if ( !((RQCaps[4] || RQCaps[3]) << 24) && (unsigned int)(*(_DWORD *)(v3 + 16) - 7) <= 3 )
  {
    wrapped_glCompressedTexImage2D(0xDE1u, v4, type, v12, height, v5, v20);
    if ( pixels == v20 )
      return;
LABEL_14:
    j_free(v20);
    return;
  }
  if ( type == 35842 )
  {
    v21 = 8;
    v22 = height;
    if ( height <= 8 )
      v22 = 8;
    if ( v12 > 8 )
      v21 = v12;
    v5 = (unsigned int)(4 * v21 * v22 + 7) >> 3;
  }
  glCompressedTexImage2D(0xDE1u, v4, type, v12, height, 0, v5, v20);
  if ( pixels != v20 )
    goto LABEL_14;
}

//----- (001D0710) --------------------------------------------------------
RQRenderTarget *__fastcall RQRenderTarget::Create(
        unsigned int width,
        unsigned int height,
        RQTargetColorType colorType,
        RQTargetDepthType depthType)
{
  int v8; // r4
  int v9; // r0
  int v10; // r6
  _QWORD *v11; // r2
  RenderQueue *v12; // r0
  unsigned __int8 *mainWorkPointer; // r2
  RenderQueue *v14; // r0
  RenderQueue *v15; // r5
  __int64 v16; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v18; // r2

  v8 = operator new(0x1Cu);
  *(_DWORD *)(v8 + 4) = colorType;
  *(_DWORD *)(v8 + 8) = depthType;
  *(_QWORD *)(v8 + 12) = 0LL;
  *(_QWORD *)(v8 + 20) = 0LL;
  v9 = operator new(0x2Cu);
  v10 = 0;
  *(_BYTE *)(v9 + 12) = 0;
  if ( colorType == TCT_RGB_565 )
    v10 = 2;
  *(_DWORD *)(v9 + 16) = v10;
  *(_DWORD *)v9 = &off_6608DC;
  *(_DWORD *)(v9 + 4) = width;
  v11 = (_QWORD *)(v9 + 20);
  *(_DWORD *)(v9 + 8) = height;
  *(_DWORD *)(v9 + 36) = v8;
  *(_DWORD *)(v9 + 40) = 0;
  *(_DWORD *)v8 = v9;
  v12 = renderQueue;
  *v11 = 0x100000001LL;
  v11[1] = 0LL;
  mainWorkPointer = v12->mainWorkPointer;
  v12->curQueueingCommand = rqTargetCreate;
  *(_DWORD *)mainWorkPointer = 26;
  v12->mainWorkPointer += 4;
  v14 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = v8;
  v14->mainWorkPointer += 4;
  v15 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v16 = *(_QWORD *)&v15->mainPointer;
  p_mainPointer = (unsigned int *)&v15->mainPointer;
  __dmb(0xBu);
  do
    v18 = __ldrex(p_mainPointer);
  while ( __strex(v18 + HIDWORD(v16) - v16, p_mainPointer) );
  __dmb(0xBu);
  if ( v15->useMutex )
    OS_MutexRelease(v15->commandMutex);
  if ( !v15->multiThread )
    RenderQueue::Process(v15);
  if ( v15->mainPointer + 1024 > v15->queueEnd )
    RenderQueue::Flush(v15);
  return (RQRenderTarget *)v8;
}
// 6608DC: using guessed type void *off_6608DC;

//----- (001D0840) --------------------------------------------------------
RQRenderTarget *__fastcall RQRenderTarget::Create(
        unsigned int width,
        unsigned int height,
        RQTargetColorType colorType,
        RQRenderTarget *sharedDepth)
{
  int v8; // r4
  RQTargetDepthType depthType; // r0
  int v10; // r0
  int v11; // r3
  _QWORD *v12; // r2
  RenderQueue *v13; // r0
  unsigned __int8 *mainWorkPointer; // r2
  RenderQueue *v15; // r0
  RenderQueue *v16; // r5
  __int64 v17; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v19; // r2

  v8 = operator new(0x1Cu);
  depthType = sharedDepth->depthType;
  *(_DWORD *)(v8 + 4) = colorType;
  *(_DWORD *)(v8 + 8) = depthType;
  *(_DWORD *)(v8 + 12) = sharedDepth;
  *(_DWORD *)(v8 + 16) = 0;
  *(_DWORD *)(v8 + 20) = 0;
  *(_DWORD *)(v8 + 24) = 0;
  v10 = operator new(0x2Cu);
  v11 = 0;
  *(_BYTE *)(v10 + 12) = 0;
  if ( colorType == TCT_RGB_565 )
    v11 = 2;
  *(_DWORD *)(v10 + 16) = v11;
  *(_DWORD *)v10 = &off_6608DC;
  *(_DWORD *)(v10 + 4) = width;
  v12 = (_QWORD *)(v10 + 20);
  *(_DWORD *)(v10 + 8) = height;
  *(_DWORD *)(v10 + 36) = v8;
  *(_DWORD *)(v10 + 40) = 0;
  *(_DWORD *)v8 = v10;
  v13 = renderQueue;
  *v12 = 0x100000001LL;
  v12[1] = 0LL;
  mainWorkPointer = v13->mainWorkPointer;
  v13->curQueueingCommand = rqTargetCreate;
  *(_DWORD *)mainWorkPointer = 26;
  v13->mainWorkPointer += 4;
  v15 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = v8;
  v15->mainWorkPointer += 4;
  v16 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v17 = *(_QWORD *)&v16->mainPointer;
  p_mainPointer = (unsigned int *)&v16->mainPointer;
  __dmb(0xBu);
  do
    v19 = __ldrex(p_mainPointer);
  while ( __strex(v19 + HIDWORD(v17) - v17, p_mainPointer) );
  __dmb(0xBu);
  if ( v16->useMutex )
    OS_MutexRelease(v16->commandMutex);
  if ( !v16->multiThread )
    RenderQueue::Process(v16);
  if ( v16->mainPointer + 1024 > v16->queueEnd )
    RenderQueue::Flush(v16);
  return (RQRenderTarget *)v8;
}
// 6608DC: using guessed type void *off_6608DC;

//----- (001D0958) --------------------------------------------------------
void __fastcall RQRenderTarget::Select(RQRenderTarget *toSelect, bool force)
{
  RenderQueue *v3; // r2
  unsigned __int8 *mainWorkPointer; // r1
  RenderQueue *v5; // r1
  RenderQueue *v6; // r5
  __int64 v7; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v9; // r2
  RenderQueue *v10; // r1
  unsigned __int8 *v11; // r2
  RenderQueue *v12; // r1
  RenderQueue *v13; // r4
  __int64 v14; // kr08_8
  unsigned int *v15; // r0
  unsigned int v16; // r2
  RenderQueue *v17; // r1
  unsigned __int8 *v18; // r2
  RenderQueue *v19; // r1
  __int64 v20; // kr10_8
  unsigned int *v21; // r0
  unsigned int v22; // r2

  if ( RQRenderTarget::selected != toSelect || force )
  {
    v3 = renderQueue;
    RQRenderTarget::selected = toSelect;
    mainWorkPointer = renderQueue->mainWorkPointer;
    renderQueue->curQueueingCommand = rqTargetSelect;
    *(_DWORD *)mainWorkPointer = 27;
    v3->mainWorkPointer += 4;
    v5 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = toSelect;
    v5->mainWorkPointer += 4;
    v6 = renderQueue;
    if ( renderQueue->useMutex )
      OS_MutexObtain(renderQueue->commandMutex);
    v7 = *(_QWORD *)&v6->mainPointer;
    p_mainPointer = (unsigned int *)&v6->mainPointer;
    __dmb(0xBu);
    do
      v9 = __ldrex(p_mainPointer);
    while ( __strex(v9 + HIDWORD(v7) - v7, p_mainPointer) );
    __dmb(0xBu);
    if ( v6->useMutex )
      OS_MutexRelease(v6->commandMutex);
    if ( !v6->multiThread )
      RenderQueue::Process(v6);
    if ( v6->mainPointer + 1024 > v6->queueEnd )
      RenderQueue::Flush(v6);
    if ( toSelect && toSelect->targetTexture->width == toSelect->targetTexture->height )
    {
      v10 = renderQueue;
      v11 = renderQueue->mainWorkPointer;
      renderQueue->curQueueingCommand = rqDisableCull;
      *(_DWORD *)v11 = 38;
      v10->mainWorkPointer += 4;
      v12 = renderQueue;
      *(_DWORD *)renderQueue->mainWorkPointer = 1;
      v12->mainWorkPointer += 4;
      v13 = renderQueue;
      if ( renderQueue->useMutex )
        OS_MutexObtain(renderQueue->commandMutex);
      v14 = *(_QWORD *)&v13->mainPointer;
      v15 = (unsigned int *)&v13->mainPointer;
      __dmb(0xBu);
      do
        v16 = __ldrex(v15);
      while ( __strex(v16 + HIDWORD(v14) - v14, v15) );
    }
    else
    {
      v17 = renderQueue;
      v18 = renderQueue->mainWorkPointer;
      renderQueue->curQueueingCommand = rqDisableCull;
      *(_DWORD *)v18 = 38;
      v17->mainWorkPointer += 4;
      v19 = renderQueue;
      *(_DWORD *)renderQueue->mainWorkPointer = 0;
      v19->mainWorkPointer += 4;
      v13 = renderQueue;
      if ( renderQueue->useMutex )
        OS_MutexObtain(renderQueue->commandMutex);
      v20 = *(_QWORD *)&v13->mainPointer;
      v21 = (unsigned int *)&v13->mainPointer;
      __dmb(0xBu);
      do
        v22 = __ldrex(v21);
      while ( __strex(v22 + HIDWORD(v20) - v20, v21) );
    }
    __dmb(0xBu);
    if ( v13->useMutex )
      OS_MutexRelease(v13->commandMutex);
    if ( !v13->multiThread )
      RenderQueue::Process(v13);
    if ( v13->mainPointer + 1024 > v13->queueEnd )
      sub_1A148C(v13);
  }
}

//----- (001D0B30) --------------------------------------------------------
void __fastcall RQRenderTarget::Delete(RQRenderTarget *toDelete)
{
  RenderQueue *v2; // r1
  unsigned __int8 *mainWorkPointer; // r2
  RenderQueue *v4; // r1
  RenderQueue *v5; // r5
  __int64 v6; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v8; // r2
  RenderQueue *v9; // r1
  unsigned __int8 *v10; // r2
  RenderQueue *v11; // r1
  RenderQueue *v12; // r4
  __int64 v13; // kr08_8
  unsigned int *v14; // r0
  unsigned int v15; // r2

  if ( RQRenderTarget::selected == toDelete )
  {
    v2 = renderQueue;
    mainWorkPointer = renderQueue->mainWorkPointer;
    renderQueue->curQueueingCommand = rqTargetSelect;
    *(_DWORD *)mainWorkPointer = 27;
    v2->mainWorkPointer += 4;
    v4 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = 0;
    v4->mainWorkPointer += 4;
    v5 = renderQueue;
    if ( renderQueue->useMutex )
      OS_MutexObtain(renderQueue->commandMutex);
    v6 = *(_QWORD *)&v5->mainPointer;
    p_mainPointer = (unsigned int *)&v5->mainPointer;
    __dmb(0xBu);
    do
      v8 = __ldrex(p_mainPointer);
    while ( __strex(v8 + HIDWORD(v6) - v6, p_mainPointer) );
    __dmb(0xBu);
    if ( v5->useMutex )
      OS_MutexRelease(v5->commandMutex);
    if ( !v5->multiThread )
      RenderQueue::Process(v5);
    if ( v5->mainPointer + 1024 > v5->queueEnd )
      RenderQueue::Flush(v5);
    RQRenderTarget::selected = 0;
  }
  v9 = renderQueue;
  v10 = renderQueue->mainWorkPointer;
  renderQueue->curQueueingCommand = rqTargetDelete;
  *(_DWORD *)v10 = 28;
  v9->mainWorkPointer += 4;
  v11 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = toDelete;
  v11->mainWorkPointer += 4;
  v12 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v13 = *(_QWORD *)&v12->mainPointer;
  v14 = (unsigned int *)&v12->mainPointer;
  __dmb(0xBu);
  do
    v15 = __ldrex(v14);
  while ( __strex(v15 + HIDWORD(v13) - v13, v14) );
  __dmb(0xBu);
  if ( v12->useMutex )
    OS_MutexRelease(v12->commandMutex);
  if ( !v12->multiThread )
    RenderQueue::Process(v12);
  if ( v12->mainPointer + 1024 > v12->queueEnd )
    sub_1A148C(v12);
}

//----- (001D0C90) --------------------------------------------------------
void __fastcall RQ_Command_rqTargetCreate(unsigned __int8 **qData)
{
  _DWORD *v1; // r5
  int v2; // r4
  __int64 v3; // r8
  int v4; // r0
  int v5; // r1
  int v6; // r1
  int v7; // r0
  int v8; // r3
  _DWORD *v9; // r6
  GLuint v10; // r4
  GLint v11; // [sp+18h] [bp-20h] BYREF
  GLint params[7]; // [sp+1Ch] [bp-1Ch] BYREF

  v1 = *(_DWORD **)*qData;
  *qData += 4;
  v2 = *v1;
  v3 = *(_QWORD *)(*v1 + 4);
  if ( ES2RenderTarget::backBuffer == -1 )
  {
    glGetIntegerv(0x8CA6u, params);
    ES2RenderTarget::backBuffer = params[0];
  }
  glGetIntegerv(0x8CA6u, &v11);
  if ( !v1[3] && v1[2] )
  {
    glGenRenderbuffers(1, v1 + 5);
    glBindRenderbuffer(36161, v1[5]);
    v4 = v1[2];
    if ( v4 == 2 )
    {
      if ( RQCaps[2] )
      {
        v5 = 36396;
        goto LABEL_12;
      }
      if ( RQCaps[0] )
      {
        v5 = 33190;
        goto LABEL_12;
      }
LABEL_7:
      v5 = 33189;
LABEL_12:
      glRenderbufferStorage(36161, v5, v3, HIDWORD(v3));
      goto LABEL_13;
    }
    if ( v4 == 1 )
      goto LABEL_7;
  }
LABEL_13:
  glGenRenderbuffers(1, v1 + 4);
  glBindRenderbuffer(36161, v1[4]);
  if ( v1[1] && RQCaps[6] )
    v6 = 32856;
  else
    v6 = 36194;
  glRenderbufferStorage(36161, v6, v3, HIDWORD(v3));
  glGenFramebuffers(1, v1 + 6);
  glBindFramebuffer(36160, v1[6]);
  glFramebufferRenderbuffer(36160, 36064, 36161, v1[4]);
  v7 = v1[3];
  if ( v7 )
  {
    v8 = *(_DWORD *)(v7 + 20);
  }
  else
  {
    if ( !v1[2] )
      goto LABEL_22;
    v8 = v1[5];
  }
  glFramebufferRenderbuffer(36160, 36096, 36161, v8);
LABEL_22:
  v9 = (_DWORD *)(v2 + 40);
  glGenTextures(1, (GLuint *)(v2 + 40));
  v10 = *(_DWORD *)(v2 + 40);
  if ( ES2Texture::curActiveTexture != 5 )
  {
    glActiveTexture(0x84C5u);
    ES2Texture::curActiveTexture = 5;
  }
  glBindTexture(0xDE1u, v10);
  ES2Texture::boundTextures[5] = v10;
  glTexParameteri(0xDE1u, 0x2801u, 9729);
  glTexParameteri(0xDE1u, 0x2800u, 9729);
  glTexParameteri(0xDE1u, 0x2802u, 33071);
  glTexParameteri(0xDE1u, 0x2803u, 33071);
  if ( v1[1] )
    glTexImage2D(0xDE1u, 0, 6408, v3, SHIDWORD(v3), 0, 0x1908u, 0x1401u, 0);
  else
    glTexImage2D(0xDE1u, 0, 6407, v3, SHIDWORD(v3), 0, 0x1907u, 0x1401u, 0);
  glFramebufferTexture2D(36160, 36064, 3553, *v9, 0);
  glCheckFramebufferStatus(36160);
  glClear(0x4000u);
  glBindFramebuffer(36160, v11);
}
// 18ACA8: using guessed type int __fastcall glFramebufferTexture2D(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 18E160: using guessed type int __fastcall glFramebufferRenderbuffer(_DWORD, _DWORD, _DWORD, _DWORD);
// 18EA0C: using guessed type int __fastcall glBindRenderbuffer(_DWORD, _DWORD);
// 18F31C: using guessed type int __fastcall glBindFramebuffer(_DWORD, _DWORD);
// 18FC30: using guessed type int __fastcall glCheckFramebufferStatus(_DWORD);
// 197390: using guessed type int __fastcall glGenRenderbuffers(_DWORD, _DWORD);
// 19C5DC: using guessed type int __fastcall glRenderbufferStorage(_DWORD, _DWORD, _DWORD, _DWORD);
// 1A1694: using guessed type int __fastcall glGenFramebuffers(_DWORD, _DWORD);
// 1D0C90: using guessed type GLint params[7];

//----- (001D0ED0) --------------------------------------------------------
void __fastcall RQ_Command_rqTargetSelect(unsigned __int8 **qData)
{
  ES2RenderTarget *v1; // r4
  GLint v2; // r1
  int Width; // r4
  void *Height; // r0
  GLint params[3]; // [sp+4h] [bp-Ch] BYREF

  v1 = *(ES2RenderTarget **)*qData;
  *qData += 4;
  currentTarget = v1;
  if ( v1 )
  {
    glBindFramebuffer(36160, v1->frameBuffer);
    sub_18C530(0, 0, v1->targetTexture->width, v1->targetTexture->height);
  }
  else
  {
    v2 = ES2RenderTarget::backBuffer;
    if ( ES2RenderTarget::backBuffer == -1 )
    {
      glGetIntegerv(0x8CA6u, params);
      v2 = params[0];
      ES2RenderTarget::backBuffer = params[0];
    }
    glBindFramebuffer(36160, v2);
    Width = OS_ScreenGetWidth();
    Height = OS_ScreenGetHeight();
    glViewport(0, 0, Width, (GLsizei)Height);
  }
}
// 18F31C: using guessed type int __fastcall glBindFramebuffer(_DWORD, _DWORD);
// 1D0ED0: using guessed type GLint params[3];

//----- (001D0F54) --------------------------------------------------------
void __fastcall RQ_Command_rqTargetDelete(unsigned __int8 **qData)
{
  _DWORD *v1; // r4

  v1 = *(_DWORD **)*qData;
  *qData += 4;
  if ( *v1 )
    (*(void (__fastcall **)(_DWORD))(*(_DWORD *)*v1 + 4))(*v1);
  glDeleteFramebuffers(1, v1 + 6);
  glDeleteRenderbuffers(1, v1 + 4);
  glDeleteRenderbuffers(1, v1 + 5);
  if ( v1 )
    sub_191374(v1);
}
// 18C288: using guessed type int __fastcall glDeleteFramebuffers(_DWORD, _DWORD);
// 19BE54: using guessed type int __fastcall glDeleteRenderbuffers(_DWORD, _DWORD);

//----- (001D0F9A) --------------------------------------------------------
void __fastcall RQ_Command_rqTargetViewport(unsigned __int8 **qData)
{
  unsigned __int8 *v1; // r3
  unsigned __int8 *v2; // r2
  unsigned __int8 *v3; // r4
  GLint v4; // r12
  unsigned __int8 *v5; // lr
  GLint v6; // r1
  GLsizei v7; // r2
  GLsizei v8; // r3

  v1 = *qData;
  v2 = *qData + 8;
  v3 = *qData + 12;
  v5 = *qData + 16;
  v4 = *(_DWORD *)*qData;
  *qData += 4;
  v6 = *((_DWORD *)v1 + 1);
  *qData = v2;
  v7 = *((_DWORD *)v1 + 2);
  *qData = v3;
  v8 = *((_DWORD *)v1 + 3);
  *qData = v5;
  sub_18C530(v4, v6, v7, v8);
}

//----- (001D0FCC) --------------------------------------------------------
void __fastcall RQ_Command_rqTargetScissor(unsigned __int8 **qData)
{
  unsigned __int8 *v1; // r1
  unsigned __int8 *v2; // r2
  GLint v3; // r8
  int v4; // r4
  GLsizei v5; // r5
  GLsizei v6; // r6
  unsigned int height; // r0

  v1 = *qData;
  v2 = *qData + 16;
  v3 = *(_DWORD *)*qData;
  *qData += 4;
  v4 = *((_DWORD *)v1 + 1);
  *qData = v1 + 8;
  v5 = *((_DWORD *)v1 + 2);
  *qData = v1 + 12;
  v6 = *((_DWORD *)v1 + 3);
  *qData = v2;
  if ( v4 + v3 + v5 + v6 )
  {
    if ( currentTarget )
      height = currentTarget->targetTexture->height;
    else
      height = (unsigned int)OS_ScreenGetHeight();
    glScissor(v3, height - (v6 + v4), v5, v6);
    sub_194A40(0xC11u);
  }
  else
  {
    sub_18C4C0(0xC11u);
  }
}

//----- (001D1044) --------------------------------------------------------
void __fastcall RQ_Command_rqTargetClear(unsigned __int8 **qData)
{
  unsigned __int8 *v1; // r3
  unsigned __int8 *v2; // r4
  unsigned __int8 *v3; // r2
  int v4; // r6
  float v5; // r5
  GLint v6; // r4
  __int64 v7; // d17

  v1 = *qData;
  v2 = *qData + 24;
  v3 = *qData + 28;
  v4 = *(_DWORD *)*qData;
  *qData += 20;
  v5 = *((float *)v1 + 5);
  *qData = v2;
  v6 = *((_DWORD *)v1 + 6);
  *qData = v3;
  if ( *((float *)v1 + 1) != curClearColor._anon_0.arr[0]
    || *((float *)v1 + 2) != curClearColor._anon_0.arr[1]
    || *((float *)v1 + 3) != curClearColor._anon_0.arr[2]
    || *((float *)v1 + 4) != curClearColor._anon_0.arr[3] )
  {
    v7 = *(_QWORD *)(v1 + 12);
    *(_QWORD *)curClearColor._anon_0.arr = *(_QWORD *)(v1 + 4);
    *(_QWORD *)&curClearColor._anon_0._anon_1.b = v7;
    glClearColor(curClearColor._anon_0.arr[0], *((GLclampf *)v1 + 2), *((GLclampf *)v1 + 3), *((GLclampf *)v1 + 4));
  }
  if ( v5 != curClearDepth )
  {
    curClearDepth = v5;
    glClearDepthf(LODWORD(v5));
  }
  if ( v6 != curClearStencil )
  {
    curClearStencil = v6;
    glClearStencil(v6);
  }
  sub_18C42C((v4 << 8) & 0x400 | (v4 << 7) & 0x100 | ((v4 & 1) << 14));
}
// 193D7C: using guessed type int __fastcall glClearDepthf(_DWORD);

//----- (001D1160) --------------------------------------------------------
void __fastcall ES2ResourceContainer::~ES2ResourceContainer(ES2ResourceContainer *this)
{
  ES2Resource *dataPtr; // r0

  this->availableResources.numEntries = 0;
  dataPtr = this->availableResources.dataPtr;
  this->_vptr$ES2ResourceContainer = (int (**)(void))&off_6608C4;
  if ( dataPtr )
  {
    free(dataPtr);
    this->availableResources.dataPtr = 0;
  }
  this->availableResources.numAlloced = 0;
}
// 6608C4: using guessed type void *off_6608C4;

//----- (001D1188) --------------------------------------------------------
void ES2Texture::BindActiveTextures()
{
  GLuint v0; // r4
  GLuint v1; // r4
  GLuint v2; // r4

  v0 = ES2Texture::activeTextures[0];
  if ( ES2Texture::activeTextures[0] && ES2Texture::boundTextures[0] != ES2Texture::activeTextures[0] )
  {
    if ( ES2Texture::curActiveTexture )
    {
      glActiveTexture(0x84C0u);
      ES2Texture::curActiveTexture = 0;
    }
    glBindTexture(0xDE1u, v0);
    ES2Texture::boundTextures[0] = v0;
  }
  v1 = ES2Texture::activeTextures[1];
  if ( ES2Texture::activeTextures[1] && ES2Texture::boundTextures[1] != ES2Texture::activeTextures[1] )
  {
    if ( ES2Texture::curActiveTexture != 1 )
    {
      glActiveTexture(0x84C1u);
      ES2Texture::curActiveTexture = 1;
    }
    glBindTexture(0xDE1u, v1);
    ES2Texture::boundTextures[1] = v1;
  }
  v2 = ES2Texture::activeTextures[2];
  if ( ES2Texture::activeTextures[2] && ES2Texture::boundTextures[2] != ES2Texture::activeTextures[2] )
  {
    if ( ES2Texture::curActiveTexture != 2 )
    {
      glActiveTexture(0x84C2u);
      ES2Texture::curActiveTexture = 2;
    }
    glBindTexture(0xDE1u, v2);
    ES2Texture::boundTextures[2] = v2;
  }
}

//----- (001D129C) --------------------------------------------------------
void __fastcall ES2TextureContainer::DeleteResource(ES2TextureContainer *this, GLuint id)
{
  GLuint textures; // [sp+4h] [bp-Ch] BYREF

  textures = id;
  glDeleteTextures(1, &textures);
}

//----- (001D12B0) --------------------------------------------------------
void __fastcall ES2Texture::~ES2Texture(ES2Texture *this)
{
  GLuint v1; // r11
  GLuint *p_texID; // r10
  GLuint v3; // r0
  GLuint v4; // r6
  unsigned int TextureSize; // r0

  v1 = 0;
  this->_vptr$RQTexture = (int (**)(void))&off_6608DC;
  p_texID = &this->texID;
  do
  {
    v3 = ES2Texture::boundTextures[v1];
    if ( v3 && v3 == *p_texID )
    {
      if ( v1 != ES2Texture::curActiveTexture )
      {
        glActiveTexture(v1 + 33984);
        ES2Texture::curActiveTexture = v1;
      }
      glBindTexture(0xDE1u, 0);
      ES2Texture::boundTextures[v1] = 0;
    }
    ++v1;
  }
  while ( v1 != 8 );
  v4 = *p_texID;
  if ( ES2Texture::activeTextures[0] == *p_texID )
    ES2Texture::activeTextures[0] = 0;
  if ( ES2Texture::activeTextures[1] == v4 )
    ES2Texture::activeTextures[1] = 0;
  if ( ES2Texture::activeTextures[2] == v4 )
    ES2Texture::activeTextures[2] = 0;
  if ( this->target )
  {
    glDeleteTextures(1, p_texID);
  }
  else
  {
    TextureSize = RQTexture::GetTextureSize(this->width, this->height, this->format);
    ES2ResourceContainer::PutResource(&es2TexPool, v4, TextureSize);
  }
}
// 6608DC: using guessed type void *off_6608DC;

//----- (001D13D0) --------------------------------------------------------
void __fastcall ES2Texture::~ES2Texture(ES2Texture *this)
{
  void *v1; // r0

  ES2Texture::~ES2Texture(this);
  sub_191374(v1);
}
// 1D13DC: variable 'v1' is possibly undefined

//----- (001D13E0) --------------------------------------------------------
void __fastcall ES2Texture::UploadMip(ES2Texture *this, unsigned int mipLevel, const void *data)
{
  unsigned int MipSize; // r5
  RenderQueue *v7; // r2
  unsigned __int8 *queueEnd; // r12
  __int64 v9; // kr00_8
  RenderQueue *v10; // r0
  RenderQueue *v11; // r0
  RenderQueue *v12; // r0
  RenderQueue *v13; // r1
  RenderQueue *v14; // r1
  unsigned __int8 *v15; // r2
  RenderQueue *v16; // r4
  __int64 v17; // kr08_8
  unsigned int *v18; // r0
  unsigned int v19; // r2
  unsigned int v20; // r6
  unsigned int v21; // r2
  RenderQueue *v22; // r0
  RenderQueue *v23; // r4
  unsigned __int8 *v24; // r0
  RenderQueue *v25; // r4
  __int64 v26; // kr10_8
  unsigned int *p_mainPointer; // r0
  unsigned int v28; // r2

  MipSize = RQTexture::GetMipSize(this, mipLevel);
  v7 = renderQueue;
  queueEnd = renderQueue->queueEnd;
  v9 = *(_QWORD *)&renderQueue->mainPointer;
  renderQueue->curQueueingCommand = rqTextureMip;
  *(_DWORD *)HIDWORD(v9) = 22;
  v7->mainWorkPointer += 4;
  v10 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = this;
  v10->mainWorkPointer += 4;
  v11 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = mipLevel;
  v11->mainWorkPointer += 4;
  v12 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = MipSize;
  v12->mainWorkPointer += 4;
  if ( (unsigned int)v9 + MipSize + 67 <= (unsigned int)queueEnd )
  {
    v20 = (MipSize + 3) & 0xFFFFFFFC;
    v21 = v20;
    v22 = renderQueue;
    if ( (MipSize & 3) == 0 )
      v21 = MipSize;
    *(_DWORD *)renderQueue->mainWorkPointer = v21;
    v22->mainWorkPointer += 4;
    v23 = renderQueue;
    v24 = (unsigned __int8 *)((int)(renderQueue->mainWorkPointer + 3) & 0xFFFFFFFC);
    renderQueue->mainWorkPointer = v24;
    qmemcpy(v24, data, MipSize);
    if ( (MipSize & 3) == 0 )
      v20 = MipSize;
    v23->mainWorkPointer += v20;
    v25 = renderQueue;
    if ( renderQueue->useMutex )
      OS_MutexObtain(renderQueue->commandMutex);
    v26 = *(_QWORD *)&v25->mainPointer;
    p_mainPointer = (unsigned int *)&v25->mainPointer;
    __dmb(0xBu);
    do
      v28 = __ldrex(p_mainPointer);
    while ( __strex(v28 + HIDWORD(v26) - v26, p_mainPointer) );
    __dmb(0xBu);
    if ( v25->useMutex )
      OS_MutexRelease(v25->commandMutex);
    if ( !v25->multiThread )
      RenderQueue::Process(v25);
    if ( v25->mainPointer + 1024 > v25->queueEnd )
      sub_1A148C(v25);
  }
  else
  {
    v13 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = 0;
    v13->mainWorkPointer += 4;
    v14 = renderQueue;
    v15 = (unsigned __int8 *)((int)(renderQueue->mainWorkPointer + 3) & 0xFFFFFFFC);
    renderQueue->mainWorkPointer = v15;
    *(_DWORD *)v15 = data;
    v14->mainWorkPointer += 4;
    v16 = renderQueue;
    if ( renderQueue->useMutex )
      OS_MutexObtain(renderQueue->commandMutex);
    v17 = *(_QWORD *)&v16->mainPointer;
    v18 = (unsigned int *)&v16->mainPointer;
    __dmb(0xBu);
    do
      v19 = __ldrex(v18);
    while ( __strex(v19 + HIDWORD(v17) - v17, v18) );
    __dmb(0xBu);
    if ( v16->useMutex )
      OS_MutexRelease(v16->commandMutex);
    if ( !v16->multiThread )
      RenderQueue::Process(v16);
    if ( v16->mainPointer + 1024 > v16->queueEnd )
      RenderQueue::Flush(v16);
    sub_1A148C(renderQueue);
  }
}

//----- (001D15DC) --------------------------------------------------------
void __fastcall ES2Texture::Select(ES2Texture *this, unsigned int slot)
{
  RenderQueue *v2; // r2
  unsigned __int8 *mainWorkPointer; // r4
  RenderQueue *v4; // r2
  RenderQueue *v5; // r0
  RenderQueue *v6; // r4
  __int64 v7; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v9; // r2

  RQTexture::selected[slot] = this;
  v2 = renderQueue;
  mainWorkPointer = renderQueue->mainWorkPointer;
  renderQueue->curQueueingCommand = rqSelectTexture;
  *(_DWORD *)mainWorkPointer = 24;
  v2->mainWorkPointer += 4;
  v4 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = this;
  v4->mainWorkPointer += 4;
  v5 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = slot;
  v5->mainWorkPointer += 4;
  v6 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v7 = *(_QWORD *)&v6->mainPointer;
  p_mainPointer = (unsigned int *)&v6->mainPointer;
  __dmb(0xBu);
  do
    v9 = __ldrex(p_mainPointer);
  while ( __strex(v9 + HIDWORD(v7) - v7, p_mainPointer) );
  __dmb(0xBu);
  if ( v6->useMutex )
    OS_MutexRelease(v6->commandMutex);
  if ( !v6->multiThread )
    RenderQueue::Process(v6);
  if ( v6->mainPointer + 1024 > v6->queueEnd )
    sub_1A148C(v6);
}

//----- (001D16B0) --------------------------------------------------------
void __fastcall RenderQueue::RenderQueue(RenderQueue *this)
{
  bool v2; // zf
  size_t v3; // r0
  int v4; // r6
  unsigned __int8 *v5; // r11
  __int64 v6; // d11
  __int64 v7; // d10
  __int64 v8; // d13
  __int64 v9; // d9
  __int64 v10; // d12
  int v11; // r0
  __int64 v12; // d8
  __int64 v13; // d17
  __int64 v14; // d16
  __int128 v15; // q9
  __int64 v16; // d15
  __int64 v17; // d14
  __int128 v18; // q14
  __int128 v19; // q13
  __int64 v20; // d23
  __int128 v21; // q12
  __int64 v22; // d22
  __int128 v23; // q9
  unsigned __int8 *v24; // r1
  unsigned __int8 *queueStart; // r6
  __int64 v26; // d21
  __int64 v27; // d20
  __int64 v28; // d23
  __int64 v29; // d27
  __int64 v30; // d29
  __int64 v31; // d28
  __int64 v32; // d31
  __int64 v33; // d30
  __int64 v34; // d0
  __int64 v35; // d1
  __int64 v36; // r0

  *(_WORD *)&this->multiThread = 257;
  this->commandMutex = OS_MutexCreate("RenderCommand");
  v2 = IsLowSpecDevice() == 0;
  v3 = 0x100000;
  if ( !v2 )
    v3 = 0x80000;
  v4 = 0x100000;
  v5 = (unsigned __int8 *)malloc(v3);
  LODWORD(v6) = RQ_Command_rqVertexBufferDelete;
  LODWORD(v7) = RQ_Command_rqVertexBufferUpdate;
  HIDWORD(v6) = RQ_Command_rqIndexBufferSelect;
  HIDWORD(v7) = RQ_Command_rqVertexBufferCPU;
  LODWORD(v16) = RQ_Command_rqTargetCreate;
  LODWORD(v17) = RQ_Command_rqSelectTexture;
  LODWORD(v8) = "rqVertexBufferDelete";
  HIDWORD(v8) = "rqIndexBufferSelect";
  LODWORD(v9) = RQ_Command_rqDebugMarker;
  LODWORD(v10) = "rqVertexBufferUpdate";
  this->queueStart = v5;
  v11 = IsLowSpecDevice();
  LODWORD(v12) = RQ_Command_rqReadPixels;
  *(_QWORD *)&this->commandSizes[2] = -1LL;
  *(_QWORD *)&this->commandSizes[4] = 0x400000004LL;
  LODWORD(v13) = RQ_Command_rqFree;
  HIDWORD(v10) = "rqVertexBufferCPU";
  LODWORD(v14) = RQ_Command_rqSetZBias;
  *(_QWORD *)&this->commands[2] = v7;
  *(_QWORD *)&this->commands[4] = v6;
  LODWORD(v22) = "rqIndexBufferUpdate";
  *(_QWORD *)&this->commandNames[2] = v10;
  *(_QWORD *)&this->commandNames[4] = v8;
  LODWORD(v15) = 1891437;
  *((_QWORD *)&v15 + 1) = __PAIR64__(RQ_Command_rqTextureWrap, 1901393);
  LODWORD(v20) = "rqIndexBufferDelete";
  HIDWORD(v16) = RQ_Command_rqTargetSelect;
  HIDWORD(v17) = RQ_Command_rqDeleteTexture;
  DWORD1(v15) = RQ_Command_rqInitTexture;
  v18 = v15;
  LODWORD(v15) = 1883429;
  *((_QWORD *)&v15 + 1) = __PAIR64__(RQ_Command_rqBuildShader, 1884265);
  DWORD1(v15) = RQ_Command_rqDrawIndexed;
  v19 = v15;
  LODWORD(v23) = 1883009;
  *((_QWORD *)&v23 + 1) = __PAIR64__(RQ_Command_rqVertexStateApply, 1883389);
  DWORD1(v23) = RQ_Command_rqIndexBufferDelete;
  HIDWORD(v20) = "rqVertexStateCreate";
  this->commands[0] = RQ_Command_rqVertexBufferSelect;
  v21 = v23;
  HIDWORD(v22) = "rqIndexBufferCPU";
  DWORD2(v23) = RQ_Command_rqDepthFunc;
  this->commandNames[0] = "rqVertexBufferSelect";
  this->commands[1] = RQ_Command_rqVertexBufferCreate;
  this->commandNames[1] = "rqVertexBufferCreate";
  this->commands[6] = RQ_Command_rqIndexBufferCreate;
  if ( v11 )
    v4 = 0x80000;
  v24 = &v5[v4];
  queueStart = this->queueStart;
  *(_WORD *)&this->flushQueue = 0;
  this->queueEnd = v24;
  this->renderPointer = queueStart;
  this->mainPointer = queueStart;
  this->mainWorkPointer = queueStart;
  this->commandSizes[0] = 4;
  this->commandSizes[1] = 4;
  this->commandSizes[6] = 4;
  this->commandNames[6] = "rqIndexBufferCreate";
  *(_QWORD *)&this->commandSizes[7] = -1LL;
  *(_QWORD *)&this->commandSizes[9] = 0x9800000004LL;
  LODWORD(v23) = RQ_Command_rqEnableBlend;
  LODWORD(v26) = RQ_Command_rqTargetScissor;
  this->commands[7] = RQ_Command_rqIndexBufferUpdate;
  *(_QWORD *)&this->commandNames[7] = v22;
  *(_QWORD *)&this->commandNames[9] = v20;
  LODWORD(v27) = RQ_Command_rqTargetViewport;
  LODWORD(v28) = "rqDrawIndexed";
  HIDWORD(v28) = "rqDrawNonIndexed";
  *(_OWORD *)&this->commands[8] = v21;
  this->commandSizes[11] = 4;
  this->commandNames[11] = "rqVertexStateApply";
  this->commands[12] = RQ_Command_rqVertexStateDelete;
  this->commandSizes[12] = 4;
  *(_QWORD *)&this->commandNames[12] = __PAIR64__("rqSetVertexDescription", "rqVertexStateDelete");
  *(_QWORD *)&this->commandNames[14] = v28;
  *(_QWORD *)&this->commandSizes[13] = 0xC00000090LL;
  *(_QWORD *)&this->commandSizes[15] = 0x100000000CLL;
  *(_OWORD *)&this->commands[13] = v19;
  LODWORD(v29) = "rqTextureMipMode";
  this->commandSizes[17] = -1;
  this->commands[17] = RQ_Command_rqSelectShader;
  this->commandNames[16] = "rqBuildShader";
  this->commandNames[17] = "rqSelectShader";
  HIDWORD(v29) = "rqTextureWrap";
  *(_QWORD *)&this->commandSizes[18] = 0x400000004LL;
  *(_QWORD *)&this->commandSizes[20] = 0xC00000008LL;
  *(_OWORD *)&this->commands[18] = v18;
  LODWORD(v30) = "rqDeleteTexture";
  *(_QWORD *)&this->commandNames[18] = __PAIR64__("rqInitTexture", "rqDeleteShader");
  *(_QWORD *)&this->commandNames[20] = v29;
  LODWORD(v31) = "rqTextureAniso";
  this->commandSizes[22] = -1;
  HIDWORD(v30) = "rqTargetCreate";
  this->commands[22] = RQ_Command_rqTextureMip;
  HIDWORD(v31) = "rqSelectTexture";
  this->commandNames[22] = "rqTextureMip";
  LODWORD(v32) = "rqTargetClear";
  LODWORD(v33) = "rqTargetDelete";
  *(_QWORD *)&this->commandSizes[23] = 0x800000008LL;
  *(_QWORD *)&this->commandSizes[25] = 0x400000004LL;
  this->commands[23] = RQ_Command_rqTextureAniso;
  HIDWORD(v32) = "rqTargetScissor";
  *(_QWORD *)&this->commandNames[23] = v31;
  *(_QWORD *)&this->commandNames[25] = v30;
  HIDWORD(v33) = "rqTargetViewport";
  LODWORD(v34) = "rqEnableBlend";
  LODWORD(v35) = "rqDepthFunc";
  *(_QWORD *)&this->commands[24] = v17;
  *(_QWORD *)&this->commands[26] = v16;
  this->commandSizes[27] = 4;
  LODWORD(v31) = "rqSetAlphaTest";
  this->commandNames[27] = "rqTargetSelect";
  this->commandSizes[28] = 4;
  LODWORD(v30) = "rqSetWindingOrder";
  this->commands[28] = RQ_Command_rqTargetDelete;
  *(_QWORD *)&this->commandNames[28] = v33;
  *(_QWORD *)&this->commandNames[30] = v32;
  LODWORD(v33) = "rqInit";
  *(_QWORD *)&this->commandSizes[29] = 0x1C00000010LL;
  *(_QWORD *)&this->commandSizes[31] = 0x400000010LL;
  LODWORD(v32) = "rqSwapBuffers";
  HIDWORD(v9) = RQ_Command_rqShutdown;
  HIDWORD(v12) = RQ_Command_rqSwapBuffers;
  HIDWORD(v13) = RQ_Command_rqCopy;
  HIDWORD(v14) = RQ_Command_rqSetWindingOrder;
  HIDWORD(v23) = RQ_Command_rqSetCull;
  DWORD1(v23) = RQ_Command_rqBlendFunc;
  HIDWORD(v26) = RQ_Command_rqEnableDepthRead;
  HIDWORD(v27) = RQ_Command_rqTargetClear;
  HIDWORD(v32) = "rqDebugMarker";
  HIDWORD(v33) = "rqReadPixels";
  HIDWORD(v30) = "rqFree";
  HIDWORD(v31) = "rqSetZBias";
  HIDWORD(v35) = "rqSetCull";
  HIDWORD(v34) = "rqBlendFunc";
  *(_QWORD *)&this->commands[29] = v27;
  *(_QWORD *)&this->commands[31] = v26;
  this->commandNames[32] = "rqEnableDepthRead";
  this->commandSizes[33] = 4;
  this->commands[33] = RQ_Command_rqEnableDepthWrite;
  this->commandNames[33] = "rqEnableDepthWrite";
  *(_QWORD *)&this->commandSizes[34] = 0x800000004LL;
  *(_QWORD *)&this->commandSizes[36] = 0x400000004LL;
  *(_OWORD *)&this->commands[34] = v23;
  *(_QWORD *)&this->commandNames[34] = v34;
  *(_QWORD *)&this->commandNames[36] = v35;
  this->commandSizes[38] = 4;
  this->commandNames[38] = "rqDisableCull";
  *(_QWORD *)&this->commandSizes[39] = 0x400000008LL;
  *(_QWORD *)&this->commandSizes[41] = 0x400000004LL;
  this->commands[38] = RQ_Command_rqDisableCull;
  this->commands[39] = RQ_Command_rqSetAlphaTest;
  *(_QWORD *)&this->commandNames[39] = v31;
  *(_QWORD *)&this->commandNames[41] = v30;
  *(_QWORD *)&this->commands[40] = v14;
  *(_QWORD *)&this->commands[42] = v13;
  this->commandNames[43] = "rqCopy";
  this->commandSizes[43] = 12;
  this->commandSizes[44] = 0;
  this->commands[44] = RQ_Command_rqInit;
  *(_QWORD *)&this->commandNames[44] = v33;
  *(_QWORD *)&this->commandNames[46] = v32;
  HIDWORD(v36) = "rqCleanup";
  *(_QWORD *)&this->commandSizes[45] = 20LL;
  *(_QWORD *)&this->commandSizes[47] = 0LL;
  *(_QWORD *)&this->commands[45] = v12;
  *(_QWORD *)&this->commands[47] = v9;
  LODWORD(v36) = "rqShutdown";
  this->commandSizes[49] = 0;
  this->commands[49] = RQ_Command_rqCleanup;
  *(_QWORD *)&this->commandNames[48] = v36;
}

//----- (001D1F30) --------------------------------------------------------
void __fastcall RQ_Command_rqFree(unsigned __int8 **qData)
{
  void *v1; // r1

  v1 = *(void **)*qData;
  *qData += 4;
  j_free(v1);
}

//----- (001D1F3E) --------------------------------------------------------
void __fastcall RQ_Command_rqCopy(unsigned __int8 **qData)
{
  unsigned __int8 *v1; // r2
  unsigned __int8 *v2; // r3
  int v3; // r12
  unsigned __int8 *v4; // lr
  int v5; // r1
  int v6; // r2

  v1 = *qData;
  v2 = *qData + 8;
  v4 = *qData + 12;
  v3 = *(_DWORD *)*qData;
  *qData += 4;
  v5 = *((_DWORD *)v1 + 1);
  *qData = v2;
  v6 = *((_DWORD *)v1 + 2);
  *qData = v4;
  sub_19EA98(v3, v5, v6);
}

//----- (001D1F66) --------------------------------------------------------
void __fastcall RenderQueue::~RenderQueue(RenderQueue *this)
{
  free(this->queueStart);
  this->queueStart = 0;
  this->queueEnd = 0;
}

//----- (001D1F7E) --------------------------------------------------------
unsigned __int8 *__fastcall RenderQueue::ProcessCommand(RenderQueue *this, unsigned __int8 *curPointer)
{
  int v2; // r2
  unsigned __int8 *v4; // [sp+4h] [bp-Ch] BYREF

  v2 = *(unsigned __int16 *)curPointer;
  v4 = curPointer + 4;
  this->commands[v2](&v4);
  return v4;
}

//----- (001D1F98) --------------------------------------------------------
void __fastcall RenderQueue::Reset(RenderQueue *this)
{
  unsigned __int8 *queueStart; // r1
  unsigned int *p_mainPointer; // r0
  unsigned __int8 *mainPointer; // r2
  int v5; // r1
  unsigned int v6; // r2
  unsigned int *p_mainWorkPointer; // r0
  unsigned __int8 *v8; // r1
  unsigned __int8 *mainWorkPointer; // r2
  int v10; // r1
  unsigned int v11; // r2
  unsigned int *p_renderPointer; // r0
  unsigned __int8 *v13; // r1
  unsigned __int8 *renderPointer; // r2
  int v15; // r1
  unsigned int v16; // r2

  if ( this->useMutex )
    OS_MutexObtain(this->commandMutex);
  queueStart = this->queueStart;
  p_mainPointer = (unsigned int *)&this->mainPointer;
  mainPointer = this->mainPointer;
  __dmb(0xBu);
  v5 = mainPointer - queueStart;
  do
    v6 = __ldrex(p_mainPointer);
  while ( __strex(v6 - v5, p_mainPointer) );
  __dmb(0xBu);
  p_mainWorkPointer = (unsigned int *)&this->mainWorkPointer;
  v8 = this->queueStart;
  mainWorkPointer = this->mainWorkPointer;
  __dmb(0xBu);
  v10 = mainWorkPointer - v8;
  do
    v11 = __ldrex(p_mainWorkPointer);
  while ( __strex(v11 - v10, p_mainWorkPointer) );
  __dmb(0xBu);
  p_renderPointer = (unsigned int *)&this->renderPointer;
  v13 = this->queueStart;
  renderPointer = this->renderPointer;
  __dmb(0xBu);
  v15 = renderPointer - v13;
  do
    v16 = __ldrex(p_renderPointer);
  while ( __strex(v16 - v15, p_renderPointer) );
  __dmb(0xBu);
  if ( this->useMutex )
    sub_18CEF0(this->commandMutex);
}

//----- (001D2030) --------------------------------------------------------
bool __fastcall RenderQueue::Process(RenderQueue *this)
{
  bool i; // r6
  int v3; // t1
  _BOOL4 useMutex; // r0
  unsigned __int8 *renderPointer; // r1
  unsigned __int8 *v7; // [sp+4h] [bp-14h] BYREF

  for ( i = 0; ; i = 1 )
  {
    if ( this->useMutex )
    {
      OS_MutexObtain(this->commandMutex);
      useMutex = this->useMutex;
    }
    else
    {
      useMutex = 0;
    }
    renderPointer = this->renderPointer;
    if ( renderPointer >= this->mainPointer )
      break;
    if ( useMutex )
    {
      OS_MutexRelease(this->commandMutex);
      renderPointer = this->renderPointer;
    }
    v3 = *(unsigned __int16 *)renderPointer;
    v7 = renderPointer + 4;
    this->commands[v3](&v7);
    this->renderPointer = v7;
  }
  if ( useMutex )
    OS_MutexRelease(this->commandMutex);
  return i;
}
// 1D2098: masking with 0x1 was optimized away because r6.1 <= 0x1

//----- (001D20A4) --------------------------------------------------------
void __fastcall RenderQueue::Flush(RenderQueue *this)
{
  unsigned __int8 *queueStart; // r1
  unsigned int *p_mainPointer; // r0
  unsigned __int8 *mainPointer; // r2
  int v5; // r1
  unsigned int v6; // r2
  unsigned int *p_mainWorkPointer; // r0
  unsigned __int8 *v8; // r1
  unsigned __int8 *mainWorkPointer; // r2
  int v10; // r1
  unsigned int v11; // r2
  unsigned int *p_renderPointer; // r0
  unsigned __int8 *v13; // r1
  unsigned __int8 *renderPointer; // r2
  int v15; // r1
  unsigned int v16; // r2

  if ( this->multiThread )
  {
    this->flushQueue = 1;
    sub_195B54(GraphicsFlushSemaphore);
  }
  else
  {
    if ( this->useMutex )
      OS_MutexObtain(this->commandMutex);
    queueStart = this->queueStart;
    p_mainPointer = (unsigned int *)&this->mainPointer;
    mainPointer = this->mainPointer;
    __dmb(0xBu);
    v5 = mainPointer - queueStart;
    do
      v6 = __ldrex(p_mainPointer);
    while ( __strex(v6 - v5, p_mainPointer) );
    __dmb(0xBu);
    p_mainWorkPointer = (unsigned int *)&this->mainWorkPointer;
    v8 = this->queueStart;
    mainWorkPointer = this->mainWorkPointer;
    __dmb(0xBu);
    v10 = mainWorkPointer - v8;
    do
      v11 = __ldrex(p_mainWorkPointer);
    while ( __strex(v11 - v10, p_mainWorkPointer) );
    __dmb(0xBu);
    p_renderPointer = (unsigned int *)&this->renderPointer;
    v13 = this->queueStart;
    renderPointer = this->renderPointer;
    __dmb(0xBu);
    v15 = renderPointer - v13;
    do
      v16 = __ldrex(p_renderPointer);
    while ( __strex(v16 - v15, p_renderPointer) );
    __dmb(0xBu);
    if ( this->useMutex )
      sub_18CEF0(this->commandMutex);
  }
}

//----- (001D215C) --------------------------------------------------------
void __fastcall RenderQueue::Finish(RenderQueue *this)
{
  if ( this->multiThread )
  {
    this->finishQueue = 1;
    sub_195B54(GraphicsFinishSemaphore);
  }
}

//----- (001D217C) --------------------------------------------------------
unsigned int __fastcall GraphicsThread(void *data)
{
  int v1; // r10
  RenderQueue *i; // r5
  int v3; // t1
  _BOOL4 useMutex; // r0
  unsigned __int8 *renderPointer; // r1
  RenderQueue *v6; // r11
  int v7; // t1
  _BOOL4 v8; // r0
  unsigned __int8 *v9; // r1
  RenderQueue *v10; // r5
  unsigned __int8 *queueStart; // r1
  unsigned int *p_mainPointer; // r0
  unsigned __int8 *mainPointer; // r2
  int v14; // r1
  unsigned int v15; // r2
  unsigned int *p_mainWorkPointer; // r0
  unsigned __int8 *v17; // r1
  unsigned __int8 *mainWorkPointer; // r2
  int v19; // r1
  unsigned int v20; // r2
  unsigned int *p_renderPointer; // r0
  unsigned __int8 *v22; // r1
  unsigned __int8 *v23; // r2
  int v24; // r1
  unsigned int v25; // r2
  int v26; // t1
  _BOOL4 v27; // r0
  unsigned __int8 *v28; // r1
  unsigned __int8 *v30; // [sp+28h] [bp-28h] BYREF
  unsigned __int8 *v31; // [sp+2Ch] [bp-24h] BYREF
  unsigned __int8 *v32; // [sp+30h] [bp-20h] BYREF

  OS_ThreadMakeCurrent();
  OS_ThreadSetValue(renderQueue);
  while ( !KillGraphicsThread )
  {
    if ( IsAndroidPaused )
    {
      OS_ThreadUnmakeCurrent();
      while ( IsAndroidPaused )
        OS_ThreadSleep(10000);
      OS_ThreadMakeCurrent();
    }
    v1 = 0;
    for ( i = renderQueue; ; i->renderPointer = v30 )
    {
      if ( i->useMutex )
      {
        OS_MutexObtain(i->commandMutex);
        useMutex = i->useMutex;
      }
      else
      {
        useMutex = 0;
      }
      renderPointer = i->renderPointer;
      if ( renderPointer >= i->mainPointer )
        break;
      if ( useMutex )
      {
        OS_MutexRelease(i->commandMutex);
        renderPointer = i->renderPointer;
      }
      v3 = *(unsigned __int16 *)renderPointer;
      v30 = renderPointer + 4;
      i->commands[v3](&v30);
      v1 = 1;
    }
    if ( useMutex )
      OS_MutexRelease(i->commandMutex);
    v6 = renderQueue;
    if ( renderQueue->flushQueue )
    {
      while ( 1 )
      {
        if ( v6->useMutex )
        {
          OS_MutexObtain(v6->commandMutex);
          v8 = v6->useMutex;
        }
        else
        {
          v8 = 0;
        }
        v9 = v6->renderPointer;
        if ( v9 >= v6->mainPointer )
          break;
        if ( v8 )
        {
          OS_MutexRelease(v6->commandMutex);
          v9 = v6->renderPointer;
        }
        v7 = *(unsigned __int16 *)v9;
        v31 = v9 + 4;
        v6->commands[v7](&v31);
        v6->renderPointer = v31;
      }
      if ( v8 )
        OS_MutexRelease(v6->commandMutex);
      RQIndexBuffer::SetSafe();
      RQVertexBuffer::SetSafe();
      v10 = renderQueue;
      if ( renderQueue->useMutex )
        OS_MutexObtain(renderQueue->commandMutex);
      queueStart = v10->queueStart;
      p_mainPointer = (unsigned int *)&v10->mainPointer;
      mainPointer = v10->mainPointer;
      __dmb(0xBu);
      v14 = mainPointer - queueStart;
      do
        v15 = __ldrex(p_mainPointer);
      while ( __strex(v15 - v14, p_mainPointer) );
      __dmb(0xBu);
      p_mainWorkPointer = (unsigned int *)&v10->mainWorkPointer;
      v17 = v10->queueStart;
      mainWorkPointer = v10->mainWorkPointer;
      __dmb(0xBu);
      v19 = mainWorkPointer - v17;
      do
        v20 = __ldrex(p_mainWorkPointer);
      while ( __strex(v20 - v19, p_mainWorkPointer) );
      __dmb(0xBu);
      p_renderPointer = (unsigned int *)&v10->renderPointer;
      v22 = v10->queueStart;
      v23 = v10->renderPointer;
      __dmb(0xBu);
      v24 = v23 - v22;
      do
        v25 = __ldrex(p_renderPointer);
      while ( __strex(v25 - v24, p_renderPointer) );
      __dmb(0xBu);
      if ( v10->useMutex )
        OS_MutexRelease(v10->commandMutex);
      renderQueue->flushQueue = 0;
      OS_SemaphorePost(GraphicsFlushSemaphore);
      v6 = renderQueue;
    }
    if ( v6->finishQueue )
    {
      while ( 1 )
      {
        if ( v6->useMutex )
        {
          OS_MutexObtain(v6->commandMutex);
          v27 = v6->useMutex;
        }
        else
        {
          v27 = 0;
        }
        v28 = v6->renderPointer;
        if ( v28 >= v6->mainPointer )
          break;
        if ( v27 )
        {
          OS_MutexRelease(v6->commandMutex);
          v28 = v6->renderPointer;
        }
        v26 = *(unsigned __int16 *)v28;
        v32 = v28 + 4;
        v6->commands[v26](&v32);
        v6->renderPointer = v32;
      }
      if ( v27 )
        OS_MutexRelease(v6->commandMutex);
      renderQueue->finishQueue = 0;
      OS_SemaphorePost(GraphicsFinishSemaphore);
    }
    if ( !(v1 << 31) )
      OS_ThreadSleep(30);
  }
  OS_ThreadUnmakeCurrent();
  return 0;
}

//----- (001D2460) --------------------------------------------------------
void RenderQueue::Initialize()
{
  RenderQueue *v0; // r0
  RenderQueue *v1; // r0

  v0 = (RenderQueue *)operator new(0x27Cu);
  RenderQueue::RenderQueue(v0);
  renderQueue = v1;
  if ( v1->multiThread )
  {
    OS_ThreadUnmakeCurrent();
    GraphicsFlushSemaphore = OS_SemaphoreCreate();
    GraphicsFinishSemaphore = OS_SemaphoreCreate();
    GraphicsThreadHandle = OS_ThreadLaunch(GraphicsThread, 0, 2u, "RenderQueue", 0, 3);
  }
}
// 1D2478: variable 'v1' is possibly undefined

//----- (001D24E0) --------------------------------------------------------
void RenderQueue::Kill()
{
  RenderQueue *v0; // r4

  v0 = renderQueue;
  if ( renderQueue->multiThread )
  {
    KillGraphicsThread = 1;
    OS_ThreadWait(GraphicsThreadHandle);
    OS_ThreadClose(GraphicsThreadHandle);
    v0 = renderQueue;
    GraphicsThreadHandle = 0;
  }
  if ( v0 )
  {
    free(v0->queueStart);
    sub_191374(v0);
  }
}

//----- (001D2548) --------------------------------------------------------
void __fastcall RQVertexBuffer::Update(RQVertexBuffer *this, const void *data, unsigned int size)
{
  RenderQueue *v6; // r0
  unsigned __int8 *mainWorkPointer; // r2
  RenderQueue *v8; // r0
  RenderQueue *v9; // r0
  RenderQueue *v10; // r6
  unsigned __int8 *v11; // r0
  RenderQueue *v12; // r4
  __int64 v13; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v15; // r2

  RQVertexBuffer::Set(this);
  v6 = renderQueue;
  if ( &renderQueue->mainPointer[size + 67] > renderQueue->queueEnd )
  {
    RenderQueue::Flush(renderQueue);
    v6 = renderQueue;
  }
  mainWorkPointer = v6->mainWorkPointer;
  v6->curQueueingCommand = rqVertexBufferUpdate;
  *(_DWORD *)mainWorkPointer = 2;
  v6->mainWorkPointer += 4;
  v8 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = this;
  v8->mainWorkPointer += 4;
  v9 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = size;
  v9->mainWorkPointer += 4;
  if ( size )
  {
    v10 = renderQueue;
    v11 = (unsigned __int8 *)((int)(renderQueue->mainWorkPointer + 3) & 0xFFFFFFFC);
    renderQueue->mainWorkPointer = v11;
    qmemcpy(v11, data, size);
    if ( (size & 3) != 0 )
      size = (size + 3) & 0xFFFFFFFC;
    v10->mainWorkPointer += size;
  }
  v12 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v13 = *(_QWORD *)&v12->mainPointer;
  p_mainPointer = (unsigned int *)&v12->mainPointer;
  __dmb(0xBu);
  do
    v15 = __ldrex(p_mainPointer);
  while ( __strex(v15 + HIDWORD(v13) - v13, p_mainPointer) );
  __dmb(0xBu);
  if ( v12->useMutex )
    OS_MutexRelease(v12->commandMutex);
  if ( !v12->multiThread )
    RenderQueue::Process(v12);
  if ( v12->mainPointer + 1024 > v12->queueEnd )
    sub_1A148C(v12);
}

//----- (001D268C) --------------------------------------------------------
void __fastcall RQVertexBuffer::Set(RQVertexBuffer *buffer)
{
  RenderQueue *v2; // r3
  unsigned __int8 *mainWorkPointer; // r1
  RenderQueue *v4; // r1
  RenderQueue *v5; // r4
  __int64 v6; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v8; // r2

  if ( RQVertexState::curState )
    RQVertexState::Apply(0);
  if ( RQVertexBuffer::curBuffer != buffer )
  {
    v2 = renderQueue;
    RQVertexBuffer::curBuffer = buffer;
    bufferChanged = 1;
    mainWorkPointer = renderQueue->mainWorkPointer;
    renderQueue->curQueueingCommand = rqVertexBufferSelect;
    *(_DWORD *)mainWorkPointer = 0;
    v2->mainWorkPointer += 4;
    v4 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = buffer;
    v4->mainWorkPointer += 4;
    v5 = renderQueue;
    if ( renderQueue->useMutex )
      OS_MutexObtain(renderQueue->commandMutex);
    v6 = *(_QWORD *)&v5->mainPointer;
    p_mainPointer = (unsigned int *)&v5->mainPointer;
    __dmb(0xBu);
    do
      v8 = __ldrex(p_mainPointer);
    while ( __strex(v8 + HIDWORD(v6) - v6, p_mainPointer) );
    __dmb(0xBu);
    if ( v5->useMutex )
      OS_MutexRelease(v5->commandMutex);
    if ( !v5->multiThread )
      RenderQueue::Process(v5);
    if ( v5->mainPointer + 1024 > v5->queueEnd )
      sub_1A148C(v5);
  }
}

//----- (001D2774) --------------------------------------------------------
void __fastcall RQVertexState::Apply(RQVertexState *state)
{
  RenderQueue *v2; // r1
  unsigned __int8 *mainWorkPointer; // r2
  RenderQueue *v4; // r1
  RenderQueue *v5; // r5
  __int64 v6; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v8; // r2

  if ( RQVertexState::curState != state )
  {
    v2 = renderQueue;
    mainWorkPointer = renderQueue->mainWorkPointer;
    renderQueue->curQueueingCommand = rqVertexStateApply;
    *(_DWORD *)mainWorkPointer = 11;
    v2->mainWorkPointer += 4;
    v4 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = state;
    v4->mainWorkPointer += 4;
    v5 = renderQueue;
    if ( renderQueue->useMutex )
      OS_MutexObtain(renderQueue->commandMutex);
    v6 = *(_QWORD *)&v5->mainPointer;
    p_mainPointer = (unsigned int *)&v5->mainPointer;
    __dmb(0xBu);
    do
      v8 = __ldrex(p_mainPointer);
    while ( __strex(v8 + HIDWORD(v6) - v6, p_mainPointer) );
    __dmb(0xBu);
    if ( v5->useMutex )
      OS_MutexRelease(v5->commandMutex);
    if ( !v5->multiThread )
      RenderQueue::Process(v5);
    if ( v5->mainPointer + 1024 > v5->queueEnd )
      RenderQueue::Flush(v5);
    RQVertexState::curState = state;
    if ( state )
    {
      RQVertexBuffer::curBuffer = (RQVertexBuffer *)-1;
      cachedDescription.attributes[0].count = 0xFFFF;
      RQIndexBuffer::curBuffer = (RQIndexBuffer *)-1;
    }
  }
}

//----- (001D2864) --------------------------------------------------------
void __fastcall RQVertexBuffer::Set(const void *data, unsigned int size, void (*QueueCPUData)(void))
{
  RenderQueue *v6; // r2
  unsigned __int8 *mainWorkPointer; // r1
  RenderQueue *v8; // r1
  RenderQueue *v9; // r5
  __int64 v10; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v12; // r2
  RenderQueue *v13; // r0
  unsigned __int8 *v14; // r2
  RenderQueue *v15; // r0
  RenderQueue *v16; // r5
  unsigned __int8 *v17; // r0
  RenderQueue *v18; // r4
  __int64 v19; // kr08_8
  unsigned int *v20; // r0
  unsigned int v21; // r2

  if ( RQVertexState::curState )
    RQVertexState::Apply(0);
  if ( RQVertexBuffer::curBuffer )
  {
    v6 = renderQueue;
    RQVertexBuffer::curBuffer = 0;
    mainWorkPointer = renderQueue->mainWorkPointer;
    renderQueue->curQueueingCommand = rqVertexBufferSelect;
    *(_DWORD *)mainWorkPointer = 0;
    v6->mainWorkPointer += 4;
    v8 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = 0;
    v8->mainWorkPointer += 4;
    v9 = renderQueue;
    if ( renderQueue->useMutex )
      OS_MutexObtain(renderQueue->commandMutex);
    v10 = *(_QWORD *)&v9->mainPointer;
    p_mainPointer = (unsigned int *)&v9->mainPointer;
    __dmb(0xBu);
    do
      v12 = __ldrex(p_mainPointer);
    while ( __strex(v12 + HIDWORD(v10) - v10, p_mainPointer) );
    __dmb(0xBu);
    if ( v9->useMutex )
      OS_MutexRelease(v9->commandMutex);
    if ( !v9->multiThread )
      RenderQueue::Process(v9);
    if ( v9->mainPointer + 1024 > v9->queueEnd )
      RenderQueue::Flush(v9);
  }
  v13 = renderQueue;
  if ( &renderQueue->mainPointer[size + 27] > renderQueue->queueEnd )
  {
    RenderQueue::Flush(renderQueue);
    v13 = renderQueue;
  }
  v14 = v13->mainWorkPointer;
  v13->curQueueingCommand = rqVertexBufferCPU;
  *(_DWORD *)v14 = 3;
  v13->mainWorkPointer += 4;
  v15 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = size;
  v15->mainWorkPointer += 4;
  if ( QueueCPUData )
  {
    QueueCPUData();
  }
  else
  {
    v16 = renderQueue;
    v17 = (unsigned __int8 *)((int)(renderQueue->mainWorkPointer + 3) & 0xFFFFFFFC);
    renderQueue->mainWorkPointer = v17;
    qmemcpy(v17, data, size);
    if ( (size & 3) != 0 )
      size = (size + 3) & 0xFFFFFFFC;
    v16->mainWorkPointer += size;
  }
  v18 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v19 = *(_QWORD *)&v18->mainPointer;
  v20 = (unsigned int *)&v18->mainPointer;
  __dmb(0xBu);
  do
    v21 = __ldrex(v20);
  while ( __strex(v21 + HIDWORD(v19) - v19, v20) );
  __dmb(0xBu);
  if ( v18->useMutex )
    OS_MutexRelease(v18->commandMutex);
  if ( !v18->multiThread )
    RenderQueue::Process(v18);
  if ( v18->mainPointer + 1024 > v18->queueEnd )
    RenderQueue::Flush(v18);
  bufferChanged = 1;
}

//----- (001D2A64) --------------------------------------------------------
void __fastcall RQVertexBuffer::Delete(RQVertexBuffer *toDelete)
{
  RenderQueue *v2; // r2
  unsigned __int8 *mainWorkPointer; // r1
  RenderQueue *v4; // r1
  RenderQueue *v5; // r5
  __int64 v6; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v8; // r2
  RenderQueue *v9; // r1
  unsigned __int8 *v10; // r2
  RenderQueue *v11; // r1
  RenderQueue *v12; // r4
  __int64 v13; // kr08_8
  unsigned int *v14; // r0
  unsigned int v15; // r2

  if ( RQVertexBuffer::curBuffer == toDelete )
  {
    v2 = renderQueue;
    RQVertexBuffer::curBuffer = 0;
    mainWorkPointer = renderQueue->mainWorkPointer;
    renderQueue->curQueueingCommand = rqVertexBufferSelect;
    *(_DWORD *)mainWorkPointer = 0;
    v2->mainWorkPointer += 4;
    v4 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = 0;
    v4->mainWorkPointer += 4;
    v5 = renderQueue;
    if ( renderQueue->useMutex )
      OS_MutexObtain(renderQueue->commandMutex);
    v6 = *(_QWORD *)&v5->mainPointer;
    p_mainPointer = (unsigned int *)&v5->mainPointer;
    __dmb(0xBu);
    do
      v8 = __ldrex(p_mainPointer);
    while ( __strex(v8 + HIDWORD(v6) - v6, p_mainPointer) );
    __dmb(0xBu);
    if ( v5->useMutex )
      OS_MutexRelease(v5->commandMutex);
    if ( !v5->multiThread )
      RenderQueue::Process(v5);
    if ( v5->mainPointer + 1024 > v5->queueEnd )
      RenderQueue::Flush(v5);
  }
  v9 = renderQueue;
  v10 = renderQueue->mainWorkPointer;
  renderQueue->curQueueingCommand = rqVertexBufferDelete;
  *(_DWORD *)v10 = 4;
  v9->mainWorkPointer += 4;
  v11 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = toDelete;
  v11->mainWorkPointer += 4;
  v12 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v13 = *(_QWORD *)&v12->mainPointer;
  v14 = (unsigned int *)&v12->mainPointer;
  __dmb(0xBu);
  do
    v15 = __ldrex(v14);
  while ( __strex(v15 + HIDWORD(v13) - v13, v14) );
  __dmb(0xBu);
  if ( v12->useMutex )
    OS_MutexRelease(v12->commandMutex);
  if ( !v12->multiThread )
    RenderQueue::Process(v12);
  if ( v12->mainPointer + 1024 > v12->queueEnd )
    sub_1A148C(v12);
}

//----- (001D2BC0) --------------------------------------------------------
void __fastcall RQIndexBuffer::Update(RQIndexBuffer *this, const void *data, unsigned int size)
{
  RenderQueue *v6; // r0
  unsigned __int8 *mainWorkPointer; // r2
  RenderQueue *v8; // r0
  RenderQueue *v9; // r0
  RenderQueue *v10; // r6
  unsigned __int8 *v11; // r0
  RenderQueue *v12; // r4
  __int64 v13; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v15; // r2

  RQIndexBuffer::Set(this);
  v6 = renderQueue;
  if ( (size & 3) != 0 )
    size = (size + 3) & 0xFFFFFFFC;
  if ( &renderQueue->mainPointer[size + 67] > renderQueue->queueEnd )
  {
    RenderQueue::Flush(renderQueue);
    v6 = renderQueue;
  }
  mainWorkPointer = v6->mainWorkPointer;
  v6->curQueueingCommand = rqIndexBufferUpdate;
  *(_DWORD *)mainWorkPointer = 7;
  v6->mainWorkPointer += 4;
  v8 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = this;
  v8->mainWorkPointer += 4;
  v9 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = size;
  v9->mainWorkPointer += 4;
  if ( size )
  {
    v10 = renderQueue;
    v11 = (unsigned __int8 *)((int)(renderQueue->mainWorkPointer + 3) & 0xFFFFFFFC);
    renderQueue->mainWorkPointer = v11;
    qmemcpy(v11, data, size);
    if ( (size & 3) != 0 )
      size = (size + 3) & 0xFFFFFFFC;
    v10->mainWorkPointer += size;
  }
  v12 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v13 = *(_QWORD *)&v12->mainPointer;
  p_mainPointer = (unsigned int *)&v12->mainPointer;
  __dmb(0xBu);
  do
    v15 = __ldrex(p_mainPointer);
  while ( __strex(v15 + HIDWORD(v13) - v13, p_mainPointer) );
  __dmb(0xBu);
  if ( v12->useMutex )
    OS_MutexRelease(v12->commandMutex);
  if ( !v12->multiThread )
    RenderQueue::Process(v12);
  if ( v12->mainPointer + 1024 > v12->queueEnd )
    sub_1A148C(v12);
}

//----- (001D2D10) --------------------------------------------------------
void __fastcall RQIndexBuffer::Set(RQIndexBuffer *buffer)
{
  RenderQueue *v2; // r2
  unsigned __int8 *mainWorkPointer; // r1
  RenderQueue *v4; // r1
  RenderQueue *v5; // r4
  __int64 v6; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v8; // r2

  if ( RQVertexState::curState )
    RQVertexState::Apply(0);
  if ( RQIndexBuffer::curBuffer != buffer )
  {
    v2 = renderQueue;
    RQIndexBuffer::curBuffer = buffer;
    mainWorkPointer = renderQueue->mainWorkPointer;
    renderQueue->curQueueingCommand = rqIndexBufferSelect;
    *(_DWORD *)mainWorkPointer = 5;
    v2->mainWorkPointer += 4;
    v4 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = buffer;
    v4->mainWorkPointer += 4;
    v5 = renderQueue;
    if ( renderQueue->useMutex )
      OS_MutexObtain(renderQueue->commandMutex);
    v6 = *(_QWORD *)&v5->mainPointer;
    p_mainPointer = (unsigned int *)&v5->mainPointer;
    __dmb(0xBu);
    do
      v8 = __ldrex(p_mainPointer);
    while ( __strex(v8 + HIDWORD(v6) - v6, p_mainPointer) );
    __dmb(0xBu);
    if ( v5->useMutex )
      OS_MutexRelease(v5->commandMutex);
    if ( !v5->multiThread )
      RenderQueue::Process(v5);
    if ( v5->mainPointer + 1024 > v5->queueEnd )
      sub_1A148C(v5);
  }
}

//----- (001D2DEC) --------------------------------------------------------
void __fastcall RQIndexBuffer::Set(const void *data, unsigned int size)
{
  unsigned int v4; // r10
  unsigned int v5; // r9
  unsigned int v6; // r5
  RenderQueue *v7; // r2
  unsigned __int8 *mainWorkPointer; // r1
  RenderQueue *v9; // r1
  RenderQueue *v10; // r6
  __int64 v11; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v13; // r2
  RenderQueue *v14; // r0
  unsigned __int8 *v15; // r2
  RenderQueue *v16; // r0
  RenderQueue *v17; // r5
  unsigned __int8 *v18; // r0
  RenderQueue *v19; // r4
  __int64 v20; // kr08_8
  unsigned int *v21; // r0
  unsigned int v22; // r2

  v4 = (size + 3) & 0xFFFFFFFC;
  v5 = size & 3;
  v6 = v4;
  if ( (size & 3) == 0 )
    v6 = size;
  if ( RQVertexState::curState )
    RQVertexState::Apply(0);
  if ( RQIndexBuffer::curBuffer )
  {
    v7 = renderQueue;
    RQIndexBuffer::curBuffer = 0;
    mainWorkPointer = renderQueue->mainWorkPointer;
    renderQueue->curQueueingCommand = rqIndexBufferSelect;
    *(_DWORD *)mainWorkPointer = 5;
    v7->mainWorkPointer += 4;
    v9 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = 0;
    v9->mainWorkPointer += 4;
    v10 = renderQueue;
    if ( renderQueue->useMutex )
      OS_MutexObtain(renderQueue->commandMutex);
    v11 = *(_QWORD *)&v10->mainPointer;
    p_mainPointer = (unsigned int *)&v10->mainPointer;
    __dmb(0xBu);
    do
      v13 = __ldrex(p_mainPointer);
    while ( __strex(v13 + HIDWORD(v11) - v11, p_mainPointer) );
    __dmb(0xBu);
    if ( v10->useMutex )
      OS_MutexRelease(v10->commandMutex);
    if ( !v10->multiThread )
      RenderQueue::Process(v10);
    if ( v10->mainPointer + 1024 > v10->queueEnd )
      RenderQueue::Flush(v10);
  }
  v14 = renderQueue;
  if ( &renderQueue->mainPointer[v6 + 15] > renderQueue->queueEnd )
  {
    RenderQueue::Flush(renderQueue);
    v14 = renderQueue;
  }
  v15 = v14->mainWorkPointer;
  v14->curQueueingCommand = rqIndexBufferCPU;
  *(_DWORD *)v15 = 8;
  v14->mainWorkPointer += 4;
  v16 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = v6;
  v16->mainWorkPointer += 4;
  v17 = renderQueue;
  v18 = (unsigned __int8 *)((int)(renderQueue->mainWorkPointer + 3) & 0xFFFFFFFC);
  renderQueue->mainWorkPointer = v18;
  qmemcpy(v18, data, size);
  if ( !v5 )
    v4 = size;
  v17->mainWorkPointer += v4;
  v19 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v20 = *(_QWORD *)&v19->mainPointer;
  v21 = (unsigned int *)&v19->mainPointer;
  __dmb(0xBu);
  do
    v22 = __ldrex(v21);
  while ( __strex(v22 + HIDWORD(v20) - v20, v21) );
  __dmb(0xBu);
  if ( v19->useMutex )
    OS_MutexRelease(v19->commandMutex);
  if ( !v19->multiThread )
    RenderQueue::Process(v19);
  if ( v19->mainPointer + 1024 > v19->queueEnd )
    sub_1A148C(v19);
}

//----- (001D2FD4) --------------------------------------------------------
void __fastcall RQIndexBuffer::Delete(RQIndexBuffer *toDelete)
{
  RenderQueue *v2; // r2
  unsigned __int8 *mainWorkPointer; // r1
  RenderQueue *v4; // r1
  RenderQueue *v5; // r5
  __int64 v6; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v8; // r2
  RenderQueue *v9; // r1
  unsigned __int8 *v10; // r2
  RenderQueue *v11; // r1
  RenderQueue *v12; // r4
  __int64 v13; // kr08_8
  unsigned int *v14; // r0
  unsigned int v15; // r2

  if ( RQIndexBuffer::curBuffer == toDelete )
  {
    v2 = renderQueue;
    RQIndexBuffer::curBuffer = 0;
    mainWorkPointer = renderQueue->mainWorkPointer;
    renderQueue->curQueueingCommand = rqIndexBufferSelect;
    *(_DWORD *)mainWorkPointer = 5;
    v2->mainWorkPointer += 4;
    v4 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = 0;
    v4->mainWorkPointer += 4;
    v5 = renderQueue;
    if ( renderQueue->useMutex )
      OS_MutexObtain(renderQueue->commandMutex);
    v6 = *(_QWORD *)&v5->mainPointer;
    p_mainPointer = (unsigned int *)&v5->mainPointer;
    __dmb(0xBu);
    do
      v8 = __ldrex(p_mainPointer);
    while ( __strex(v8 + HIDWORD(v6) - v6, p_mainPointer) );
    __dmb(0xBu);
    if ( v5->useMutex )
      OS_MutexRelease(v5->commandMutex);
    if ( !v5->multiThread )
      RenderQueue::Process(v5);
    if ( v5->mainPointer + 1024 > v5->queueEnd )
      RenderQueue::Flush(v5);
  }
  v9 = renderQueue;
  v10 = renderQueue->mainWorkPointer;
  renderQueue->curQueueingCommand = rqIndexBufferDelete;
  *(_DWORD *)v10 = 9;
  v9->mainWorkPointer += 4;
  v11 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = toDelete;
  v11->mainWorkPointer += 4;
  v12 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v13 = *(_QWORD *)&v12->mainPointer;
  v14 = (unsigned int *)&v12->mainPointer;
  __dmb(0xBu);
  do
    v15 = __ldrex(v14);
  while ( __strex(v15 + HIDWORD(v13) - v13, v14) );
  __dmb(0xBu);
  if ( v12->useMutex )
    OS_MutexRelease(v12->commandMutex);
  if ( !v12->multiThread )
    RenderQueue::Process(v12);
  if ( v12->mainPointer + 1024 > v12->queueEnd )
    sub_1A148C(v12);
}

//----- (001D3134) --------------------------------------------------------
void __fastcall RQSetDescription(const RQVertexBufferDescription *desc)
{
  int v2; // r0
  bool v3; // zf
  _BOOL4 v4; // r5
  RenderQueue *v5; // r0
  unsigned __int8 *mainWorkPointer; // r1
  RenderQueue *v7; // r0
  RenderQueue *v8; // r5
  RenderQueue *v9; // r4
  __int64 v10; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v12; // r2

  if ( RQVertexState::curState )
    RQVertexState::Apply(0);
  v2 = memcmp(desc, &cachedDescription, 0x8Cu);
  v3 = v2 == 0;
  v4 = bufferChanged;
  if ( !v2 )
    v3 = !bufferChanged;
  if ( !v3 )
  {
    qmemcpy(&cachedDescription, desc, sizeof(cachedDescription));
    v5 = renderQueue;
    mainWorkPointer = renderQueue->mainWorkPointer;
    renderQueue->curQueueingCommand = rqSetVertexDescription;
    *(_DWORD *)mainWorkPointer = 13;
    v5->mainWorkPointer += 4;
    v7 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = v4;
    v7->mainWorkPointer += 4;
    v8 = renderQueue;
    qmemcpy(renderQueue->mainWorkPointer, desc, 0x8Cu);
    v8->mainWorkPointer += 140;
    v9 = renderQueue;
    if ( renderQueue->useMutex )
      OS_MutexObtain(renderQueue->commandMutex);
    v10 = *(_QWORD *)&v9->mainPointer;
    p_mainPointer = (unsigned int *)&v9->mainPointer;
    __dmb(0xBu);
    do
      v12 = __ldrex(p_mainPointer);
    while ( __strex(v12 + HIDWORD(v10) - v10, p_mainPointer) );
    __dmb(0xBu);
    if ( v9->useMutex )
      OS_MutexRelease(v9->commandMutex);
    if ( !v9->multiThread )
      RenderQueue::Process(v9);
    if ( v9->mainPointer + 1024 > v9->queueEnd )
      RenderQueue::Flush(v9);
    bufferChanged = 0;
  }
}

//----- (001D3254) --------------------------------------------------------
void __fastcall RQVertexState::Delete(RQVertexState *state)
{
  RenderQueue *v2; // r1
  unsigned __int8 *mainWorkPointer; // r2
  RenderQueue *v4; // r1
  RenderQueue *v5; // r4
  __int64 v6; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v8; // r2

  if ( RQVertexState::curState == state )
    RQVertexState::Apply(0);
  v2 = renderQueue;
  mainWorkPointer = renderQueue->mainWorkPointer;
  renderQueue->curQueueingCommand = rqVertexStateDelete;
  *(_DWORD *)mainWorkPointer = 12;
  v2->mainWorkPointer += 4;
  v4 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = state;
  v4->mainWorkPointer += 4;
  v5 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v6 = *(_QWORD *)&v5->mainPointer;
  p_mainPointer = (unsigned int *)&v5->mainPointer;
  __dmb(0xBu);
  do
    v8 = __ldrex(p_mainPointer);
  while ( __strex(v8 + HIDWORD(v6) - v6, p_mainPointer) );
  __dmb(0xBu);
  if ( v5->useMutex )
    OS_MutexRelease(v5->commandMutex);
  if ( !v5->multiThread )
    RenderQueue::Process(v5);
  if ( v5->mainPointer + 1024 > v5->queueEnd )
    sub_1A148C(v5);
}

//----- (001D3310) --------------------------------------------------------
void __fastcall RQDrawIndexed(RQShader *withShader, RQDrawMode mode, unsigned int count, void *indexOffset)
{
  RenderQueue *v7; // r1
  unsigned __int8 *mainWorkPointer; // r2
  RenderQueue *v9; // r1
  RenderQueue *v10; // r1
  RenderQueue *v11; // r1
  RenderQueue *v12; // r4
  __int64 v13; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v15; // r2

  (*((void (__fastcall **)(RQShader *))withShader->_vptr$RQShader + 6))(withShader);
  v7 = renderQueue;
  mainWorkPointer = renderQueue->mainWorkPointer;
  renderQueue->curQueueingCommand = rqDrawIndexed;
  *(_DWORD *)mainWorkPointer = 14;
  v7->mainWorkPointer += 4;
  v9 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = mode;
  v9->mainWorkPointer += 4;
  v10 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = count;
  v10->mainWorkPointer += 4;
  v11 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = indexOffset;
  v11->mainWorkPointer += 4;
  v12 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v13 = *(_QWORD *)&v12->mainPointer;
  p_mainPointer = (unsigned int *)&v12->mainPointer;
  __dmb(0xBu);
  do
    v15 = __ldrex(p_mainPointer);
  while ( __strex(v15 + HIDWORD(v13) - v13, p_mainPointer) );
  __dmb(0xBu);
  if ( v12->useMutex )
    OS_MutexRelease(v12->commandMutex);
  if ( !v12->multiThread )
    RenderQueue::Process(v12);
  if ( v12->mainPointer + 1024 > v12->queueEnd )
    sub_1A148C(v12);
}

//----- (001D33F0) --------------------------------------------------------
void __fastcall RQDrawNonIndexed(RQShader *withShader, RQDrawMode mode, unsigned int offset, unsigned int count)
{
  RenderQueue *v7; // r1
  unsigned __int8 *mainWorkPointer; // r2
  RenderQueue *v9; // r1
  RenderQueue *v10; // r1
  RenderQueue *v11; // r1
  RenderQueue *v12; // r4
  __int64 v13; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v15; // r2

  (*((void (__fastcall **)(RQShader *))withShader->_vptr$RQShader + 6))(withShader);
  v7 = renderQueue;
  mainWorkPointer = renderQueue->mainWorkPointer;
  renderQueue->curQueueingCommand = rqDrawNonIndexed;
  *(_DWORD *)mainWorkPointer = 15;
  v7->mainWorkPointer += 4;
  v9 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = mode;
  v9->mainWorkPointer += 4;
  v10 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = offset;
  v10->mainWorkPointer += 4;
  v11 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = count;
  v11->mainWorkPointer += 4;
  v12 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v13 = *(_QWORD *)&v12->mainPointer;
  p_mainPointer = (unsigned int *)&v12->mainPointer;
  __dmb(0xBu);
  do
    v15 = __ldrex(p_mainPointer);
  while ( __strex(v15 + HIDWORD(v13) - v13, p_mainPointer) );
  __dmb(0xBu);
  if ( v12->useMutex )
    OS_MutexRelease(v12->commandMutex);
  if ( !v12->multiThread )
    RenderQueue::Process(v12);
  if ( v12->mainPointer + 1024 > v12->queueEnd )
    sub_1A148C(v12);
}

//----- (001D34D0) --------------------------------------------------------
bool __fastcall operator==(const RQMatrix *oneway, const RQMatrix *oranother)
{
  return memcmp(oneway, oranother, 0x40u) == 0;
}

//----- (001D34E6) --------------------------------------------------------
bool __fastcall operator!=(const RQMatrix *oneway, const RQMatrix *oranother)
{
  return memcmp(oneway, oranother, 0x40u) != 0;
}

//----- (001D34F8) --------------------------------------------------------
void __fastcall RQTexture::SetAniso(RQTexture *this, RQAnisoMode withAniso)
{
  RenderQueue *v2; // r3
  unsigned __int8 *mainWorkPointer; // r4
  RenderQueue *v4; // r3
  RenderQueue *v5; // r0
  RenderQueue *v6; // r4
  __int64 v7; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v9; // r2

  if ( this->anisoMode != withAniso )
  {
    this->anisoMode = withAniso;
    if ( RQCaps[7] )
    {
      v2 = renderQueue;
      mainWorkPointer = renderQueue->mainWorkPointer;
      renderQueue->curQueueingCommand = rqTextureAniso;
      *(_DWORD *)mainWorkPointer = 23;
      v2->mainWorkPointer += 4;
      v4 = renderQueue;
      *(_DWORD *)renderQueue->mainWorkPointer = this;
      v4->mainWorkPointer += 4;
      v5 = renderQueue;
      *(_DWORD *)renderQueue->mainWorkPointer = withAniso;
      v5->mainWorkPointer += 4;
      v6 = renderQueue;
      if ( renderQueue->useMutex )
        OS_MutexObtain(renderQueue->commandMutex);
      v7 = *(_QWORD *)&v6->mainPointer;
      p_mainPointer = (unsigned int *)&v6->mainPointer;
      __dmb(0xBu);
      do
        v9 = __ldrex(p_mainPointer);
      while ( __strex(v9 + HIDWORD(v7) - v7, p_mainPointer) );
      __dmb(0xBu);
      if ( v6->useMutex )
        OS_MutexRelease(v6->commandMutex);
      if ( !v6->multiThread )
        RenderQueue::Process(v6);
      if ( v6->mainPointer + 1024 > v6->queueEnd )
        sub_1A148C(v6);
    }
  }
}

//----- (001D35CC) --------------------------------------------------------
void __fastcall RQTexture::SetWrap(RQTexture *this, RQWrapMode x, RQWrapMode y)
{
  RQWrapMode xWrap; // r3
  bool v4; // zf
  RenderQueue *v5; // r1
  unsigned __int8 *mainWorkPointer; // r2
  RenderQueue *v7; // r1
  RenderQueue *v8; // r1
  RenderQueue *v9; // r1
  RenderQueue *v10; // r4
  __int64 v11; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v13; // r2

  xWrap = this->xWrap;
  v4 = xWrap == x;
  if ( xWrap == x )
    v4 = this->yWrap == y;
  if ( !v4 )
  {
    this->xWrap = x;
    this->yWrap = y;
    v5 = renderQueue;
    mainWorkPointer = renderQueue->mainWorkPointer;
    renderQueue->curQueueingCommand = rqTextureWrap;
    *(_DWORD *)mainWorkPointer = 21;
    v5->mainWorkPointer += 4;
    v7 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = this;
    v7->mainWorkPointer += 4;
    v8 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = this->xWrap;
    v8->mainWorkPointer += 4;
    v9 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = this->yWrap;
    v9->mainWorkPointer += 4;
    v10 = renderQueue;
    if ( renderQueue->useMutex )
      OS_MutexObtain(renderQueue->commandMutex);
    v11 = *(_QWORD *)&v10->mainPointer;
    p_mainPointer = (unsigned int *)&v10->mainPointer;
    __dmb(0xBu);
    do
      v13 = __ldrex(p_mainPointer);
    while ( __strex(v13 + HIDWORD(v11) - v11, p_mainPointer) );
    __dmb(0xBu);
    if ( v10->useMutex )
      OS_MutexRelease(v10->commandMutex);
    if ( !v10->multiThread )
      RenderQueue::Process(v10);
    if ( v10->mainPointer + 1024 > v10->queueEnd )
      sub_1A148C(v10);
  }
}

//----- (001D36AC) --------------------------------------------------------
void __fastcall RQTexture::SetMipMode(RQTexture *this, RQMipMode mode)
{
  RenderQueue *v2; // r3
  unsigned __int8 *mainWorkPointer; // r4
  RenderQueue *v4; // r3
  RenderQueue *v5; // r0
  RenderQueue *v6; // r4
  __int64 v7; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v9; // r2

  if ( this->hasMips )
    mode = MM_LinearLinear;
  if ( mode != this->mipMode )
  {
    this->mipMode = mode;
    v2 = renderQueue;
    mainWorkPointer = renderQueue->mainWorkPointer;
    renderQueue->curQueueingCommand = rqTextureMipMode;
    *(_DWORD *)mainWorkPointer = 20;
    v2->mainWorkPointer += 4;
    v4 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = this;
    v4->mainWorkPointer += 4;
    v5 = renderQueue;
    *(_DWORD *)renderQueue->mainWorkPointer = mode;
    v5->mainWorkPointer += 4;
    v6 = renderQueue;
    if ( renderQueue->useMutex )
      OS_MutexObtain(renderQueue->commandMutex);
    v7 = *(_QWORD *)&v6->mainPointer;
    p_mainPointer = (unsigned int *)&v6->mainPointer;
    __dmb(0xBu);
    do
      v9 = __ldrex(p_mainPointer);
    while ( __strex(v9 + HIDWORD(v7) - v7, p_mainPointer) );
    __dmb(0xBu);
    if ( v6->useMutex )
      OS_MutexRelease(v6->commandMutex);
    if ( !v6->multiThread )
      RenderQueue::Process(v6);
    if ( v6->mainPointer + 1024 > v6->queueEnd )
      sub_1A148C(v6);
  }
}

//----- (001D3778) --------------------------------------------------------
void __fastcall RQTexture::GetMipDimensions(const RQTexture *this, unsigned int mipLevel, int *x, int *y)
{
  __int64 v4; // kr00_8
  int v5; // lr
  int v6; // r12
  RQTextureFormat format; // r4
  int v8; // r0
  int v9; // r1
  int v10; // r4
  bool v11; // cc
  int v12; // r4

  v4 = *(_QWORD *)&this->width;
  v5 = 1;
  v6 = HIDWORD(v4) >> mipLevel;
  format = this->format;
  v8 = 1;
  if ( (int)(HIDWORD(v4) >> mipLevel) > 1 )
    v5 = HIDWORD(v4) >> mipLevel;
  v9 = (unsigned int)v4 >> mipLevel;
  if ( v9 > 1 )
    v8 = v9;
  if ( (unsigned int)format > TF_ETC1 )
    goto LABEL_24;
  if ( ((1 << format) & (unsigned int)&stru_43F7C.st_value) != 0 )
  {
    v10 = 4;
    if ( v8 <= 4 )
      v9 = 4;
    v11 = v5 <= 4;
LABEL_15:
    *x = v9;
    if ( v11 )
      v6 = v10;
    v5 = v6;
    goto LABEL_18;
  }
  v12 = 1 << format;
  if ( (v12 & 0xC000) == 0 )
  {
    if ( (v12 & 0x30000) != 0 )
    {
      v10 = 8;
      if ( v8 <= 8 )
        v9 = 8;
      v11 = v5 <= 8;
      goto LABEL_15;
    }
LABEL_24:
    *x = v8;
    goto LABEL_18;
  }
  if ( v8 <= 16 )
    v9 = 16;
  *x = v9;
  if ( v5 <= 8 )
    v6 = 8;
  v5 = v6;
LABEL_18:
  *y = v5;
}
// 43F7C: using guessed type Elf32_Sym stru_43F7C;

//----- (001D3814) --------------------------------------------------------
unsigned int __fastcall RQTexture::GetTextureSize(unsigned int w, unsigned int h, RQTextureFormat format)
{
  unsigned int result; // r0
  unsigned int v4; // r2
  unsigned int v5; // r2
  unsigned int v6; // r2
  unsigned int v7; // r2

  switch ( format )
  {
    case TF_RGBA_8888:
      result = 4 * w * h;
      break;
    case TF_RGB_888:
      result = 3 * w * h;
      break;
    case TF_RGB_565:
    case TF_RGBA_5551:
    case TF_RGBA_4444:
    case TF_LA_88:
      result = 2 * w * h;
      break;
    case TF_L_8:
      result = w * h;
      break;
    case TF_DXT1:
    case TF_DXT1A:
    case TF_ATC_NoAlpha:
    case TF_ETC1:
      v4 = 4;
      if ( w <= 4 )
        w = 4;
      if ( h > 4 )
        v4 = h;
      result = (w * v4) >> 1;
      break;
    case TF_DXT3:
    case TF_DXT5:
    case TF_ATC_InterpAlpha:
    case TF_ATC_ExplicitAlpha:
      v5 = 4;
      if ( w <= 4 )
        w = 4;
      if ( h > 4 )
        v5 = h;
      result = w * v5;
      break;
    case TF_PVR_2BPP_RGB:
    case TF_PVR_2BPP_RGBA:
      v6 = 8;
      if ( (int)h <= 8 )
        h = 8;
      if ( (int)w > 8 )
        v6 = w;
      result = (2 * v6 * h + 7) >> 3;
      break;
    case TF_PVR_4BPP_RGB:
    case TF_PVR_4BPP_RGBA:
      v7 = 8;
      if ( (int)h <= 8 )
        h = 8;
      if ( (int)w > 8 )
        v7 = w;
      result = (4 * v7 * h + 7) >> 3;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (001D38AC) --------------------------------------------------------
unsigned int __fastcall RQTexture::GetMipOffset(
        unsigned int w,
        unsigned int h,
        RQTextureFormat format,
        unsigned int forMip)
{
  unsigned int result; // r0
  unsigned int v6; // r11
  unsigned int v7; // r8
  unsigned int v8; // r5
  signed int v9; // r9
  signed int v10; // r6
  signed int v11; // r10
  int v12; // r4
  int v13; // r5
  int v14; // r4
  int v15; // r5
  int v16; // r4

  result = 0;
  if ( forMip && (int)(h * w) >= 2 )
  {
    result = 0;
    v6 = 0;
    do
    {
      v8 = h >> v6;
      v9 = 1;
      v10 = w >> v6;
      if ( (int)(h >> v6) > 1 )
        v9 = h >> v6;
      v11 = 1;
      if ( v10 > 1 )
        v11 = w >> v6;
      switch ( format )
      {
        case TF_RGBA_8888:
          v7 = 4 * v11 * v9;
          break;
        case TF_RGB_888:
          v7 = 3 * v11 * v9;
          break;
        case TF_RGB_565:
        case TF_RGBA_5551:
        case TF_RGBA_4444:
        case TF_LA_88:
          v7 = 2 * v11 * v9;
          break;
        case TF_L_8:
          v7 = v9 * v11;
          break;
        case TF_DXT1:
        case TF_DXT1A:
        case TF_ATC_NoAlpha:
        case TF_ETC1:
          v12 = 4;
          if ( (unsigned int)v11 > 4 )
            v12 = v11;
          v13 = 4;
          if ( (unsigned int)v9 > 4 )
            v13 = v9;
          v7 = (unsigned int)(v12 * v13) >> 1;
          break;
        case TF_DXT3:
        case TF_DXT5:
        case TF_ATC_InterpAlpha:
        case TF_ATC_ExplicitAlpha:
          v14 = 4;
          if ( (unsigned int)v11 > 4 )
            v14 = v11;
          v15 = 4;
          if ( (unsigned int)v9 > 4 )
            v15 = v9;
          v7 = v15 * v14;
          break;
        case TF_PVR_2BPP_RGB:
        case TF_PVR_2BPP_RGBA:
          v16 = 16;
          if ( v9 <= 8 )
            v8 = 8;
          if ( v11 > 8 )
            v16 = 2 * v10;
          goto LABEL_35;
        case TF_PVR_4BPP_RGB:
        case TF_PVR_4BPP_RGBA:
          v16 = 32;
          if ( v9 <= 8 )
            v8 = 8;
          if ( v11 > 8 )
            v16 = 4 * v10;
LABEL_35:
          v7 = (v16 * v8 + 7) >> 3;
          break;
        default:
          v7 = 0;
          break;
      }
      ++v6;
      result += v7;
    }
    while ( v6 < forMip && (unsigned int)(v9 * v11) > 1 );
  }
  return result;
}

//----- (001D39C4) --------------------------------------------------------
unsigned int __fastcall RQTexture::GetMipSize(const RQTexture *this, unsigned int mipLevel)
{
  signed int v2; // r12
  RQTextureFormat format; // r3
  signed int v4; // r2
  int v5; // lr
  signed int v6; // r1
  unsigned int v7; // r0
  int v8; // r4
  int v9; // r0
  unsigned int result; // r0
  int v11; // r0
  int v12; // r0
  int v13; // r0
  int v14; // r0

  v2 = 1;
  format = this->format;
  v4 = this->height >> mipLevel;
  v5 = 1;
  if ( v4 > 1 )
    v2 = this->height >> mipLevel;
  v6 = this->width >> mipLevel;
  v7 = format - 7;
  if ( v6 > 1 )
    v5 = v6;
  if ( v7 <= 0xB )
  {
    v8 = dword_1D3AC0[v7];
    v9 = dword_1D3AF0[v7];
    if ( v2 <= v8 )
      v4 = v8;
    if ( v5 <= v9 )
      v6 = v9;
    v2 = v4;
    v5 = v6;
  }
  switch ( format )
  {
    case TF_RGBA_8888:
      result = 4 * v5 * v2;
      break;
    case TF_RGB_888:
      result = 3 * v5 * v2;
      break;
    case TF_RGB_565:
    case TF_RGBA_5551:
    case TF_RGBA_4444:
    case TF_LA_88:
      result = 2 * v5 * v2;
      break;
    case TF_L_8:
      result = v2 * v5;
      break;
    case TF_DXT1:
    case TF_DXT1A:
    case TF_ATC_NoAlpha:
    case TF_ETC1:
      v11 = 4;
      if ( (unsigned int)v5 <= 4 )
        v5 = 4;
      if ( (unsigned int)v2 > 4 )
        v11 = v2;
      result = (unsigned int)(v11 * v5) >> 1;
      break;
    case TF_DXT3:
    case TF_DXT5:
    case TF_ATC_InterpAlpha:
    case TF_ATC_ExplicitAlpha:
      v12 = 4;
      if ( (unsigned int)v5 <= 4 )
        v5 = 4;
      if ( (unsigned int)v2 > 4 )
        v12 = v2;
      result = v12 * v5;
      break;
    case TF_PVR_2BPP_RGB:
    case TF_PVR_2BPP_RGBA:
      v13 = 8;
      if ( v2 <= 8 )
        v2 = 8;
      if ( v5 > 8 )
        v13 = v5;
      result = (unsigned int)(2 * v13 * v2 + 7) >> 3;
      break;
    case TF_PVR_4BPP_RGB:
    case TF_PVR_4BPP_RGBA:
      v14 = 8;
      if ( v2 <= 8 )
        v2 = 8;
      if ( v5 > 8 )
        v14 = v5;
      result = (unsigned int)(4 * v14 * v2 + 7) >> 3;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 1D3AC0: using guessed type int dword_1D3AC0[12];
// 1D3AF0: using guessed type int dword_1D3AF0[12];

//----- (001D3B20) --------------------------------------------------------
unsigned int __fastcall RQTexture::GetNumComponents(const RQTexture *this)
{
  RQTextureFormat format; // r0

  format = this->format;
  if ( (unsigned int)format <= TF_ETC1 )
    return dword_5EC7E0[format];
  else
    return 0;
}
// 5EC7E0: using guessed type _DWORD dword_5EC7E0[19];

//----- (001D3B38) --------------------------------------------------------
void __fastcall RQRenderTarget::Viewport(int x, int y, unsigned int width, unsigned int height)
{
  RenderQueue *v4; // r4
  unsigned __int8 *mainWorkPointer; // lr
  RenderQueue *v6; // r5
  RenderQueue *v7; // r0
  RenderQueue *v8; // r0
  RenderQueue *v9; // r0
  RenderQueue *v10; // r4
  __int64 v11; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v13; // r2

  v4 = renderQueue;
  mainWorkPointer = renderQueue->mainWorkPointer;
  renderQueue->curQueueingCommand = rqTargetViewport;
  *(_DWORD *)mainWorkPointer = 29;
  v4->mainWorkPointer += 4;
  v6 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = x;
  v6->mainWorkPointer += 4;
  v7 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = y;
  v7->mainWorkPointer += 4;
  v8 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = width;
  v8->mainWorkPointer += 4;
  v9 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = height;
  v9->mainWorkPointer += 4;
  v10 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v11 = *(_QWORD *)&v10->mainPointer;
  p_mainPointer = (unsigned int *)&v10->mainPointer;
  __dmb(0xBu);
  do
    v13 = __ldrex(p_mainPointer);
  while ( __strex(v13 + HIDWORD(v11) - v11, p_mainPointer) );
  __dmb(0xBu);
  if ( v10->useMutex )
    OS_MutexRelease(v10->commandMutex);
  if ( !v10->multiThread )
    RenderQueue::Process(v10);
  if ( v10->mainPointer + 1024 > v10->queueEnd )
    sub_1A148C(v10);
}

//----- (001D3C24) --------------------------------------------------------
void __fastcall RQRenderTarget::Clear(unsigned int flags, float *color, float depth, int stencil)
{
  RenderQueue *v4; // r4
  unsigned __int8 *mainWorkPointer; // lr
  RenderQueue *v6; // r5
  RenderQueue *v7; // r0
  unsigned __int8 *v8; // r1
  RenderQueue *v9; // r0
  RenderQueue *v10; // r0
  RenderQueue *v11; // r4
  __int64 v12; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v14; // r2
  __int64 v15; // [sp+0h] [bp-18h]
  __int64 v16; // [sp+8h] [bp-10h]

  v4 = renderQueue;
  mainWorkPointer = renderQueue->mainWorkPointer;
  renderQueue->curQueueingCommand = rqTargetClear;
  *(_DWORD *)mainWorkPointer = 30;
  v4->mainWorkPointer += 4;
  v6 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = flags;
  v6->mainWorkPointer += 4;
  v7 = renderQueue;
  v15 = *(_QWORD *)color;
  v16 = *((_QWORD *)color + 1);
  v8 = renderQueue->mainWorkPointer;
  *(_QWORD *)v8 = v15;
  *((_QWORD *)v8 + 1) = v16;
  v7->mainWorkPointer += 16;
  v9 = renderQueue;
  *(float *)renderQueue->mainWorkPointer = depth;
  v9->mainWorkPointer += 4;
  v10 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = stencil;
  v10->mainWorkPointer += 4;
  v11 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v12 = *(_QWORD *)&v11->mainPointer;
  p_mainPointer = (unsigned int *)&v11->mainPointer;
  __dmb(0xBu);
  do
    v14 = __ldrex(p_mainPointer);
  while ( __strex(v14 + HIDWORD(v12) - v12, p_mainPointer) );
  __dmb(0xBu);
  if ( v11->useMutex )
    OS_MutexRelease(v11->commandMutex);
  if ( !v11->multiThread )
    RenderQueue::Process(v11);
  if ( v11->mainPointer + 1024 > v11->queueEnd )
    sub_1A148C(v11);
}

//----- (001D3D20) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall RQTexture::ConvertToRaw32(
        unsigned __int8 *rawData,
        unsigned __int8 *srcData,
        unsigned int w,
        unsigned int h,
        RQTextureFormat a5)
{
  char *v5; // r5
  unsigned int v6; // r6
  void *v7; // r4
  unsigned int v8; // r4
  unsigned __int8 *v9; // r0
  bool v10; // cc
  __int128 v11; // q8
  char *v12; // r0
  unsigned __int8 *v13; // r2
  unsigned int v14; // r3
  unsigned __int8 *v15; // r1
  __int128 v16; // q12 OVERLAPPED
  char *v17; // r5
  unsigned int v18; // lr
  unsigned __int8 *v19; // r0
  bool v20; // cc
  __int64 v21; // d30
  __int64 v22; // d31
  unsigned __int8 *v23; // r2
  char *v24; // r0
  unsigned int v25; // r3
  unsigned __int8 *v26; // r4
  int64x2_t v27; // q8
  int64x2_t v28; // q6
  int8x16_t v29; // q7
  uint16x8_t v30; // q9
  int64x2_t v31; // q11
  uint16x8_t v32; // q10
  uint16x8_t v33; // q8
  int64x2_t v34; // q2
  uint16x8_t v35; // q11
  int64x2_t v36; // q9
  uint16x8_t v37; // q10
  int32x4_t v38; // q6
  uint16x8_t v39; // q9
  int64x2_t v40; // q7
  int64x2_t v41; // q5
  int64x2_t v42; // q5
  int64x2_t v43; // q2
  int16x8_t v44; // q9
  int64x2_t v45; // q8
  uint32x4_t v46; // q7
  int64x2_t v47; // q10
  int16x8_t v48; // q11
  unsigned __int64 v49; // d25
  unsigned __int64 v50; // d24
  unsigned __int64 v51; // d29
  unsigned __int64 v52; // d28
  unsigned __int64 v53; // d27
  unsigned __int64 v54; // d26
  char *v55; // r5
  int v56; // r0
  unsigned int v57; // r4
  unsigned __int8 *v58; // r0
  bool v59; // cc
  int64x2_t v60; // q10
  unsigned __int8 *v61; // r12
  int64x2_t v62; // q11
  char *v63; // lr
  unsigned int v64; // r0
  unsigned __int8 *v65; // r2
  int64x2_t v66; // q8
  const char *v67; // r3
  int64x2_t v68; // q2
  int64x2_t v69; // q4
  uint16x8_t v70; // q6
  uint32x4_t v71; // q8
  int64x2_t v72; // q1
  int32x4_t v73; // q0
  uint16x8_t v74; // q1
  uint16x8_t v75; // q8
  int32x4_t v76; // q3
  int32x4_t v77; // q5 OVERLAPPED
  uint16x8_t v78; // q8
  int32x4_t v79; // q2
  uint32x4_t v80; // q4
  uint16x8_t v81; // q9
  int32x4_t v82; // q8
  int16x8_t v83; // q4
  int64x2_t v84; // q9
  uint16x8_t v85; // q9
  int16x8_t v86; // q12
  int64x2_t v87; // q9
  int16x8_t v88; // q15
  int64x2_t v89; // q9
  int8x16_t v90; // q9
  int8x16_t v91; // q8
  char *v92; // r5
  int v93; // r0
  unsigned int v94; // r4
  unsigned __int8 *v95; // r0
  bool v96; // cc
  int64x2_t v97; // q8
  unsigned __int8 *v98; // r12
  char *v99; // r3
  unsigned int v100; // r0
  const char *v101; // r2
  int64x2_t v102; // q0 OVERLAPPED
  int8x16_t v103; // q1
  int64x2_t v104; // q2
  int8x16_t v105; // q3
  char *v106; // r5
  unsigned int v107; // r1
  unsigned __int8 v108; // r6
  unsigned int v109; // r1
  unsigned int v110; // r6
  unsigned int v111; // r0
  unsigned __int8 v112; // t1
  unsigned int v113; // r0
  unsigned __int8 v114; // t1
  int64x2_t v115; // [sp+0h] [bp-68h]
  int8x8x3_t v116; // 0:d18.8,8:d20.8,16:d22.8 OVERLAPPED
  int8x8x3_t v117; // 0:d19.8,8:d21.8,16:d23.8 OVERLAPPED
  int8x8x4_t v118; // 0:d0.8,8:d1.8,16:d2.8,24:d3.8
  int8x8x4_t v119; // 0:d6.8,8:d7.8,16:d8.8,24:d9.8
  int8x8x4_t v120; // 0:d12.8,8:d13.8,16:d14.8,24:d15.8
  int8x8x4_t v121; // 0:d18.8,8:d19.8,16:d20.8,24:d21.8
  int8x8x4_t v122; // 0:d22.8,8:d23.8,16:d24.8,24:d25.8
  int8x8x4_t v123; // 0:d26.8,8:d27.8,16:d28.8,24:d29.8 OVERLAPPED

  v5 = (char *)rawData;
  v6 = h * w;
  switch ( a5 )
  {
    case TF_RGBA_8888:
      sub_19EA98(rawData, srcData, 4 * v6);
      return;
    case TF_RGB_888:
      if ( !v6 )
        return;
      if ( v6 <= 0xF )
        goto LABEL_46;
      v8 = v6 - (v6 & 0xF);
      if ( v6 == (v6 & 0xF) )
        goto LABEL_46;
      v9 = &srcData[3 * v6];
      v10 = v9 > (unsigned __int8 *)v5;
      if ( v9 > (unsigned __int8 *)v5 )
        v10 = &v5[4 * v6] > (char *)srcData;
      if ( v10 )
      {
LABEL_46:
        v8 = 0;
        v12 = v5;
        v13 = srcData;
      }
      else
      {
        *(_QWORD *)&v11 = -1LL;
        *((_QWORD *)&v11 + 1) = -1LL;
        v12 = &v5[4 * v8];
        v13 = &srcData[3 * v8];
        v14 = v6 - (v6 & 0xF);
        do
        {
          v116 = vld3_s8((const char *)srcData);
          v15 = srcData + 24;
          v14 -= 16;
          v117 = vld3_s8((const char *)v15);
          srcData = v15 + 24;
          v16 = v11;
          vst4_s8(v5, *(int8x8x4_t *)v116.val[0].n64_u64);
          v17 = v5 + 32;
          vst4_s8(v17, *(int8x8x4_t *)v117.val[0].n64_u64);
          v5 = v17 + 32;
        }
        while ( v14 );
        if ( (v6 & 0xF) == 0 )
          return;
      }
      v107 = v6 - v8;
      do
      {
        --v107;
        *v12 = *v13;
        v12[1] = v13[1];
        v108 = v13[2];
        v13 += 3;
        v12[3] = -1;
        v12[2] = v108;
        v12 += 4;
      }
      while ( v107 );
      return;
    case TF_RGB_565:
      if ( !v6 )
        return;
      if ( v6 <= 0xF )
        goto LABEL_50;
      v18 = v6 - (v6 & 0xF);
      if ( v6 == (v6 & 0xF) )
        goto LABEL_50;
      v19 = &srcData[2 * v6];
      v20 = v19 > (unsigned __int8 *)v5;
      if ( v19 > (unsigned __int8 *)v5 )
        v20 = &v5[4 * v6] > (char *)srcData;
      if ( v20 )
      {
LABEL_50:
        v18 = 0;
        v24 = v5;
        v23 = srcData;
LABEL_51:
        v109 = v6 - v18;
        do
        {
          --v109;
          *v24 = *v23 & 0xF8 | (*v23 >> 5);
          v24[1] = (*v23 >> 1) & 3 | (32 * *v23) | ((unsigned __int8)(v23[1] & 0xE0) >> 3);
          v110 = v23[1];
          v23 += 2;
          v24[3] = -1;
          v24[2] = (v110 >> 2) & 7 | (8 * v110);
          v24 += 4;
        }
        while ( v109 );
        return;
      }
      v21 = -1LL;
      v22 = -1LL;
      v23 = &srcData[2 * v18];
      v24 = &v5[4 * v18];
      v25 = v6 - (v6 & 0xF);
      v26 = srcData;
      do
      {
        v118 = vld2q_s8((const char *)v26);
        v26 += 32;
        v27.n128_u64[0] = 0x606060606060606LL;
        v27.n128_u64[1] = 0x606060606060606LL;
        v25 -= 16;
        v28 = vandq_s64(*(int64x2_t *)v118.val[0].n64_u64, v27);
        v119 = vld2q_s8((const char *)srcData);
        v29 = vshlq_n_s8(*(int8x16_t *)v118.val[0].n64_u64, 5u);
        srcData = v26;
        v27.n128_u64[0] = 0xE0E0E0E0E0E0E0E0LL;
        v27.n128_u64[1] = 0xE0E0E0E0E0E0E0E0LL;
        v30 = vmovl_u8(*(uint8x8_t *)&v28.n128_i8[8]);
        v31 = vandq_s64(*(int64x2_t *)v119.val[2].n64_u64, v27);
        v32 = vmovl_u8(*(uint8x8_t *)&v29.n128_i8[8]);
        *(int8x16_t *)v118.val[0].n64_u64 = vshlq_n_s8(*(int8x16_t *)v118.val[2].n64_u64, 3u);
        v33 = vmovl_u8(*(uint8x8_t *)&v31.n128_i8[8]);
        v34 = vorrq_s64(
                vshrq_n_u32(vmovl_u16(*(uint16x4_t *)&v30.n128_i8[8]), 1u),
                vmovl_u16(*(uint16x4_t *)&v32.n128_i8[8]));
        v35 = vmovl_u8((uint8x8_t)v31.n128_u64[0]);
        v36 = vorrq_s64(vshrq_n_u32(vmovl_u16((uint16x4_t)v30.n128_u64[0]), 1u), vmovl_u16((uint16x4_t)v32.n128_u64[0]));
        v37 = vmovl_u8((uint8x8_t)v28.n128_u64[0]);
        v38 = vorrq_s64(v36, vshrq_n_u32(vmovl_u16((uint16x4_t)v33.n128_u64[0]), 3u));
        v39 = vmovl_u8((uint8x8_t)v29.n128_u64[0]);
        v40 = vmovl_u16((uint16x4_t)v39.n128_u64[0]);
        v115 = vorrq_s64(v34, vshrq_n_u32(vmovl_u16(*(uint16x4_t *)&v33.n128_i8[8]), 3u));
        v41.n128_u64[0] = 0xF8F8F8F8F8F8F8F8LL;
        v41.n128_u64[1] = 0xF8F8F8F8F8F8F8F8LL;
        v42 = vandq_s64(*(int64x2_t *)v119.val[0].n64_u64, v41);
        v34.n128_u64[0] = 0x1C1C1C1C1C1C1C1CLL;
        v34.n128_u64[1] = 0x1C1C1C1C1C1C1C1CLL;
        v43 = vandq_s64(*(int64x2_t *)v118.val[2].n64_u64, v34);
        v44 = vorrq_s64(
                vorrq_s64(
                  vshrq_n_u32(vmovl_u16(*(uint16x4_t *)&v37.n128_i8[8]), 1u),
                  vmovl_u16(*(uint16x4_t *)&v39.n128_i8[8])),
                vshrq_n_u32(vmovl_u16(*(uint16x4_t *)&v35.n128_i8[8]), 3u));
        v45 = vorrq_s64(vshrq_n_u32(vmovl_u16((uint16x4_t)v37.n128_u64[0]), 1u), v40);
        v46 = vmovl_u16((uint16x4_t)v35.n128_u64[0]);
        v47 = vshrq_n_u16(vmovl_u8(v119.val[1]), 5u);
        *(int64x2_t *)v118.val[2].n64_u64 = vorrq_s64(
                                              vshrq_n_u16(vmovl_u8(v119.val[0]), 5u),
                                              vmovl_u8((uint8x8_t)v42.n128_u64[0]));
        *(uint16x8_t *)v119.val[0].n64_u64 = vmovl_u8(v118.val[1]);
        v48 = vorrq_s64(vshrq_n_u16(vmovl_u8((uint8x8_t)v43.n128_u64[0]), 2u), vmovl_u8(v118.val[0]));
        v118.val[0].n64_u64[0] = v115.n128_u64[0];
        v118.val[1].n64_u64[0] = v115.n128_u64[1];
        v49 = vmovn_s16(vorrq_s64(v47, vmovl_u8(*(uint8x8_t *)&v42.n128_i8[8]))).n64_u64[0];
        v118.val[1] = vmovn_s32(*(int32x4_t *)v118.val[0].n64_u64);
        v50 = vmovn_s16(*(int16x8_t *)v118.val[2].n64_u64).n64_u64[0];
        *(int16x4_t *)&v44.n128_i8[8] = vmovn_s32(v44);
        v51 = vmovn_s16(vorrq_s64(vshrq_n_u16(vmovl_u8(*(uint8x8_t *)&v43.n128_i8[8]), 2u), *(int64x2_t *)v119.val[0].n64_u64)).n64_u64[0];
        v118.val[0] = vmovn_s32(v38);
        v52 = vmovn_s16(v48).n64_u64[0];
        v44.n128_u64[0] = vmovn_s32(vorrq_s64(v45, vshrq_n_u32(v46, 3u))).n64_u64[0];
        v53 = vmovn_s16(*(int16x8_t *)v118.val[0].n64_u64).n64_u64[0];
        v54 = vmovn_s16(v44).n64_u64[0];
        vst4_s8(v5, *(int8x8x4_t *)(&v21 - 3));
        v55 = v5 + 32;
        vst4_s8(v55, *(int8x8x4_t *)(&v22 - 3));
        v5 = v55 + 32;
      }
      while ( v25 );
      if ( (v6 & 0xF) != 0 )
        goto LABEL_51;
      return;
    case TF_RGBA_5551:
      if ( v6 )
      {
        if ( v6 <= 0xF )
          goto LABEL_54;
        v56 = v6 & 0xF;
        if ( (v6 & 0xF) == 0 )
          v56 = 16;
        v57 = v6 - v56;
        if ( v6 == v56 )
          goto LABEL_54;
        v58 = &srcData[(2 * v6) | 1];
        v59 = v58 > (unsigned __int8 *)v5;
        if ( v58 > (unsigned __int8 *)v5 )
          v59 = &v5[4 * v6] > (char *)srcData;
        if ( v59 )
        {
LABEL_54:
          v57 = 0;
        }
        else
        {
          v60.n128_u64[0] = 0xF8000000F8LL;
          v60.n128_u64[1] = 0xF8000000F8LL;
          v61 = &srcData[2 * v57];
          v62.n128_u64[0] = 0x700000007LL;
          v62.n128_u64[1] = 0x700000007LL;
          v63 = &v5[4 * v57];
          v64 = v57;
          v65 = srcData;
          do
          {
            v123 = vld2q_s8((const char *)v65);
            v65 += 32;
            v66.n128_u64[0] = 0xC0C0C0C0C0C0C0C0LL;
            v66.n128_u64[1] = 0xC0C0C0C0C0C0C0C0LL;
            v67 = (const char *)(srcData + 1);
            v64 -= 16;
            v68 = vandq_s64(*(int64x2_t *)v123.val[2].n64_u64, v66);
            v66.n128_u64[0] = 0x707070707070707LL;
            v66.n128_u64[1] = 0x707070707070707LL;
            *(uint16x8_t *)v123.val[2].n64_u64 = vmovl_u8(*(uint8x8_t *)&v68.n128_i8[8]);
            v69 = vorrq_s64(
                    vandq_s64(*(int64x2_t *)v123.val[0].n64_u64, v66),
                    vshlq_n_s8(*(int8x16_t *)v123.val[0].n64_u64, 5u));
            v70 = vmovl_u8((uint8x8_t)v68.n128_u64[0]);
            *(uint16x8_t *)v123.val[0].n64_u64 = vmovl_u8(*(uint8x8_t *)&v69.n128_i8[8]);
            v71 = vmovl_u16(v123.val[2]);
            v72 = vshrq_n_u32(vmovl_u16(v123.val[3]), 3u);
            *(int8x8x4_t *)((char *)&v123 + 16) = vld2q_s8(v67);
            v73 = vorrq_s64(v72, vmovl_u16(v123.val[1]));
            v74 = vmovl_u8(v123.val[2]);
            v123.val[1] = vmovn_s32(v73);
            v123.val[0] = vmovn_s32(vorrq_s64(vshrq_n_u32(v71, 3u), vmovl_u16(v123.val[0])));
            v75 = vmovl_u8(v123.val[3]);
            v76 = vorrq_s64(
                    vandq_s64(vshll_n_u16((uint16x4_t)v75.n128_u64[0], 2u), v60),
                    vandq_s64(vshrq_n_u32(vmovl_u16((uint16x4_t)v75.n128_u64[0]), 3u), v62));
            v77 = vorrq_s64(
                    vandq_s64(vshll_n_u16(*(uint16x4_t *)&v75.n128_i8[8], 2u), v60),
                    vandq_s64(vshrq_n_u32(vmovl_u16(*(uint16x4_t *)&v75.n128_i8[8]), 3u), v62));
            v78 = vmovl_u8((uint8x8_t)v69.n128_u64[0]);
            v79 = vorrq_s64(
                    vshrq_n_u32(vmovl_u16((uint16x4_t)v70.n128_u64[0]), 3u),
                    vmovl_u16((uint16x4_t)v78.n128_u64[0]));
            v80 = vmovl_u16(*(uint16x4_t *)&v70.n128_i8[8]);
            v120 = vld2q_s8((const char *)srcData);
            srcData = v65;
            v81 = vmovl_u8(v120.val[0]);
            v82 = vorrq_s64(vshrq_n_u32(v80, 3u), vmovl_u16(*(uint16x4_t *)&v78.n128_i8[8]));
            v83 = vmovl_u16(*(uint16x4_t *)&v81.n128_i8[8]);
            v84 = vmovl_u16((uint16x4_t)v81.n128_u64[0]);
            *(int16x4_t *)&v83.n128_i8[8] = vmovn_s32(vorrq_s64(vandq_s64(v83, v60), vshrq_n_u32(v83, 5u)));
            v83.n128_u64[0] = vmovn_s32(vorrq_s64(vandq_s64(v84, v60), vshrq_n_u32(v84, 5u))).n64_u64[0];
            v85 = vmovl_u8(v120.val[1]);
            v86 = vmovl_u16(*(uint16x4_t *)&v85.n128_i8[8]);
            v87 = vmovl_u16((uint16x4_t)v85.n128_u64[0]);
            *(int16x4_t *)&v86.n128_i8[8] = vmovn_s32(vorrq_s64(vandq_s64(v86, v60), vshrq_n_u32(v86, 5u)));
            v86.n128_u64[0] = vmovn_s32(vorrq_s64(vandq_s64(v87, v60), vshrq_n_u32(v87, 5u))).n64_u64[0];
            v89 = v88;
            v123.val[2].n64_u64[0] = 0x101010101010101LL;
            v123.val[3].n64_u64[0] = 0x101010101010101LL;
            *(int16x4_t *)&v88.n128_i8[8] = vmovn_s32(v77);
            v90 = vandq_s64(v89, *(int64x2_t *)v123.val[2].n64_u64);
            v123.val[3] = vmovn_s32(v82);
            v123.val[2] = vmovn_s32(v79);
            v91 = vnegq_s8(v90);
            *(int8x8_t *)&v77.n128_i8[8] = vmovn_s16(v86);
            v77.n128_u64[0] = vmovn_s16(v83).n64_u64[0];
            v120.val[1] = vmovn_s16(*(int16x8_t *)v123.val[0].n64_u64);
            *(int16x4_t *)&v90.n128_i8[8] = vmovn_s32(
                                              vorrq_s64(
                                                vandq_s64(vshll_n_u16(*(uint16x4_t *)&v74.n128_i8[8], 2u), v60),
                                                vandq_s64(
                                                  vshrq_n_u32(vmovl_u16(*(uint16x4_t *)&v74.n128_i8[8]), 3u),
                                                  v62)));
            v88.n128_u64[0] = vmovn_s32(v76).n64_u64[0];
            v120.val[0] = vmovn_s16(*(int16x8_t *)v123.val[2].n64_u64);
            v90.n128_u64[0] = vmovn_s32(
                                vorrq_s64(
                                  vandq_s64(vshll_n_u16((uint16x4_t)v74.n128_u64[0], 2u), v60),
                                  vandq_s64(vshrq_n_u32(vmovl_u16((uint16x4_t)v74.n128_u64[0]), 3u), v62))).n64_u64[0];
            v120.val[3] = vmovn_s16(v88);
            v120.val[2] = vmovn_s16(v90);
            vst4_s8(v5, *(int8x8x4_t *)v77.n128_u64);
            v92 = v5 + 32;
            vst4_s8(v92, *(int8x8x4_t *)&v77.n128_i8[8]);
            v5 = v92 + 32;
          }
          while ( v64 );
          v5 = v63;
          srcData = v61;
        }
        v111 = v6 - v57;
        do
        {
          --v111;
          *v5 = *srcData & 0xF8 | (*srcData >> 5);
          v5[1] = *srcData & 7 | (32 * *srcData) | ((unsigned __int8)(srcData[1] & 0xC0) >> 3);
          v5[2] = (srcData[1] >> 3) & 7 | (4 * srcData[1]) & 0xF8;
          v112 = srcData[2];
          srcData += 2;
          v5[3] = -(v112 & 1);
          v5 += 4;
        }
        while ( v111 );
      }
      return;
    case TF_RGBA_4444:
      if ( v6 )
      {
        if ( v6 <= 0xF )
          goto LABEL_58;
        v93 = v6 & 0xF;
        if ( (v6 & 0xF) == 0 )
          v93 = 16;
        v94 = v6 - v93;
        if ( v6 == v93 )
          goto LABEL_58;
        v95 = &srcData[(2 * v6) | 1];
        v96 = v95 > (unsigned __int8 *)v5;
        if ( v95 > (unsigned __int8 *)v5 )
          v96 = &v5[4 * v6] > (char *)srcData;
        if ( v96 )
        {
LABEL_58:
          v94 = 0;
        }
        else
        {
          v97.n128_u64[0] = 0xF0F0F0F0F0F0F0F0LL;
          v97.n128_u64[1] = 0xF0F0F0F0F0F0F0F0LL;
          v98 = &srcData[2 * v94];
          v99 = &v5[4 * v94];
          v100 = v94;
          do
          {
            v101 = (const char *)(srcData + 1);
            v121 = vld2q_s8((const char *)srcData);
            srcData += 32;
            v100 -= 16;
            v122 = vld2q_s8(v101);
            v102 = vandq_s64(*(int64x2_t *)v121.val[0].n64_u64, v97);
            v103 = vshlq_n_s8(*(int8x16_t *)v121.val[0].n64_u64, 4u);
            v104 = vandq_s64(*(int64x2_t *)v122.val[0].n64_u64, v97);
            v105 = vshlq_n_s8(*(int8x16_t *)v122.val[2].n64_u64, 4u);
            vst4_s8(v5, *(int8x8x4_t *)v102.n128_u64);
            v106 = v5 + 32;
            vst4_s8(v106, *(int8x8x4_t *)&v102.n128_i8[8]);
            v5 = v106 + 32;
          }
          while ( v100 );
          v5 = v99;
          srcData = v98;
        }
        v113 = v6 - v94;
        do
        {
          --v113;
          *v5 = *srcData & 0xF0;
          v5[1] = 16 * *srcData;
          v5[2] = srcData[1] & 0xF0;
          v114 = srcData[2];
          srcData += 2;
          v5[3] = 16 * v114;
          v5 += 4;
        }
        while ( v113 );
      }
      return;
    case TF_DXT1:
    case TF_DXT1A:
    case TF_DXT3:
    case TF_DXT5:
      v7 = ConvertDXTToRaw8888(srcData, a5, w, h);
      qmemcpy(v5, v7, 4 * v6);
      j_free(v7);
      return;
    default:
      return;
  }
}
// 1D3D20: fragmented variable at d30.8 may be wrong
// 1D3D20: fragmented variable at d31.8 may be wrong
// 1D3DE1: failed to expand linear variable 0:d18.8,8:d20.8,16:d22.8
// 1D3DE7: failed to expand linear variable 0:d19.8,8:d21.8,16:d23.8
// 1D3FC3: failed to expand linear variable 0:d26.8,8:d27.8,16:d28.8,24:d29.8
// 1D4087: failed to expand linear variable q5.16
// 1D419F: failed to expand linear variable q0.16
// 1D3D20: using guessed type int64x2_t var_68;

//----- (001D42C0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall RQTexture::ConvertToRaw16(
        unsigned __int8 *rawData,
        unsigned __int8 *srcData,
        unsigned int w,
        unsigned int h,
        RQTextureFormat a5)
{
  int16x4_t *v5; // r5
  unsigned int v6; // r6
  void *v7; // r4
  unsigned int v8; // r4
  unsigned __int8 *v9; // r0
  bool v10; // cc
  int16x4_t *v11; // r2
  unsigned __int8 *v12; // r0
  unsigned int v13; // r3
  unsigned __int64 v14; // d17
  unsigned __int64 v15; // d22
  uint16x8_t v16; // q13
  uint16x8_t v17; // q12
  unsigned int v18; // r4
  unsigned __int8 *v19; // r0
  bool v20; // cc
  int16x4_t *v21; // r2
  unsigned __int8 *v22; // r0
  unsigned int v23; // r3
  unsigned __int64 v24; // d22
  unsigned __int64 v25; // d23
  uint16x8_t v26; // q11
  uint16x4_t v27; // d21
  unsigned int v28; // r1
  unsigned __int8 v29; // r5
  __int16 v30; // r3
  unsigned int v31; // r4
  __int16 v32; // r6
  unsigned int v33; // r1
  unsigned int v34; // r5
  __int16 v35; // r3
  __int16 v36; // r6
  int8x8x3_t v37; // 0:d18.8,8:d19.8,16:d20.8 OVERLAPPED
  int8x8x4_t v38; // 0:d18.8,8:d19.8,16:d20.8,24:d21.8

  v5 = (int16x4_t *)rawData;
  v6 = h * w;
  switch ( a5 )
  {
    case TF_RGBA_8888:
      if ( !v6 )
        return;
      if ( v6 < 8 )
        goto LABEL_24;
      v8 = v6 - (v6 & 7);
      if ( v6 == (v6 & 7) )
        goto LABEL_24;
      v9 = &srcData[4 * v6];
      v10 = v9 > (unsigned __int8 *)v5;
      if ( v9 > (unsigned __int8 *)v5 )
        v10 = (char *)v5 + 2 * v6 > (char *)srcData;
      if ( v10 )
      {
LABEL_24:
        v8 = 0;
        v12 = srcData;
        v11 = v5;
      }
      else
      {
        v11 = (int16x4_t *)((char *)v5 + 2 * v8);
        v12 = &srcData[4 * v8];
        v13 = v6 - (v6 & 7);
        do
        {
          v38 = vld4_s8((const char *)srcData);
          srcData += 32;
          v13 -= 8;
          v14 = v38.val[0].n64_u64[0] & 0xF0F0F0F0F0F0F0F0LL;
          v15 = v38.val[1].n64_u64[0] & 0xF0F0F0F0F0F0F0F0LL;
          *(uint16x8_t *)v38.val[0].n64_u64 = vmovl_u8(v38.val[3]);
          v16 = vmovl_u8((uint8x8_t)v15);
          v17 = vmovl_u8((uint8x8_t)v14);
          *(uint16x8_t *)v38.val[2].n64_u64 = vmovl_u8((uint8x8_t)(v38.val[2].n64_u64[0] & 0xF0F0F0F0F0F0F0F0LL));
          v5->n64_u64[0] = vmovn_s32(
                             vorrq_s64(
                               vorrq_s64(
                                 vorrq_s64(
                                   vshll_n_u16((uint16x4_t)v16.n128_u64[0], 4u),
                                   vshll_n_u16((uint16x4_t)v17.n128_u64[0], 8u)),
                                 vmovl_u16(v38.val[2])),
                               vshrq_n_u32(vmovl_u16(v38.val[0]), 4u))).n64_u64[0];
          v5[1].n64_u64[0] = vmovn_s32(
                               vorrq_s64(
                                 vorrq_s64(
                                   vorrq_s64(
                                     vshll_n_u16(*(uint16x4_t *)&v16.n128_i8[8], 4u),
                                     vshll_n_u16(*(uint16x4_t *)&v17.n128_i8[8], 8u)),
                                   vmovl_u16(v38.val[3])),
                                 vshrq_n_u32(vmovl_u16(v38.val[1]), 4u))).n64_u64[0];
          v5 += 2;
        }
        while ( v13 );
        if ( (v6 & 7) == 0 )
          return;
      }
      v28 = v6 - v8;
      do
      {
        --v28;
        v29 = v12[2];
        v30 = *v12 & 0xF0;
        v31 = v12[3];
        v32 = 16 * (v12[1] & 0xF0);
        v12 += 4;
        v11->n64_u16[0] = v32 | (v30 << 8) | v29 & 0xF0 | (v31 >> 4);
        v11 = (int16x4_t *)((char *)v11 + 2);
      }
      while ( v28 );
      return;
    case TF_RGB_888:
      if ( !v6 )
        return;
      if ( v6 <= 7 )
        goto LABEL_28;
      v18 = v6 - (v6 & 7);
      if ( v6 == (v6 & 7) )
        goto LABEL_28;
      v19 = &srcData[3 * v6];
      v20 = v19 > (unsigned __int8 *)v5;
      if ( v19 > (unsigned __int8 *)v5 )
        v20 = (char *)v5 + 2 * v6 > (char *)srcData;
      if ( v20 )
      {
LABEL_28:
        v18 = 0;
        v22 = srcData;
        v21 = v5;
LABEL_29:
        v33 = v6 - v18;
        do
        {
          --v33;
          v34 = v22[2];
          v35 = *v22 & 0xF8;
          v36 = v22[1] & 0xFC;
          v22 += 3;
          v21->n64_u16[0] = (8 * v36) | (v35 << 8) | (v34 >> 3);
          v21 = (int16x4_t *)((char *)v21 + 2);
        }
        while ( v33 );
        return;
      }
      v21 = (int16x4_t *)((char *)v5 + 2 * v18);
      v22 = &srcData[3 * v18];
      v23 = v6 - (v6 & 7);
      do
      {
        v37 = vld3_s8((const char *)srcData);
        srcData += 24;
        v23 -= 8;
        v24 = v37.val[0].n64_u64[0] & 0xF8F8F8F8F8F8F8F8LL;
        v25 = v37.val[1].n64_u64[0] & 0xFCFCFCFCFCFCFCFCLL;
        *(uint16x8_t *)v37.val[0].n64_u64 = vmovl_u8(v37.val[2]);
        *(uint16x8_t *)v37.val[2].n64_u64 = vmovl_u8((uint8x8_t)v24);
        v26 = vmovl_u8((uint8x8_t)v25);
        v5->n64_u64[0] = vmovn_s32(
                           vorrq_s64(
                             vorrq_s64(vshll_n_u16((uint16x4_t)v26.n128_u64[0], 3u), vshll_n_u16(v37.val[2], 8u)),
                             vshrq_n_u32(vmovl_u16(v37.val[0]), 3u))).n64_u64[0];
        v5[1].n64_u64[0] = vmovn_s32(
                             vorrq_s64(
                               vorrq_s64(vshll_n_u16(*(uint16x4_t *)&v26.n128_i8[8], 3u), vshll_n_u16(v27, 8u)),
                               vshrq_n_u32(vmovl_u16(v37.val[1]), 3u))).n64_u64[0];
        v5 += 2;
      }
      while ( v23 );
      if ( (v6 & 7) != 0 )
        goto LABEL_29;
      return;
    case TF_RGB_565:
    case TF_RGBA_5551:
    case TF_RGBA_4444:
      sub_19EA98(rawData, srcData, 2 * v6);
      return;
    case TF_DXT1:
    case TF_DXT1A:
    case TF_DXT3:
    case TF_DXT5:
      v7 = ConvertDXTToRaw16(srcData, a5, w, h);
      qmemcpy(v5, v7, 2 * v6);
      j_free(v7);
      return;
    default:
      return;
  }
}
// 1D440B: failed to expand linear variable 0:d18.8,8:d19.8,16:d20.8

//----- (001D44DC) --------------------------------------------------------
RwBBox_0 *__fastcall RwBBoxCalculate(RwBBox_0 *boundBox, const RwV3d_0 *verts, RwInt32 numVerts)
{
  __int64 v3; // d16
  __int64 v4; // d16
  int v5; // r2
  float x; // s0
  const RwV3d_0 *v7; // r1
  float v8; // s2
  float y; // s2
  float z; // s2
  float v11; // s2
  float v12; // s2

  v3 = *(_QWORD *)&verts->x;
  boundBox->inf.z = verts->z;
  *(_QWORD *)&boundBox->inf.x = v3;
  v4 = *(_QWORD *)&verts->x;
  boundBox->sup.z = verts->z;
  *(_QWORD *)&boundBox->sup.x = v4;
  if ( numVerts != 1 )
  {
    v5 = 1 - numVerts;
    x = boundBox->inf.x;
    v7 = verts + 1;
    do
    {
      v8 = v7->x;
      if ( x > v7->x )
      {
        boundBox->inf.x = v8;
        x = v8;
      }
      y = v7->y;
      if ( boundBox->inf.y > y )
        boundBox->inf.y = y;
      z = v7->z;
      if ( boundBox->inf.z > z )
        boundBox->inf.z = z;
      if ( boundBox->sup.x < v7->x )
        boundBox->sup.x = v7->x;
      v11 = v7->y;
      if ( boundBox->sup.y < v11 )
        boundBox->sup.y = v11;
      v12 = v7->z;
      ++v7;
      if ( boundBox->sup.z < v12 )
        boundBox->sup.z = v12;
      ++v5;
    }
    while ( v5 );
  }
  return boundBox;
}

//----- (001D4594) --------------------------------------------------------
RwBBox_0 *__fastcall RwBBoxInitialize(RwBBox_0 *boundBox, const RwV3d_0 *vertex)
{
  __int64 v2; // d16
  __int64 v3; // d16

  v2 = *(_QWORD *)&vertex->x;
  boundBox->inf.z = vertex->z;
  *(_QWORD *)&boundBox->inf.x = v2;
  v3 = *(_QWORD *)&vertex->x;
  boundBox->sup.z = vertex->z;
  *(_QWORD *)&boundBox->sup.x = v3;
  return boundBox;
}

//----- (001D45AE) --------------------------------------------------------
RwBBox_0 *__fastcall RwBBoxAddPoint(RwBBox_0 *boundBox, const RwV3d_0 *vertex)
{
  float y; // s0
  float z; // s0
  float v4; // s0
  float v5; // s0

  if ( boundBox->inf.x > vertex->x )
    boundBox->inf.x = vertex->x;
  y = vertex->y;
  if ( boundBox->inf.y > y )
    boundBox->inf.y = y;
  z = vertex->z;
  if ( boundBox->inf.z > z )
    boundBox->inf.z = z;
  if ( boundBox->sup.x < vertex->x )
    boundBox->sup.x = vertex->x;
  v4 = vertex->y;
  if ( boundBox->sup.y < v4 )
    boundBox->sup.y = v4;
  v5 = vertex->z;
  if ( boundBox->sup.z < v5 )
    boundBox->sup.z = v5;
  return boundBox;
}

//----- (001D4634) --------------------------------------------------------
RwBool __fastcall RwBBoxContainsPoint(const RwBBox_0 *boundBox, const RwV3d_0 *vertex)
{
  float y; // s2
  float z; // s0
  RwBool v5; // r1

  if ( boundBox->inf.x > vertex->x )
    return 0;
  y = vertex->y;
  if ( boundBox->inf.y > y )
    return 0;
  z = vertex->z;
  if ( boundBox->inf.z > z || boundBox->sup.x < vertex->x )
    return 0;
  v5 = 0;
  if ( boundBox->sup.y >= y && boundBox->sup.z >= z )
    return 1;
  return v5;
}

//----- (001D46A4) --------------------------------------------------------
RwInt32 __fastcall RwCameraRegisterPluginStream(
        RwUInt32 pluginID,
        RwPluginDataChunkReadCallBack readCB,
        RwPluginDataChunkWriteCallBack writeCB,
        RwPluginDataChunkGetSizeCallBack getSizeCB)
{
  return _rwPluginRegistryAddPluginStream(&cameraTKList, pluginID, readCB, writeCB, getSizeCB);
}

//----- (001D46C8) --------------------------------------------------------
RwInt32 __fastcall RwCameraSetStreamAlwaysCallBack(RwUInt32 pluginID, RwPluginDataChunkAlwaysCallBack alwaysCB)
{
  return sub_196434(&cameraTKList, pluginID, alwaysCB);
}

//----- (001D46DC) --------------------------------------------------------
RwUInt32 __fastcall RwCameraStreamGetSize(const RwCamera_0 *camera)
{
  return _rwPluginRegistryGetSize(&cameraTKList, camera) + 56;
}

//----- (001D46F4) --------------------------------------------------------
const RwCamera_0 *__fastcall RwCameraStreamWrite(const RwCamera_0 *camera, RwStream_0 *stream)
{
  RwInt32 Size; // r0
  RwReal y; // r1
  RwReal nearPlane; // r2
  RwReal farPlane; // r3
  RwReal fogPlane; // r6
  const RwCamera_0 *result; // r0
  RwV2d_0 mem; // [sp+8h] [bp-30h] BYREF
  RwReal v11[2]; // [sp+10h] [bp-28h] BYREF
  RwReal v12; // [sp+18h] [bp-20h] BYREF
  RwReal v13; // [sp+1Ch] [bp-1Ch] BYREF
  _DWORD v14[6]; // [sp+20h] [bp-18h] BYREF

  Size = _rwPluginRegistryGetSize(&cameraTKList, camera);
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 5, Size + 56, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
    return 0;
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 1, 32, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
    return 0;
  mem = camera->viewWindow;
  y = camera->viewOffset.y;
  nearPlane = camera->nearPlane;
  farPlane = camera->farPlane;
  fogPlane = camera->fogPlane;
  v11[0] = camera->viewOffset.x;
  v11[1] = y;
  v12 = nearPlane;
  v13 = farPlane;
  *(RwReal *)v14 = fogPlane;
  v14[1] = camera->projectionType;
  RwMemRealToFloat32(&mem, 8u);
  RwMemRealToFloat32(v11, 8u);
  RwMemRealToFloat32(&v12, 4u);
  RwMemRealToFloat32(&v13, 4u);
  RwMemRealToFloat32(v14, 4u);
  RwMemLittleEndian32(&mem, 0x20u);
  if ( !RwStreamWrite(stream, &mem, 0x20u) )
    return 0;
  result = (const RwCamera_0 *)_rwPluginRegistryWriteDataChunks(&cameraTKList, stream, camera);
  if ( result )
    return camera;
  return result;
}
// 35FFC: using guessed type Elf32_Sym stru_35FFC;
// 1D46F4: using guessed type RwReal var_28[2];

//----- (001D47C8) --------------------------------------------------------
RwCamera_0 *__fastcall RwCameraStreamRead(RwStream_0 *stream)
{
  RwUInt32 v2; // r0
  RwCamera_0 *v3; // r0
  RwCamera_0 *v4; // r5
  RwUInt32 v6; // [sp+0h] [bp-38h] BYREF
  RwUInt32 lengthOut; // [sp+4h] [bp-34h] BYREF
  RwError_0 buffer; // [sp+8h] [bp-30h] BYREF
  RwV2d_0 v9; // [sp+10h] [bp-28h] BYREF
  __int64 nearClip; // [sp+18h] [bp-20h] BYREF
  __int64 v11; // [sp+20h] [bp-18h] BYREF

  if ( !RwStreamFindChunk(stream, 1u, &lengthOut, &v6) )
    return 0;
  if ( v6 - 212992 > 0x2003 )
  {
    v4 = 0;
    buffer.pluginID = 0;
    buffer.errorCode = _rwerror(-2147483644);
    RwErrorSet(&buffer);
    return v4;
  }
  buffer = 0LL;
  v9 = 0LL;
  nearClip = 0LL;
  v11 = 0LL;
  v2 = RwStreamRead(stream, &buffer, lengthOut);
  if ( v2 != lengthOut )
    return 0;
  RwMemNative32(&buffer, 0x20u);
  RwMemFloat32ToReal(&buffer, 8u);
  RwMemFloat32ToReal(&v9, 8u);
  RwMemFloat32ToReal(&nearClip, 4u);
  RwMemFloat32ToReal((char *)&nearClip + 4, 4u);
  RwMemFloat32ToReal(&v11, 4u);
  v3 = RwCameraCreate();
  v4 = v3;
  if ( !v3 || !_rwPluginRegistryReadDataChunks(&cameraTKList, stream, v3) )
    return 0;
  RwCameraSetViewWindow(v4, (const RwV2d_0 *)&buffer);
  RwCameraSetViewOffset(v4, &v9);
  RwCameraSetNearClipPlane(v4, *(RwReal *)&nearClip);
  RwCameraSetFarClipPlane(v4, *((RwReal *)&nearClip + 1));
  LODWORD(v4->fogPlane) = v11;
  RwCameraSetProjection(v4, SHIDWORD(v11));
  return v4;
}

//----- (001D48BC) --------------------------------------------------------
RwCameraChunkInfo *__fastcall RwCameraChunkInfoRead(
        RwStream_0 *stream,
        RwCameraChunkInfo *cameraChunkInfo,
        RwInt32 *bytesRead)
{
  RwCameraChunkInfo *v6; // r6
  RwUInt32 v7; // r0
  RwUInt32 lengthOut[5]; // [sp+4h] [bp-14h] BYREF

  v6 = 0;
  if ( RwStreamFindChunk(stream, 1u, lengthOut, 0) )
  {
    cameraChunkInfo->viewWindow = 0LL;
    cameraChunkInfo->viewOffset = 0LL;
    *(_QWORD *)&cameraChunkInfo->nearPlane = 0LL;
    *(_QWORD *)&cameraChunkInfo->fogPlane = 0LL;
    if ( RwStreamRead(stream, cameraChunkInfo, 0x20u) == 32 )
    {
      v7 = lengthOut[0];
      *bytesRead = lengthOut[0] + 12;
      RwStreamSkip(stream, v7 - 32);
      RwMemNative32(cameraChunkInfo, 0x20u);
      RwMemFloat32ToReal(cameraChunkInfo, 8u);
      RwMemFloat32ToReal(&cameraChunkInfo->viewOffset, 8u);
      RwMemFloat32ToReal(&cameraChunkInfo->nearPlane, 4u);
      RwMemFloat32ToReal(&cameraChunkInfo->farPlane, 4u);
      RwMemFloat32ToReal(&cameraChunkInfo->fogPlane, 4u);
      return cameraChunkInfo;
    }
    else
    {
      return 0;
    }
  }
  return v6;
}
// 1D48BC: using guessed type RwUInt32 lengthOut[5];

//----- (001D4954) --------------------------------------------------------
RwInt32 __fastcall RwFrameRegisterPluginStream(
        RwUInt32 pluginID,
        RwPluginDataChunkReadCallBack readCB,
        RwPluginDataChunkWriteCallBack writeCB,
        RwPluginDataChunkGetSizeCallBack getSizeCB)
{
  return _rwPluginRegistryAddPluginStream(&frameTKList, pluginID, readCB, writeCB, getSizeCB);
}

//----- (001D4978) --------------------------------------------------------
RwInt32 __fastcall RwFrameSetStreamAlwaysCallBack(RwUInt32 pluginID, RwPluginDataChunkAlwaysCallBack alwaysCB)
{
  return sub_196434(&frameTKList, pluginID, alwaysCB);
}

//----- (001D498C) --------------------------------------------------------
rwFrameList_0 *__fastcall _rwFrameListInitialize(rwFrameList_0 *frameList, RwFrame_0 *frame)
{
  RwInt32 v4; // r6
  RwFrame_0 **v5; // r4
  RwError_0 code; // [sp+4h] [bp-24h] BYREF
  RwFrame_0 **frameListPos; // [sp+Ch] [bp-1Ch] BYREF

  v4 = RwFrameCount(frame);
  v5 = (RwFrame_0 **)(*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * v4);
  if ( v5 )
  {
    frameListPos = v5;
    rwFrameListMakeBreadthFirst(&frameListPos, frame);
    frameList->frames = v5;
    frameList->numFrames = v4;
  }
  else
  {
    frameList = 0;
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483629, 4 * v4);
    RwErrorSet(&code);
  }
  return frameList;
}

//----- (001D49F4) --------------------------------------------------------
RwFrame_0 ***__fastcall rwFrameListMakeBreadthFirst(RwFrame_0 ***frameListPos, RwFrame_0 *frame)
{
  RwFrame_0 ***v3; // r5

  v3 = frameListPos;
  while ( frame )
  {
    *(*v3)++ = frame;
    frameListPos = (RwFrame_0 ***)rwFrameListMakeBreadthFirst(v3, frame->next);
    frame = frame->child;
  }
  return frameListPos;
}

//----- (001D4A1E) --------------------------------------------------------
RwBool __fastcall _rwFrameListFindFrame(const rwFrameList_0 *frameList, const RwFrame_0 *frame, RwInt32 *npIndex)
{
  RwInt32 numFrames; // r12
  RwFrame_0 **frames; // lr
  RwInt32 v5; // r0

  numFrames = frameList->numFrames;
  if ( numFrames < 1 )
    return 0;
  frames = frameList->frames;
  v5 = 0;
  while ( frames[v5] != frame )
  {
    if ( ++v5 >= numFrames )
      return 0;
  }
  *npIndex = v5;
  return 1;
}

//----- (001D4A4C) --------------------------------------------------------
rwFrameList_0 *__fastcall _rwFrameListDeinitialize(rwFrameList_0 *frameList)
{
  if ( frameList->numFrames )
  {
    (*((void (__fastcall **)(RwFrame_0 **))RwEngineInstance + 76))(frameList->frames);
    frameList->frames = 0;
  }
  return frameList;
}

//----- (001D4A74) --------------------------------------------------------
RwUInt32 __fastcall _rwFrameListStreamGetSize(const rwFrameList_0 *frameList)
{
  RwInt32 numFrames; // r0
  RwUInt32 v3; // r5
  RwInt32 v4; // r6
  RwInt32 Size; // r0

  numFrames = frameList->numFrames;
  v3 = ((56 * numFrames) | 4) + 12;
  if ( numFrames >= 1 )
  {
    v4 = 0;
    do
    {
      Size = _rwPluginRegistryGetSize(&frameTKList, frameList->frames[v4++]);
      v3 += Size + 12;
    }
    while ( v4 < frameList->numFrames );
  }
  return v3;
}

//----- (001D4AC4) --------------------------------------------------------
const rwFrameList_0 *__fastcall _rwFrameListStreamWrite(const rwFrameList_0 *frameList, RwStream_0 *stream)
{
  const rwFrameList_0 *v2; // r9
  RwInt32 numFrames; // r0
  RwInt32 v5; // r5
  RwInt32 v6; // r4
  RwInt32 Size; // r0
  int v8; // r0
  int v9; // r10
  RwFrame_0 **frames; // r1
  RwFrame_0 *v11; // r8
  double v12; // d16
  __int64 v13; // d16
  __int64 v14; // d16
  __int64 v15; // d16
  RwFrame_0 *parent; // r3
  int v17; // r2
  int v18; // r4
  RwStream_0 *v20; // [sp+8h] [bp-60h]
  double v21; // [sp+10h] [bp-58h] BYREF
  RwReal z; // [sp+18h] [bp-50h]
  __int64 v23; // [sp+1Ch] [bp-4Ch] BYREF
  RwReal v24; // [sp+24h] [bp-44h]
  __int64 v25; // [sp+28h] [bp-40h] BYREF
  RwReal v26; // [sp+30h] [bp-38h]
  __int64 v27; // [sp+34h] [bp-34h] BYREF
  RwReal v28; // [sp+3Ch] [bp-2Ch]
  int v29; // [sp+40h] [bp-28h]
  RwUInt32 flags; // [sp+44h] [bp-24h]
  int mem[8]; // [sp+48h] [bp-20h] BYREF

  v2 = frameList;
  numFrames = frameList->numFrames;
  v5 = ((56 * numFrames) | 4) + 12;
  if ( numFrames >= 1 )
  {
    v6 = 0;
    do
    {
      Size = _rwPluginRegistryGetSize(&frameTKList, v2->frames[v6++]);
      v5 += Size + 12;
    }
    while ( v6 < v2->numFrames );
  }
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 14, v5, 0x36003u, 0xFFFFu) )
    return 0;
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 1, (56 * v2->numFrames) | 4, 0x36003u, 0xFFFFu) )
    return 0;
  mem[0] = v2->numFrames;
  RwMemLittleEndian32(mem, 4u);
  if ( !RwStreamWrite(stream, mem, 4u) )
    return 0;
  v8 = v2->numFrames;
  if ( v8 >= 1 )
  {
    v20 = stream;
    v9 = 0;
    while ( 1 )
    {
      frames = v2->frames;
      v11 = v2->frames[v9];
      v12 = *(double *)&v11->modelling.right.x;
      z = v11->modelling.right.z;
      v21 = v12;
      v13 = *(_QWORD *)&v11->modelling.up.x;
      v24 = v11->modelling.up.z;
      v23 = v13;
      v14 = *(_QWORD *)&v11->modelling.at.x;
      v26 = v11->modelling.at.z;
      v25 = v14;
      v15 = *(_QWORD *)&v11->modelling.pos.x;
      v28 = v11->modelling.pos.z;
      v27 = v15;
      parent = (RwFrame_0 *)v11->object.parent;
      if ( parent )
      {
        if ( v8 < 1 )
          return 0;
        v17 = 0;
        while ( frames[v17] != parent )
        {
          if ( ++v17 >= v8 )
            return 0;
        }
      }
      else
      {
        v17 = -1;
      }
      v29 = v17;
      RwMemRealToFloat32(&v21, 0xCu);
      RwMemRealToFloat32(&v23, 0xCu);
      RwMemRealToFloat32(&v25, 0xCu);
      RwMemRealToFloat32(&v27, 0xCu);
      flags = v11->modelling.flags;
      RwMemLittleEndian32(&v21, 0x38u);
      if ( !RwStreamWrite(v20, &v21, 0x38u) )
        break;
      v8 = v2->numFrames;
      if ( ++v9 >= v8 )
      {
        if ( v8 < 1 )
          return v2;
        v18 = 0;
        while ( _rwPluginRegistryWriteDataChunks(&frameTKList, v20, v2->frames[v18]) )
        {
          if ( ++v18 >= v2->numFrames )
            return v2;
        }
        return 0;
      }
    }
    return 0;
  }
  return v2;
}

//----- (001D4C88) --------------------------------------------------------
rwFrameList_0 *__fastcall _rwFrameListStreamRead(RwStream_0 *stream, rwFrameList_0 *frameList)
{
  RwStream_0 *v3; // r11
  int v4; // r1
  RwFrame_0 **v5; // r0
  int v6; // r9
  RwFrame_0 *v7; // r0
  RwFrame_0 *v8; // r6
  RwError_0 v9; // d16
  __int64 v10; // d16
  __int64 v11; // d16
  __int64 v12; // d16
  int v13; // r10
  int v14; // r6
  RwInt32 v15; // r0
  RwStream_0 *v17; // [sp+8h] [bp-80h]
  rwFrameList_0 *v18; // [sp+Ch] [bp-7Ch]
  RwError_0 code; // [sp+10h] [bp-78h] BYREF
  RwReal v20; // [sp+18h] [bp-70h]
  __int64 v21; // [sp+1Ch] [bp-6Ch] BYREF
  RwReal v22; // [sp+24h] [bp-64h]
  __int64 v23; // [sp+28h] [bp-60h] BYREF
  RwReal v24; // [sp+30h] [bp-58h]
  __int64 v25; // [sp+34h] [bp-54h] BYREF
  RwReal v26; // [sp+3Ch] [bp-4Ch]
  int v27; // [sp+40h] [bp-48h]
  RwUInt32 versionOut; // [sp+4Ch] [bp-3Ch] BYREF
  RwUInt32 lengthOut; // [sp+50h] [bp-38h] BYREF
  int buffer[13]; // [sp+54h] [bp-34h] BYREF

  v3 = stream;
  if ( !RwStreamFindChunk(stream, 1u, &lengthOut, &versionOut) )
    return 0;
  if ( versionOut - 212992 > 0x2003 )
  {
    frameList = 0;
    code.pluginID = 0;
    v15 = _rwerror(-2147483644);
LABEL_23:
    code.errorCode = v15;
    RwErrorSet(&code);
    return frameList;
  }
  if ( RwStreamRead(v3, buffer, 4u) != 4 )
    return 0;
  RwMemNative32(buffer, 4u);
  v4 = buffer[0];
  frameList->numFrames = buffer[0];
  v5 = (RwFrame_0 **)(*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * v4);
  frameList->frames = v5;
  if ( !v5 )
  {
    frameList = 0;
    code.pluginID = 0;
    v15 = _rwerror(-2147483629, 4 * buffer[0]);
    goto LABEL_23;
  }
  if ( buffer[0] >= 1 )
  {
    v6 = 0;
    v18 = frameList;
    v17 = v3;
    do
    {
      if ( RwStreamRead(v3, &code, 0x38u) != 56
        || (RwMemNative32(&code, 0x38u),
            RwMemFloat32ToReal(&code, 0xCu),
            RwMemFloat32ToReal(&v21, 0xCu),
            RwMemFloat32ToReal(&v23, 0xCu),
            RwMemFloat32ToReal(&v25, 0xCu),
            v7 = RwFrameCreate(),
            (v8 = v7) == 0) )
      {
        (*((void (__fastcall **)(RwFrame_0 **))RwEngineInstance + 76))(frameList->frames);
        return 0;
      }
      v9 = code;
      v7->modelling.right.z = v20;
      *(RwError_0 *)&v7->modelling.right.x = v9;
      v10 = v21;
      v7->modelling.up.z = v22;
      *(_QWORD *)&v7->modelling.up.x = v10;
      v11 = v23;
      v7->modelling.at.z = v24;
      *(_QWORD *)&v7->modelling.at.x = v11;
      v12 = v25;
      v7->modelling.pos.z = v26;
      *(_QWORD *)&v7->modelling.pos.x = v12;
      v13 = -131076;
      if ( _rwMatrixNormalError(&v7->modelling) <= 0.01
        && _rwMatrixOrthogonalError(&v8->modelling) <= 0.01
        && _rwMatrixDeterminant(&v8->modelling) >= 0.99 )
      {
        v13 = -131073;
      }
      v8->modelling.flags &= v13;
      frameList = v18;
      v18->frames[v6] = v8;
      v3 = v17;
      if ( v27 >= 0 )
        RwFrameAddChild(v18->frames[v27], v8);
      ++v6;
    }
    while ( v6 < buffer[0] );
    if ( buffer[0] < 1 )
      return frameList;
    v14 = 0;
    while ( _rwPluginRegistryReadDataChunks(&frameTKList, v17, v18->frames[v14]) )
    {
      if ( ++v14 >= buffer[0] )
        return frameList;
    }
    return 0;
  }
  return frameList;
}

//----- (001D4ECC) --------------------------------------------------------
RwBool __fastcall _rwStringDestroy(RwChar *string)
{
  (*((void (__fastcall **)(RwChar *))RwEngineInstance + 76))(string);
  return 1;
}

//----- (001D4EE8) --------------------------------------------------------
RwUInt32 __fastcall _rwStringStreamGetSize(const RwChar *string)
{
  if ( !string )
    string = nullString;
  return ((*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(string) + 4) & 0xFFFFFFFC;
}

//----- (001D4F14) --------------------------------------------------------
const RwChar *__fastcall _rwStringStreamWrite(const RwChar *string, RwStream_0 *stream)
{
  const RwChar *v4; // r0
  unsigned int v5; // r6
  const RwChar *result; // r0

  v4 = nullString;
  if ( !string )
    string = nullString;
  if ( string )
    v4 = string;
  v5 = ((*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(v4) + 4) & 0xFFFFFFFC;
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 2, v5, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
    return 0;
  result = (const RwChar *)RwStreamWrite(stream, string, v5);
  if ( result )
    return string;
  return result;
}
// 35FFC: using guessed type Elf32_Sym stru_35FFC;

//----- (001D4F88) --------------------------------------------------------
RwChar *__fastcall _rwStringStreamFindAndRead(RwChar *string, RwStream_0 *stream)
{
  RwChar *v4; // r4
  RwUInt32 v5; // r6
  int v6; // r0
  RwUInt32 v7; // r11
  RwChar *v8; // r5
  RwUInt32 v9; // r4
  unsigned int v10; // r1
  unsigned int v11; // r0
  int v12; // r2
  bool v13; // cf
  RwError_0 *v14; // r2
  int v15; // r3
  RwChar *v16; // r6
  RwError_0 v17; // d16
  RwError_0 v18; // d17
  RwChar *v19; // r10
  RwUInt32 v20; // r0
  int v21; // r1
  RwChar *v22; // r2
  RwChar *v23; // r3
  RwUInt32 v24; // r1
  RwChar v25; // t1
  int16x8_t *v26; // r2
  int v27; // r3
  int8x8_t *v28; // r4
  int16x8_t v29; // q8
  RwUInt32 v30; // r4
  RwInt32 v32; // r0
  int v33; // [sp+8h] [bp-B0h]
  RwUInt32 version; // [sp+Ch] [bp-ACh] BYREF
  RwUInt32 offset; // [sp+10h] [bp-A8h] BYREF
  RwUInt32 v36; // [sp+14h] [bp-A4h] BYREF
  RwError_0 buffer[16]; // [sp+18h] [bp-A0h] BYREF

  v4 = 0;
  while ( 1 )
  {
    if ( !_rwStreamReadChunkHeader(stream, &v36, &offset, &version, 0) )
      return v4;
    if ( v36 == 19 )
      break;
    if ( v36 == 2 )
    {
      v7 = offset;
      if ( string || (string = (RwChar *)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(offset)) != 0 )
      {
        if ( v7 )
        {
          v8 = string;
          do
          {
            v9 = v7;
            if ( v7 >= 0x40 )
              v9 = 64;
            if ( RwStreamRead(stream, buffer, v9) != v9 )
              return 0;
            v10 = 1;
            if ( v9 > 1 )
              v10 = v9;
            if ( v10 >= 0x10 )
            {
              v11 = v10 & 0x70;
              if ( (v10 & 0x70) != 0 )
              {
                v12 = 1;
                if ( v9 > 1 )
                  v12 = v9;
                v13 = v8 >= (RwChar *)buffer + v12;
                if ( v8 < (RwChar *)buffer + v12 )
                  v13 = buffer >= (RwError_0 *)&v8[v12];
                if ( v13 )
                {
                  v14 = buffer;
                  v15 = v10 & 0x70;
                  v16 = v8;
                  do
                  {
                    v17 = *v14;
                    v18 = v14[1];
                    v14 += 2;
                    v15 -= 16;
                    *(RwError_0 *)v16 = v17;
                    *((RwError_0 *)v16 + 1) = v18;
                    v16 += 16;
                  }
                  while ( v15 );
                  if ( v10 == v11 )
                    goto LABEL_33;
                }
                else
                {
                  v11 = 0;
                }
              }
              else
              {
                v11 = 0;
              }
            }
            else
            {
              v11 = 0;
            }
            do
            {
              v8[v11] = *((_BYTE *)&buffer[0].pluginID + v11);
              ++v11;
            }
            while ( v11 < v9 );
LABEL_33:
            v8 += v9;
            v7 -= v9;
          }
          while ( v7 );
        }
        return string;
      }
      v4 = 0;
      buffer[0].pluginID = 0;
      v32 = _rwerror(-2147483629, v7);
LABEL_61:
      buffer[0].errorCode = v32;
      RwErrorSet(buffer);
      return v4;
    }
    if ( !RwStreamSkip(stream, offset) )
      return 0;
  }
  v5 = offset;
  if ( string )
  {
    v6 = 0;
    if ( !offset )
      return string;
  }
  else
  {
    string = (RwChar *)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(offset);
    if ( !string )
    {
      v4 = 0;
      buffer[0].pluginID = 0;
      v32 = _rwerror(-2147483629, v5);
      goto LABEL_61;
    }
    v6 = 1;
    if ( !v5 )
      return string;
  }
  v19 = string;
  v33 = v6;
  while ( 1 )
  {
    v30 = v5;
    if ( v5 >= 0x80 )
      v30 = 128;
    if ( RwStreamRead(stream, buffer, v30) != v30 )
      break;
    v5 -= v30;
    v20 = v30 >> 1;
    if ( v30 >> 1 )
    {
      if ( v30 >= 0x10
        && (v21 = (v30 >> 1) & 0x78, (v20 & 0x78) != 0)
        && (v19 >= (RwChar *)buffer + 2 * v20 || &v19[v20] <= (RwChar *)buffer) )
      {
        v26 = (int16x8_t *)buffer;
        v27 = (v30 >> 1) & 0x78;
        v28 = (int8x8_t *)v19;
        do
        {
          v29 = *v26++;
          v27 -= 8;
          v28->n64_u64[0] = vmovn_s16(v29).n64_u64[0];
          ++v28;
        }
        while ( v27 );
        if ( v20 == v21 )
          goto LABEL_46;
      }
      else
      {
        v21 = 0;
      }
      v22 = (RwChar *)buffer + 2 * v21;
      v23 = &v19[v21];
      v24 = v20 - v21;
      do
      {
        v25 = *v22;
        v22 += 2;
        --v24;
        *v23++ = v25;
      }
      while ( v24 );
    }
LABEL_46:
    v19 += v20;
    if ( !v5 )
      return string;
  }
  if ( v33 )
    (*((void (__fastcall **)(RwChar *))RwEngineInstance + 76))(string);
  return 0;
}

//----- (001D51A8) --------------------------------------------------------
RwInt32 __fastcall RwTextureRegisterPluginStream(
        RwUInt32 pluginID,
        RwPluginDataChunkReadCallBack readCB,
        RwPluginDataChunkWriteCallBack writeCB,
        RwPluginDataChunkGetSizeCallBack getSizeCB)
{
  return _rwPluginRegistryAddPluginStream(&textureTKList, pluginID, readCB, writeCB, getSizeCB);
}

//----- (001D51CC) --------------------------------------------------------
RwInt32 __fastcall RwTextureSetStreamAlwaysCallBack(RwUInt32 pluginID, RwPluginDataChunkAlwaysCallBack alwaysCB)
{
  return sub_196434(&textureTKList, pluginID, alwaysCB);
}

//----- (001D51E0) --------------------------------------------------------
RwUInt32 __fastcall RwTextureStreamGetSize(const RwTexture_0 *texture)
{
  int v2; // r5
  int v3; // r6

  v2 = (*((int (__fastcall **)(RwChar *))RwEngineInstance + 70))(texture->name);
  v3 = (*((int (__fastcall **)(RwChar *))RwEngineInstance + 70))(texture->mask);
  return _rwPluginRegistryGetSize(&textureTKList, texture) + ((v2 + 56) & 0xFFFFFFFC) + ((v3 + 4) & 0xFFFFFFFC);
}

//----- (001D5238) --------------------------------------------------------
const RwTexture_0 *__fastcall RwTextureStreamWrite(const RwTexture_0 *texture, RwStream_0 *stream)
{
  RwChar *name; // r11
  int v5; // r6
  int v6; // r5
  RwInt32 Size; // r0
  int v8; // r0
  unsigned int v9; // r10
  unsigned int v10; // r6
  const RwTexture_0 *result; // r0
  int mem[8]; // [sp+8h] [bp-20h] BYREF

  name = texture->name;
  v5 = (*((int (__fastcall **)(RwChar *))RwEngineInstance + 70))(texture->name);
  v6 = (*((int (__fastcall **)(RwChar *))RwEngineInstance + 70))(texture->mask);
  Size = _rwPluginRegistryGetSize(&textureTKList, texture);
  if ( !_rwStreamWriteVersionedChunkHeader(
          stream,
          6,
          Size + ((v5 + 56) & 0xFFFFFFFC) + ((v6 + 4) & 0xFFFFFFFC),
          (RwUInt32)&stru_35FFC.st_value + 3,
          0xFFFFu)
    || !_rwStreamWriteVersionedChunkHeader(stream, 1, 4, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
  {
    return 0;
  }
  v8 = !texture->raster || (texture->raster->cFormat & 0x10) != 0 ? 0 : 0x10000;
  mem[0] = v8 | LOWORD(texture->filterAddressing);
  RwMemLittleEndian32(mem, 4u);
  if ( !RwStreamWrite(stream, mem, 4u) )
    return 0;
  v9 = ((*((int (__fastcall **)(RwChar *))RwEngineInstance + 70))(name) + 4) & 0xFFFFFFFC;
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 2, v9, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
    return 0;
  if ( !RwStreamWrite(stream, name, v9) )
    return 0;
  v10 = ((*((int (__fastcall **)(RwChar *))RwEngineInstance + 70))(texture->mask) + 4) & 0xFFFFFFFC;
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 2, v10, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu)
    || !RwStreamWrite(stream, texture->mask, v10) )
  {
    return 0;
  }
  result = (const RwTexture_0 *)_rwPluginRegistryWriteDataChunks(&textureTKList, stream, texture);
  if ( result )
    return texture;
  return result;
}
// 35FFC: using guessed type Elf32_Sym stru_35FFC;

//----- (001D5390) --------------------------------------------------------
RwTexture_0 *__fastcall RwTextureStreamRead(RwStream_0 *stream)
{
  RwTexture_0 *v2; // r5
  RwUInt32 v3; // r0
  int v4; // r5
  int v5; // r6
  RwBool Mipmapping; // r9
  RwBool AutoMipmapping; // r8
  RwBool v8; // r0
  RwTexture_0 *v9; // r0
  int v11; // [sp+0h] [bp-128h] BYREF
  RwUInt32 versionOut; // [sp+4h] [bp-124h] BYREF
  RwUInt32 lengthOut; // [sp+8h] [bp-120h] BYREF
  RwChar string[128]; // [sp+Ch] [bp-11Ch] BYREF
  RwError_0 code; // [sp+8Ch] [bp-9Ch] BYREF

  if ( !RwStreamFindChunk(stream, 1u, &lengthOut, &versionOut) )
    return 0;
  v2 = 0;
  if ( versionOut - 212992 > 0x2003 )
  {
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483644);
    RwErrorSet(&code);
    return v2;
  }
  v11 = 0;
  v3 = RwStreamRead(stream, &v11, lengthOut);
  if ( v3 == lengthOut )
  {
    RwMemNative32(&v11, 4u);
    v4 = v11;
    v5 = (unsigned __int8)v11;
    if ( (v11 & 0xF000) == 0 )
    {
      v4 = v11 | (16 * v11) & 0xF000;
      v11 = v4;
    }
    Mipmapping = RwTextureGetMipmapping();
    AutoMipmapping = RwTextureGetAutoMipmapping();
    if ( (unsigned int)(v5 - 3) > 3 )
    {
      RwTextureSetMipmapping(0);
    }
    else
    {
      RwTextureSetMipmapping(1);
      if ( (v4 & 0x10000) == 0 )
      {
        v8 = 1;
        goto LABEL_12;
      }
    }
    v8 = 0;
LABEL_12:
    RwTextureSetAutoMipmapping(v8);
    if ( _rwStringStreamFindAndRead((RwChar *)&code, stream) && _rwStringStreamFindAndRead(string, stream) )
    {
      v9 = RwTextureRead((const RwChar *)&code, string);
      v2 = v9;
      if ( v9 )
      {
        if ( v9->refCount == 1 )
          v9->filterAddressing = (unsigned __int16)v11;
        RwTextureSetMipmapping(Mipmapping);
        RwTextureSetAutoMipmapping(AutoMipmapping);
        if ( !_rwPluginRegistryReadDataChunks(&textureTKList, stream, v2) )
          return 0;
        return v2;
      }
      _rwPluginRegistrySkipDataChunks(&textureTKList, stream);
    }
    RwTextureSetMipmapping(Mipmapping);
    RwTextureSetAutoMipmapping(AutoMipmapping);
    return 0;
  }
  return v2;
}

//----- (001D54CC) --------------------------------------------------------
RwInt32 __fastcall RwTexDictionaryRegisterPluginStream(
        RwUInt32 pluginID,
        RwPluginDataChunkReadCallBack readCB,
        RwPluginDataChunkWriteCallBack writeCB,
        RwPluginDataChunkGetSizeCallBack getSizeCB)
{
  return _rwPluginRegistryAddPluginStream(&texDictTKList, pluginID, readCB, writeCB, getSizeCB);
}

//----- (001D54F0) --------------------------------------------------------
RwInt32 __fastcall RwTexDictionarySetStreamAlwaysCallBack(RwUInt32 pluginID, RwPluginDataChunkAlwaysCallBack alwaysCB)
{
  return sub_196434(&texDictTKList, pluginID, alwaysCB);
}

//----- (001D5504) --------------------------------------------------------
RwUInt32 __fastcall RwTexDictionaryStreamGetSize(const RwTexDictionary_0 *texDict)
{
  RwInt32 Size; // r0
  RwUInt32 result; // r0
  RwUInt32 v4; // [sp+0h] [bp-10h] BYREF
  int v5; // [sp+4h] [bp-Ch]

  v5 = 1;
  v4 = 16;
  RwTexDictionaryForAllTextures(texDict, addNativeTextureSize, &v4);
  if ( !v5 )
    return 0;
  Size = _rwPluginRegistryGetSize(&texDictTKList, texDict);
  result = Size + v4 + 12;
  v4 = result;
  return result;
}

//----- (001D554C) --------------------------------------------------------
RwTexture_0 *__fastcall addNativeTextureSize(RwTexture_0 *texture, void *data)
{
  RwTexture_0 *v4; // r6
  int v6[5]; // [sp+4h] [bp-14h] BYREF

  v4 = 0;
  if ( (*((int (__fastcall **)(int *, RwTexture_0 *, _DWORD))RwEngineInstance + 43))(v6, texture, 0) )
  {
    *(_DWORD *)data += v6[0] + 12;
    v4 = texture;
    *(_DWORD *)data += _rwPluginRegistryGetSize(&textureTKList, texture) + 12;
  }
  else
  {
    *((_DWORD *)data + 1) = 0;
  }
  return v4;
}
// 1D554C: using guessed type int var_14[5];

//----- (001D55A8) --------------------------------------------------------
const RwTexDictionary_0 *__fastcall RwTexDictionaryStreamWrite(const RwTexDictionary_0 *texDict, RwStream_0 *stream)
{
  const RwTexDictionary_0 *v3; // r4
  RwInt32 Size; // r0
  char *v5; // r0
  const RwTexDictionary_0 *v6; // r6
  __int16 v8; // [sp+4h] [bp-1Ch] BYREF
  RwStream_0 *pData; // [sp+8h] [bp-18h] BYREF
  int v10; // [sp+Ch] [bp-14h]

  v3 = texDict;
  v10 = 1;
  pData = (RwStream_0 *)&word_10;
  RwTexDictionaryForAllTextures(texDict, addNativeTextureSize, &pData);
  if ( !v10 )
    return 0;
  Size = _rwPluginRegistryGetSize(&texDictTKList, v3);
  v5 = (char *)pData + Size;
  if ( v5 == (char *)-12
    || !_rwStreamWriteVersionedChunkHeader(stream, 22, (RwInt32)(v5 + 12), (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
  {
    return 0;
  }
  v6 = 0;
  if ( _rwStreamWriteVersionedChunkHeader(stream, 1, 4, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
  {
    v8 = 0;
    RwTexDictionaryForAllTextures(v3, countTexturesInDictionary, &v8);
    RwMemLittleEndian32(&v8, 4u);
    if ( RwStreamWrite(stream, &v8, 4u) )
    {
      pData = stream;
      v10 = 1;
      RwTexDictionaryForAllTextures(v3, writeNativeTexture, &pData);
      if ( _rwPluginRegistryWriteDataChunks(&texDictTKList, stream, v3) )
      {
        if ( !v10 )
          return 0;
        return v3;
      }
      else
      {
        v6 = 0;
        v10 = 0;
      }
    }
  }
  return v6;
}
// 10: using guessed type __int16 word_10;
// 35FFC: using guessed type Elf32_Sym stru_35FFC;

//----- (001D5690) --------------------------------------------------------
RwTexture_0 *__fastcall countTexturesInDictionary(RwTexture_0 *texture, void *data)
{
  ++*(_DWORD *)data;
  return texture;
}

//----- (001D5698) --------------------------------------------------------
RwTexture_0 *__fastcall writeNativeTexture(RwTexture_0 *texture, void *data)
{
  RwTexture_0 *v2; // r4
  RwInt32 Size; // r0
  RwInt32 v6[5]; // [sp+4h] [bp-14h] BYREF

  v2 = texture;
  if ( !(*((int (__fastcall **)(RwInt32 *, RwTexture_0 *, _DWORD))RwEngineInstance + 43))(v6, texture, 0)
    || (Size = _rwPluginRegistryGetSize(&textureTKList, v2),
        v6[0] += Size + 12,
        !_rwStreamWriteVersionedChunkHeader(*(RwStream_0 **)data, 21, v6[0], 0x36003u, 0xFFFFu))
    || !(*((int (__fastcall **)(_DWORD, RwTexture_0 *, RwInt32))RwEngineInstance + 45))(*(_DWORD *)data, v2, v6[0])
    || !_rwPluginRegistryWriteDataChunks(&textureTKList, *(RwStream_0 **)data, v2) )
  {
    v2 = 0;
    *((_DWORD *)data + 1) = 0;
  }
  return v2;
}
// 1D5698: using guessed type RwInt32 var_14[5];

//----- (001D5730) --------------------------------------------------------
RwTexDictionary_0 *__fastcall RwTexDictionaryStreamRead(RwStream_0 *stream)
{
  RwTexDictionary_0 *v2; // r6
  RwUInt32 v3; // r0
  RwTexDictionary_0 *v4; // r4
  bool v5; // zf
  RwError_0 code; // [sp+4h] [bp-34h] BYREF
  void *object; // [sp+Ch] [bp-2Ch] BYREF
  int buffer; // [sp+10h] [bp-28h] BYREF
  RwUInt32 versionOut; // [sp+14h] [bp-24h] BYREF
  RwUInt32 lengthOut[8]; // [sp+18h] [bp-20h] BYREF

  if ( !RwStreamFindChunk(stream, 1u, lengthOut, &versionOut) )
    return 0;
  v2 = 0;
  if ( versionOut - 212992 > 0x2003 )
  {
LABEL_19:
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483644);
    RwErrorSet(&code);
    return v2;
  }
  buffer = 0;
  v3 = RwStreamRead(stream, &buffer, lengthOut[0]);
  if ( v3 == lengthOut[0] )
  {
    RwMemNative32(&buffer, 4u);
    v4 = RwTexDictionaryCreate();
    if ( v4 )
    {
      v5 = (unsigned __int16)buffer == 0;
      LOWORD(buffer) = buffer - 1;
      if ( v5 )
      {
LABEL_13:
        if ( _rwPluginRegistryReadDataChunks(&texDictTKList, stream, v4) )
        {
          return v4;
        }
        else
        {
          v2 = 0;
          RwTexDictionaryForAllTextures(v4, destroyTexture, 0);
          RwTexDictionaryDestroy(v4);
        }
      }
      else
      {
        while ( RwStreamFindChunk(stream, 0x15u, lengthOut, &versionOut) )
        {
          if ( versionOut - 212992 >= 0x2004 )
          {
            v2 = 0;
            RwTexDictionaryForAllTextures(v4, destroyTexture, 0);
            RwTexDictionaryDestroy(v4);
            goto LABEL_19;
          }
          if ( !(*((int (__fastcall **)(RwStream_0 *, void **, RwUInt32))RwEngineInstance + 44))(
                  stream,
                  &object,
                  lengthOut[0])
            || !object
            || !_rwPluginRegistryReadDataChunks(&textureTKList, stream, object) )
          {
            break;
          }
          RwTexDictionaryAddTexture(v4, (RwTexture_0 *)object);
          v5 = (unsigned __int16)buffer == 0;
          LOWORD(buffer) = buffer - 1;
          if ( v5 )
            goto LABEL_13;
        }
        RwTexDictionaryForAllTextures(v4, destroyTexture, 0);
        RwTexDictionaryDestroy(v4);
        return 0;
      }
      return v2;
    }
    return 0;
  }
  return v2;
}

//----- (001D58B0) --------------------------------------------------------
RwTexture_0 *__fastcall destroyTexture(RwTexture_0 *texture, void *data)
{
  RwTextureDestroy(texture);
  return texture;
}

//----- (001D58BE) --------------------------------------------------------
RwTextureChunkInfo *__fastcall _rwTextureChunkInfoRead(
        RwStream_0 *stream,
        RwTextureChunkInfo *textureChunkInfo,
        RwInt32 *bytesRead)
{
  RwTextureChunkInfo *v6; // r6
  RwUInt32 v7; // r0
  unsigned __int16 v8; // r0
  unsigned int v10; // [sp+0h] [bp-18h] BYREF
  RwUInt32 lengthOut[5]; // [sp+4h] [bp-14h] BYREF

  v6 = 0;
  if ( RwStreamFindChunk(stream, 1u, lengthOut, 0) )
  {
    v10 = 0;
    if ( RwStreamRead(stream, &v10, 4u) == 4 )
    {
      v7 = lengthOut[0];
      *bytesRead = lengthOut[0] + 12;
      RwStreamSkip(stream, v7 - 4);
      RwMemNative32(&v10, 4u);
      v8 = v10;
      v6 = textureChunkInfo;
      textureChunkInfo->addressingU = (v10 >> 8) & 0xF;
      textureChunkInfo->addressingV = v8 >> 12;
      textureChunkInfo->filtering = (unsigned __int8)v8;
    }
  }
  return v6;
}
// 1D58BE: using guessed type RwUInt32 lengthOut[5];

//----- (001D5930) --------------------------------------------------------
void *__fastcall _rwCameraClose(void *instance, RwInt32 offset, RwInt32 size)
{
  RwFreeList_0 *v4; // r0

  v4 = *(RwFreeList_0 **)((char *)RwEngineInstance + cameraModule);
  if ( v4 )
  {
    RwFreeListDestroy(v4);
    *(_DWORD *)((char *)RwEngineInstance + cameraModule) = 0;
  }
  --cameraModule;
  return instance;
}
// 6BCD28: using guessed type int cameraModule;
// 6BCD2C: using guessed type int cameraModule;

//----- (001D5980) --------------------------------------------------------
void __fastcall RwCameraSetFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rwCameraFreeListPreallocBlocks = numBlocksToPrealloc;
  _rwCameraFreeListBlockSize = blockSize;
}

//----- (001D5998) --------------------------------------------------------
void *__fastcall _rwCameraOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  RwFreeList_0 *v4; // r0
  int v5; // r2

  cameraModule = offset;
  v4 = RwFreeListCreateAndPreallocateSpace(
         cameraTKList.sizeOfStruct,
         _rwCameraFreeListBlockSize,
         4,
         _rwCameraFreeListPreallocBlocks,
         &_rwCameraFreeList);
  v5 = cameraModule;
  *(_DWORD *)((char *)RwEngineInstance + cameraModule) = v4;
  if ( !*(_DWORD *)((char *)RwEngineInstance + v5) )
    return 0;
  ++cameraModule;
  return instance;
}
// 6BCD28: using guessed type int cameraModule;
// 6BCD2C: using guessed type int cameraModule;

//----- (001D5A14) --------------------------------------------------------
RwCamera_0 *__fastcall RwCameraEndUpdate(RwCamera_0 *camera)
{
  return (RwCamera_0 *)((int (*)(void))camera->endUpdate)();
}

//----- (001D5A18) --------------------------------------------------------
RwCamera_0 *__fastcall RwCameraBeginUpdate(RwCamera_0 *camera)
{
  return (RwCamera_0 *)((int (*)(void))camera->beginUpdate)();
}

//----- (001D5A1C) --------------------------------------------------------
RwCamera_0 *__fastcall RwCameraSetViewOffset(RwCamera_0 *camera, const RwV2d_0 *offset)
{
  RwFrame_0 *parent; // r0

  parent = (RwFrame_0 *)camera->object.object.parent;
  camera->viewOffset = *offset;
  if ( parent )
    RwFrameUpdateObjects(parent);
  return camera;
}

//----- (001D5A38) --------------------------------------------------------
RwCamera_0 *__fastcall RwCameraSetNearClipPlane(RwCamera_0 *camera, RwReal nearClip)
{
  float v3; // s16
  float v4; // s2
  float farPlane; // s0
  float nearPlane; // s4
  RwFrame_0 *parent; // r0
  float v8; // s6
  float v9; // s8
  float v10; // s2
  RwReal v11; // s6

  camera->nearPlane = nearClip;
  v3 = RwIm2DGetNearScreenZ();
  v4 = RwIm2DGetFarScreenZ();
  farPlane = camera->farPlane;
  if ( camera->projectionType == rwPARALLEL )
  {
    nearPlane = camera->nearPlane;
  }
  else
  {
    nearPlane = 1.0 / camera->nearPlane;
    farPlane = 1.0 / farPlane;
  }
  parent = (RwFrame_0 *)camera->object.object.parent;
  v8 = (float)(v4 - v3) * 0.0001;
  v9 = v3 + v8;
  v10 = v4 - v8;
  v11 = (float)(v10 - (float)(v3 + v8)) / (float)(farPlane - nearPlane);
  camera->zScale = v11;
  camera->zShift = (float)((float)(v10 + v9) - (float)((float)(farPlane + nearPlane) * v11)) * 0.5;
  if ( parent )
    RwFrameUpdateObjects(parent);
  return camera;
}

//----- (001D5ACC) --------------------------------------------------------
RwCamera_0 *__fastcall RwCameraSetFarClipPlane(RwCamera_0 *camera, RwReal farClip)
{
  float v3; // s16
  float v4; // s2
  float farPlane; // s0
  float nearPlane; // s4
  RwFrame_0 *parent; // r0
  float v8; // s6
  float v9; // s8
  float v10; // s2
  RwReal v11; // s6

  camera->farPlane = farClip;
  v3 = RwIm2DGetNearScreenZ();
  v4 = RwIm2DGetFarScreenZ();
  farPlane = camera->farPlane;
  if ( camera->projectionType == rwPARALLEL )
  {
    nearPlane = camera->nearPlane;
  }
  else
  {
    nearPlane = 1.0 / camera->nearPlane;
    farPlane = 1.0 / farPlane;
  }
  parent = (RwFrame_0 *)camera->object.object.parent;
  v8 = (float)(v4 - v3) * 0.0001;
  v9 = v3 + v8;
  v10 = v4 - v8;
  v11 = (float)(v10 - (float)(v3 + v8)) / (float)(farPlane - nearPlane);
  camera->zScale = v11;
  camera->zShift = (float)((float)(v10 + v9) - (float)((float)(farPlane + nearPlane) * v11)) * 0.5;
  if ( parent )
    RwFrameUpdateObjects(parent);
  return camera;
}

//----- (001D5B60) --------------------------------------------------------
RwFrustumTestResult_0 __fastcall RwCameraFrustumTestSphere(const RwCamera_0 *camera, const RwSphere_0 *sphere)
{
  float x; // s4
  float y; // s8
  float z; // s6
  float radius; // s0
  float v6; // s2
  float v7; // s10
  float v8; // s12
  float v9; // s14
  float v10; // s1
  float v11; // s4
  RwFrustumTestResult_0 result; // r0
  float v13; // s0

  x = sphere->center.x;
  y = sphere->center.y;
  z = sphere->center.z;
  radius = sphere->radius;
  v6 = (float)((float)((float)(sphere->center.x * camera->frustumPlanes[0].plane.normal.x)
                     + (float)(y * camera->frustumPlanes[0].plane.normal.y))
             + (float)(z * camera->frustumPlanes[0].plane.normal.z))
     - camera->frustumPlanes[0].plane.distance;
  if ( v6 > radius )
    return 0;
  v7 = (float)((float)((float)(x * camera->frustumPlanes[1].plane.normal.x)
                     + (float)(y * camera->frustumPlanes[1].plane.normal.y))
             + (float)(z * camera->frustumPlanes[1].plane.normal.z))
     - camera->frustumPlanes[1].plane.distance;
  if ( v7 > radius )
    return 0;
  v8 = (float)((float)((float)(x * camera->frustumPlanes[2].plane.normal.x)
                     + (float)(y * camera->frustumPlanes[2].plane.normal.y))
             + (float)(z * camera->frustumPlanes[2].plane.normal.z))
     - camera->frustumPlanes[2].plane.distance;
  if ( v8 > radius )
    return 0;
  v9 = (float)((float)((float)(x * camera->frustumPlanes[3].plane.normal.x)
                     + (float)(y * camera->frustumPlanes[3].plane.normal.y))
             + (float)(z * camera->frustumPlanes[3].plane.normal.z))
     - camera->frustumPlanes[3].plane.distance;
  if ( v9 > radius )
    return 0;
  v10 = (float)((float)((float)(x * camera->frustumPlanes[4].plane.normal.x)
                      + (float)(y * camera->frustumPlanes[4].plane.normal.y))
              + (float)(z * camera->frustumPlanes[4].plane.normal.z))
      - camera->frustumPlanes[4].plane.distance;
  if ( v10 > radius )
    return 0;
  v11 = (float)((float)((float)(x * camera->frustumPlanes[5].plane.normal.x)
                      + (float)(y * camera->frustumPlanes[5].plane.normal.y))
              + (float)(z * camera->frustumPlanes[5].plane.normal.z))
      - camera->frustumPlanes[5].plane.distance;
  if ( v11 > radius )
    return 0;
  v13 = -radius;
  result = rwSPHEREINSIDE;
  if ( v6 > v13 )
    result = rwSPHEREBOUNDARY;
  if ( v7 > v13 )
    result = rwSPHEREBOUNDARY;
  if ( v8 > v13 )
    result = rwSPHEREBOUNDARY;
  if ( v9 > v13 )
    result = rwSPHEREBOUNDARY;
  if ( v10 > v13 )
    result = rwSPHEREBOUNDARY;
  if ( v11 > v13 )
    return 1;
  return result;
}

//----- (001D5CF0) --------------------------------------------------------
RwCamera_0 *__fastcall RwCameraClear(RwCamera_0 *camera, RwRGBA_0 *color, RwInt32 clearMode)
{
  RwCamera_0 *result; // r0

  result = (RwCamera_0 *)(*((int (__fastcall **)(RwCamera_0 *, RwRGBA_0 *, RwInt32))RwEngineInstance + 39))(
                           camera,
                           color,
                           clearMode);
  if ( result )
    return camera;
  return result;
}

//----- (001D5D14) --------------------------------------------------------
RwCamera_0 *__fastcall RwCameraShowRaster(RwCamera_0 *camera, void *dev, RwUInt32 flags)
{
  RwCamera_0 *result; // r0

  result = (RwCamera_0 *)RwRasterShowRaster(camera->frameBuffer, dev, flags);
  if ( result )
    return camera;
  return result;
}

//----- (001D5D28) --------------------------------------------------------
RwCamera_0 *__fastcall RwCameraSetProjection(RwCamera_0 *camera, RwCameraProjection_0 projection)
{
  RwCamera_0 *v2; // r4
  RwFrame_0 *parent; // r0
  float v4; // s16
  float v5; // s2
  float farPlane; // s0
  float nearPlane; // s4
  float v8; // s6
  float v9; // s8
  float v10; // s2
  RwReal v11; // s6
  RwError_0 v13; // [sp+0h] [bp-18h] BYREF

  v2 = camera;
  if ( (unsigned int)(projection - 1) > 1 )
  {
    v2 = 0;
    v13.pluginID = 0;
    v13.errorCode = _rwerror(-2147483645, "Invalid projection type specified");
    RwErrorSet(&v13);
  }
  else
  {
    parent = (RwFrame_0 *)camera->object.object.parent;
    v2->projectionType = projection;
    if ( parent )
      RwFrameUpdateObjects(parent);
    v4 = RwIm2DGetNearScreenZ();
    v5 = RwIm2DGetFarScreenZ();
    farPlane = v2->farPlane;
    if ( v2->projectionType == rwPARALLEL )
    {
      nearPlane = v2->nearPlane;
    }
    else
    {
      nearPlane = 1.0 / v2->nearPlane;
      farPlane = 1.0 / farPlane;
    }
    v8 = (float)(v5 - v4) * 0.0001;
    v9 = v4 + v8;
    v10 = v5 - v8;
    v11 = (float)(v10 - (float)(v4 + v8)) / (float)(farPlane - nearPlane);
    v2->zScale = v11;
    v2->zShift = (float)((float)(v10 + v9) - (float)((float)(farPlane + nearPlane) * v11)) * 0.5;
  }
  return v2;
}

//----- (001D5E04) --------------------------------------------------------
RwCamera_0 *__fastcall RwCameraSetViewWindow(RwCamera_0 *camera, const RwV2d_0 *viewWindow)
{
  RwV2d_0 v3; // kr00_8
  RwFrame_0 *parent; // r0

  if ( viewWindow->x == 0.0 && viewWindow->y == 0.0 )
  {
    viewWindow->x = 1.0;
    viewWindow->y = 1.0;
  }
  v3 = *viewWindow;
  parent = (RwFrame_0 *)camera->object.object.parent;
  camera->viewWindow = *viewWindow;
  camera->recipViewWindow.x = 1.0 / v3.x;
  camera->recipViewWindow.y = 1.0 / v3.y;
  if ( parent )
    RwFrameUpdateObjects(parent);
  return camera;
}

//----- (001D5E60) --------------------------------------------------------
RwInt32 __fastcall RwCameraRegisterPlugin(
        RwInt32 size,
        RwUInt32 pluginID,
        RwPluginObjectConstructor constructCB,
        RwPluginObjectDestructor destructCB,
        RwPluginObjectCopy copyCB)
{
  return _rwPluginRegistryAddPlugin(&cameraTKList, size, pluginID, constructCB, destructCB, copyCB);
}

//----- (001D5E8C) --------------------------------------------------------
RwInt32 __fastcall RwCameraGetPluginOffset(RwUInt32 pluginID)
{
  return sub_18F574(&cameraTKList, pluginID);
}

//----- (001D5E9C) --------------------------------------------------------
RwBool __fastcall RwCameraValidatePlugins(const RwCamera_0 *camera)
{
  return 1;
}

//----- (001D5EA0) --------------------------------------------------------
RwBool __fastcall RwCameraDestroy(RwCamera_0 *camera)
{
  _rwPluginRegistryDeInitObject(&cameraTKList, camera);
  _rwObjectHasFrameReleaseFrame(camera);
  (*((void (__fastcall **)(_DWORD, RwCamera_0 *))RwEngineInstance + 80))(
    *(_DWORD *)((char *)RwEngineInstance + cameraModule),
    camera);
  return 1;
}
// 6BCD28: using guessed type int cameraModule;

//----- (001D5EE0) --------------------------------------------------------
RwCamera_0 *RwCameraCreate()
{
  char *v0; // r4
  __int64 v1; // d18
  __int64 v2; // d19
  float v3; // s16
  float v4; // s2
  float v5; // s0
  float v6; // s4
  float v7; // s6
  float v8; // s8
  float v9; // s2
  float v10; // s6

  v0 = (char *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                 + cameraModule));
  if ( !v0 )
    return 0;
  *(float *)&v1 = 1.0;
  *((float *)&v1 + 1) = 1.0;
  *(float *)&v2 = 1.0;
  *((float *)&v2 + 1) = 1.0;
  v0[7] = 0;
  *(_WORD *)(v0 + 5) = 0;
  *v0 = 4;
  *((_DWORD *)v0 + 34) = 1084227584;
  *((_DWORD *)v0 + 24) = 0;
  *((_DWORD *)v0 + 25) = 0;
  *(_DWORD *)(v0 + 1) = 0;
  *((_DWORD *)v0 + 4) = CameraSync;
  *((_DWORD *)v0 + 5) = 1;
  *((_DWORD *)v0 + 6) = CameraBeginUpdate;
  *((_DWORD *)v0 + 7) = CameraEndUpdate;
  *((_QWORD *)v0 + 13) = v1;
  *((_QWORD *)v0 + 14) = v2;
  *((_QWORD *)v0 + 15) = 0LL;
  *((_QWORD *)v0 + 16) = 0x412000003D4CCCCDLL;
  v3 = RwIm2DGetNearScreenZ();
  v4 = RwIm2DGetFarScreenZ();
  v5 = *((float *)v0 + 33);
  if ( *((_DWORD *)v0 + 5) == 2 )
  {
    v6 = *((float *)v0 + 32);
  }
  else
  {
    v6 = 1.0 / *((float *)v0 + 32);
    v5 = 1.0 / v5;
  }
  *((_DWORD *)v0 + 11) = 0;
  v7 = (float)(v4 - v3) * 0.0001;
  v8 = v3 + v7;
  v9 = v4 - v7;
  v10 = (float)(v9 - (float)(v3 + v7)) / (float)(v5 - v6);
  *((float *)v0 + 35) = v10;
  *((float *)v0 + 36) = (float)((float)(v9 + v8) - (float)((float)(v5 + v6) * v10)) * 0.5;
  _rwPluginRegistryInitObject(&cameraTKList, v0);
  return (RwCamera_0 *)v0;
}
// 6BCD28: using guessed type int cameraModule;

//----- (001D600C) --------------------------------------------------------
RwObjectHasFrame_0 *__fastcall CameraSync(RwObjectHasFrame_0 *type)
{
  RwLLLink *prev; // s2
  RwMatrix *p_prev; // r0
  void *parent; // r1
  float v5; // s6
  float v6; // s2
  float v7; // s4
  float v8; // s8
  float v9; // s6
  int v10; // r6
  float v11; // s2
  float v12; // s8
  float v13; // s6
  float v14; // s4
  float v15; // s0
  float v16; // s2
  float v17; // s4
  float v18; // s2
  float v19; // s6
  float v20; // s0
  float *v21; // r0
  const RwV3d_0 *p_sync; // r8
  void *v23; // s0
  RwLLLink *next; // s2
  float v25; // s4
  float v26; // s12
  float v27; // s14
  float v28; // s10
  float v29; // s6
  float v30; // s0
  float v31; // s1
  float v32; // s3
  float v33; // s13
  float v34; // s5
  float v35; // s11
  void *v36; // s18
  float v37; // s2
  float v38; // s16
  float v39; // s5
  float v40; // s3
  float v41; // s8
  float v42; // s7
  float v43; // s10
  float v44; // s6
  float v45; // s15
  float v46; // s0
  float v47; // s13
  float v48; // s4
  float v49; // s14
  float v50; // s12
  float v51; // s9
  float v52; // s13
  float v53; // s4
  float v54; // s18
  float v55; // s0
  float v56; // s2
  float *v57; // r2
  float v58; // s10
  float v59; // s12
  float v60; // s8
  float v61; // s6
  float v62; // s14
  float v63; // s1
  float v64; // s12
  float v65; // s14
  float v66; // s1
  __int64 v67; // d16
  char v68; // r6
  void *v69; // s0
  RwLLLink *v70; // s2
  RwLLLink *v71; // s4
  float v72; // s2
  float v73; // s8
  float v74; // s0
  float v75; // s10
  char v76; // r0
  RwObjectHasFrameSyncFunction sync; // s6
  float v78; // s0
  RwLLLink *v79; // s2
  float v80; // s0
  char v81; // r0
  float v82; // s0
  char v83; // r0
  void *v84; // s12
  float v85; // s0
  float v86; // s16
  float v87; // s2
  float v88; // s18
  RwObjectHasFrameSyncFunction v89; // s10
  float v90; // s12
  float v91; // s20
  float v92; // s0
  float v93; // s4
  float v94; // s6
  float v95; // s0
  RwReal v96; // r0
  char v97; // r1
  float v98; // s0
  float v99; // s4
  float v100; // s2
  float v101; // s12
  RwObjectHasFrameSyncFunction v102; // s5
  float v103; // s6
  float v104; // s4
  float v105; // s6
  float v106; // s10
  float v107; // s0
  float v108; // s8
  float v109; // s14
  RwReal v110; // r0
  float v111; // s0
  char v112; // r1
  void *v113; // s2
  float v114; // s12
  float v115; // s16
  RwLLLink *v116; // s4
  float v117; // s20
  float v118; // s0
  float v119; // s18
  float v120; // s1
  RwObjectHasFrameSyncFunction v121; // s5
  float v122; // s10
  float v123; // s6
  float v124; // s4
  float v125; // s12
  float v126; // s0
  float v127; // s10
  float v128; // s2
  float v129; // s4
  float v130; // s8
  float v131; // s14
  RwReal v132; // r0
  char v133; // r1
  float v134; // s2
  float v135; // s4
  float v136; // s0
  float v137; // s12
  float v138; // s5
  float v139; // s8
  float v140; // s4
  float v141; // s6
  float v142; // s10
  float v143; // s0
  float v144; // s8
  float v145; // s14
  float v146; // s12
  char v147; // r0
  float v148; // s0
  float v149; // s2
  float v150; // s4
  float v151; // s6
  float v152; // s6
  float v153; // s8
  float v154; // s4
  float v155; // s0
  float v156; // s2
  float v157; // s4
  float v158; // s2
  float v159; // s8
  float v160; // s0
  RwLLLink *v161; // s6
  RwLLLink *v162; // s8
  float v163; // s2
  void *v164; // s4
  void *v165; // s14
  RwLLLink *v166; // s1
  char *v167; // r5
  float v168; // s12
  float v169; // s2
  float v170; // s0
  float v171; // s4
  float v172; // s10
  float v173; // s12
  float v174; // s3
  float v175; // s5
  float v176; // s2
  float v177; // s14
  float v178; // s0
  float v179; // s4
  void *v180; // s0
  RwLLLink *v181; // s2
  RwLLLink *v182; // s4
  RwLLLink *v183; // s6
  RwObjectHasFrameSyncFunction v184; // s8
  float v185; // s10
  char v186; // r0
  float v187; // s0
  char v188; // r0
  char v189; // r0
  float v190; // s0
  float v191; // s4
  float v192; // s0
  char v193; // r0
  void *v194; // s12
  float v195; // s0
  float v196; // s18
  float v197; // s2
  float v198; // s20
  RwObjectHasFrameSyncFunction v199; // s10
  float v200; // s12
  float v201; // s22
  float v202; // s0
  float v203; // s4
  float v204; // s6
  float v205; // s0
  float v206; // s12
  char v207; // r0
  float v208; // s0
  float v209; // s4
  float v210; // s2
  float v211; // s6
  float v212; // s0
  float v213; // s2
  float v214; // s4
  float v215; // s10
  float v216; // s0
  float v217; // s6
  float v218; // s4
  float v219; // s3
  char v220; // r0
  float v221; // s4
  float v222; // s0
  float v223; // s2
  float v224; // s12
  char v225; // r0
  RwLLLink *v226; // s12
  RwObjectHasFrameSyncFunction v227; // s14
  float v228; // s1
  RwLLLink *v229; // s5
  RwObjectHasFrameSyncFunction v230; // s7
  float v231; // s9
  float v232; // s13
  float v233; // s15
  char v234; // r0
  float v235; // s9
  float v236; // s5
  char v237; // r0

  prev = type[5].lFrame.prev;
  p_prev = (RwMatrix *)&type[1].lFrame.prev;
  parent = type->object.parent;
  v5 = *(float *)&prev * -0.5;
  v6 = (float)(*(float *)&prev * -0.5) * *(float *)&type[6].object.type;
  v7 = v5 * *((float *)parent + 22);
  v8 = v5 * *((float *)parent + 21);
  v9 = *((float *)parent + 20) * v5;
  if ( *(_DWORD *)&type[1].object.type == 1 )
  {
    v10 = 0;
    v11 = 0.5 - v6;
    v12 = v8 + (float)(v11 * *((float *)parent + 29));
    v13 = v9 + (float)(v11 * *((float *)parent + 28));
    v14 = v7 + (float)(v11 * *((float *)parent + 30));
    *(float *)&type[2].lFrame.next = v12;
    *(float *)&type[1].lFrame.prev = v13;
    *(float *)&type[3].object.parent = v14;
    v15 = *(float *)&type[5].sync * -0.5;
    v16 = v11
        + (float)((float)((float)(v13 * *((float *)parent + 32)) + (float)(v12 * *((float *)parent + 33)))
                + (float)(v14 * *((float *)parent + 34)));
    v17 = (float)(v15 * *(float *)&type[6].object.parent) + 0.5;
    *(float *)&type[4].object.type = 0.5 - v16;
    v18 = (float)(*((float *)parent + 24) * v15) + (float)(*((float *)parent + 28) * v17);
    v19 = (float)(v15 * *((float *)parent + 25)) + (float)(*((float *)parent + 29) * v17);
    v20 = (float)(v15 * *((float *)parent + 26)) + (float)(v17 * *((float *)parent + 30));
    *(float *)&type[1].sync = v18;
    *(float *)&type[2].lFrame.prev = v19;
    *(float *)&type[3].lFrame.next = v20;
    *(float *)&type[4].object.parent = 0.5
                                     - (float)(v17
                                             + (float)((float)((float)(v18 * *((float *)parent + 32))
                                                             + (float)(v19 * *((float *)parent + 33)))
                                                     + (float)(v20 * *((float *)parent + 34))));
    *(_DWORD *)&type[2].object.type = *((_DWORD *)parent + 28);
    type[2].sync = (RwObjectHasFrameSyncFunction)*((_DWORD *)parent + 29);
    type[3].lFrame.prev = (RwLLLink *)*((_DWORD *)parent + 30);
    *(float *)&type[4].lFrame.next = -(float)((float)((float)(*((float *)parent + 32) * *((float *)parent + 28))
                                                    + (float)(*((float *)parent + 33) * *((float *)parent + 29)))
                                            + (float)(*((float *)parent + 34) * *((float *)parent + 30)));
    RwMatrixOptimize(p_prev, 0);
    v21 = (float *)type->object.parent;
    p_sync = (const RwV3d_0 *)&type[14].sync;
    v23 = type[5].object.parent;
    next = type[5].lFrame.next;
    v25 = v21[20];
    v26 = v21[21];
    v27 = v21[22];
    v28 = v25 * *(float *)&v23;
    v29 = v26 * *(float *)&v23;
    v30 = v27 * *(float *)&v23;
    v31 = v21[24];
    v32 = v21[25];
    v33 = v31 * *(float *)&next;
    v34 = v21[26];
    v35 = v32 * *(float *)&next;
    v36 = type[6].object.parent;
    v37 = v34 * *(float *)&next;
    v38 = v29 + v29;
    v39 = *(float *)&v36 * v34;
    v40 = *(float *)&v36 * v32;
    v41 = (float)(v29 + v21[29]) + v35;
    v42 = v28 + v28;
    v43 = (float)(v21[28] + v28) + v33;
    v44 = (float)(v30 + v21[30]) + v37;
    v45 = v30 + v30;
    v46 = v33 + v33;
    v47 = *(float *)&type[6].object.type;
    *(float *)&type[14].sync = v43;
    v48 = v25 * v47;
    *(float *)&type[15].object.type = v41;
    *(float *)&type[15].object.parent = v44;
    v49 = v27 * v47;
    v50 = v26 * v47;
    v51 = (float)(v41 - v38) - (float)(v35 + v35);
    v52 = (float)(v43 - v42) - v46;
    *(float *)&type[15].lFrame.next = v43 - v42;
    v53 = (float)(v31 * *(float *)&v36) - v48;
    *(float *)&type[15].lFrame.prev = v41 - v38;
    v54 = (float)(v44 - v45) - (float)(v37 + v37);
    *(float *)&type[15].sync = v44 - v45;
    v55 = v39 - v49;
    v56 = v40 - v50;
    *(float *)&type[16].object.type = v52;
    *(float *)&type[16].object.parent = v51;
    *(float *)&type[16].lFrame.next = v54;
    *(float *)&type[16].lFrame.prev = v42 + v52;
    *(float *)&type[16].sync = v38 + v51;
    *(float *)&type[17].object.type = v45 + v54;
    while ( 1 )
    {
      v57 = (float *)(&type->object.type + v10);
      v58 = v43 - v53;
      v59 = v53 + v21[32];
      v60 = v41 - v56;
      v61 = v44 - v55;
      v57[74] = v59;
      v62 = v56 + v21[33];
      v57[75] = v62;
      v63 = v55 + v21[34];
      v57[76] = v63;
      v57[74] = v59 + (float)(v58 * *(float *)&type[6].lFrame.next);
      v57[75] = v62 + (float)(v60 * *(float *)&type[6].lFrame.next);
      v57[76] = v63 + (float)(v61 * *(float *)&type[6].lFrame.next);
      v64 = v53 + v21[32];
      v57[86] = v64;
      v65 = v56 + v21[33];
      v57[87] = v65;
      v66 = v55 + v21[34];
      v57[88] = v66;
      v57[86] = v64 + (float)(v58 * *(float *)&type[6].lFrame.prev);
      v57[87] = v65 + (float)(v60 * *(float *)&type[6].lFrame.prev);
      v57[88] = v66 + (float)(v61 * *(float *)&type[6].lFrame.prev);
      if ( v10 == 36 )
        break;
      v43 = v57[77];
      v10 += 12;
      v41 = v57[78];
      v44 = v57[79];
    }
    v67 = *((_QWORD *)v21 + 14);
    v68 = 0;
    v69 = type[17].object.parent;
    v70 = type[17].lFrame.next;
    v71 = type[17].lFrame.prev;
    *(float *)&type[8].object.type = v21[30];
    *(_QWORD *)&type[7].lFrame.prev = v67;
    v72 = *(float *)&v70 * v21[29];
    v73 = *(float *)&type[8].object.type;
    v74 = *(float *)&v69 * v21[28];
    v75 = v21[30];
    v76 = 0;
    sync = type[7].sync;
    v78 = v74 + v72;
    v79 = type[7].lFrame.prev;
    v80 = v78 + (float)(*(float *)&v71 * v75);
    if ( v73 >= 0.0 )
      v76 = 1;
    BYTE2(type[8].lFrame.next) = v76;
    LOBYTE(type[8].lFrame.next) = *(float *)&v79 >= 0.0;
    BYTE1(type[8].lFrame.next) = *(float *)&sync >= 0.0;
    v81 = 0;
    *(float *)&type[8].object.parent = v80;
    *(float *)&type[8].lFrame.prev = -*(float *)&v79;
    *(float *)&type[8].sync = -*(float *)&sync;
    v82 = (float)((float)-(float)(*(float *)&v79 * *(float *)&type[14].sync)
                - (float)(*(float *)&type[15].object.type * *(float *)&sync))
        - (float)(*(float *)&type[15].object.parent * v73);
    *(float *)&type[9].object.type = -v73;
    if ( *(float *)&v79 <= -0.0 )
      v81 = 1;
    LOBYTE(type[9].lFrame.next) = v81;
    v83 = 0;
    *(float *)&type[9].object.parent = v82;
    if ( v73 <= -0.0 )
      v83 = 1;
    BYTE2(type[9].lFrame.next) = v83;
    BYTE1(type[9].lFrame.next) = *(float *)&sync <= -0.0;
    v84 = type[18].object.parent;
    v85 = *(float *)&type[18].object.type;
    v86 = *(float *)&type[15].sync - *(float *)&v84;
    v87 = *(float *)&type[18].lFrame.prev - v85;
    v88 = *(float *)&type[15].lFrame.prev - v85;
    v89 = type[17].sync;
    v90 = *(float *)&type[18].sync - *(float *)&v84;
    v91 = *(float *)&type[15].lFrame.next - *(float *)&v89;
    v92 = *(float *)&type[18].lFrame.next - *(float *)&v89;
    v93 = (float)(v88 * v90) - (float)(v86 * v87);
    v94 = (float)(v86 * v92) - (float)(v91 * v90);
    v95 = (float)(v91 * v87) - (float)(v88 * v92);
    *(float *)&type[9].lFrame.prev = v93;
    *(float *)&type[9].sync = v94;
    *(float *)&type[10].object.type = v95;
    v96 = _rwInvSqrt((float)(v95 * v95) + (float)((float)(v93 * v93) + (float)(v94 * v94)));
    v97 = 0;
    v98 = *(float *)&type[17].object.parent - *(float *)&type[17].sync;
    v99 = *(float *)&type[17].lFrame.prev - *(float *)&type[18].object.parent;
    v100 = *(float *)&type[17].lFrame.next - *(float *)&type[18].object.type;
    v101 = v96 * *(float *)&type[9].sync;
    v102 = type[15].sync;
    v103 = v88 * v99;
    v104 = (float)(v91 * v99) - (float)(v86 * v98);
    v105 = (float)(v86 * v100) - v103;
    v106 = v96 * *(float *)&type[9].lFrame.prev;
    v107 = (float)(v88 * v98) - (float)(v91 * v100);
    v108 = v96 * *(float *)&type[10].object.type;
    v109 = (float)(v106 * *(float *)&type[15].lFrame.next) + (float)(v101 * *(float *)&type[15].lFrame.prev);
    if ( v106 >= 0.0 )
      v97 = 1;
    LOBYTE(type[10].lFrame.next) = v97;
    BYTE2(type[10].lFrame.next) = v108 >= 0.0;
    BYTE1(type[10].lFrame.next) = v101 >= 0.0;
    *(float *)&type[9].lFrame.prev = v106;
    *(float *)&type[9].sync = v101;
    *(float *)&type[10].object.type = v108;
    *(float *)&type[10].object.parent = v109 + (float)(v108 * *(float *)&v102);
    *(float *)&type[10].lFrame.prev = v105;
    *(float *)&type[10].sync = v104;
    *(float *)&type[11].object.type = v107;
    v110 = _rwInvSqrt((float)(v107 * v107) + (float)((float)(v105 * v105) + (float)(v104 * v104)));
    v111 = *(float *)&type[19].object.type;
    v112 = 0;
    v113 = type[19].object.parent;
    v114 = *(float *)&type[17].object.parent - v111;
    v115 = *(float *)&type[16].lFrame.prev - v111;
    v116 = type[19].lFrame.next;
    v117 = *(float *)&type[16].sync - *(float *)&v113;
    v118 = *(float *)&type[17].lFrame.next - *(float *)&v113;
    v119 = *(float *)&type[17].object.type - *(float *)&v116;
    v120 = *(float *)&type[17].lFrame.prev - *(float *)&v116;
    v121 = type[15].sync;
    v122 = v117 * v114;
    v123 = v119 * v118;
    v124 = v119 * v114;
    v125 = v110 * *(float *)&type[10].sync;
    v126 = (float)(v115 * v118) - v122;
    v127 = v110 * *(float *)&type[10].lFrame.prev;
    v128 = v124 - (float)(v115 * v120);
    v129 = (float)(v117 * v120) - v123;
    v130 = v110 * *(float *)&type[11].object.type;
    v131 = (float)(v127 * *(float *)&type[15].lFrame.next) + (float)(v125 * *(float *)&type[15].lFrame.prev);
    if ( v127 >= 0.0 )
      v112 = 1;
    LOBYTE(type[11].lFrame.next) = v112;
    BYTE2(type[11].lFrame.next) = v130 >= 0.0;
    BYTE1(type[11].lFrame.next) = v125 >= 0.0;
    *(float *)&type[10].lFrame.prev = v127;
    *(float *)&type[10].sync = v125;
    *(float *)&type[11].object.type = v130;
    *(float *)&type[11].object.parent = v131 + (float)(v130 * *(float *)&v121);
    *(float *)&type[11].lFrame.prev = v129;
    *(float *)&type[11].sync = v128;
    *(float *)&type[12].object.type = v126;
    v132 = _rwInvSqrt((float)(v126 * v126) + (float)((float)(v129 * v129) + (float)(v128 * v128)));
    v133 = 0;
    v134 = *(float *)&type[18].lFrame.prev - *(float *)&type[19].object.parent;
    v135 = *(float *)&type[18].sync - *(float *)&type[19].lFrame.next;
    v136 = *(float *)&type[18].lFrame.next - *(float *)&type[19].object.type;
    v137 = v132 * *(float *)&type[11].sync;
    v138 = *(float *)&type[17].object.type;
    v139 = v115 * v135;
    v140 = (float)(v119 * v134) - (float)(v117 * v135);
    v141 = v139 - (float)(v119 * v136);
    v142 = v132 * *(float *)&type[11].lFrame.prev;
    v143 = (float)(v117 * v136) - (float)(v115 * v134);
    v144 = v132 * *(float *)&type[12].object.type;
    v145 = (float)(v142 * *(float *)&type[16].lFrame.prev) + (float)(v137 * *(float *)&type[16].sync);
    if ( v142 >= 0.0 )
      v133 = 1;
    LOBYTE(type[12].lFrame.next) = v133;
    BYTE2(type[12].lFrame.next) = v144 >= 0.0;
    BYTE1(type[12].lFrame.next) = v137 >= 0.0;
    *(float *)&type[11].lFrame.prev = v142;
    *(float *)&type[11].sync = v137;
    *(float *)&type[12].object.type = v144;
    *(float *)&type[12].object.parent = v145 + (float)(v144 * v138);
    *(float *)&type[12].lFrame.prev = v140;
    *(float *)&type[12].sync = v141;
    *(float *)&type[13].object.type = v143;
    v146 = _rwInvSqrt((float)(v143 * v143) + (float)((float)(v140 * v140) + (float)(v141 * v141)));
    v147 = 0;
    v148 = v146 * *(float *)&type[12].lFrame.prev;
    v149 = v146 * *(float *)&type[12].sync;
    v150 = v146 * *(float *)&type[13].object.type;
    v151 = (float)((float)(v148 * *(float *)&type[16].lFrame.prev) + (float)(v149 * *(float *)&type[16].sync))
         + (float)(v150 * *(float *)&type[17].object.type);
    if ( v148 >= 0.0 )
      v147 = 1;
    LOBYTE(type[13].lFrame.next) = v147;
    BYTE1(type[13].lFrame.next) = v149 >= 0.0;
    *(float *)&type[12].lFrame.prev = v148;
    *(float *)&type[12].sync = v149;
    *(float *)&type[13].object.type = v150;
    *(float *)&type[13].object.parent = v151;
    if ( v150 >= 0.0 )
      v68 = 1;
  }
  else
  {
    v68 = 0;
    v152 = v9 - (float)(*((float *)parent + 28) * v6);
    v153 = v8 - (float)(*((float *)parent + 29) * v6);
    v154 = v7 - (float)(*((float *)parent + 30) * v6);
    *(float *)&type[2].lFrame.next = v153;
    *(float *)&type[1].lFrame.prev = v152;
    *(float *)&type[3].object.parent = v154;
    v155 = *(float *)&type[5].sync * -0.5;
    v156 = 0.5
         - (float)((float)((float)((float)(v152 * *((float *)parent + 32)) + (float)(v153 * *((float *)parent + 33)))
                         + (float)(v154 * *((float *)parent + 34)))
                 - v6);
    v157 = v155 * *(float *)&type[6].object.parent;
    *(float *)&type[4].object.type = v156;
    v158 = (float)(*((float *)parent + 24) * v155) + (float)(*((float *)parent + 28) * v157);
    v159 = (float)(v155 * *((float *)parent + 25)) + (float)(v157 * *((float *)parent + 29));
    v160 = (float)(v155 * *((float *)parent + 26)) + (float)(v157 * *((float *)parent + 30));
    *(float *)&type[1].sync = v158;
    *(float *)&type[2].lFrame.prev = v159;
    *(float *)&type[3].lFrame.next = v160;
    *(float *)&type[4].object.parent = 0.5
                                     - (float)(v157
                                             + (float)((float)((float)(v158 * *((float *)parent + 32))
                                                             + (float)(v159 * *((float *)parent + 33)))
                                                     + (float)(v160 * *((float *)parent + 34))));
    *(_DWORD *)&type[2].object.type = *((_DWORD *)parent + 28);
    type[2].sync = (RwObjectHasFrameSyncFunction)*((_DWORD *)parent + 29);
    type[3].lFrame.prev = (RwLLLink *)*((_DWORD *)parent + 30);
    *(float *)&type[4].lFrame.next = -(float)((float)((float)(*((float *)parent + 32) * *((float *)parent + 28))
                                                    + (float)(*((float *)parent + 33) * *((float *)parent + 29)))
                                            + (float)(*((float *)parent + 34) * *((float *)parent + 30)));
    RwMatrixOptimize(p_prev, 0);
    v161 = type[6].lFrame.next;
    v162 = type[6].lFrame.prev;
    p_sync = (const RwV3d_0 *)&type[14].sync;
    v163 = *(float *)&type[6].object.type;
    v164 = type[6].object.parent;
    v165 = type[5].object.parent;
    v166 = type[5].lFrame.next;
    v167 = (char *)type->object.parent;
    type[15].object.parent = v161;
    type[15].sync = (RwObjectHasFrameSyncFunction)v161;
    v168 = -(float)(v163 * (float)(1.0 - *(float *)&v161));
    v169 = -(float)(v163 * (float)(1.0 - *(float *)&v162));
    v170 = (float)(1.0 - *(float *)&v162) * *(float *)&v164;
    v171 = (float)(1.0 - *(float *)&v161) * *(float *)&v164;
    v172 = *(float *)&v165 + v168;
    v173 = v168 - *(float *)&v165;
    v174 = v169 - *(float *)&v165;
    v175 = v170 - *(float *)&v166;
    v176 = *(float *)&v165 + v169;
    v177 = *(float *)&v166 + v171;
    v178 = *(float *)&v166 + v170;
    v179 = v171 - *(float *)&v166;
    *(float *)&type[15].lFrame.next = v173;
    *(float *)&type[14].sync = v172;
    *(float *)&type[16].object.type = v173;
    *(float *)&type[15].lFrame.prev = v177;
    *(float *)&type[16].object.parent = v179;
    *(float *)&type[15].object.type = v177;
    *(float *)&type[18].object.type = v178;
    type[18].object.parent = v162;
    *(float *)&type[18].lFrame.next = v174;
    *(float *)&type[18].lFrame.prev = v175;
    type[18].sync = (RwObjectHasFrameSyncFunction)v162;
    *(float *)&type[19].object.type = v176;
    *(float *)&type[19].object.parent = v175;
    type[19].lFrame.next = v162;
    type[16].lFrame.next = v161;
    *(float *)&type[16].lFrame.prev = v172;
    *(float *)&type[16].sync = v179;
    *(float *)&type[17].object.type = *(float *)&v161;
    *(float *)&type[17].object.parent = v176;
    *(float *)&type[17].lFrame.next = v178;
    type[17].lFrame.prev = v162;
    *(float *)&type[17].sync = v174;
    RwV3dTransformPoints((RwV3d_0 *)&type[14].sync, (const RwV3d_0 *)&type[14].sync, 8, (const RwMatrix *)(v167 + 80));
    v180 = type[17].object.parent;
    v181 = type[17].lFrame.next;
    v182 = type[17].lFrame.prev;
    *(_QWORD *)&type[7].lFrame.prev = *((_QWORD *)v167 + 14);
    v183 = type[7].lFrame.prev;
    v184 = type[7].sync;
    *(_DWORD *)&type[8].object.type = *((_DWORD *)v167 + 30);
    v185 = *(float *)&type[8].object.type;
    v186 = 0;
    v187 = (float)((float)(*(float *)&v180 * *(float *)&v183) + (float)(*(float *)&v181 * *(float *)&v184))
         + (float)(*(float *)&v182 * v185);
    if ( *(float *)&v183 >= 0.0 )
      v186 = 1;
    LOBYTE(type[8].lFrame.next) = v186;
    v188 = 0;
    *(float *)&type[8].object.parent = v187;
    if ( v185 >= 0.0 )
      v188 = 1;
    BYTE2(type[8].lFrame.next) = v188;
    BYTE1(type[8].lFrame.next) = *(float *)&v184 >= 0.0;
    v189 = 0;
    *(float *)&type[8].lFrame.prev = -*(float *)&v183;
    *(float *)&type[8].sync = -*(float *)&v184;
    v190 = *(float *)&type[15].object.type;
    *(float *)&type[9].object.type = -v185;
    v191 = *(float *)&type[15].object.parent * v185;
    v192 = (float)-(float)(*(float *)&v183 * *(float *)&type[14].sync) - (float)(v190 * *(float *)&v184);
    if ( *(float *)&v183 <= -0.0 )
      v189 = 1;
    LOBYTE(type[9].lFrame.next) = v189;
    v193 = 0;
    *(float *)&type[9].object.parent = v192 - v191;
    if ( v185 <= -0.0 )
      v193 = 1;
    BYTE2(type[9].lFrame.next) = v193;
    BYTE1(type[9].lFrame.next) = *(float *)&v184 <= -0.0;
    v194 = type[18].object.parent;
    v195 = *(float *)&type[18].object.type;
    v196 = *(float *)&type[15].sync - *(float *)&v194;
    v197 = *(float *)&type[18].lFrame.prev - v195;
    v198 = *(float *)&type[15].lFrame.prev - v195;
    v199 = type[17].sync;
    v200 = *(float *)&type[18].sync - *(float *)&v194;
    v201 = *(float *)&type[15].lFrame.next - *(float *)&v199;
    v202 = *(float *)&type[18].lFrame.next - *(float *)&v199;
    v203 = (float)(v198 * v200) - (float)(v196 * v197);
    v204 = (float)(v196 * v202) - (float)(v201 * v200);
    v205 = (float)(v201 * v197) - (float)(v198 * v202);
    *(float *)&type[9].lFrame.prev = v203;
    *(float *)&type[9].sync = v204;
    *(float *)&type[10].object.type = v205;
    v206 = _rwInvSqrt((float)(v205 * v205) + (float)((float)(v203 * v203) + (float)(v204 * v204)));
    v207 = 0;
    v208 = v206 * *(float *)&type[9].lFrame.prev;
    v209 = v206 * *(float *)&type[10].object.type;
    v210 = v206 * *(float *)&type[9].sync;
    v211 = (float)((float)(v208 * *(float *)&type[15].lFrame.next) + (float)(v210 * *(float *)&type[15].lFrame.prev))
         + (float)(v209 * *(float *)&type[15].sync);
    if ( v208 >= 0.0 )
      v207 = 1;
    LOBYTE(type[10].lFrame.next) = v207;
    BYTE2(type[10].lFrame.next) = v209 >= 0.0;
    BYTE1(type[10].lFrame.next) = v210 >= 0.0;
    *(float *)&type[9].lFrame.prev = v208;
    *(float *)&type[9].sync = v210;
    *(float *)&type[10].object.type = v209;
    *(float *)&type[10].object.parent = v211;
    v212 = *(float *)&type[17].object.parent - *(float *)&type[17].sync;
    v213 = *(float *)&type[17].lFrame.next - *(float *)&type[18].object.type;
    v214 = *(float *)&type[17].lFrame.prev - *(float *)&type[18].object.parent;
    v215 = v196 * v212;
    v216 = (float)(v198 * v212) - (float)(v201 * v213);
    v217 = (float)(v196 * v213) - (float)(v198 * v214);
    v218 = (float)(v201 * v214) - v215;
    *(float *)&type[10].lFrame.prev = v217;
    *(float *)&type[10].sync = v218;
    *(float *)&type[11].object.type = v216;
    v219 = _rwInvSqrt((float)(v216 * v216) + (float)((float)(v217 * v217) + (float)(v218 * v218)));
    v220 = 0;
    v221 = v219 * *(float *)&type[10].lFrame.prev;
    v222 = v219 * *(float *)&type[11].object.type;
    v223 = v219 * *(float *)&type[10].sync;
    v224 = (float)((float)(v221 * *(float *)&type[15].lFrame.next) + (float)(v223 * *(float *)&type[15].lFrame.prev))
         + (float)(v222 * *(float *)&type[15].sync);
    if ( v221 >= 0.0 )
      v220 = 1;
    LOBYTE(type[11].lFrame.next) = v220;
    BYTE2(type[11].lFrame.next) = v222 >= 0.0;
    BYTE1(type[11].lFrame.next) = v223 >= 0.0;
    v225 = 0;
    *(float *)&type[10].lFrame.prev = v221;
    *(float *)&type[10].sync = v223;
    *(float *)&type[11].object.type = v222;
    *(float *)&type[11].object.parent = v224;
    v226 = type[9].lFrame.prev;
    v227 = type[9].sync;
    v228 = *(float *)&type[10].object.type;
    *(float *)&type[11].lFrame.prev = -*(float *)&v226;
    *(float *)&type[11].sync = -*(float *)&v227;
    v229 = type[16].lFrame.prev;
    v230 = type[16].sync;
    v231 = *(float *)&type[17].object.type;
    v232 = -(float)(*(float *)&v226 * *(float *)&v229);
    *(float *)&type[12].object.type = -v228;
    v233 = v231 * v228;
    if ( *(float *)&v226 <= -0.0 )
      v225 = 1;
    LOBYTE(type[12].lFrame.next) = v225;
    v234 = 0;
    v235 = v231 * v222;
    v236 = (float)-(float)(v221 * *(float *)&v229) - (float)(*(float *)&v230 * v223);
    *(float *)&type[12].object.parent = (float)(v232 - (float)(*(float *)&v230 * *(float *)&v227)) - v233;
    if ( v228 <= -0.0 )
      v234 = 1;
    BYTE2(type[12].lFrame.next) = v234;
    BYTE1(type[12].lFrame.next) = *(float *)&v227 <= -0.0;
    LOBYTE(type[13].lFrame.next) = v221 <= -0.0;
    v237 = 0;
    *(float *)&type[12].lFrame.prev = -v221;
    *(float *)&type[12].sync = -v223;
    *(float *)&type[13].object.type = -v222;
    *(float *)&type[13].object.parent = v236 - v235;
    if ( v223 <= -0.0 )
      v237 = 1;
    BYTE1(type[13].lFrame.next) = v237;
    if ( v222 <= -0.0 )
      v68 = 1;
  }
  BYTE2(type[13].lFrame.next) = v68;
  RwBBoxCalculate((RwBBox_0 *)&type[13].lFrame.prev, p_sync, 8);
  return type;
}

//----- (001D6E4C) --------------------------------------------------------
RwCamera_0 *__fastcall CameraBeginUpdate(RwCamera_0 *camera)
{
  RwCamera_0 *v2; // r5

  *(_DWORD *)RwEngineInstance = camera;
  _rwFrameSyncDirty();
  v2 = 0;
  if ( (*((int (__fastcall **)(_DWORD, RwCamera_0 *, _DWORD))RwEngineInstance + 19))(0, camera, 0) )
  {
    _rwPipeInitForCamera(camera);
    return camera;
  }
  return v2;
}

//----- (001D6E80) --------------------------------------------------------
RwCamera_0 *__fastcall CameraEndUpdate(RwCamera_0 *camera)
{
  RwCamera_0 *v2; // r5

  v2 = 0;
  if ( (*((int (__fastcall **)(_DWORD, RwCamera_0 *, _DWORD))RwEngineInstance + 28))(0, camera, 0) )
  {
    *(_DWORD *)RwEngineInstance = 0;
    return camera;
  }
  return v2;
}

//----- (001D6EB4) --------------------------------------------------------
RwCamera_0 *__fastcall RwCameraClone(RwCamera_0 *camera)
{
  RwCamera_0 *v2; // r0
  RwCamera_0 *v3; // r4
  float v4; // s16
  float v5; // s2
  float farPlane; // s0
  float nearPlane; // s4
  float v8; // s6
  float v9; // s8
  float v10; // s2
  RwReal v11; // s6

  v2 = RwCameraCreate();
  v3 = v2;
  if ( !v2 )
    return 0;
  _rwObjectHasFrameSetFrame(v2, (RwFrame_0 *)camera->object.object.parent);
  v3->beginUpdate = camera->beginUpdate;
  v3->endUpdate = camera->endUpdate;
  v3->viewWindow.x = camera->viewWindow.x;
  v3->viewWindow.y = camera->viewWindow.y;
  v3->recipViewWindow.x = camera->recipViewWindow.x;
  v3->recipViewWindow.y = camera->recipViewWindow.y;
  v3->viewOffset.x = camera->viewOffset.x;
  v3->viewOffset.y = camera->viewOffset.y;
  v3->nearPlane = camera->nearPlane;
  v3->farPlane = camera->farPlane;
  v3->fogPlane = camera->fogPlane;
  v3->frameBuffer = camera->frameBuffer;
  v3->zBuffer = camera->zBuffer;
  v3->projectionType = camera->projectionType;
  v4 = RwIm2DGetNearScreenZ();
  v5 = RwIm2DGetFarScreenZ();
  farPlane = v3->farPlane;
  if ( v3->projectionType == rwPARALLEL )
  {
    nearPlane = v3->nearPlane;
  }
  else
  {
    nearPlane = 1.0 / v3->nearPlane;
    farPlane = 1.0 / farPlane;
  }
  v8 = (float)(v5 - v4) * 0.0001;
  v9 = v4 + v8;
  v10 = v5 - v8;
  v11 = (float)(v10 - (float)(v4 + v8)) / (float)(farPlane - nearPlane);
  v3->zScale = v11;
  v3->zShift = (float)((float)(v10 + v9) - (float)((float)(farPlane + nearPlane) * v11)) * 0.5;
  _rwPluginRegistryCopyObject(&cameraTKList, v3, camera);
  return v3;
}

//----- (001D6FA4) --------------------------------------------------------
void _rwCameraValOpen()
{
  RwImage_0 *v0; // r4
  RwInt32 width; // r0
  RwImage_0 *v2; // r0
  RwImage_0 *v3; // r5
  RwImage_0 *v4; // r0
  RwRaster_0 *v5; // r0
  RwInt32 v6; // [sp+8h] [bp-18h] BYREF
  RwInt32 npDepth; // [sp+Ch] [bp-14h] BYREF
  RwInt32 npHeight; // [sp+10h] [bp-10h] BYREF
  RwInt32 npWidth[3]; // [sp+14h] [bp-Ch] BYREF

  if ( LogoRaster )
    return;
  v0 = RwImageCreate(128, 64, 32);
  v0->stride = 512;
  v0->cpPixels = LogoData;
  RwImageFindRasterFormat(v0, 4, npWidth, &npHeight, &npDepth, &v6);
  width = v0->width;
  if ( width != npWidth[0] || v0->height != npHeight )
  {
    if ( v0->depth == 8 )
    {
      v2 = RwImageCreate(width, v0->height, 32);
      v3 = v2;
      if ( v2 )
      {
        if ( RwImageAllocatePixels(v2) )
        {
          RwImageCopy(v3, v0);
          RwImageDestroy(v0);
LABEL_11:
          v4 = RwImageCreate(npWidth[0], npHeight, 32);
          v0 = v4;
          if ( v4 && RwImageAllocatePixels(v4) )
          {
            RwImageResample(v0, v3);
            RwImageDestroy(v3);
          }
          else
          {
            RwImageDestroy(v3);
            v0 = 0;
          }
          goto LABEL_15;
        }
        RwImageDestroy(v3);
      }
      RwImageDestroy(v0);
      v3 = 0;
      goto LABEL_11;
    }
    v3 = v0;
    goto LABEL_11;
  }
LABEL_15:
  RwImageGammaCorrect(v0);
  v5 = RwRasterCreate(npWidth[0], npHeight, npDepth, v6);
  LogoRaster = v5;
  if ( v5 )
    RwRasterSetFromImage(v5, v0);
  RwImageDestroy(v0);
}
// 1D6FA4: using guessed type RwInt32 npWidth[3];

//----- (001D7094) --------------------------------------------------------
void _rwCameraValClose()
{
  if ( LogoRaster )
  {
    RwRasterDestroy(LogoRaster);
    LogoRaster = 0;
  }
}

//----- (001D70C0) --------------------------------------------------------
void __fastcall _rwCameraValRender(RwCamera_0 *camera)
{
  RwRaster_0 *frameBuffer; // r0
  float width; // s2
  int height; // r5
  float v5; // s0
  int v6; // r10
  int v7; // r6
  int v8; // r1
  bool v9; // cc
  bool v10; // cc
  int v11; // r8
  int v12; // r9
  float nearPlane; // s16
  int v14; // r4
  RwIm2DVertex v15; // [sp+0h] [bp-B8h] BYREF
  float v16; // [sp+1Ch] [bp-9Ch]
  float v17; // [sp+20h] [bp-98h]
  int v18; // [sp+24h] [bp-94h]
  float v19; // [sp+28h] [bp-90h]
  int v20; // [sp+2Ch] [bp-8Ch]
  int v21; // [sp+30h] [bp-88h]
  int v22; // [sp+34h] [bp-84h]
  float v23; // [sp+38h] [bp-80h]
  float v24; // [sp+3Ch] [bp-7Ch]
  int v25; // [sp+40h] [bp-78h]
  float v26; // [sp+44h] [bp-74h]
  int v27; // [sp+48h] [bp-70h]
  int v28; // [sp+4Ch] [bp-6Ch]
  int v29; // [sp+50h] [bp-68h]
  float v30; // [sp+54h] [bp-64h]
  float v31; // [sp+58h] [bp-60h]
  int v32; // [sp+5Ch] [bp-5Ch]
  float v33; // [sp+60h] [bp-58h]
  int v34; // [sp+64h] [bp-54h]
  int v35; // [sp+68h] [bp-50h]
  int v36; // [sp+6Ch] [bp-4Ch]
  char v37[4]; // [sp+70h] [bp-48h] BYREF
  void *v38; // [sp+74h] [bp-44h] BYREF
  void *v39; // [sp+78h] [bp-40h] BYREF
  void *v40; // [sp+7Ch] [bp-3Ch] BYREF
  void *v41; // [sp+80h] [bp-38h] BYREF
  void *v42; // [sp+84h] [bp-34h] BYREF
  void *v43; // [sp+88h] [bp-30h] BYREF
  void *v44; // [sp+8Ch] [bp-2Ch] BYREF
  void *value; // [sp+90h] [bp-28h] BYREF
  RwInt16 yOffset; // [sp+94h] [bp-24h] BYREF
  RwInt16 xOffset[17]; // [sp+96h] [bp-22h] BYREF

  frameBuffer = camera->frameBuffer;
  width = (float)frameBuffer->width;
  height = frameBuffer->height;
  v5 = (float)(camera->viewWindow.x * (float)height) / (float)((float)(width + width) * camera->viewWindow.y);
  v6 = (int)(float)(width * 0.1);
  v7 = (int)(float)(v5 * (float)v6);
  if ( height - 48 < v7 )
  {
    v7 = height - 48;
    v6 = (int)(float)((float)(height - 48) / v5);
  }
  RwRasterGetOffset(frameBuffer, xOffset, &yOffset);
  v9 = v7 < 1;
  if ( v7 >= 1 )
    v9 = v6 < 1;
  if ( !v9 )
  {
    v10 = xOffset[0] < -15;
    if ( xOffset[0] >= -15 )
    {
      v8 = yOffset + height - v7;
      v10 = v8 < 25;
    }
    if ( !v10 )
    {
      v11 = v8 - 24;
      v12 = xOffset[0] + 16;
      nearPlane = camera->nearPlane;
      v14 = RwIm2DGetNearScreenZ();
      RwRenderStateGet(rwRENDERSTATEZTESTENABLE, &value);
      RwRenderStateGet(rwRENDERSTATEZWRITEENABLE, &v44);
      RwRenderStateGet(rwRENDERSTATEVERTEXALPHAENABLE, &v43);
      RwRenderStateGet(rwRENDERSTATESRCBLEND, &v42);
      RwRenderStateGet(rwRENDERSTATEDESTBLEND, &v41);
      RwRenderStateGet(rwRENDERSTATETEXTURERASTER, &v40);
      RwRenderStateGet(rwRENDERSTATETEXTUREFILTER, &v39);
      RwRenderStateGet(rwRENDERSTATECULLMODE, &v38);
      RwRenderStateGet(rwRENDERSTATETEXTUREADDRESS, v37);
      RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
      RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
      RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
      RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
      RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, LogoRaster);
      RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
      RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
      RwRenderStateSet(rwRENDERSTATETEXTUREADDRESS, (char *)&dword_0 + 1);
      v27 = -1;
      v34 = -1;
      LODWORD(v15.z) = v14;
      v18 = v14;
      v25 = v14;
      v32 = v14;
      v15.t = 0.0;
      *(_DWORD *)&v15.r = -1;
      v15.s = 0.0;
      v20 = -1;
      v21 = 0;
      v22 = 1065353216;
      v28 = 1065353216;
      v29 = 1065353216;
      v35 = 1065353216;
      v36 = 0;
      v15.y = (float)v11;
      v15.x = (float)v12;
      v15.rhw = 1.0 / nearPlane;
      v16 = (float)v12;
      v19 = 1.0 / nearPlane;
      v17 = (float)(v11 + v7);
      v26 = 1.0 / nearPlane;
      v24 = v17;
      v23 = (float)(v12 + v6);
      v33 = 1.0 / nearPlane;
      v31 = (float)v11;
      v30 = v23;
      RwIm2DRenderPrimitive(rwPRIMTYPETRIFAN, &v15, 4);
      RwRenderStateSet(rwRENDERSTATEZTESTENABLE, value);
      RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, v44);
      RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, v43);
      RwRenderStateSet(rwRENDERSTATESRCBLEND, v42);
      RwRenderStateSet(rwRENDERSTATEDESTBLEND, v41);
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, v40);
      RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, v39);
      RwRenderStateSet(rwRENDERSTATECULLMODE, v38);
    }
  }
}
// 1D7168: variable 'v8' is possibly undefined
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;
// 1D70C0: using guessed type RwInt16 xOffset[17];
// 1D70C0: using guessed type char var_48[4];

//----- (001D72F8) --------------------------------------------------------
RwBool __fastcall _rwDeviceSystemRequest(RwDevice_0 *device, RwInt32 requestID, void *pOut, void *pInOut, RwInt32 a5)
{
  RwBool v7; // r6
  _BOOL4 v9; // r6
  RwError_0 v10; // [sp+0h] [bp-18h] BYREF

  v7 = device->fpSystem(requestID, pOut, pInOut, a5);
  if ( !v7 )
  {
    v7 = 1;
    switch ( requestID )
    {
      case 13:
        v7 = 1;
        *(_DWORD *)pOut = 1;
        return v7;
      case 14:
        v9 = 0;
        if ( a5 )
          goto LABEL_10;
        (*((void (__fastcall **)(void *, const char *))RwEngineInstance + 62))(pOut, "Only rendering sub system");
        goto LABEL_11;
      case 15:
        v7 = 1;
        *(_DWORD *)pOut = 0;
        return v7;
      case 16:
        v9 = a5 == 0;
LABEL_10:
        if ( !v9 )
          goto LABEL_12;
LABEL_11:
        v7 = 1;
        break;
      case 17:
      case 18:
        return v7;
      default:
LABEL_12:
        v7 = 0;
        v10.pluginID = 0;
        v10.errorCode = _rwerror(24, requestID);
        RwErrorSet(&v10);
        break;
    }
  }
  return v7;
}

//----- (001D739C) --------------------------------------------------------
RwUInt32 _rwGetNumEngineInstances()
{
  return engineInstancesOpened;
}

//----- (001D73A8) --------------------------------------------------------
RwInt32 RwEngineGetVersion()
{
  return 221187;
}

//----- (001D73B4) --------------------------------------------------------
RwInt32 __fastcall RwEngineRegisterPlugin(
        RwInt32 size,
        RwUInt32 pluginID,
        RwPluginObjectConstructor initCB,
        RwPluginObjectDestructor termCB)
{
  return _rwPluginRegistryAddPlugin(&engineTKList, size, pluginID, initCB, termCB, 0);
}

//----- (001D73DC) --------------------------------------------------------
RwInt32 __fastcall RwEngineGetPluginOffset(RwUInt32 pluginID)
{
  return sub_18F574(&engineTKList, pluginID);
}

//----- (001D73EC) --------------------------------------------------------
RwInt32 RwEngineGetNumSubSystems()
{
  int v0; // r4
  int v2[3]; // [sp+4h] [bp-Ch] BYREF

  v0 = 1;
  v2[0] = 1;
  if ( (*((int (__fastcall **)(int, int *, _DWORD, _DWORD))RwEngineInstance + 5))(13, v2, 0, 0) )
    return v2[0];
  v2[0] = 1;
  return v0;
}
// 1D73EC: using guessed type int var_C[3];

//----- (001D7420) --------------------------------------------------------
RwSubSystemInfo_0 *__fastcall RwEngineGetSubSystemInfo(RwSubSystemInfo_0 *subSystemInfo, RwInt32 subSystemIndex)
{
  RwSubSystemInfo_0 *v2; // r4
  int v4; // r5
  RwError_0 v6; // [sp+0h] [bp-18h] BYREF

  v2 = subSystemInfo;
  v4 = (*((int (__fastcall **)(int, RwSubSystemInfo_0 *, _DWORD, RwInt32))RwEngineInstance + 5))(
         14,
         subSystemInfo,
         0,
         subSystemIndex);
  if ( !v4 )
  {
    if ( subSystemIndex )
    {
      v4 = 0;
      v6.pluginID = 0;
      v6.errorCode = _rwerror(24, 14);
      RwErrorSet(&v6);
    }
    else
    {
      (*((void (__fastcall **)(RwSubSystemInfo_0 *, const char *))RwEngineInstance + 62))(
        v2,
        "Only rendering sub system");
      v4 = 1;
    }
  }
  if ( !v4 )
    return 0;
  return v2;
}

//----- (001D7490) --------------------------------------------------------
RwInt32 RwEngineGetCurrentSubSystem()
{
  int v0; // r4
  int v2[3]; // [sp+4h] [bp-Ch] BYREF

  v0 = 0;
  if ( (*((int (__fastcall **)(int, int *, _DWORD, _DWORD))RwEngineInstance + 5))(15, v2, 0, 0) )
    return v2[0];
  v2[0] = 0;
  return v0;
}
// 1D7490: using guessed type int var_C[3];

//----- (001D74C0) --------------------------------------------------------
RwBool __fastcall RwEngineSetSubSystem(RwInt32 subSystemIndex)
{
  int v2; // r4
  RwError_0 v4; // [sp+0h] [bp-10h] BYREF

  v2 = (*((int (__fastcall **)(int, _DWORD, _DWORD, RwInt32))RwEngineInstance + 5))(16, 0, 0, subSystemIndex);
  if ( !v2 )
  {
    if ( subSystemIndex )
    {
      v2 = 0;
      v4.pluginID = 0;
      v4.errorCode = _rwerror(24, 16);
      RwErrorSet(&v4);
    }
    else
    {
      v2 = 1;
    }
  }
  return v2 != 0;
}

//----- (001D750C) --------------------------------------------------------
RwInt32 RwEngineGetNumVideoModes()
{
  int v0; // r0
  int v1; // r1
  int v3; // [sp+4h] [bp-14h] BYREF
  RwError_0 code; // [sp+8h] [bp-10h] BYREF

  v0 = (*((int (__fastcall **)(int, int *, _DWORD, _DWORD))RwEngineInstance + 5))(5, &v3, 0, 0);
  if ( !v0 )
  {
    code.pluginID = 0;
    code.errorCode = _rwerror(24, 5);
    RwErrorSet(&code);
    v0 = 0;
  }
  v1 = v3;
  if ( !v0 )
    return -1;
  return v1;
}

//----- (001D7554) --------------------------------------------------------
RwVideoMode_0 *__fastcall RwEngineGetVideoModeInfo(RwVideoMode_0 *modeinfo, RwInt32 modeIndex)
{
  RwVideoMode_0 *v2; // r4
  int v3; // r0
  RwError_0 v5; // [sp+0h] [bp-18h] BYREF

  v2 = modeinfo;
  v3 = (*((int (__fastcall **)(int, RwVideoMode_0 *, _DWORD, RwInt32))RwEngineInstance + 5))(6, modeinfo, 0, modeIndex);
  if ( !v3 )
  {
    v5.pluginID = 0;
    v5.errorCode = _rwerror(24, 6);
    RwErrorSet(&v5);
    v3 = 0;
  }
  if ( !v3 )
    return 0;
  return v2;
}

//----- (001D75A0) --------------------------------------------------------
RwInt32 RwEngineGetCurrentVideoMode()
{
  int v0; // r0
  int v1; // r1
  int v3; // [sp+4h] [bp-14h] BYREF
  RwError_0 code; // [sp+8h] [bp-10h] BYREF

  v0 = (*((int (__fastcall **)(int, int *, _DWORD, _DWORD))RwEngineInstance + 5))(10, &v3, 0, 0);
  if ( !v0 )
  {
    code.pluginID = 0;
    code.errorCode = _rwerror(24, 10);
    RwErrorSet(&code);
    v0 = 0;
  }
  v1 = v3;
  if ( !v0 )
    return -1;
  return v1;
}

//----- (001D75E8) --------------------------------------------------------
RwBool __fastcall RwEngineSetVideoMode(RwInt32 modeIndex)
{
  int v1; // r0
  RwError_0 v3; // [sp+0h] [bp-10h] BYREF

  v1 = (*((int (__fastcall **)(int, _DWORD, _DWORD, RwInt32))RwEngineInstance + 5))(7, 0, 0, modeIndex);
  if ( !v1 )
  {
    v3.pluginID = 0;
    v3.errorCode = _rwerror(24, 7);
    RwErrorSet(&v3);
    v1 = 0;
  }
  return v1 != 0;
}

//----- (001D7628) --------------------------------------------------------
RwInt32 RwEngineGetTextureMemorySize()
{
  int v0; // r0
  int v1; // r1
  int v3; // [sp+4h] [bp-14h] BYREF
  RwError_0 code; // [sp+8h] [bp-10h] BYREF

  v0 = (*((int (__fastcall **)(int, int *, _DWORD, _DWORD))RwEngineInstance + 5))(12, &v3, 0, 0);
  if ( !v0 )
  {
    code.pluginID = 0;
    code.errorCode = _rwerror(24, 12);
    RwErrorSet(&code);
    v0 = 0;
  }
  v1 = v3;
  if ( !v0 )
    return -1;
  return v1;
}

//----- (001D7670) --------------------------------------------------------
RwInt32 RwEngineGetMaxTextureSize()
{
  int v0; // r0
  int v1; // r1
  int v3; // [sp+4h] [bp-14h] BYREF
  RwError_0 code; // [sp+8h] [bp-10h] BYREF

  v0 = (*((int (__fastcall **)(int, int *, _DWORD, _DWORD))RwEngineInstance + 5))(19, &v3, 0, 0);
  if ( !v0 )
  {
    code.pluginID = 0;
    code.errorCode = _rwerror(24, 19);
    RwErrorSet(&code);
    v0 = 0;
  }
  v1 = v3;
  if ( !v0 )
    return -1;
  return v1;
}

//----- (001D76B8) --------------------------------------------------------
RwBool __fastcall RwEngineSetFocus(RwBool enable)
{
  int v1; // r0
  RwError_0 v3; // [sp+0h] [bp-10h] BYREF

  v1 = (*((int (__fastcall **)(int, _DWORD, _DWORD, RwBool))RwEngineInstance + 5))(8, 0, 0, enable);
  if ( !v1 )
  {
    v3.pluginID = 0;
    v3.errorCode = _rwerror(24, 8);
    RwErrorSet(&v3);
    v1 = 0;
  }
  return v1 != 0;
}

//----- (001D76F8) --------------------------------------------------------
RwMetrics_0 *RwEngineGetMetrics()
{
  return (RwMetrics_0 *)*((_DWORD *)RwEngineInstance + 81);
}

//----- (001D770C) --------------------------------------------------------
RwBool RwEngineStop()
{
  int v0; // r8
  void *v1; // r6
  int v2; // r0
  RwError_0 v4; // [sp+0h] [bp-18h] BYREF

  v0 = 0;
  v1 = RwEngineInstance;
  (*((void (__fastcall **)(int, _DWORD, _DWORD, _DWORD))RwEngineInstance + 5))(18, 0, 0, 0);
  _rwPluginRegistryDeInitObject(&engineTKList, RwEngineInstance);
  v2 = (*((int (__fastcall **)(int, _DWORD, _DWORD, _DWORD))v1 + 5))(3, 0, 0, 0);
  if ( v2 )
  {
    v0 = v2;
    *((_DWORD *)RwEngineInstance + 82) = 2;
  }
  else
  {
    v4.pluginID = 0;
    v4.errorCode = _rwerror(24, 3);
    RwErrorSet(&v4);
  }
  return v0;
}

//----- (001D7784) --------------------------------------------------------
RwBool RwEngineStart()
{
  int v0; // r6
  void *v1; // r5
  RwInt32 v2; // r0
  RwError_0 v4; // [sp+0h] [bp-18h] BYREF

  v0 = 0;
  v1 = RwEngineInstance;
  if ( !(*((int (__fastcall **)(int, _DWORD, _DWORD, _DWORD))RwEngineInstance + 5))(2, 0, 0, 0) )
  {
    v4.pluginID = 0;
    v2 = _rwerror(24, 2);
    goto LABEL_7;
  }
  if ( !_rwPluginRegistryInitObject(&engineTKList, RwEngineInstance) )
  {
    v0 = 0;
    if ( (*((int (__fastcall **)(int, _DWORD, _DWORD, _DWORD))v1 + 5))(3, 0, 0, 0) )
      return v0;
    v4.pluginID = 0;
    v2 = _rwerror(24, 3);
LABEL_7:
    v4.errorCode = v2;
    RwErrorSet(&v4);
    return v0;
  }
  RwImageSetGamma(*((RwReal *)RwEngineInstance + 4));
  (*((void (__fastcall **)(int, _DWORD, _DWORD, _DWORD))v1 + 5))(17, 0, 0, 0);
  v0 = 1;
  *((_DWORD *)RwEngineInstance + 82) = 3;
  return v0;
}

//----- (001D7824) --------------------------------------------------------
RwBool RwEngineClose()
{
  int v0; // r4
  int v1; // r5
  void *v2; // r6
  RwError_0 v4; // [sp+0h] [bp-20h] BYREF

  v0 = 0;
  v1 = (*((int (__fastcall **)(int, _DWORD, _DWORD, _DWORD))RwEngineInstance + 5))(1, 0, 0, 0);
  if ( v1 )
  {
    v2 = RwEngineInstance;
    RwEngineInstance = &staticGlobals;
    qmemcpy(&staticGlobals, v2, sizeof(staticGlobals));
    staticGlobals.memoryFuncs.rwfree(v2);
    v0 = v1;
    --engineInstancesOpened;
    *((_DWORD *)RwEngineInstance + 82) = 1;
  }
  else
  {
    v4.pluginID = 0;
    v4.errorCode = _rwerror(24, 1);
    RwErrorSet(&v4);
  }
  return v0;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (001D78B4) --------------------------------------------------------
RwBool __fastcall RwEngineOpen(RwEngineOpenParams_0 *initParams)
{
  RwGlobals_0 *v2; // r0
  RwDevice_0 *Handle; // r6
  RwBool v4; // r4
  RwGlobals_0 *v5; // r0
  char *v6; // r8
  RwInt32 v7; // r0
  RwInt32 v8; // r0
  RwError_0 v10[4]; // [sp+0h] [bp-20h] BYREF

  v2 = (RwGlobals_0 *)RwEngineInstance;
  if ( !RwEngineInstance )
  {
    v2 = &staticGlobals;
    RwEngineInstance = &staticGlobals;
  }
  if ( v2->engineStatus != rwENGINESTATUSINITED )
  {
    v4 = 0;
    v7 = -2147483647;
LABEL_17:
    v10[0].pluginID = 0;
    v8 = _rwerror(v7);
LABEL_18:
    v10[0].errorCode = v8;
    RwErrorSet(v10);
    return v4;
  }
  if ( !initParams )
  {
    v4 = 0;
    v7 = -2147483626;
    goto LABEL_17;
  }
  Handle = _rwDeviceGetHandle();
  v4 = (RwBool)Handle;
  if ( !Handle )
    return v4;
  v5 = (RwGlobals_0 *)(*((int (__fastcall **)(RwInt32))RwEngineInstance + 75))(engineTKList.sizeOfStruct);
  v6 = (char *)v5;
  RwEngineInstance = v5;
  if ( !v5 )
  {
    v4 = 0;
    v10[0].pluginID = 0;
    v8 = _rwerror(-2147483629, engineTKList.sizeOfStruct);
    goto LABEL_18;
  }
  qmemcpy(v5, &staticGlobals, sizeof(RwGlobals_0));
  if ( !Handle->fpSystem(4, v6 + 16, v6 + 300, 0) )
  {
    v10[0].pluginID = 0;
    v10[0].errorCode = _rwerror(24, 4);
    RwErrorSet(v10);
  }
  v4 = 0;
  if ( Handle->fpSystem(0, 0, initParams, 0) )
  {
    if ( !Handle->fpSystem(11, (char *)RwEngineInstance + 72, 0, 29) )
    {
      v10[0].pluginID = 0;
      v10[0].errorCode = _rwerror(24, 11);
      RwErrorSet(v10);
    }
    v4 = 1;
    ++engineInstancesOpened;
    *((_DWORD *)RwEngineInstance + 82) = 2;
  }
  else
  {
    v10[0].pluginID = 0;
    v10[0].errorCode = _rwerror(24, 0);
    RwErrorSet(v10);
    RwEngineInstance = &staticGlobals;
    qmemcpy(&staticGlobals, v6, sizeof(staticGlobals));
    staticGlobals.memoryFuncs.rwfree(v6);
  }
  return v4;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (001D7A4C) --------------------------------------------------------
RwBool RwEngineTerm()
{
  if ( engineInstancesOpened )
    return 0;
  _rwPluginRegistryClose();
  _rwFileSystemClose();
  _rwMemoryClose();
  *((_DWORD *)RwEngineInstance + 82) = 0;
  return 1;
}

//----- (001D7A8C) --------------------------------------------------------
RwBool __fastcall RwEngineInit(const RwMemoryFunctions_0 *memFuncs, RwUInt32 openFlags, RwUInt32 resArenaSize)
{
  RwBool v5; // r0
  _DWORD *v6; // r0
  RwInt32 v7; // r10
  RwInt32 v8; // r11
  RwInt32 v9; // r5
  RwBool v10; // r6
  int v11; // r5
  RwBool result; // r0
  RwInt32 v13; // [sp+Ch] [bp-3Ch]
  RwInt32 v14; // [sp+10h] [bp-38h]
  RwInt32 v15; // [sp+14h] [bp-34h]
  RwInt32 v16; // [sp+18h] [bp-30h]
  RwInt32 v17; // [sp+1Ch] [bp-2Ch]
  RwInt32 v18; // [sp+20h] [bp-28h]
  RwInt32 v19; // [sp+24h] [bp-24h]
  RwInt32 v20; // [sp+28h] [bp-20h]

  RwEngineInstance = &staticGlobals;
  if ( openFlags << 31 )
  {
    staticGlobals.memoryAlloc = MallocWrapper;
    staticGlobals.memoryFree = FreeWrapper;
    v5 = 0;
  }
  else
  {
    staticGlobals.memoryAlloc = _rwFreeListAllocReal;
    staticGlobals.memoryFree = _rwFreeListFreeReal;
    v5 = 1;
  }
  _rwFreeListEnable(v5);
  v6 = RwEngineInstance;
  *((_DWORD *)RwEngineInstance + 83) = resArenaSize;
  if ( !v6[82] && _rwStringOpen() )
  {
    if ( _rwMemoryOpen(memFuncs) )
    {
      if ( _rwFileSystemOpen() )
      {
        if ( _rwPluginRegistryOpen() )
        {
          v20 = _rwPluginRegistryAddPlugin(&engineTKList, 8, 0x40Fu, _rwErrorOpen, _rwErrorClose, 0);
          v19 = _rwPluginRegistryAddPlugin(&engineTKList, 24, 0x401u, _rwVectorOpen, _rwVectorClose, 0);
          v18 = _rwPluginRegistryAddPlugin(&engineTKList, 0, 0x40Du, _rwColorOpen, _rwColorClose, 0);
          v17 = _rwPluginRegistryAddPlugin(&engineTKList, 24, 0x402u, _rwMatrixOpen, _rwMatrixClose, 0);
          v16 = _rwPluginRegistryAddPlugin(&engineTKList, 4, 0x403u, _rwFrameOpen, _rwFrameClose, 0);
          v15 = _rwPluginRegistryAddPlugin(&engineTKList, 4, 0x404u, _rwStreamModuleOpen, _rwStreamModuleClose, 0);
          v14 = _rwPluginRegistryAddPlugin(&engineTKList, 4, 0x405u, _rwCameraOpen, _rwCameraClose, 0);
          v13 = _rwPluginRegistryAddPlugin(&engineTKList, 544, 0x406u, _rwImageOpen, _rwImageClose, 0);
          v7 = _rwPluginRegistryAddPlugin(&engineTKList, 100, 0x407u, _rwRasterOpen, _rwRasterClose, 0);
          v8 = _rwPluginRegistryAddPlugin(&engineTKList, 52, 0x408u, _rwTextureOpen, _rwTextureClose, 0);
          v9 = _rwPluginRegistryAddPlugin(&engineTKList, 96, 0x409u, _rwRenderPipelineOpen, _rwRenderPipelineClose, 0);
          v10 = _rwPipeAttach();
          v11 = v20 | v19 | v18 | v17 | v16 | v15 | v14 | v13 | v7 | v8 | v9 | v10 | _rwPluginRegistryAddPlugin(
                                                                                       &engineTKList,
                                                                                       116,
                                                                                       0x40Au,
                                                                                       _rwIm3DOpen,
                                                                                       _rwIm3DClose,
                                                                                       0);
          if ( (_rwPluginRegistryAddPlugin(&engineTKList, 40, 0x40Bu, _rwResourcesOpen, _rwResourcesClose, 0) | v11) >= 0 )
          {
            result = _rwDeviceRegisterPlugin();
            if ( result )
            {
              *((_DWORD *)RwEngineInstance + 82) = 1;
              return result;
            }
          }
          _rwPluginRegistryClose();
        }
        _rwFileSystemClose();
      }
      _rwMemoryClose();
    }
    _rwStringClose();
  }
  return 0;
}

//----- (001D7DA8) --------------------------------------------------------
void *__fastcall MallocWrapper(RwFreeList_0 *fl)
{
  return (void *)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(fl->entrySize);
}

//----- (001D7DBC) --------------------------------------------------------
RwFreeList_0 *__fastcall FreeWrapper(RwFreeList_0 *fl, void *pData)
{
  (*((void (__fastcall **)(void *))RwEngineInstance + 76))(pData);
  return fl;
}

//----- (001D7DDC) --------------------------------------------------------
void __fastcall RwFrameSetFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rwFrameFreeListPreallocBlocks = numBlocksToPrealloc;
  _rwFrameFreeListBlockSize = blockSize;
}

//----- (001D7DF4) --------------------------------------------------------
void *__fastcall _rwFrameOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  RwFreeList_0 *v4; // r0
  int v5; // r2
  _DWORD *v6; // r0

  frameModule = offset;
  v4 = RwFreeListCreateAndPreallocateSpace(
         frameTKList.sizeOfStruct,
         _rwFrameFreeListBlockSize,
         4,
         _rwFrameFreeListPreallocBlocks,
         &_rwFrameOpen(void *,int,int)::frameFreeList);
  v5 = frameModule;
  *(_DWORD *)((char *)RwEngineInstance + frameModule) = v4;
  v6 = RwEngineInstance;
  if ( !*(_DWORD *)((char *)RwEngineInstance + v5) )
    return 0;
  *((_DWORD *)RwEngineInstance + 47) = (char *)RwEngineInstance + 188;
  v6[48] = v6 + 47;
  ++frameModule;
  return instance;
}
// 6BCEB4: using guessed type int frameModule;
// 6BCEB8: using guessed type int frameModule;

//----- (001D7E78) --------------------------------------------------------
void *__fastcall _rwFrameClose(void *instance, RwInt32 offset, RwInt32 size)
{
  RwFreeList_0 *v4; // r0

  v4 = *(RwFreeList_0 **)((char *)RwEngineInstance + frameModule);
  if ( v4 )
  {
    RwFreeListDestroy(v4);
    *(_DWORD *)((char *)RwEngineInstance + frameModule) = 0;
  }
  --frameModule;
  return instance;
}
// 6BCEB4: using guessed type int frameModule;
// 6BCEB8: using guessed type int frameModule;

//----- (001D7EC8) --------------------------------------------------------
RwFrame_0 *__fastcall _rwFrameCloneAndLinkClones(RwFrame_0 *root)
{
  RwFrame_0 *result; // r0
  RwFrame *v2; // r2
  RwUInt8 privateFlags; // r12
  RwLLLink *v4; // r3

  result = rwFrameCloneRecurse(root, 0);
  if ( result )
  {
    v2 = result->root;
    result->object.privateFlags &= 0xFCu;
    privateFlags = v2->object.privateFlags;
    if ( (privateFlags & 3) == 0 )
    {
      v4 = (RwLLLink *)((char *)RwEngineInstance + 188);
      v2->inDirtyListLink.next = (RwLLLink *)*((_DWORD *)RwEngineInstance + 47);
      result->root->inDirtyListLink.prev = v4;
      v4->next->prev = &result->root->inDirtyListLink;
      v4->next = &result->root->inDirtyListLink;
      v2 = result->root;
    }
    v2->object.privateFlags = privateFlags | 3;
    result->object.privateFlags |= 0xCu;
  }
  return result;
}

//----- (001D7F2C) --------------------------------------------------------
RwFrame_0 *__fastcall rwFrameCloneRecurse(RwFrame_0 *oldFrame, RwFrame_0 *newRoot)
{
  int v4; // r4
  RwUInt8 privateFlags; // r1
  __int64 v6; // d16
  __int64 v7; // d17
  __int64 v8; // d18
  __int64 v9; // d19
  __int64 v10; // d20
  __int64 v11; // d21
  __int64 v12; // d22
  __int64 v13; // d23
  RwFrame *child; // r5
  RwFrame_0 *v15; // r0

  v4 = (*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + frameModule));
  if ( !v4 )
    return 0;
  *(_BYTE *)v4 = oldFrame->object.type;
  *(_BYTE *)(v4 + 1) = oldFrame->object.subType;
  *(_BYTE *)(v4 + 2) = oldFrame->object.flags;
  privateFlags = oldFrame->object.privateFlags;
  *(_DWORD *)(v4 + 144) = v4 + 144;
  *(_BYTE *)(v4 + 3) = privateFlags;
  *(_DWORD *)(v4 + 148) = v4 + 144;
  *(_DWORD *)(v4 + 4) = 0;
  v6 = *(_QWORD *)&oldFrame->modelling.up.x;
  v7 = *(_QWORD *)&oldFrame->modelling.up.z;
  v8 = *(_QWORD *)&oldFrame->modelling.at.x;
  v9 = *(_QWORD *)&oldFrame->modelling.at.z;
  v10 = *(_QWORD *)&oldFrame->modelling.pos.x;
  v11 = *(_QWORD *)&oldFrame->modelling.pos.z;
  v12 = *(_QWORD *)&oldFrame->modelling.right.x;
  v13 = *(_QWORD *)&oldFrame->modelling.right.z;
  if ( !newRoot )
    newRoot = (RwFrame_0 *)v4;
  *(_DWORD *)(v4 + 160) = newRoot;
  *(_DWORD *)(v4 + 152) = 0;
  *(_DWORD *)(v4 + 156) = 0;
  *(_QWORD *)(v4 + 16) = v12;
  *(_QWORD *)(v4 + 24) = v13;
  *(_QWORD *)(v4 + 64) = v10;
  *(_QWORD *)(v4 + 72) = v11;
  *(_QWORD *)(v4 + 48) = v8;
  *(_QWORD *)(v4 + 56) = v9;
  *(_QWORD *)(v4 + 32) = v6;
  *(_QWORD *)(v4 + 40) = v7;
  child = oldFrame->child;
  oldFrame->root = (RwFrame *)v4;
  if ( child )
  {
    while ( 1 )
    {
      v15 = rwFrameCloneRecurse(child, newRoot);
      if ( !v15 )
        break;
      v15->next = *(RwFrame **)(v4 + 152);
      *(_DWORD *)(v4 + 152) = v15;
      v15->object.parent = (void *)v4;
      child = child->next;
      if ( !child )
        goto LABEL_7;
    }
    rwFrameDestroyRecurse((RwFrame_0 *)v4);
    return 0;
  }
LABEL_7:
  _rwPluginRegistryInitObject(&frameTKList, (void *)v4);
  _rwPluginRegistryCopyObject(&frameTKList, (void *)v4, oldFrame);
  return (RwFrame_0 *)v4;
}
// 6BCEB4: using guessed type int frameModule;

//----- (001D802C) --------------------------------------------------------
RwFrame_0 *__fastcall RwFrameUpdateObjects(RwFrame_0 *frame)
{
  RwFrame *root; // r2
  RwUInt8 privateFlags; // r12
  RwLLLink *v3; // r3

  root = frame->root;
  privateFlags = root->object.privateFlags;
  if ( (privateFlags & 3) == 0 )
  {
    v3 = (RwLLLink *)((char *)RwEngineInstance + 188);
    root->inDirtyListLink.next = (RwLLLink *)*((_DWORD *)RwEngineInstance + 47);
    frame->root->inDirtyListLink.prev = v3;
    v3->next->prev = &frame->root->inDirtyListLink;
    v3->next = &frame->root->inDirtyListLink;
    root = frame->root;
  }
  root->object.privateFlags = privateFlags | 3;
  frame->object.privateFlags |= 0xCu;
  return frame;
}

//----- (001D8078) --------------------------------------------------------
RwFrame_0 *__fastcall _rwFramePurgeClone(RwFrame_0 *root)
{
  void *parent; // r0
  RwFrame_0 *v3; // r1
  RwFrame_0 *v4; // r0

  parent = root->object.parent;
  if ( parent )
  {
    v3 = (RwFrame_0 *)*((_DWORD *)parent + 40);
    v4 = root;
  }
  else
  {
    v4 = root;
    v3 = root;
  }
  rwSetHierarchyRoot(v4, v3);
  return root;
}

//----- (001D8096) --------------------------------------------------------
void __fastcall rwSetHierarchyRoot(RwFrame_0 *frame, RwFrame_0 *root)
{
  RwFrame *child; // r5

  child = frame->child;
  frame->root = root;
  while ( child )
  {
    rwSetHierarchyRoot(child, root);
    child = child->next;
  }
}

//----- (001D80BC) --------------------------------------------------------
RwFrame_0 *__fastcall RwFrameCloneHierarchy(RwFrame_0 *root)
{
  RwFrame_0 *v2; // r0
  RwFrame_0 *v3; // r4
  RwFrame *v4; // r1
  RwUInt8 privateFlags; // r0
  RwLLLink *v6; // r2
  void *parent; // r0
  RwFrame_0 *v8; // r1
  RwFrame_0 *v9; // r0

  v2 = rwFrameCloneRecurse(root, 0);
  v3 = v2;
  if ( v2 )
  {
    v4 = v2->root;
    v2->object.privateFlags &= 0xFCu;
    privateFlags = v4->object.privateFlags;
    if ( (privateFlags & 3) == 0 )
    {
      v6 = (RwLLLink *)((char *)RwEngineInstance + 188);
      v4->inDirtyListLink.next = (RwLLLink *)*((_DWORD *)RwEngineInstance + 47);
      v3->root->inDirtyListLink.prev = v6;
      v6->next->prev = &v3->root->inDirtyListLink;
      v6->next = &v3->root->inDirtyListLink;
      v4 = v3->root;
    }
    v4->object.privateFlags = privateFlags | 3;
    v3->object.privateFlags |= 0xCu;
  }
  parent = root->object.parent;
  if ( parent )
  {
    v8 = (RwFrame_0 *)*((_DWORD *)parent + 40);
    v9 = root;
  }
  else
  {
    v9 = root;
    v8 = root;
  }
  rwSetHierarchyRoot(v9, v8);
  return v3;
}

//----- (001D8134) --------------------------------------------------------
RwBool __fastcall RwFrameDirty(const RwFrame_0 *frame)
{
  return frame->root->object.privateFlags & 3;
}

//----- (001D8140) --------------------------------------------------------
void __fastcall _rwFrameInit(RwFrame_0 *frame)
{
  *(_DWORD *)&frame->object.type = 0;
  frame->object.parent = 0;
  frame->objectList.link.next = &frame->objectList.link;
  frame->objectList.link.prev = &frame->objectList.link;
  *(_QWORD *)&frame->modelling.up.x = 0x3F80000000000000LL;
  frame->modelling.right.z = 0.0;
  frame->modelling.right.x = 1.0;
  frame->modelling.right.y = 0.0;
  frame->modelling.up.z = 0.0;
  frame->modelling.at.x = 0.0;
  *(_QWORD *)&frame->modelling.at.y = 0x3F80000000000000LL;
  frame->modelling.pos.y = 0.0;
  frame->modelling.pos.z = 0.0;
  frame->modelling.flags = (RwUInt32)&elf_hash_chain[16294] + 3;
  frame->modelling.pos.x = 0.0;
  frame->ltm.at.x = 0.0;
  *(_QWORD *)&frame->ltm.at.y = 0x3F80000000000000LL;
  frame->ltm.pos.x = 0.0;
  frame->ltm.pos.y = 0.0;
  frame->ltm.pos.z = 0.0;
  frame->ltm.right.x = 1.0;
  frame->ltm.right.y = 0.0;
  frame->ltm.right.z = 0.0;
  frame->ltm.flags = (RwUInt32)&elf_hash_chain[16294] + 3;
  *(_QWORD *)&frame->ltm.up.x = 0x3F80000000000000LL;
  frame->ltm.up.z = 0.0;
  frame->child = 0;
  frame->next = 0;
  frame->root = frame;
  sub_19EBF4(&frameTKList, frame);
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (001D81AC) --------------------------------------------------------
RwFrame_0 *RwFrameCreate()
{
  _DWORD *v0; // r4
  RwFrame_0 *result; // r0

  v0 = (_DWORD *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                   + frameModule));
  result = 0;
  if ( v0 )
  {
    *v0 = 0;
    v0[1] = 0;
    v0[36] = v0 + 36;
    v0[37] = v0 + 36;
    v0[12] = 0;
    v0[13] = 0;
    v0[14] = 1065353216;
    v0[16] = 0;
    v0[17] = 0;
    v0[18] = 0;
    v0[4] = 1065353216;
    v0[5] = 0;
    v0[6] = 0;
    v0[7] = (char *)&elf_hash_chain[16294] + 3;
    v0[8] = 0;
    v0[9] = 1065353216;
    v0[10] = 0;
    v0[28] = 0;
    v0[29] = 0;
    v0[30] = 1065353216;
    v0[32] = 0;
    v0[33] = 0;
    v0[34] = 0;
    v0[20] = 1065353216;
    v0[21] = 0;
    v0[22] = 0;
    v0[23] = (char *)&elf_hash_chain[16294] + 3;
    v0[24] = 0;
    v0[25] = 1065353216;
    v0[26] = 0;
    v0[38] = 0;
    v0[39] = 0;
    v0[40] = v0;
    _rwPluginRegistryInitObject(&frameTKList, v0);
    return (RwFrame_0 *)v0;
  }
  return result;
}
// 10168: using guessed type int elf_hash_chain[22025];
// 6BCEB4: using guessed type int frameModule;

//----- (001D8240) --------------------------------------------------------
RwBool __fastcall RwFrameInit(RwFrame_0 *frame)
{
  *(_DWORD *)&frame->object.type = 0;
  frame->object.parent = 0;
  frame->objectList.link.next = &frame->objectList.link;
  frame->objectList.link.prev = &frame->objectList.link;
  frame->modelling.at.x = 0.0;
  frame->modelling.at.y = 0.0;
  frame->modelling.at.z = 1.0;
  frame->modelling.right.x = 1.0;
  frame->modelling.right.y = 0.0;
  frame->modelling.right.z = 0.0;
  frame->modelling.flags = (RwUInt32)&elf_hash_chain[16294] + 3;
  frame->modelling.up.x = 0.0;
  frame->modelling.up.y = 1.0;
  frame->modelling.up.z = 0.0;
  frame->modelling.pos.x = 0.0;
  frame->modelling.pos.y = 0.0;
  frame->modelling.pos.z = 0.0;
  frame->ltm.at.x = 0.0;
  frame->ltm.at.y = 0.0;
  frame->ltm.at.z = 1.0;
  frame->ltm.pos.x = 0.0;
  frame->ltm.pos.y = 0.0;
  frame->ltm.pos.z = 0.0;
  frame->ltm.right.x = 1.0;
  frame->ltm.right.y = 0.0;
  frame->ltm.right.z = 0.0;
  frame->ltm.flags = (RwUInt32)&elf_hash_chain[16294] + 3;
  frame->ltm.up.x = 0.0;
  frame->ltm.up.y = 1.0;
  frame->ltm.up.z = 0.0;
  frame->child = 0;
  frame->next = 0;
  frame->root = frame;
  _rwPluginRegistryInitObject(&frameTKList, frame);
  frame->object.privateFlags |= 0x10u;
  return 1;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (001D82B8) --------------------------------------------------------
void __fastcall _rwFrameDeInit(RwFrame_0 *frame)
{
  _DWORD *parent; // r0
  RwFrame **p_next; // r0
  RwFrame_0 *i; // r1
  RwFrame_0 *v5; // t1
  RwFrame *root; // r1
  RwUInt8 privateFlags; // r0
  RwLLLink *v8; // r2
  int v9; // r0
  RwFrame *child; // r0
  RwFrame *next; // r2

  _rwPluginRegistryDeInitObject(&frameTKList, frame);
  parent = frame->object.parent;
  if ( parent )
  {
    v5 = (RwFrame_0 *)parent[38];
    p_next = (RwFrame **)(parent + 38);
    for ( i = v5; i != frame; i = i->next )
      p_next = &i->next;
    *p_next = frame->next;
    frame->next = 0;
    frame->object.parent = 0;
    rwSetHierarchyRoot(frame, frame);
    root = frame->root;
    privateFlags = root->object.privateFlags;
    if ( (privateFlags & 3) == 0 )
    {
      v8 = (RwLLLink *)((char *)RwEngineInstance + 188);
      root->inDirtyListLink.next = (RwLLLink *)*((_DWORD *)RwEngineInstance + 47);
      frame->root->inDirtyListLink.prev = v8;
      v8->next->prev = &frame->root->inDirtyListLink;
      v8->next = &frame->root->inDirtyListLink;
      root = frame->root;
    }
    root->object.privateFlags = privateFlags | 3;
    v9 = frame->object.privateFlags | 0xC;
    frame->object.privateFlags = v9;
  }
  else
  {
    v9 = frame->object.privateFlags;
  }
  if ( v9 << 30 )
  {
    frame->inDirtyListLink.prev->next = frame->inDirtyListLink.next;
    frame->inDirtyListLink.next->prev = frame->inDirtyListLink.prev;
  }
  child = frame->child;
  if ( child )
  {
    do
    {
      next = child->next;
      child->object.parent = 0;
      child = next;
    }
    while ( next );
  }
}

//----- (001D8370) --------------------------------------------------------
RwFrame_0 *__fastcall RwFrameRemoveChild(RwFrame_0 *child)
{
  _DWORD *parent; // r0
  RwFrame **p_next; // r0
  RwFrame_0 *i; // r1
  RwFrame_0 *v5; // t1
  RwFrame *root; // r1
  RwUInt8 privateFlags; // r0
  RwLLLink *v8; // r2

  parent = child->object.parent;
  v5 = (RwFrame_0 *)parent[38];
  p_next = (RwFrame **)(parent + 38);
  for ( i = v5; i != child; i = i->next )
    p_next = &i->next;
  *p_next = child->next;
  child->next = 0;
  child->object.parent = 0;
  rwSetHierarchyRoot(child, child);
  root = child->root;
  privateFlags = root->object.privateFlags;
  if ( (privateFlags & 3) == 0 )
  {
    v8 = (RwLLLink *)((char *)RwEngineInstance + 188);
    root->inDirtyListLink.next = (RwLLLink *)*((_DWORD *)RwEngineInstance + 47);
    child->root->inDirtyListLink.prev = v8;
    v8->next->prev = &child->root->inDirtyListLink;
    v8->next = &child->root->inDirtyListLink;
    root = child->root;
  }
  root->object.privateFlags = privateFlags | 3;
  child->object.privateFlags |= 0xCu;
  return child;
}

//----- (001D83EC) --------------------------------------------------------
RwBool __fastcall RwFrameDestroy(RwFrame_0 *frame)
{
  _rwFrameDeInit(frame);
  (*((void (__fastcall **)(_DWORD, RwFrame_0 *))RwEngineInstance + 80))(
    *(_DWORD *)((char *)RwEngineInstance + frameModule),
    frame);
  return 1;
}
// 6BCEB4: using guessed type int frameModule;

//----- (001D841C) --------------------------------------------------------
RwBool __fastcall RwFrameDeInit(RwFrame_0 *frame)
{
  _rwFrameDeInit(frame);
  return 1;
}

//----- (001D8428) --------------------------------------------------------
RwBool __fastcall RwFrameDestroyHierarchy(RwFrame_0 *frame)
{
  rwFrameDestroyRecurse(frame);
  return 1;
}

//----- (001D8434) --------------------------------------------------------
void __fastcall rwFrameDestroyRecurse(RwFrame_0 *frame)
{
  RwFrame *child; // r0
  RwFrame *next; // r5

  if ( frame )
  {
    child = frame->child;
    if ( child )
    {
      do
      {
        next = child->next;
        rwFrameDestroyRecurse(child);
        child = next;
      }
      while ( next );
    }
    _rwPluginRegistryDeInitObject(&frameTKList, frame);
    if ( frame->object.privateFlags << 30 )
    {
      frame->inDirtyListLink.prev->next = frame->inDirtyListLink.next;
      frame->inDirtyListLink.next->prev = frame->inDirtyListLink.prev;
    }
    (*((void (__fastcall **)(_DWORD, RwFrame_0 *))RwEngineInstance + 80))(
      *(_DWORD *)((char *)RwEngineInstance + frameModule),
      frame);
  }
}
// 6BCEB4: using guessed type int frameModule;

//----- (001D849C) --------------------------------------------------------
RwMatrix *__fastcall RwFrameGetLTM(RwFrame_0 *frame)
{
  RwFrame *root; // r0

  root = frame->root;
  if ( root->object.privateFlags << 31 )
    _rwFrameSyncHierarchyLTM(root);
  return &frame->ltm;
}

//----- (001D84B6) --------------------------------------------------------
RwFrame_0 *__fastcall RwFrameGetRoot(const RwFrame_0 *frame)
{
  return frame->root;
}

//----- (001D84BC) --------------------------------------------------------
RwFrame_0 *__fastcall RwFrameAddChild(RwFrame_0 *parent, RwFrame_0 *child)
{
  _DWORD *v4; // r0
  RwFrame **p_next; // r0
  RwFrame_0 *i; // r1
  RwFrame_0 *v7; // t1
  RwFrame *root; // r1
  RwUInt8 privateFlags; // r0
  RwLLLink *v10; // r2
  RwUInt8 *p_privateFlags; // r6
  RwFrame *v12; // r1
  RwUInt8 v13; // r0
  RwLLLink *v14; // r2

  v4 = child->object.parent;
  if ( v4 )
  {
    v7 = (RwFrame_0 *)v4[38];
    p_next = (RwFrame **)(v4 + 38);
    for ( i = v7; i != child; i = i->next )
      p_next = &i->next;
    *p_next = child->next;
    child->next = 0;
    child->object.parent = 0;
    rwSetHierarchyRoot(child, child);
    root = child->root;
    privateFlags = root->object.privateFlags;
    if ( (privateFlags & 3) == 0 )
    {
      v10 = (RwLLLink *)((char *)RwEngineInstance + 188);
      root->inDirtyListLink.next = (RwLLLink *)*((_DWORD *)RwEngineInstance + 47);
      child->root->inDirtyListLink.prev = v10;
      v10->next->prev = &child->root->inDirtyListLink;
      v10->next = &child->root->inDirtyListLink;
      root = child->root;
    }
    root->object.privateFlags = privateFlags | 3;
    p_privateFlags = &child->object.privateFlags;
    child->object.privateFlags |= 0xCu;
  }
  else
  {
    p_privateFlags = &child->object.privateFlags;
  }
  child->next = parent->child;
  parent->child = child;
  child->object.parent = parent;
  rwSetHierarchyRoot(child, parent->root);
  if ( child->object.privateFlags << 30 )
  {
    child->inDirtyListLink.prev->next = child->inDirtyListLink.next;
    child->inDirtyListLink.next->prev = child->inDirtyListLink.prev;
    child->object.privateFlags &= 0xFCu;
  }
  v12 = child->root;
  v13 = v12->object.privateFlags;
  if ( (v13 & 3) == 0 )
  {
    v14 = (RwLLLink *)((char *)RwEngineInstance + 188);
    v12->inDirtyListLink.next = (RwLLLink *)*((_DWORD *)RwEngineInstance + 47);
    child->root->inDirtyListLink.prev = v14;
    v14->next->prev = &child->root->inDirtyListLink;
    v14->next = &child->root->inDirtyListLink;
    v12 = child->root;
  }
  v12->object.privateFlags = v13 | 3;
  *p_privateFlags |= 0xCu;
  return parent;
}

//----- (001D85C8) --------------------------------------------------------
RwFrame_0 *__fastcall RwFrameForAllChildren(RwFrame_0 *frame, RwFrameCallBack callBack, void *data)
{
  RwFrame *child; // r0
  RwFrame *next; // r5
  bool v7; // zf

  child = frame->child;
  do
  {
    if ( !child )
      break;
    next = child->next;
    v7 = ((int (*)(void))callBack)() == 0;
    child = next;
  }
  while ( !v7 );
  return frame;
}

//----- (001D85F2) --------------------------------------------------------
RwInt32 __fastcall RwFrameCount(RwFrame_0 *frame)
{
  RwFrame *child; // r5
  RwInt32 i; // r4
  RwInt32 v3; // r0

  child = frame->child;
  for ( i = 1; child; i += v3 )
  {
    v3 = RwFrameCount(child);
    child = child->next;
  }
  return i;
}

//----- (001D8614) --------------------------------------------------------
RwFrame_0 *__fastcall RwFrameTranslate(RwFrame_0 *frame, const RwV3d_0 *translation, RwOpCombineType_0 combineOp)
{
  RwFrame *root; // r1
  RwUInt8 privateFlags; // r0
  RwLLLink *v6; // r2

  RwMatrixTranslate(&frame->modelling, translation, combineOp);
  root = frame->root;
  privateFlags = root->object.privateFlags;
  if ( (privateFlags & 3) == 0 )
  {
    v6 = (RwLLLink *)((char *)RwEngineInstance + 188);
    root->inDirtyListLink.next = (RwLLLink *)*((_DWORD *)RwEngineInstance + 47);
    frame->root->inDirtyListLink.prev = v6;
    v6->next->prev = &frame->root->inDirtyListLink;
    v6->next = &frame->root->inDirtyListLink;
    root = frame->root;
  }
  root->object.privateFlags = privateFlags | 3;
  frame->object.privateFlags |= 0xCu;
  return frame;
}

//----- (001D8670) --------------------------------------------------------
RwFrame_0 *__fastcall RwFrameScale(RwFrame_0 *frame, const RwV3d_0 *scale, RwOpCombineType_0 combineOp)
{
  RwFrame *root; // r1
  RwUInt8 privateFlags; // r0
  RwLLLink *v6; // r2

  RwMatrixScale(&frame->modelling, scale, combineOp);
  root = frame->root;
  privateFlags = root->object.privateFlags;
  if ( (privateFlags & 3) == 0 )
  {
    v6 = (RwLLLink *)((char *)RwEngineInstance + 188);
    root->inDirtyListLink.next = (RwLLLink *)*((_DWORD *)RwEngineInstance + 47);
    frame->root->inDirtyListLink.prev = v6;
    v6->next->prev = &frame->root->inDirtyListLink;
    v6->next = &frame->root->inDirtyListLink;
    root = frame->root;
  }
  root->object.privateFlags = privateFlags | 3;
  frame->object.privateFlags |= 0xCu;
  return frame;
}

//----- (001D86CC) --------------------------------------------------------
RwFrame_0 *__fastcall RwFrameTransform(RwFrame_0 *frame, const RwMatrix *transform, RwOpCombineType_0 combineOp)
{
  RwFrame *root; // r1
  RwUInt8 privateFlags; // r0
  RwLLLink *v6; // r2

  RwMatrixTransform(&frame->modelling, transform, combineOp);
  root = frame->root;
  privateFlags = root->object.privateFlags;
  if ( (privateFlags & 3) == 0 )
  {
    v6 = (RwLLLink *)((char *)RwEngineInstance + 188);
    root->inDirtyListLink.next = (RwLLLink *)*((_DWORD *)RwEngineInstance + 47);
    frame->root->inDirtyListLink.prev = v6;
    v6->next->prev = &frame->root->inDirtyListLink;
    v6->next = &frame->root->inDirtyListLink;
    root = frame->root;
  }
  root->object.privateFlags = privateFlags | 3;
  frame->object.privateFlags |= 0xCu;
  return frame;
}

//----- (001D8728) --------------------------------------------------------
RwFrame_0 *__fastcall RwFrameRotate(RwFrame_0 *frame, const RwV3d_0 *axis, RwReal angle, RwOpCombineType_0 combineOp)
{
  RwFrame *root; // r1
  RwUInt8 privateFlags; // r0
  RwLLLink *v7; // r2

  RwMatrixRotate(&frame->modelling, axis, angle, combineOp);
  root = frame->root;
  privateFlags = root->object.privateFlags;
  if ( (privateFlags & 3) == 0 )
  {
    v7 = (RwLLLink *)((char *)RwEngineInstance + 188);
    root->inDirtyListLink.next = (RwLLLink *)*((_DWORD *)RwEngineInstance + 47);
    frame->root->inDirtyListLink.prev = v7;
    v7->next->prev = &frame->root->inDirtyListLink;
    v7->next = &frame->root->inDirtyListLink;
    root = frame->root;
  }
  root->object.privateFlags = privateFlags | 3;
  frame->object.privateFlags |= 0xCu;
  return frame;
}

//----- (001D8784) --------------------------------------------------------
RwFrame_0 *__fastcall RwFrameSetIdentity(RwFrame_0 *frame)
{
  RwFrame *root; // r2
  RwUInt8 privateFlags; // r12
  RwLLLink *v3; // r3

  frame->modelling.right.x = 1.0;
  frame->modelling.up.y = 1.0;
  frame->modelling.up.x = 0.0;
  frame->modelling.right.y = 0.0;
  frame->modelling.right.z = 0.0;
  frame->modelling.up.z = 0.0;
  frame->modelling.at.x = 0.0;
  frame->modelling.at.y = 0.0;
  frame->modelling.at.z = 1.0;
  frame->modelling.pos.x = 0.0;
  frame->modelling.pos.y = 0.0;
  frame->modelling.pos.z = 0.0;
  frame->modelling.flags |= 0x20003u;
  root = frame->root;
  privateFlags = root->object.privateFlags;
  if ( (privateFlags & 3) == 0 )
  {
    v3 = (RwLLLink *)((char *)RwEngineInstance + 188);
    root->inDirtyListLink.next = (RwLLLink *)*((_DWORD *)RwEngineInstance + 47);
    frame->root->inDirtyListLink.prev = v3;
    v3->next->prev = &frame->root->inDirtyListLink;
    v3->next = &frame->root->inDirtyListLink;
    root = frame->root;
  }
  root->object.privateFlags = privateFlags | 3;
  frame->object.privateFlags |= 0xCu;
  return frame;
}

//----- (001D87FC) --------------------------------------------------------
RwFrame_0 *__fastcall RwFrameOrthoNormalize(RwFrame_0 *frame)
{
  RwFrame *root; // r1
  RwUInt8 privateFlags; // r0
  RwLLLink *v4; // r2

  RwMatrixOrthoNormalize(&frame->modelling, &frame->modelling);
  root = frame->root;
  privateFlags = root->object.privateFlags;
  if ( (privateFlags & 3) == 0 )
  {
    v4 = (RwLLLink *)((char *)RwEngineInstance + 188);
    root->inDirtyListLink.next = (RwLLLink *)*((_DWORD *)RwEngineInstance + 47);
    frame->root->inDirtyListLink.prev = v4;
    v4->next->prev = &frame->root->inDirtyListLink;
    v4->next = &frame->root->inDirtyListLink;
    root = frame->root;
  }
  root->object.privateFlags = privateFlags | 3;
  frame->object.privateFlags |= 0xCu;
  return frame;
}

//----- (001D8858) --------------------------------------------------------
RwFrame_0 *__fastcall RwFrameForAllObjects(RwFrame_0 *frame, RwObjectCallBack callBack, void *data)
{
  RwLLLink *next; // r0
  RwLinkList_0 *p_objectList; // r5
  RwLLLink *v8; // r4
  bool v9; // zf

  p_objectList = &frame->objectList;
  next = frame->objectList.link.next;
  do
  {
    if ( next == (RwLLLink *)p_objectList )
      break;
    v8 = next->next;
    v9 = (int)callBack((RwObject_0 *)&next[-1], data) == 0;
    next = v8;
  }
  while ( !v9 );
  return frame;
}

//----- (001D8888) --------------------------------------------------------
RwBool __fastcall RwFrameSetStaticPluginsSize(RwInt32 size)
{
  return sub_19C8E0(&frameTKList, (size + 3) & 0xFFFFFFFC);
}

//----- (001D889C) --------------------------------------------------------
RwInt32 __fastcall RwFrameRegisterPlugin(
        RwInt32 size,
        RwUInt32 pluginID,
        RwPluginObjectConstructor constructCB,
        RwPluginObjectDestructor destructCB,
        RwPluginObjectCopy copyCB)
{
  return _rwPluginRegistryAddPlugin(&frameTKList, size, pluginID, constructCB, destructCB, copyCB);
}

//----- (001D88C8) --------------------------------------------------------
RwInt32 __fastcall RwFrameGetPluginOffset(RwUInt32 pluginID)
{
  return sub_18F574(&frameTKList, pluginID);
}

//----- (001D88D8) --------------------------------------------------------
RwBool __fastcall RwFrameValidatePlugins(const RwFrame_0 *frame)
{
  return 1;
}

//----- (001D88DC) --------------------------------------------------------
void __fastcall RwImageSetFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rwImageFreeListPreallocBlocks = numBlocksToPrealloc;
  _rwImageFreeListBlockSize = blockSize;
}

//----- (001D88F4) --------------------------------------------------------
void __fastcall RwImageFormatSetFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rwImageFormatFreeListPreallocBlocks = numBlocksToPrealloc;
}

//----- (001D8900) --------------------------------------------------------
void *__fastcall _rwImageOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  RwFreeList_0 *v4; // r0
  int v5; // r2
  RwFreeList_0 *v6; // r0
  int v7; // r1
  char *v8; // r0
  int v9; // r0
  int v10; // r1
  _BYTE *v11; // r0
  int i; // r0
  int v13; // r6
  char *v14; // r3
  int v15; // r0
  int v16; // r2
  int v17; // r0
  int v18; // r0
  int v19; // r0

  imageModule = offset;
  v4 = RwFreeListCreateAndPreallocateSpace(
         imageTKList.sizeOfStruct,
         _rwImageFreeListBlockSize,
         4,
         _rwImageFreeListPreallocBlocks,
         &_rwImageFreeList);
  v5 = imageModule;
  *(_DWORD *)((char *)RwEngineInstance + imageModule) = v4;
  if ( !*(_DWORD *)((char *)RwEngineInstance + v5) )
    return 0;
  v6 = RwFreeListCreateAndPreallocateSpace(
         52,
         _rwImageFreeListBlockSize,
         4,
         _rwImageFormatFreeListPreallocBlocks,
         &_rwImageFormatFreeList);
  v7 = imageModule;
  *(_DWORD *)((char *)RwEngineInstance + imageModule + 536) = v6;
  v8 = (char *)RwEngineInstance + v7;
  if ( !*(_DWORD *)((char *)RwEngineInstance + v7 + 536) )
  {
    RwFreeListDestroy(*(RwFreeList_0 **)v8);
    instance = 0;
    *(_DWORD *)((char *)RwEngineInstance + imageModule) = 0;
    return instance;
  }
  *((_DWORD *)v8 + 2) = 256;
  v9 = (*((int (__fastcall **)(_DWORD))RwEngineInstance + 75))(*(_DWORD *)((char *)RwEngineInstance + v7 + 8));
  v10 = imageModule;
  *(_DWORD *)((char *)RwEngineInstance + imageModule + 4) = v9;
  v11 = *(_BYTE **)((char *)RwEngineInstance + v10 + 4);
  if ( !v11 )
  {
    RwFreeListDestroy(*(RwFreeList_0 **)((char *)RwEngineInstance + v10 + 536));
    instance = 0;
    v19 = imageModule;
    *(_DWORD *)((char *)RwEngineInstance + imageModule + 536) = 0;
    RwFreeListDestroy(*(RwFreeList_0 **)((char *)RwEngineInstance + v19));
    *(_DWORD *)((char *)RwEngineInstance + imageModule) = 0;
    return instance;
  }
  *v11 = 0;
  ++imageModule;
  *(_DWORD *)((char *)RwEngineInstance + v10 + 524) = 1065353216;
  *((_BYTE *)RwEngineInstance + v10 + 12) = 0;
  *((_BYTE *)RwEngineInstance + v10 + 268) = 0;
  for ( i = 13; i != 268; ++i )
  {
    v13 = (int)(float)((float)((float)((float)(i - 12) / 255.0) * 255.0) + 0.5);
    *((_BYTE *)RwEngineInstance + v10 + i) = v13;
    v14 = (char *)RwEngineInstance + v10 + i;
    v14[256] = v13;
  }
  *(_DWORD *)((char *)RwEngineInstance + v10 + 540) = 0;
  *(_DWORD *)((char *)RwEngineInstance + v10 + 532) = 256;
  v15 = (*((int (__fastcall **)(_DWORD))RwEngineInstance + 75))(*(_DWORD *)((char *)RwEngineInstance + v10 + 532));
  v16 = imageModule;
  *(_DWORD *)((char *)RwEngineInstance + imageModule + 528) = v15;
  if ( !*(_DWORD *)((char *)RwEngineInstance + v16 + 528) )
  {
    (*((void (__fastcall **)(_DWORD))RwEngineInstance + 76))(*(_DWORD *)((char *)RwEngineInstance + v16 + 4));
    v17 = imageModule;
    *(_DWORD *)((char *)RwEngineInstance + imageModule + 4) = 0;
    *(_DWORD *)((char *)RwEngineInstance + v17 + 8) = 0;
    RwFreeListDestroy(*(RwFreeList_0 **)((char *)RwEngineInstance + v17 + 536));
    v18 = imageModule;
    *(_DWORD *)((char *)RwEngineInstance + imageModule + 536) = 0;
    RwFreeListDestroy(*(RwFreeList_0 **)((char *)RwEngineInstance + v18));
    *(_DWORD *)((char *)RwEngineInstance + imageModule) = 0;
    return 0;
  }
  return instance;
}
// 6BCF04: using guessed type int imageModule;
// 6BCF08: using guessed type int imageModule;

//----- (001D8B74) --------------------------------------------------------
RwBool __fastcall RwImageSetGamma(RwReal gammaValue)
{
  int v3; // r5
  int v4; // r10
  float v5; // s20
  float v6; // r0

  v3 = 269;
  v4 = imageModule;
  *(RwReal *)((char *)RwEngineInstance + imageModule + 524) = gammaValue;
  *((_BYTE *)RwEngineInstance + v4 + 12) = 0;
  *((_BYTE *)RwEngineInstance + v4 + 268) = 0;
  do
  {
    v5 = powf((float)(v3 - 268) / 255.0, 1.0 / gammaValue);
    v6 = powf((float)(v3 - 268) / 255.0, gammaValue);
    *((char *)RwEngineInstance + v4 + v3 - 256) = (int)(float)((float)(v5 * 255.0) + 0.5);
    *((_BYTE *)RwEngineInstance + v4 + v3++) = (int)(float)((float)(v6 * 255.0) + 0.5);
  }
  while ( v3 != 524 );
  return 1;
}
// 6BCF04: using guessed type int imageModule;

//----- (001D8C54) --------------------------------------------------------
void *__fastcall _rwImageClose(void *instance, RwInt32 offset, RwInt32 size)
{
  int v4; // r2
  void (**v5)(void); // r3
  char *v6; // r0
  int v7; // r1
  int *v8; // r4
  RwFreeList_0 *v9; // r0
  RwFreeList_0 *v10; // r0

  v4 = imageModule;
  v5 = (void (**)(void))RwEngineInstance;
  if ( *(_DWORD *)((char *)RwEngineInstance + imageModule + 528) )
  {
    (*((void (**)(void))RwEngineInstance + 76))();
    v4 = imageModule;
    *(_DWORD *)((char *)RwEngineInstance + imageModule + 528) = 0;
    *(_DWORD *)((char *)RwEngineInstance + v4 + 532) = 0;
    v5 = (void (**)(void))RwEngineInstance;
  }
  if ( *(void (**)(void))((char *)v5 + v4 + 4) )
  {
    v5[76]();
    v4 = imageModule;
    *(_DWORD *)((char *)RwEngineInstance + imageModule + 4) = 0;
    *(_DWORD *)((char *)RwEngineInstance + v4 + 8) = 0;
    v5 = (void (**)(void))RwEngineInstance;
  }
  v6 = (char *)v5 + v4;
  v7 = *(int *)((char *)v5 + v4 + 540);
  if ( v7 )
  {
    v8 = (int *)(v6 + 540);
    do
    {
      *v8 = *(_DWORD *)(v7 + 48);
      (*((void (__fastcall **)(_DWORD))RwEngineInstance + 80))(*(_DWORD *)((char *)RwEngineInstance + imageModule + 536));
      v4 = imageModule;
      v5 = (void (**)(void))RwEngineInstance;
      v6 = (char *)RwEngineInstance + imageModule;
      v8 = (int *)((char *)RwEngineInstance + imageModule + 540);
      v7 = *v8;
    }
    while ( *v8 );
  }
  v9 = (RwFreeList_0 *)*((_DWORD *)v6 + 134);
  if ( v9 )
  {
    RwFreeListDestroy(v9);
    v4 = imageModule;
    *(_DWORD *)((char *)RwEngineInstance + imageModule + 536) = 0;
    v5 = (void (**)(void))RwEngineInstance;
  }
  v10 = *(RwFreeList_0 **)((char *)v5 + v4);
  if ( v10 )
  {
    RwFreeListDestroy(v10);
    *(_DWORD *)((char *)RwEngineInstance + imageModule) = 0;
  }
  --imageModule;
  return instance;
}
// 6BCF04: using guessed type int imageModule;
// 6BCF08: using guessed type int imageModule;

//----- (001D8D80) --------------------------------------------------------
void __fastcall _rwImageGammaUnCorrectArrayOfRGBA(RwRGBA_0 *rgbaOut, RwRGBA_0 *rgbaIn, RwInt32 numEls)
{
  char *v3; // r12
  RwUInt8 alpha; // r3

  if ( numEls )
  {
    v3 = (char *)RwEngineInstance + imageModule + 268;
    do
    {
      --numEls;
      rgbaOut->_anon_0._anon_0.red = v3[rgbaIn->_anon_0._anon_0.red];
      rgbaOut->_anon_0._anon_0.green = v3[rgbaIn->_anon_0._anon_0.green];
      rgbaOut->_anon_0._anon_0.blue = v3[rgbaIn->_anon_0._anon_0.blue];
      alpha = rgbaIn->_anon_0._anon_0.alpha;
      ++rgbaIn;
      rgbaOut->_anon_0._anon_0.alpha = alpha;
      ++rgbaOut;
    }
    while ( numEls );
  }
}
// 6BCF04: using guessed type int imageModule;

//----- (001D8DD0) --------------------------------------------------------
void __fastcall _rwImageGammaCorrectArrayOfRGBA(RwRGBA_0 *rgbaOut, RwRGBA_0 *rgbaIn, RwInt32 numEls)
{
  char *v3; // r12
  RwUInt8 alpha; // r3

  if ( numEls )
  {
    v3 = (char *)RwEngineInstance + imageModule + 12;
    do
    {
      --numEls;
      rgbaOut->_anon_0._anon_0.red = v3[rgbaIn->_anon_0._anon_0.red];
      rgbaOut->_anon_0._anon_0.green = v3[rgbaIn->_anon_0._anon_0.green];
      rgbaOut->_anon_0._anon_0.blue = v3[rgbaIn->_anon_0._anon_0.blue];
      alpha = rgbaIn->_anon_0._anon_0.alpha;
      ++rgbaIn;
      rgbaOut->_anon_0._anon_0.alpha = alpha;
      ++rgbaOut;
    }
    while ( numEls );
  }
}
// 6BCF04: using guessed type int imageModule;

//----- (001D8E20) --------------------------------------------------------
RwImage_0 *__fastcall RwImageCreate(RwInt32 width, RwInt32 height, RwInt32 depth)
{
  RwImage_0 *v6; // r4
  RwImage_0 *result; // r0

  v6 = (RwImage_0 *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                      + imageModule));
  result = 0;
  if ( v6 )
  {
    v6->cpPixels = 0;
    v6->palette = 0;
    v6->flags = 0;
    v6->width = width;
    v6->height = height;
    v6->depth = depth;
    _rwPluginRegistryInitObject(&imageTKList, v6);
    return v6;
  }
  return result;
}
// 6BCF04: using guessed type int imageModule;

//----- (001D8E78) --------------------------------------------------------
RwBool __fastcall RwImageDestroy(RwImage_0 *image)
{
  RwInt32 flags; // r0

  if ( LOBYTE(image->flags) << 31 )
  {
    (*((void (__fastcall **)(RwUInt8 *))RwEngineInstance + 76))(image->cpPixels);
    flags = image->flags;
    image->cpPixels = 0;
    image->palette = 0;
    image->flags = flags & 0xFFFFFFFE;
  }
  _rwPluginRegistryDeInitObject(&imageTKList, image);
  (*((void (__fastcall **)(_DWORD, RwImage_0 *))RwEngineInstance + 80))(
    *(_DWORD *)((char *)RwEngineInstance + imageModule),
    image);
  return 1;
}
// 6BCF04: using guessed type int imageModule;

//----- (001D8ED8) --------------------------------------------------------
RwImage_0 *__fastcall RwImageFreePixels(RwImage_0 *image)
{
  RwInt32 flags; // r0

  (*((void (__fastcall **)(RwUInt8 *))RwEngineInstance + 76))(image->cpPixels);
  flags = image->flags;
  image->cpPixels = 0;
  image->palette = 0;
  image->flags = flags & 0xFFFFFFFE;
  return image;
}

//----- (001D8F04) --------------------------------------------------------
RwImage_0 *__fastcall RwImageAllocatePixels(RwImage_0 *image)
{
  RwImage_0 *v1; // r4
  RwInt32 height; // r8
  RwInt32 depth; // r6
  unsigned int v4; // r5
  int v5; // r0
  unsigned int v6; // r9
  int v7; // r0
  bool v8; // zf
  RwRGBA_0 *v9; // r0
  RwInt32 flags; // r1
  RwError_0 v12; // [sp+0h] [bp-20h] BYREF

  v1 = image;
  height = image->height;
  depth = image->depth;
  v4 = (((depth + 7) >> 3) * image->width + 3) & 0xFFFFFFFC;
  v5 = 0;
  v1->stride = v4;
  if ( depth == 4 )
    v5 = 64;
  if ( depth == 8 )
    v5 = 1024;
  v6 = v5 + v4 * height;
  v7 = (*((int (__fastcall **)(unsigned int))RwEngineInstance + 75))(v6);
  v1->cpPixels = (RwUInt8 *)v7;
  if ( v7 )
  {
    v8 = depth == 8;
    if ( depth != 8 )
      v8 = depth == 4;
    if ( v8 )
      v9 = (RwRGBA_0 *)(v7 + v4 * height);
    else
      v9 = 0;
    flags = v1->flags;
    v1->palette = v9;
    v1->flags = flags | 1;
  }
  else
  {
    v12.pluginID = 0;
    v12.errorCode = _rwerror(-2147483629, v6);
    RwErrorSet(&v12);
    return 0;
  }
  return v1;
}

//----- (001D8FA0) --------------------------------------------------------
RwImage_0 *__fastcall RwImageResize(RwImage_0 *image, RwInt32 width, RwInt32 height)
{
  RwImage_0 *v3; // r4
  RwInt32 v4; // r6
  bool v5; // zf
  int v6; // r0
  RwInt32 depth; // r5
  int v8; // r0
  int v9; // r3
  RwRGBA_0 *v10; // r11
  int v11; // r10
  unsigned int v12; // r8
  int v13; // r0
  bool v14; // zf
  RwInt32 v15; // r0
  int v16; // r10
  int v17; // r11
  RwUInt8 *cpPixels; // r5
  RwUInt8 *v19; // r9
  size_t v20; // r6
  RwRGBA_0 *v22; // [sp+4h] [bp-34h]
  RwInt32 v23; // [sp+8h] [bp-30h]
  RwUInt8 *v24; // [sp+Ch] [bp-2Ch]
  RwInt32 v25; // [sp+10h] [bp-28h]
  RwError_0 code; // [sp+14h] [bp-24h] BYREF

  v3 = image;
  v4 = height;
  v6 = LOBYTE(image->flags) << 31;
  v5 = v6 == 0;
  if ( v6 )
    v5 = v3->cpPixels == 0;
  if ( !v5 )
  {
    depth = v3->depth;
    v8 = 0;
    v9 = 0;
    if ( depth == 8 )
      v8 = 1;
    v25 = width;
    if ( depth == 4 )
      v9 = 1;
    v10 = (RwRGBA_0 *)(v9 | v8);
    v11 = v9 | v8;
    if ( v9 | v8 )
      v11 = 4 << depth;
    v12 = (width * ((depth + 7) >> 3) + 3) & 0xFFFFFFFC;
    v13 = (*((int (__fastcall **)(unsigned int))RwEngineInstance + 75))(v11 + v12 * height);
    if ( !v13 )
    {
      code.pluginID = 0;
      code.errorCode = _rwerror(-2147483629, v11 + v12 * v4);
      RwErrorSet(&code);
      return 0;
    }
    v24 = (RwUInt8 *)v13;
    if ( v10 )
      v10 = (RwRGBA_0 *)(v13 + v12 * v4);
    v14 = depth == 8;
    if ( depth != 8 )
      v14 = depth == 4;
    if ( v14 )
      qmemcpy(v10, v3->palette, v11);
    v22 = v10;
    v16 = v3->height;
    v15 = v3->width;
    if ( v15 > v25 )
      v15 = v25;
    v23 = v4;
    if ( v16 > v4 )
      v16 = v4;
    if ( v16 > 0 )
    {
      v17 = 0;
      cpPixels = v3->cpPixels;
      v19 = v24;
      v20 = ((v3->depth + 7) >> 3) * v15;
      do
      {
        qmemcpy(v19, cpPixels, v20);
        ++v17;
        v19 += v12;
        cpPixels += v3->stride;
      }
      while ( v17 < v16 );
    }
    (*((void (__fastcall **)(RwUInt8 *))RwEngineInstance + 76))(v3->cpPixels);
    v3->stride = v12;
    v3->cpPixels = v24;
    v3->palette = v22;
    v4 = v23;
    width = v25;
  }
  v3->width = width;
  v3->height = v4;
  return v3;
}

//----- (001D90C8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
RwImage_0 *__fastcall RwImageMakeMask(RwImage_0 *image)
{
  RwInt32 depth; // r1
  unsigned int v2; // r3
  RwRGBA_0 *palette; // r6
  int v4; // r12
  int v5; // r1
  int v6; // r3
  RwUInt8 *p_alpha; // r1
  int v8; // lr
  const char *v9; // r4
  uint8x16_t v10; // q12
  uint16x8_t v11; // q13
  uint16x8_t v12; // q14
  int v13; // r1
  RwRGBA_0 *v14; // r2
  unsigned int green; // r5
  unsigned int v16; // r4
  unsigned int blue; // r2
  RwInt32 height; // r12
  RwInt32 width; // r3
  RwInt32 v20; // lr
  RwUInt8 *cpPixels; // r1
  RwInt32 v22; // r2
  unsigned __int8 *v23; // r6
  unsigned int v24; // r3
  int8x8x4_t v25; // 0:d16.8,8:d18.8,16:d20.8,24:d22.8 OVERLAPPED
  int8x8x4_t v26; // 0:d17.8,8:d19.8,16:d21.8,24:d23.8

  depth = image->depth;
  if ( depth == 4 )
  {
LABEL_4:
    v2 = 1;
    palette = image->palette;
    v4 = 1 << depth;
    if ( 1 << depth > 1 )
      v2 = 1 << depth;
    if ( v2 < 0x10 )
      goto LABEL_13;
    v5 = v2 & 0xF;
    if ( (v2 & 0xF) == 0 )
      v5 = 16;
    v6 = v2 - v5;
    if ( v6 )
    {
      p_alpha = &palette[15]._anon_0._anon_0.alpha;
      v8 = v6;
      do
      {
        v9 = (const char *)(p_alpha - 63);
        v8 -= 16;
        v25 = vld4_s8(v9);
        v9 += 32;
        v26 = vld4_s8(v9);
        v10 = vmaxq_u8(*(uint8x16_t *)v25.val[1].n64_u64, *(uint8x16_t *)v25.val[0].n64_u64);
        v11 = vmovl_u8(v25.val[2]);
        v12 = vmovl_u8((uint8x8_t)v10.n128_u64[0]);
        *(uint16x8_t *)v25.val[0].n64_u64 = vmovl_u8(v26.val[2]);
        *(uint16x8_t *)v25.val[2].n64_u64 = vmovl_u8(*(uint8x8_t *)&v10.n128_i8[8]);
        v26.val[1] = vmovn_s32(vmaxq_u32(vmovl_u16(*(uint16x4_t *)&v12.n128_i8[8]), vmovl_u16(*(uint16x4_t *)&v11.n128_i8[8])));
        v25.val[1] = vmovn_s32(vmaxq_u32(vmovl_u16((uint16x4_t)v12.n128_u64[0]), vmovl_u16((uint16x4_t)v11.n128_u64[0])));
        v26.val[2] = vmovn_s32(vmaxq_u32(vmovl_u16(v26.val[2]), vmovl_u16(v26.val[0])));
        v25.val[2] = vmovn_s32(vmaxq_u32(vmovl_u16(v25.val[2]), vmovl_u16(v25.val[0])));
        v25.val[0] = vmovn_s16(*(int16x8_t *)v25.val[1].n64_u64);
        v26.val[0] = vmovn_s16(*(int16x8_t *)v25.val[2].n64_u64);
        *(p_alpha - 56) = v25.val[0].n64_u8[1];
        *(p_alpha - 60) = v25.val[0].n64_u8[0];
        *(p_alpha - 52) = v25.val[0].n64_u8[2];
        *(p_alpha - 48) = v25.val[0].n64_u8[3];
        *(p_alpha - 44) = v25.val[0].n64_u8[4];
        *(p_alpha - 40) = v25.val[0].n64_u8[5];
        *(p_alpha - 36) = v25.val[0].n64_u8[6];
        *(p_alpha - 32) = v25.val[0].n64_u8[7];
        *(p_alpha - 28) = v26.val[0].n64_u8[0];
        *(p_alpha - 24) = v26.val[0].n64_u8[1];
        *(p_alpha - 20) = v26.val[0].n64_u8[2];
        *(p_alpha - 16) = v26.val[0].n64_u8[3];
        *(p_alpha - 12) = v26.val[0].n64_u8[4];
        *(p_alpha - 8) = v26.val[0].n64_u8[5];
        *(p_alpha - 4) = v26.val[0].n64_u8[6];
        *p_alpha = v26.val[0].n64_u8[7];
        p_alpha += 64;
      }
      while ( v8 );
    }
    else
    {
LABEL_13:
      v6 = 0;
    }
    v13 = (4 * v6) | 3;
    do
    {
      v14 = &palette[v6++];
      green = v14->_anon_0._anon_0.green;
      v16 = *((unsigned __int8 *)&palette->_anon_0._anon_0 + v13 - 3);
      blue = v14->_anon_0._anon_0.blue;
      if ( green > v16 )
        v16 = green;
      if ( v16 < blue )
        LOBYTE(v16) = blue;
      *(&palette->_anon_0._anon_0.red + v13) = v16;
      v13 += 4;
    }
    while ( v6 < v4 );
    return image;
  }
  if ( depth != 32 )
  {
    if ( depth != 8 )
      return image;
    goto LABEL_4;
  }
  height = image->height;
  if ( height >= 1 )
  {
    width = image->width;
    v20 = 0;
    cpPixels = image->cpPixels;
    do
    {
      if ( width >= 1 )
      {
        v22 = 0;
        do
        {
          v23 = &cpPixels[4 * v22];
          v24 = *v23;
          ++v22;
          if ( v23[1] > v24 )
            v24 = v23[1];
          if ( v24 < v23[2] )
            LOBYTE(v24) = v23[2];
          v23[3] = v24;
          width = image->width;
        }
        while ( v22 < width );
        height = image->height;
      }
      ++v20;
      cpPixels += image->stride;
    }
    while ( v20 < height );
  }
  return image;
}
// 1D9113: failed to expand linear variable 0:d16.8,8:d18.8,16:d20.8,24:d22.8

//----- (001D9280) --------------------------------------------------------
RwImage_0 *__fastcall RwImageApplyMask(RwImage_0 *image, const RwImage_0 *mask)
{
  RwInt32 width; // r5
  RwInt32 height; // r10
  RwInt32 depth; // r8
  RwImage_0 *v7; // r0
  RwImage_0 *v8; // r4
  RwImage_0 *v9; // r6
  __int64 v10; // kr00_8
  RwInt32 v11; // r5
  RwInt32 v12; // r10
  char *v13; // r6
  int v14; // r0
  bool v15; // zf
  RwInt32 v16; // r0
  RwInt32 flags; // r0
  RwRGBA_0 *v19; // r0
  RwInt32 v20; // r1
  RwInt32 v21; // r0
  RwInt32 v22; // r2
  RwInt32 v23; // r1
  int v24; // r6
  RwUInt8 *v25; // r0
  RwInt32 v26; // r0
  RwInt32 v27; // r1
  __int64 v28; // r0
  RwInt32 v29; // r3
  RwUInt8 *cpPixels; // r12
  RwInt32 v31; // r6
  RwInt32 v32; // r5
  RwInt32 v33; // r4
  RwError_0 code; // [sp+4h] [bp-24h] BYREF

  width = image->width;
  if ( width != mask->width || (height = image->height, height != mask->height) )
  {
    v9 = 0;
    v16 = -2147483638;
LABEL_18:
    code.pluginID = 0;
    code.errorCode = _rwerror(v16);
    RwErrorSet(&code);
    return v9;
  }
  depth = image->depth;
  if ( depth != 4 )
  {
    if ( depth == 32 )
      goto LABEL_30;
    if ( depth != 8 )
    {
      v16 = -2147483639;
      v9 = 0;
      goto LABEL_18;
    }
  }
  v7 = (RwImage_0 *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                      + imageModule));
  v8 = v7;
  v9 = 0;
  if ( !v7 )
    return v9;
  v7->cpPixels = 0;
  v7->palette = 0;
  v7->flags = 0;
  v7->width = width;
  v7->height = height;
  v7->depth = depth;
  _rwPluginRegistryInitObject(&imageTKList, v7);
  v10 = *(_QWORD *)&v8->width;
  v11 = v8->depth;
  v12 = (((v11 + 7) >> 3) * v10 + 3) & 0xFFFFFFFC;
  v8->stride = v12;
  if ( v11 == 4 )
    v9 = (RwImage_0 *)&dword_40;
  if ( v11 == 8 )
    v9 = (RwImage_0 *)(elf_hash_bucket + 772);
  v13 = (char *)v9 + v12 * HIDWORD(v10);
  v14 = (*((int (__fastcall **)(char *))RwEngineInstance + 75))(v13);
  v8->cpPixels = (RwUInt8 *)v14;
  if ( !v14 )
  {
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483629, v13);
    RwErrorSet(&code);
    if ( LOBYTE(v8->flags) << 31 )
    {
      (*((void (__fastcall **)(RwUInt8 *))RwEngineInstance + 76))(v8->cpPixels);
      flags = v8->flags;
      v8->cpPixels = 0;
      v8->palette = 0;
      v8->flags = flags & 0xFFFFFFFE;
    }
    _rwPluginRegistryDeInitObject(&imageTKList, v8);
    (*((void (__fastcall **)(_DWORD, RwImage_0 *))RwEngineInstance + 80))(
      *(_DWORD *)((char *)RwEngineInstance + imageModule),
      v8);
    return 0;
  }
  v15 = v11 == 8;
  if ( v11 != 8 )
    v15 = v11 == 4;
  if ( v15 )
    v19 = (RwRGBA_0 *)(v10 + v12 * HIDWORD(v10));
  else
    v19 = 0;
  v20 = v8->flags;
  v8->palette = v19;
  v8->flags = v20 | 1;
  RwImageCopy(v8, image);
  if ( LOBYTE(image->flags) << 31 )
  {
    (*((void (__fastcall **)(RwUInt8 *))RwEngineInstance + 76))(image->cpPixels);
    v21 = image->flags;
    image->cpPixels = 0;
    image->palette = 0;
    image->flags = v21 & 0xFFFFFFFE;
  }
  v22 = image->height;
  v23 = 4 * image->width;
  image->depth = 32;
  image->stride = v23;
  v24 = v22 * v23;
  v25 = (RwUInt8 *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(v22 * v23);
  image->cpPixels = v25;
  if ( v25 )
  {
    v26 = image->flags;
    image->palette = 0;
    image->flags = v26 | 1;
  }
  else
  {
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483629, v24);
    RwErrorSet(&code);
  }
  RwImageCopy(image, v8);
  (*((void (__fastcall **)(RwUInt8 *))RwEngineInstance + 76))(v8->cpPixels);
  v27 = v8->flags;
  v8->cpPixels = 0;
  v8->palette = 0;
  v8->flags = v27 & 0xFFFFFFFE;
  _rwPluginRegistryDeInitObject(&imageTKList, v8);
  (*((void (__fastcall **)(_DWORD, RwImage_0 *))RwEngineInstance + 80))(
    *(_DWORD *)((char *)RwEngineInstance + imageModule),
    v8);
  height = image->height;
LABEL_30:
  if ( height >= 1 )
  {
    v28 = *(_QWORD *)&mask->cpPixels;
    v29 = 0;
    cpPixels = image->cpPixels;
    do
    {
      v31 = mask->depth;
      switch ( v31 )
      {
        case 4:
          goto LABEL_35;
        case 32:
          if ( image->width >= 1 )
          {
            v33 = 0;
            do
            {
              cpPixels[4 * v33 + 3] = *(_BYTE *)(v28 + 3 + 4 * v33);
              ++v33;
            }
            while ( v33 < image->width );
          }
          break;
        case 8:
LABEL_35:
          if ( image->width >= 1 )
          {
            v32 = 0;
            do
            {
              cpPixels[4 * v32 + 3] = *(_BYTE *)(HIDWORD(v28) + 4 * *(unsigned __int8 *)(v28 + v32) + 3);
              ++v32;
            }
            while ( v32 < image->width );
          }
          break;
      }
      ++v29;
      LODWORD(v28) = v28 + mask->stride;
      cpPixels += image->stride;
    }
    while ( v29 < image->height );
  }
  return image;
}
// 40: using guessed type int dword_40;
// FC: using guessed type int elf_hash_bucket[16411];
// 6BCF04: using guessed type int imageModule;

//----- (001D9560) --------------------------------------------------------
RwImage_0 *__fastcall RwImageCopy(RwImage_0 *destImage, const RwImage_0 *sourceImage)
{
  const RwImage_0 *v2; // r9
  RwImage_0 *v3; // r10
  RwInt32 depth; // r1
  RwInt32 v5; // r6
  RwRGBA_0 *v6; // r0
  RwRGBA_0 *v7; // r1
  int v8; // r1
  RwUInt8 *v9; // r6
  RwInt32 v10; // r5
  RwUInt8 *v11; // r4
  size_t v12; // r8
  const RwImage_0 *v13; // r0
  signed int width; // r2
  int height; // r11
  RwUInt8 *cpPixels; // r8
  int v17; // r1
  RwUInt8 *v18; // r9
  RwRGBA_0 *palette; // r0
  bool v20; // zf
  int i; // r1
  RwUInt8 *v22; // r5
  RwUInt8 *v23; // r3
  signed int v24; // r4
  int v25; // t1
  signed int v26; // r4
  RwInt32 flags; // r0
  const RwImage_0 *v29; // [sp+0h] [bp-28h]
  RwError_0 code; // [sp+4h] [bp-24h] BYREF

  v2 = sourceImage;
  v3 = destImage;
  depth = sourceImage->depth;
  v5 = destImage->depth;
  if ( v5 != depth )
  {
    v13 = v2;
    height = v3->height;
    width = v3->width;
    cpPixels = v3->cpPixels;
    v17 = v5 | (depth << 8);
    v18 = v2->cpPixels;
    v29 = v13;
    palette = v13->palette;
    if ( v17 <= 2055 )
    {
      if ( v17 != 1028 )
      {
        if ( v17 != 1032 )
        {
          if ( v17 != 1056 )
          {
LABEL_14:
            v3 = 0;
            code.pluginID = 0;
            code.errorCode = _rwerror(-2147483639);
            RwErrorSet(&code);
            goto LABEL_29;
          }
LABEL_19:
          if ( height >= 1 )
          {
            for ( i = 0; i != height; ++i )
            {
              if ( width >= 1 )
              {
                v22 = v18;
                v23 = cpPixels;
                v24 = width;
                do
                {
                  v25 = *v22++;
                  --v24;
                  *(RwRGBA_0 *)v23 = palette[v25];
                  v23 += 4;
                }
                while ( v24 );
              }
              cpPixels += v3->stride;
              v18 += v29->stride;
            }
          }
          goto LABEL_29;
        }
        if ( height >= 1 )
        {
          do
          {
            v26 = width;
            qmemcpy(cpPixels, v18, width);
            --height;
            width = v26;
            cpPixels += v3->stride;
            v18 += v29->stride;
          }
          while ( height );
          v2 = v29;
          goto LABEL_30;
        }
      }
LABEL_29:
      v2 = v29;
      goto LABEL_30;
    }
    v20 = v17 == 2056;
    if ( v17 != 2056 )
      v20 = v17 == 8224;
    if ( v20 )
      goto LABEL_29;
    if ( v17 != 2080 )
      goto LABEL_14;
    goto LABEL_19;
  }
  v6 = destImage->palette;
  if ( v6 )
  {
    if ( v5 <= 8 )
    {
      v7 = v2->palette;
      if ( v7 )
      {
        qmemcpy(v6, v7, 4 << v5);
        v5 = v3->depth;
      }
    }
  }
  if ( v3->height >= 1 )
  {
    v8 = v5 + 7;
    v9 = v2->cpPixels;
    v10 = 0;
    v11 = v3->cpPixels;
    v12 = (v8 >> 3) * v3->width;
    do
    {
      qmemcpy(v11, v9, v12);
      ++v10;
      v11 += v3->stride;
      v9 += v2->stride;
    }
    while ( v10 < v3->height );
  }
LABEL_30:
  flags = v3->flags;
  v3->flags &= ~2u;
  v3->flags = flags & 0xFFFFFFFD | (2 * (((unsigned int)v2->flags >> 1) & 1));
  return v3;
}

//----- (001D96C4) --------------------------------------------------------
const RwChar *__fastcall RwImageSetPath(const RwChar *path)
{
  const RwChar *v1; // r6
  int v2; // r0
  char *v3; // r2
  size_t v4; // r5
  int v5; // r1
  int v6; // r0
  RwError_0 v8; // [sp+0h] [bp-18h] BYREF

  v1 = path;
  v2 = (*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(path);
  v3 = (char *)RwEngineInstance;
  v4 = v2 + 1;
  v5 = imageModule;
  if ( v2 + 1 > *(_DWORD *)((char *)RwEngineInstance + imageModule + 8) )
  {
    v6 = (*((int (__fastcall **)(_DWORD, size_t))RwEngineInstance + 77))(
           *(_DWORD *)((char *)RwEngineInstance + imageModule + 4),
           v4);
    if ( !v6 )
    {
      v1 = 0;
      v8.pluginID = 0;
      v8.errorCode = _rwerror(-2147483629, v4);
      RwErrorSet(&v8);
      return v1;
    }
    v5 = imageModule;
    *(_DWORD *)((char *)RwEngineInstance + imageModule + 4) = v6;
    *(_DWORD *)((char *)RwEngineInstance + v5 + 8) = v4;
    v3 = (char *)RwEngineInstance;
  }
  qmemcpy(*(void **)&v3[v5 + 4], v1, v4);
  return v1;
}
// 6BCF04: using guessed type int imageModule;

//----- (001D9758) --------------------------------------------------------
RwChar *RwImageGetPath()
{
  return *(RwChar **)((char *)RwEngineInstance + imageModule + 4);
}
// 6BCF04: using guessed type int imageModule;

//----- (001D9774) --------------------------------------------------------
void __fastcall _rwImageSwapPath(RwChar **path, RwInt32 *size)
{
  int v2; // r12

  v2 = imageModule;
  *path = *(RwChar **)((char *)RwEngineInstance + imageModule + 4);
  *size = *(_DWORD *)((char *)RwEngineInstance + v2 + 8);
  *(_DWORD *)((char *)RwEngineInstance + v2 + 4) = *path;
  *(_DWORD *)((char *)RwEngineInstance + v2 + 8) = *size;
}
// 6BCF04: using guessed type int imageModule;

//----- (001D97AC) --------------------------------------------------------
RwImage_0 *__fastcall RwImageRead(const RwChar *imageName)
{
  const RwChar *v2; // r5
  int v3; // r0
  int v4; // r0
  int v5; // r5
  int v6; // r6
  RwImage_0 *result; // r0
  int v8; // [sp+0h] [bp-20h] BYREF
  RwImage_0 *v9; // [sp+4h] [bp-1Ch]

  v2 = (const RwChar *)(*((int (__fastcall **)(const RwChar *, int))RwEngineInstance + 66))(imageName, 58);
  if ( !v2 )
    v2 = imageName;
  v3 = (*((int (__fastcall **)(const RwChar *, int))RwEngineInstance + 66))(v2, 47);
  if ( v3 )
    v2 = (const RwChar *)v3;
  v4 = (*((int (__fastcall **)(const RwChar *, int))RwEngineInstance + 66))(v2, 92);
  if ( v4 )
    v2 = (const RwChar *)v4;
  v5 = (*((int (__fastcall **)(const RwChar *, int))RwEngineInstance + 66))(v2, 46);
  if ( !v5 )
    return 0;
  v6 = *(_DWORD *)((char *)RwEngineInstance + imageModule + 540);
  if ( !v6 )
    return 0;
  if ( (*((int (__fastcall **)(_DWORD, int))RwEngineInstance + 68))(
         *(_DWORD *)((char *)RwEngineInstance + imageModule + 540),
         v5) )
  {
    do
    {
      if ( !(*((int (__fastcall **)(int, int))RwEngineInstance + 68))(v6 + 20, v5) )
        break;
      v6 = *(_DWORD *)(v6 + 48);
      if ( !v6 )
        return 0;
    }
    while ( (*((int (__fastcall **)(int, int))RwEngineInstance + 68))(v6, v5) );
  }
  result = 0;
  if ( *(_DWORD *)(v6 + 40) )
  {
    v8 = *(_DWORD *)(v6 + 40);
    v9 = 0;
    ImagePathForAllFullNames(imageName, 5, ImageAttempRead, &v8);
    return v9;
  }
  return result;
}
// 6BCF04: using guessed type int imageModule;

//----- (001D989C) --------------------------------------------------------
RwChar *__fastcall ImagePathForAllFullNames(
        const RwChar *filename,
        RwInt32 extraBytes,
        rwPathCallBack *callBack,
        void *data)
{
  const RwChar *v4; // r6
  _BYTE *v5; // r4
  int v6; // r0
  RwChar *result; // r0
  bool v8; // zf
  int v9; // r0
  size_t v10; // r11
  _BYTE *v11; // r10
  int v12; // r0
  int v13; // r2
  signed int v14; // r5
  char *v15; // r1
  int v16; // r0
  int v17; // r0
  RwChar *v18; // r5
  int v19; // r0
  void (__fastcall **v20)(RwChar *, const RwChar *); // r5
  int v21; // r2
  int v22; // r4
  int v23; // r0
  int v24; // r0
  const RwChar *v25; // r1
  RwChar *v26; // r4
  RwInt32 v27; // r0
  const RwChar *v30; // [sp+14h] [bp-2Ch]
  RwError_0 code; // [sp+1Ch] [bp-24h] BYREF

  v4 = filename;
  v5 = *(_BYTE **)((char *)RwEngineInstance + imageModule + 4);
  v6 = _rwpathisabsolute(filename);
  v30 = v4;
  if ( !v5 || v6 || !*v5 )
  {
    v19 = (*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(v4);
    v20 = (void (__fastcall **)(RwChar *, const RwChar *))RwEngineInstance;
    v21 = imageModule;
    v22 = v19 + extraBytes;
    if ( *(_DWORD *)((char *)RwEngineInstance + imageModule + 532) >= v19 + extraBytes )
    {
      v25 = v4;
    }
    else
    {
      v23 = *(_DWORD *)((char *)RwEngineInstance + imageModule + 528);
      if ( v23 )
        v24 = (*((int (__fastcall **)(int, int))RwEngineInstance + 77))(v23, v22);
      else
        v24 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(v22);
      v25 = v4;
      if ( !v24 )
      {
        code.pluginID = 0;
        v27 = _rwerror(-2147483629, v22);
LABEL_32:
        code.errorCode = v27;
        return (RwChar *)RwErrorSet(&code);
      }
      v21 = imageModule;
      *(_DWORD *)((char *)RwEngineInstance + imageModule + 528) = v24;
      *(_DWORD *)((char *)RwEngineInstance + v21 + 532) = v22;
      v20 = (void (__fastcall **)(RwChar *, const RwChar *))RwEngineInstance;
    }
    result = (RwChar *)v20 + v21;
    v26 = *(RwChar **)((char *)v20 + v21 + 528);
    if ( v26 )
    {
      v20[62](v26, v25);
      return callBack(v26, data);
    }
    return result;
  }
  result = (RwChar *)&RwEngineInstance;
  while ( 1 )
  {
    v8 = v5 == 0;
    if ( v5 )
    {
      result = (RwChar *)(unsigned __int8)*v5;
      v8 = result == 0;
    }
    if ( v8 )
      return result;
    (*((void (__fastcall **)(_BYTE *, int))RwEngineInstance + 67))(v5, 59);
    v9 = (*((int (__fastcall **)(_BYTE *, int))RwEngineInstance + 67))(v5, 59);
    if ( v9 )
    {
      v10 = v9 - (_DWORD)v5;
      v11 = (_BYTE *)(v9 + 1);
    }
    else
    {
      v10 = (*((int (__fastcall **)(_BYTE *))RwEngineInstance + 70))(v5);
      v11 = 0;
    }
    v12 = (*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(v4);
    v13 = imageModule;
    v14 = v10 + extraBytes + v12;
    v15 = (char *)RwEngineInstance;
    if ( *(_DWORD *)((char *)RwEngineInstance + imageModule + 532) >= v14 )
    {
      v4 = v30;
    }
    else
    {
      v16 = *(_DWORD *)((char *)RwEngineInstance + imageModule + 528);
      if ( v16 )
        v17 = (*((int (__fastcall **)(int, signed int))RwEngineInstance + 77))(v16, v14);
      else
        v17 = (*((int (__fastcall **)(signed int))RwEngineInstance + 75))(v14);
      v4 = v30;
      if ( !v17 )
      {
        code.pluginID = 0;
        v27 = _rwerror(-2147483629, v14);
        goto LABEL_32;
      }
      v13 = imageModule;
      *(_DWORD *)((char *)RwEngineInstance + imageModule + 528) = v17;
      *(_DWORD *)((char *)RwEngineInstance + v13 + 532) = v14;
      v15 = (char *)RwEngineInstance;
    }
    result = (RwChar *)&v15[v13];
    v18 = *(RwChar **)&v15[v13 + 528];
    if ( v18 )
    {
      qmemcpy(*(void **)&v15[v13 + 528], v5, v10);
      (*((void (__fastcall **)(RwChar *, const RwChar *))RwEngineInstance + 62))(&v18[v10], v4);
      result = callBack(v18, data);
      v5 = v11;
      if ( result )
        continue;
    }
    return result;
  }
}
// 6BCF04: using guessed type int imageModule;

//----- (001D9AD0) --------------------------------------------------------
RwChar *__fastcall ImageAttempRead(RwChar *pathname, void *data)
{
  RwChar *v2; // r4
  int v4; // r0

  v2 = pathname;
  if ( (*((int (__fastcall **)(RwChar *))RwEngineInstance + 49))(pathname) )
  {
    v4 = (*(int (__fastcall **)(RwChar *))data)(v2);
    *((_DWORD *)data + 1) = v4;
    if ( v4 )
      return 0;
  }
  return v2;
}

//----- (001D9B00) --------------------------------------------------------
const RwChar *__fastcall RwImageFindFileType(const RwChar *imageName)
{
  const RwChar *data; // [sp+4h] [bp-Ch] BYREF

  data = 0;
  ImagePathForAllFullNames(imageName, 20, ImageDetermineExtender, &data);
  return data;
}

//----- (001D9B20) --------------------------------------------------------
RwChar *__fastcall ImageDetermineExtender(RwChar *pathname, void *data)
{
  RwChar *v2; // r4
  int v4; // r0
  int v5; // r6
  RwChar *v6; // r9

  v2 = pathname;
  v4 = (*((int (__fastcall **)(RwChar *))RwEngineInstance + 70))(pathname);
  v5 = *(_DWORD *)((char *)RwEngineInstance + imageModule + 540);
  if ( v5 )
  {
    v6 = &v2[v4];
    (*((void (__fastcall **)(RwChar *, _DWORD))RwEngineInstance + 62))(
      &v2[v4],
      *(_DWORD *)((char *)RwEngineInstance + imageModule + 540));
    if ( !(*((int (__fastcall **)(RwChar *))RwEngineInstance + 49))(v2) )
    {
      while ( 1 )
      {
        (*((void (__fastcall **)(RwChar *, int))RwEngineInstance + 62))(v6, v5 + 20);
        if ( (*((int (__fastcall **)(RwChar *))RwEngineInstance + 49))(v2) )
          break;
        v5 = *(_DWORD *)(v5 + 48);
        if ( !v5 )
          return v2;
        (*((void (__fastcall **)(RwChar *, int))RwEngineInstance + 62))(v6, v5);
        if ( (*((int (__fastcall **)(RwChar *))RwEngineInstance + 49))(v2) )
          goto LABEL_3;
      }
      v5 += 20;
    }
LABEL_3:
    v2 = 0;
    *(_DWORD *)data = v5;
  }
  return v2;
}
// 6BCF04: using guessed type int imageModule;

//----- (001D9BEC) --------------------------------------------------------
RwBool __fastcall RwImageRegisterImageFormat(
        const RwChar *extension,
        RwImageCallBackRead imageRead,
        RwImageCallBackWrite imageWrite)
{
  int *v6; // r0
  int v7; // r6
  int v8; // r5
  int v9; // r0
  RwBool v10; // r6
  __int64 v11; // d17
  int v12; // r1
  char *v13; // r0
  _QWORD v15[2]; // [sp+0h] [bp-38h] BYREF
  int v16; // [sp+10h] [bp-28h]

  LOBYTE(v15[0]) = 46;
  (*((void (__fastcall **)(char *, const RwChar *, int))RwEngineInstance + 63))((char *)v15 + 1, extension, 18);
  HIBYTE(v16) = 0;
  (*((void (__fastcall **)(_QWORD *))RwEngineInstance + 72))(v15);
  v6 = (int *)((char *)RwEngineInstance + imageModule + 540);
LABEL_2:
  v7 = *v6;
  v8 = 0;
  while ( v7 && !v8 )
  {
    v8 = v7;
    if ( (*((int (__fastcall **)(int, _QWORD *))RwEngineInstance + 68))(v7, v15) )
    {
      v6 = (int *)(v7 + 48);
      goto LABEL_2;
    }
  }
  if ( !v8 )
  {
    v9 = (*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + imageModule + 536));
    v8 = v9;
    v10 = 0;
    if ( !v9 )
      return v10;
    v11 = v15[1];
    v12 = v16;
    *(_QWORD *)v9 = v15[0];
    *(_QWORD *)(v9 + 8) = v11;
    *(_DWORD *)(v9 + 16) = v12;
    *(_BYTE *)(v9 + 20) = 46;
    (*((void (__fastcall **)(int, const RwChar *, int))RwEngineInstance + 63))(v9 + 21, extension, 18);
    *(_BYTE *)(v8 + 39) = 0;
    (*((void (__fastcall **)(int))RwEngineInstance + 71))(v8 + 20);
    *(_DWORD *)(v8 + 40) = 0;
    *(_DWORD *)(v8 + 44) = 0;
    v13 = (char *)RwEngineInstance + imageModule;
    *(_DWORD *)(v8 + 48) = *(_DWORD *)((char *)RwEngineInstance + imageModule + 540);
    *((_DWORD *)v13 + 135) = v8;
  }
  v10 = 1;
  if ( imageRead )
    *(_DWORD *)(v8 + 40) = imageRead;
  if ( imageWrite )
    *(_DWORD *)(v8 + 44) = imageWrite;
  return v10;
}
// 6BCF04: using guessed type int imageModule;

//----- (001D9D40) --------------------------------------------------------
RwImage_0 *__fastcall RwImageWrite(RwImage_0 *image, const RwChar *imageName)
{
  int v4; // r6
  int (__fastcall **v5)(_DWORD, int); // r0
  int v6; // r5
  int (__fastcall *v7)(RwImage_0 *, const RwChar *); // r2

  v4 = (*((int (__fastcall **)(const RwChar *, int))RwEngineInstance + 66))(imageName, 46);
  if ( !v4 )
    return 0;
  v5 = (int (__fastcall **)(_DWORD, int))RwEngineInstance;
  v6 = *(_DWORD *)((char *)RwEngineInstance + imageModule + 540);
  if ( !v6 )
    return 0;
  while ( 1 )
  {
    if ( !v5[68](v6, v4) || !(*((int (__fastcall **)(int, int))RwEngineInstance + 68))(v6 + 20, v4) )
    {
      v7 = *(int (__fastcall **)(RwImage_0 *, const RwChar *))(v6 + 44);
      if ( v7 )
        break;
    }
    v6 = *(_DWORD *)(v6 + 48);
    if ( !v6 )
      return 0;
    v5 = (int (__fastcall **)(_DWORD, int))RwEngineInstance;
  }
  return (RwImage_0 *)v7(image, imageName);
}
// 6BCF04: using guessed type int imageModule;

//----- (001D9DDC) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
RwImage_0 *__fastcall RwImageReadMaskedImage(const RwChar *imageName, const RwChar *maskName)
{
  RwImage_0 *v3; // r4
  bool v4; // zf
  RwImage_0 *v5; // r0
  RwImage_0 *v6; // r5
  RwInt32 flags; // r0
  RwInt32 v9; // r0
  void (__fastcall **v10)(_DWORD, RwImage_0 *); // r2
  int v11; // r0
  RwImage_0 *v12; // r1
  RwInt32 v13; // r0
  RwInt32 v14; // r0
  RwInt32 v15; // r0

  v3 = RwImageRead(imageName);
  if ( v3 )
  {
    v4 = maskName == 0;
    if ( maskName )
      v4 = *maskName == 0;
    if ( v4 )
      return v3;
    v5 = RwImageRead(maskName);
    v6 = v5;
    if ( v5 )
    {
      RwImageMakeMask(v5);
      if ( v6 )
      {
        if ( RwImageApplyMask(v3, v6) )
        {
          if ( LOBYTE(v6->flags) << 31 )
          {
            (*((void (__fastcall **)(RwUInt8 *))RwEngineInstance + 76))(v6->cpPixels);
            flags = v6->flags;
            v6->cpPixels = 0;
            v6->palette = 0;
            v6->flags = flags & 0xFFFFFFFE;
          }
          _rwPluginRegistryDeInitObject(&imageTKList, v6);
          (*((void (__fastcall **)(_DWORD, RwImage_0 *))RwEngineInstance + 80))(
            *(_DWORD *)((char *)RwEngineInstance + imageModule),
            v6);
          return v3;
        }
        if ( LOBYTE(v3->flags) << 31 )
        {
          (*((void (__fastcall **)(RwUInt8 *))RwEngineInstance + 76))(v3->cpPixels);
          v14 = v3->flags;
          v3->cpPixels = 0;
          v3->palette = 0;
          v3->flags = v14 & 0xFFFFFFFE;
        }
        _rwPluginRegistryDeInitObject(&imageTKList, v3);
        (*((void (__fastcall **)(_DWORD, RwImage_0 *))RwEngineInstance + 80))(
          *(_DWORD *)((char *)RwEngineInstance + imageModule),
          v3);
        if ( LOBYTE(v6->flags) << 31 )
        {
          (*((void (__fastcall **)(RwUInt8 *))RwEngineInstance + 76))(v6->cpPixels);
          v15 = v6->flags;
          v6->cpPixels = 0;
          v6->palette = 0;
          v6->flags = v15 & 0xFFFFFFFE;
        }
      }
      else
      {
        if ( LOBYTE(v3->flags) << 31 )
        {
          (*((void (__fastcall **)(RwUInt8 *))RwEngineInstance + 76))(v3->cpPixels);
          v13 = v3->flags;
          v3->cpPixels = 0;
          v3->palette = 0;
          v3->flags = v13 & 0xFFFFFFFE;
        }
        _rwPluginRegistryDeInitObject(&imageTKList, v3);
        (*((void (__fastcall **)(_DWORD, RwImage_0 *))RwEngineInstance + 80))(
          *(_DWORD *)((char *)RwEngineInstance + imageModule),
          v3);
        (*((void (__fastcall **)(int))RwEngineInstance + 76))(1);
        dword_14 = 0;
        off_18 = 0;
        dword_0 = 1179403646;
      }
      _rwPluginRegistryDeInitObject(&imageTKList, v6);
      v10 = (void (__fastcall **)(_DWORD, RwImage_0 *))RwEngineInstance;
      v11 = *(_DWORD *)((char *)RwEngineInstance + imageModule);
      v12 = v6;
    }
    else
    {
      if ( LOBYTE(v3->flags) << 31 )
      {
        (*((void (__fastcall **)(RwUInt8 *))RwEngineInstance + 76))(v3->cpPixels);
        v9 = v3->flags;
        v3->cpPixels = 0;
        v3->palette = 0;
        v3->flags = v9 & 0xFFFFFFFE;
      }
      _rwPluginRegistryDeInitObject(&imageTKList, v3);
      v10 = (void (__fastcall **)(_DWORD, RwImage_0 *))RwEngineInstance;
      v11 = *(_DWORD *)((char *)RwEngineInstance + imageModule);
      v12 = v3;
    }
    v10[80](v11, v12);
  }
  return 0;
}
// 1D9F06: write access to const memory at 14 has been detected
// 1D9F06: write access to const memory at 18 has been detected
// 0: using guessed type int dword_0;
// 14: using guessed type int dword_14;
// 18: using guessed type int (*off_18)();
// 6BCF04: using guessed type int imageModule;

//----- (001DA018) --------------------------------------------------------
RwUInt32 __fastcall RwRGBAToPixel(RwRGBA_0 *rgbIn, RwInt32 rasterFormat)
{
  RwUInt32 v3; // [sp+4h] [bp-Ch] BYREF

  (*((void (__fastcall **)(RwUInt32 *, RwRGBA_0 *, RwInt32))RwEngineInstance + 20))(&v3, rgbIn, rasterFormat);
  return v3;
}

//----- (001DA03C) --------------------------------------------------------
RwRGBA_0 *__fastcall RwRGBASetFromPixel(RwRGBA_0 *rgbOut, RwUInt32 pixelValue, RwInt32 rasterFormat)
{
  RwUInt32 v5[3]; // [sp+4h] [bp-Ch] BYREF

  v5[0] = pixelValue;
  (*((void (__fastcall **)(RwRGBA_0 *, RwUInt32 *, RwInt32))RwEngineInstance + 21))(rgbOut, v5, rasterFormat);
  return rgbOut;
}
// 1DA03C: using guessed type RwUInt32 var_C[3];

//----- (001DA060) --------------------------------------------------------
RwInt32 __fastcall RwImageRegisterPlugin(
        RwInt32 size,
        RwUInt32 pluginID,
        RwPluginObjectConstructor constructCB,
        RwPluginObjectDestructor destructCB,
        RwPluginObjectCopy copyCB)
{
  return _rwPluginRegistryAddPlugin(&imageTKList, size, pluginID, constructCB, destructCB, copyCB);
}

//----- (001DA088) --------------------------------------------------------
RwInt32 __fastcall RwImageGetPluginOffset(RwUInt32 pluginID)
{
  return sub_18F574(&imageTKList, pluginID);
}

//----- (001DA098) --------------------------------------------------------
RwBool __fastcall RwImageValidatePlugins(const RwImage_0 *image)
{
  return 1;
}

//----- (001DA09C) --------------------------------------------------------
RwInt32 __fastcall RwImageStreamGetSize(const RwImage_0 *image)
{
  __int64 v1; // kr00_8
  RwInt32 stride; // r0
  int v3; // r3

  v1 = *(_QWORD *)&image->height;
  stride = image->stride;
  v3 = stride * v1;
  if ( SHIDWORD(v1) < 9 )
    v3 = (4 << SBYTE4(v1)) + stride * v1;
  return v3 + 28;
}

//----- (001DA0B8) --------------------------------------------------------
RwImage_0 *__fastcall RwImageStreamRead(RwStream_0 *stream)
{
  int v2; // r5
  int v3; // r6
  int v4; // r10
  int *v5; // r0
  int *v6; // r9
  int v7; // r4
  __int64 v8; // kr00_8
  int v9; // r5
  int v10; // r6
  int v11; // r4
  int v12; // r0
  bool v13; // zf
  int v14; // r0
  int v15; // r1
  signed int v16; // r2
  signed int v17; // r6
  int v18; // r4
  int v19; // r5
  void *v20; // r1
  int v21; // r0
  RwUInt32 v23; // [sp+0h] [bp-38h] BYREF
  RwUInt32 lengthOut; // [sp+4h] [bp-34h] BYREF
  int buffer; // [sp+8h] [bp-30h] BYREF
  int v26; // [sp+Ch] [bp-2Ch]
  int v27; // [sp+10h] [bp-28h]
  RwUInt32 length; // [sp+14h] [bp-24h]
  RwError_0 code; // [sp+18h] [bp-20h] BYREF

  if ( !RwStreamFindChunk(stream, 1u, &lengthOut, &v23) )
    return 0;
  RwStreamRead(stream, &buffer, 0x10u);
  RwMemNative32(&buffer, 0x10u);
  v2 = buffer;
  v3 = v26;
  v4 = v27;
  v5 = (int *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + imageModule));
  v6 = v5;
  v7 = 0;
  if ( v5 )
  {
    v5[5] = 0;
    v5[6] = 0;
    *v5 = 0;
    v5[1] = v2;
    v5[2] = v3;
    v5[3] = v4;
    _rwPluginRegistryInitObject(&imageTKList, v5);
  }
  else
  {
    v6 = 0;
  }
  v8 = *(_QWORD *)(v6 + 1);
  v9 = v6[3];
  v10 = (((v9 + 7) >> 3) * v8 + 3) & 0xFFFFFFFC;
  v6[4] = v10;
  if ( v9 == 4 )
    v7 = 64;
  if ( v9 == 8 )
    v7 = 1024;
  v11 = v7 + v10 * HIDWORD(v8);
  v12 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(v11);
  v6[5] = v12;
  if ( v12 )
  {
    v13 = v9 == 8;
    if ( v9 != 8 )
      v13 = v9 == 4;
    if ( v13 )
      v14 = v8 + v10 * HIDWORD(v8);
    else
      v14 = 0;
    v15 = *v6;
    v6[6] = v14;
    *v6 = v15 | 1;
  }
  else
  {
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483629, v11);
    RwErrorSet(&code);
  }
  v16 = length;
  v17 = v6[4];
  if ( v17 == length )
  {
    RwStreamRead(stream, (void *)v6[5], v6[2] * v17);
  }
  else if ( v26 >= 1 )
  {
    v18 = 1;
    v19 = 0;
    while ( 1 )
    {
      v20 = (void *)(v6[5] + v19);
      if ( v17 <= v16 )
      {
        RwStreamRead(stream, v20, v17);
        RwStreamSkip(stream, length - v17);
      }
      else
      {
        RwStreamRead(stream, v20, v16);
      }
      if ( v18 >= v26 )
        break;
      v16 = length;
      v19 += v17;
      ++v18;
    }
  }
  v21 = v6[3];
  if ( v21 <= 8 )
    RwStreamRead(stream, (void *)v6[6], 4 << v21);
  return (RwImage_0 *)v6;
}
// 6BCF04: using guessed type int imageModule;

//----- (001DA238) --------------------------------------------------------
const RwImage_0 *__fastcall RwImageStreamWrite(const RwImage_0 *image, RwStream_0 *stream)
{
  const RwImage_0 *v2; // r4
  RwInt32 *p_height; // r2
  RwInt32 height; // r0
  int v6; // r1
  RwInt32 v7; // r2
  int v8; // r3
  __int64 v9; // d17
  int depth; // r0
  _QWORD mem[3]; // [sp+10h] [bp-28h] BYREF

  v2 = image;
  p_height = &image->height;
  height = image->height;
  v6 = p_height[1];
  v7 = p_height[2];
  v8 = v7 * height;
  if ( v6 < 9 )
    v8 = (4 << v6) + v7 * height;
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 24, v8 + 28, 0x36003u, 0xFFFFu)
    || !_rwStreamWriteVersionedChunkHeader(stream, 1, 16, 0x36003u, 0xFFFFu) )
  {
    return 0;
  }
  v9 = *(_QWORD *)&v2->depth;
  mem[0] = *(_QWORD *)&v2->width;
  mem[1] = v9;
  RwMemLittleEndian32(mem, 0x10u);
  RwStreamWrite(stream, mem, 0x10u);
  RwStreamWrite(stream, v2->cpPixels, v2->stride * v2->height);
  depth = v2->depth;
  if ( depth <= 8 )
    RwStreamWrite(stream, v2->palette, 4 << depth);
  return v2;
}
// 1DA238: using guessed type _QWORD mem[3];

//----- (001DA2EC) --------------------------------------------------------
RwRGBA_0 *__fastcall RwRGBAGammaCorrect(RwRGBA_0 *rgb)
{
  int green; // lr
  int v2; // r2
  int blue; // r4

  green = rgb->_anon_0._anon_0.green;
  v2 = imageModule;
  blue = rgb->_anon_0._anon_0.blue;
  rgb->_anon_0._anon_0.red = *((_BYTE *)RwEngineInstance + imageModule + rgb->_anon_0._anon_0.red + 12);
  rgb->_anon_0._anon_0.green = *((_BYTE *)RwEngineInstance + v2 + green + 12);
  rgb->_anon_0._anon_0.blue = *((_BYTE *)RwEngineInstance + v2 + blue + 12);
  return rgb;
}
// 6BCF04: using guessed type int imageModule;

//----- (001DA330) --------------------------------------------------------
RwImage_0 *__fastcall RwImageGammaCorrect(RwImage_0 *image)
{
  RwInt32 v2; // r0
  RwInt32 depth; // r2
  RwRGBA_0 *palette; // r1
  int v5; // r0
  char *v6; // r2
  int green; // r6
  int blue; // r5
  RwUInt8 *cpPixels; // r11
  RwInt32 height; // r8
  int v11; // r3
  RwInt32 width; // r10
  int v13; // r12
  RwUInt8 *v14; // r6
  char *v15; // r5
  RwInt32 v16; // r2
  int v17; // r0
  int v18; // r1
  RwError_0 code; // [sp+4h] [bp-24h] BYREF

  v2 = -2147483626;
  depth = image->depth;
  if ( depth != 4 )
  {
    if ( depth == 32 )
    {
      cpPixels = image->cpPixels;
      if ( cpPixels )
      {
        height = image->height;
        if ( height >= 1 )
        {
          v11 = 0;
          width = image->width;
          v13 = imageModule;
          do
          {
            if ( width )
            {
              v14 = cpPixels;
              v15 = (char *)RwEngineInstance + v13 + 12;
              v16 = width;
              do
              {
                --v16;
                v17 = v14[1];
                v18 = v14[2];
                *v14 = v15[*v14];
                v14[1] = v15[v17];
                v14[2] = v15[v18];
                v14 += 4;
              }
              while ( v16 );
            }
            ++v11;
            cpPixels += image->stride;
          }
          while ( v11 != height );
        }
        goto LABEL_15;
      }
      goto LABEL_16;
    }
    if ( depth != 8 )
    {
      image = 0;
      v2 = -2147483640;
      goto LABEL_18;
    }
  }
  palette = image->palette;
  if ( !palette )
  {
LABEL_16:
    image = 0;
LABEL_18:
    code.pluginID = 0;
    code.errorCode = _rwerror(v2);
    RwErrorSet(&code);
    return image;
  }
  v5 = 1 << depth;
  v6 = (char *)RwEngineInstance + imageModule + 12;
  do
  {
    --v5;
    green = palette->_anon_0._anon_0.green;
    blue = palette->_anon_0._anon_0.blue;
    palette->_anon_0._anon_0.red = v6[palette->_anon_0._anon_0.red];
    palette->_anon_0._anon_0.green = v6[green];
    palette->_anon_0._anon_0.blue = v6[blue];
    ++palette;
  }
  while ( v5 );
LABEL_15:
  image->flags |= 2u;
  return image;
}
// 6BCF04: using guessed type int imageModule;

//----- (001DA434) --------------------------------------------------------
RwReal RwImageGetGamma()
{
  return *(float *)((char *)RwEngineInstance + imageModule + 524);
}
// 6BCF04: using guessed type int imageModule;

//----- (001DA454) --------------------------------------------------------
RwImage_0 *__fastcall RwImageSetFromRaster(RwImage_0 *image, RwRaster_0 *raster)
{
  RwImage_0 *result; // r0

  result = (RwImage_0 *)(*((int (__fastcall **)(RwImage_0 *, RwRaster_0 *, _DWORD))RwEngineInstance + 24))(
                          image,
                          raster,
                          0);
  if ( result )
    return image;
  return result;
}

//----- (001DA478) --------------------------------------------------------
RwRaster_0 *__fastcall RwRasterSetFromImage(RwRaster_0 *raster, RwImage_0 *image)
{
  RwRaster_0 *result; // r0

  result = (RwRaster_0 *)(*((int (__fastcall **)(RwRaster_0 *, RwImage_0 *, _DWORD))RwEngineInstance + 25))(
                           raster,
                           image,
                           0);
  if ( result )
    return raster;
  return result;
}

//----- (001DA49C) --------------------------------------------------------
RwImage_0 *__fastcall RwImageFindRasterFormat(
        RwImage_0 *ipImage,
        RwInt32 nRasterType,
        RwInt32 *npWidth,
        RwInt32 *npHeight,
        RwInt32 *npDepth,
        RwInt32 *npFormat)
{
  RwImage_0 *v6; // r4
  char v10[12]; // [sp+4h] [bp-44h] BYREF
  RwInt32 v11; // [sp+10h] [bp-38h]
  RwInt32 v12; // [sp+14h] [bp-34h]
  RwInt32 v13; // [sp+18h] [bp-30h]
  unsigned __int8 v14; // [sp+24h] [bp-24h]
  unsigned __int8 v15; // [sp+26h] [bp-22h]

  v6 = ipImage;
  if ( !(*((int (__fastcall **)(char *, RwImage_0 *, RwInt32))RwEngineInstance + 27))(v10, ipImage, nRasterType) )
    return 0;
  *npFormat = v14 | (v15 << 8);
  *npWidth = v11;
  *npHeight = v12;
  *npDepth = v13;
  return v6;
}
// 1DA49C: using guessed type char var_44[12];

//----- (001DA4F0) --------------------------------------------------------
RwRGBA_0 *__fastcall RwRGBAGetRasterPixel(RwRGBA_0 *rgbOut, RwRaster_0 *raster, RwInt32 x, RwInt32 y)
{
  RwRGBA_0 *v8; // r6
  RwRaster_0 *v9; // r0
  RwRaster_0 *v10; // r5
  RwImage_0 *v11; // r0
  RwImage_0 *v12; // r4
  RwRect_0 v14; // [sp+0h] [bp-28h] BYREF

  v8 = 0;
  v9 = RwRasterCreate(0, 0, 0, 0);
  v10 = v9;
  if ( v9 )
  {
    v14.x = x;
    v14.y = y;
    v14.w = 1;
    v14.h = 1;
    if ( RwRasterSubRaster(v9, raster, &v14) && (v11 = RwImageCreate(1, 1, 32), (v12 = v11) != 0) )
    {
      v11->cpPixels = (RwUInt8 *)rgbOut;
      (*((void (__fastcall **)(RwImage_0 *, RwRaster_0 *, _DWORD))RwEngineInstance + 24))(v11, v10, 0);
      RwImageDestroy(v12);
      RwRasterDestroy(v10);
      return rgbOut;
    }
    else
    {
      RwRasterDestroy(v10);
      return 0;
    }
  }
  return v8;
}

//----- (001DA574) --------------------------------------------------------
RwRaster_0 *__fastcall RwRasterRead(const RwChar *filename)
{
  RwInt32 v1; // r6
  RwInt32 v2; // r8
  int v3; // r9
  RwInt32 v4; // r10
  RwImage_0 *v5; // r0
  RwImage_0 *v6; // r4
  RwInt32 width; // r2
  bool v8; // zf
  RwImage_0 *Resample; // r5
  RwRaster_0 *v10; // r0
  RwRaster_0 *v11; // r4
  char v13[12]; // [sp+4h] [bp-4Ch] BYREF
  RwInt32 v14; // [sp+10h] [bp-40h]
  RwInt32 v15; // [sp+14h] [bp-3Ch]
  RwInt32 v16; // [sp+18h] [bp-38h]
  unsigned __int8 v17; // [sp+24h] [bp-2Ch]
  unsigned __int8 v18; // [sp+26h] [bp-2Ah]

  v5 = RwImageRead(filename);
  v6 = v5;
  if ( !v5 )
    return 0;
  if ( !(*((int (__fastcall **)(char *, RwImage_0 *, _DWORD))RwEngineInstance + 27))(v13, v5, 0) )
    goto LABEL_7;
  v1 = v14;
  v4 = v15;
  width = v6->width;
  v2 = v16;
  v8 = v14 == width;
  v3 = v17 | (v18 << 8);
  if ( v14 == width )
    v8 = v15 == v6->height;
  if ( v8 )
  {
LABEL_7:
    Resample = v6;
  }
  else
  {
    Resample = RwImageCreateResample(v6, v14, v15);
    RwImageDestroy(v6);
  }
  v10 = RwRasterCreate(v1, v4, v2, v3);
  v11 = v10;
  if ( !v10 )
  {
    RwImageDestroy(Resample);
    return 0;
  }
  (*((void (__fastcall **)(RwRaster_0 *, RwImage_0 *, _DWORD))RwEngineInstance + 25))(v10, Resample, 0);
  RwImageDestroy(Resample);
  return v11;
}
// 1DA5D8: variable 'v1' is possibly undefined
// 1DA5D8: variable 'v4' is possibly undefined
// 1DA5D8: variable 'v2' is possibly undefined
// 1DA5D8: variable 'v3' is possibly undefined
// 1DA574: using guessed type char var_4C[12];

//----- (001DA614) --------------------------------------------------------
RwRaster_0 *__fastcall RwRasterReadMaskedRaster(const RwChar *filename, const RwChar *maskname)
{
  RwImage_0 *MaskedImage; // r0
  RwImage_0 *v3; // r4
  RwRaster_0 *v4; // r0
  RwRaster_0 *v5; // r5

  MaskedImage = RwImageReadMaskedImage(filename, maskname);
  v3 = MaskedImage;
  if ( MaskedImage )
  {
    v4 = RwRasterCreate(MaskedImage->width, MaskedImage->height, 0, 0);
    v5 = v4;
    if ( v4 )
    {
      (*((void (__fastcall **)(RwRaster_0 *, RwImage_0 *, _DWORD))RwEngineInstance + 25))(v4, v3, 0);
      RwImageDestroy(v3);
      return v5;
    }
    RwImageDestroy(v3);
  }
  return 0;
}

//----- (001DA65C) --------------------------------------------------------
RwInt32 __fastcall RwRasterGetPluginOffset(RwUInt32 pluginID)
{
  return sub_18F574(&rasterTKList, pluginID);
}

//----- (001DA66C) --------------------------------------------------------
RwRaster_0 *RwRasterGetCurrentContext()
{
  return *(RwRaster_0 **)((char *)RwEngineInstance
                        + 4 * *(_DWORD *)((char *)RwEngineInstance + rasterModule + 40)
                        + rasterModule);
}
// 6BCF30: using guessed type int rasterModule;

//----- (001DA68C) --------------------------------------------------------
RwRaster_0 *__fastcall RwRasterRenderScaled(RwRaster_0 *raster, RwRect_0 *rect)
{
  (*((void (__fastcall **)(RwRaster_0 *, RwRect_0 *, _DWORD))RwEngineInstance + 36))(raster, rect, 0);
  return raster;
}

//----- (001DA6AC) --------------------------------------------------------
RwRaster_0 *__fastcall RwRasterGetOffset(RwRaster_0 *raster, RwInt16 *xOffset, RwInt16 *yOffset)
{
  *xOffset = raster->nOffsetX;
  *yOffset = raster->nOffsetY;
  return raster;
}

//----- (001DA6B8) --------------------------------------------------------
RwRaster_0 *__fastcall RwRasterUnlock(RwRaster_0 *raster)
{
  (*((void (__fastcall **)(_DWORD, RwRaster_0 *, _DWORD))RwEngineInstance + 34))(0, raster, 0);
  return raster;
}

//----- (001DA6DC) --------------------------------------------------------
RwBool __fastcall RwRasterClear(RwInt32 pixelValue)
{
  RwBool v1; // r4
  int v2; // r3
  RwError_0 v4; // [sp+0h] [bp-10h] BYREF

  v1 = 0;
  v2 = *(_DWORD *)((char *)RwEngineInstance + rasterModule + 40);
  if ( v2 > 0 )
    v1 = 1;
  if ( v2 < 1 )
  {
    v4.pluginID = 0;
    v4.errorCode = _rwerror(21);
    RwErrorSet(&v4);
  }
  else
  {
    (*((void (__fastcall **)(_DWORD, _DWORD, RwInt32))RwEngineInstance + 32))(0, 0, pixelValue);
  }
  return v1;
}
// 6BCF30: using guessed type int rasterModule;

//----- (001DA730) --------------------------------------------------------
RwBool __fastcall RwRasterValidatePlugins(const RwRaster_0 *raster)
{
  return 1;
}

//----- (001DA734) --------------------------------------------------------
RwRaster_0 *__fastcall RwRasterRenderFast(RwRaster_0 *raster, RwInt32 x, RwInt32 y)
{
  _DWORD v5[6]; // [sp+0h] [bp-18h] BYREF

  v5[0] = x;
  v5[1] = y;
  (*((void (__fastcall **)(RwRaster_0 *, _DWORD *, _DWORD))RwEngineInstance + 37))(raster, v5, 0);
  return raster;
}
// 1DA734: using guessed type _DWORD var_18[6];

//----- (001DA760) --------------------------------------------------------
RwBool __fastcall RwRasterClearRect(RwRect_0 *rect, RwInt32 pixelValue)
{
  (*((void (__fastcall **)(_DWORD, RwRect_0 *, RwInt32))RwEngineInstance + 31))(0, rect, pixelValue);
  return 1;
}

//----- (001DA780) --------------------------------------------------------
RwRaster_0 *__fastcall RwRasterRender(RwRaster_0 *raster, RwInt32 x, RwInt32 y)
{
  _DWORD v5[6]; // [sp+0h] [bp-18h] BYREF

  v5[0] = x;
  v5[1] = y;
  (*((void (__fastcall **)(RwRaster_0 *, _DWORD *, _DWORD))RwEngineInstance + 35))(raster, v5, 0);
  return raster;
}
// 1DA780: using guessed type _DWORD var_18[6];

//----- (001DA7AC) --------------------------------------------------------
RwRaster_0 *__fastcall RwRasterUnlockPalette(RwRaster_0 *raster)
{
  (*((void (__fastcall **)(_DWORD, RwRaster_0 *, _DWORD))RwEngineInstance + 42))(0, raster, 0);
  return raster;
}

//----- (001DA7D0) --------------------------------------------------------
RwBool __fastcall RwRasterDestroy(RwRaster_0 *raster)
{
  _rwPluginRegistryDeInitObject(&rasterTKList, raster);
  (*((void (__fastcall **)(_DWORD, RwRaster_0 *, _DWORD))RwEngineInstance + 23))(0, raster, 0);
  (*((void (__fastcall **)(_DWORD, RwRaster_0 *))RwEngineInstance + 80))(
    *(_DWORD *)((char *)RwEngineInstance + rasterModule + 96),
    raster);
  return 1;
}
// 6BCF30: using guessed type int rasterModule;

//----- (001DA818) --------------------------------------------------------
RwRaster_0 *__fastcall RwRasterPushContext(RwRaster_0 *raster)
{
  RwRaster_0 *v2; // r5
  int v3; // r1
  int v4; // r3

  v2 = 0;
  if ( (*((int (__fastcall **)(_DWORD, RwRaster_0 *, _DWORD))RwEngineInstance + 29))(0, raster, 0) )
  {
    v2 = raster;
    v3 = rasterModule;
    v4 = *(_DWORD *)((char *)RwEngineInstance + rasterModule + 40) + 1;
    *(_DWORD *)((char *)RwEngineInstance + rasterModule + 40) = v4;
    *(_DWORD *)((char *)RwEngineInstance + 4 * v4 + v3) = raster;
  }
  return v2;
}
// 6BCF30: using guessed type int rasterModule;

//----- (001DA864) --------------------------------------------------------
RwInt32 __fastcall RwRasterRegisterPlugin(
        RwInt32 size,
        RwUInt32 pluginID,
        RwPluginObjectConstructor constructCB,
        RwPluginObjectDestructor destructCB,
        RwPluginObjectCopy copyCB)
{
  return _rwPluginRegistryAddPlugin(&rasterTKList, size, pluginID, constructCB, destructCB, copyCB);
}

//----- (001DA88C) --------------------------------------------------------
RwUInt8 *__fastcall RwRasterLockPalette(RwRaster_0 *raster, RwInt32 lockMode)
{
  RwUInt8 *result; // r0
  RwUInt8 *v3; // [sp+4h] [bp-Ch] BYREF

  result = (RwUInt8 *)(*((int (__fastcall **)(RwUInt8 **, RwRaster_0 *, RwInt32))RwEngineInstance + 41))(
                        &v3,
                        raster,
                        lockMode);
  if ( result )
    return v3;
  return result;
}

//----- (001DA8B8) --------------------------------------------------------
RwRaster_0 *RwRasterPopContext()
{
  int v0; // r1
  int v1; // r3
  char *v2; // r1
  int v3; // r4
  RwRaster_0 *result; // r0

  v0 = rasterModule;
  v1 = *(_DWORD *)((char *)RwEngineInstance + rasterModule + 40);
  *(_DWORD *)((char *)RwEngineInstance + rasterModule + 40) = v1 - 1;
  v2 = (char *)RwEngineInstance + v0;
  v3 = *(_DWORD *)&v2[4 * v1];
  result = (RwRaster_0 *)(*((int (__fastcall **)(_DWORD, _DWORD, _DWORD))RwEngineInstance + 29))(
                           0,
                           *(_DWORD *)&v2[4 * *((_DWORD *)v2 + 10)],
                           0);
  if ( result )
    return (RwRaster_0 *)v3;
  return result;
}
// 6BCF30: using guessed type int rasterModule;

//----- (001DA900) --------------------------------------------------------
RwInt32 __fastcall RwRasterGetNumLevels(RwRaster_0 *raster)
{
  RwInt32 result; // r0
  int v2; // r1
  RwInt32 v3; // [sp+4h] [bp-Ch] BYREF

  if ( (char)raster->cFormat > -1 )
    return 1;
  v2 = (*((int (__fastcall **)(RwInt32 *, RwRaster_0 *, _DWORD))RwEngineInstance + 46))(&v3, raster, 0);
  result = v3;
  if ( !v2 )
    return -1;
  return result;
}

//----- (001DA93C) --------------------------------------------------------
RwRaster_0 *__fastcall RwRasterShowRaster(RwRaster_0 *raster, void *dev, RwUInt32 flags)
{
  int (__fastcall *v6)(RwRaster_0 *, void *, RwUInt32); // r4
  RwRaster_0 *result; // r0

  v6 = (int (__fastcall *)(RwRaster_0 *, void *, RwUInt32))*((_DWORD *)RwEngineInstance + 38);
  _rwResourcesPurge();
  result = (RwRaster_0 *)v6(raster, dev, flags);
  if ( result )
    return raster;
  return result;
}

//----- (001DA974) --------------------------------------------------------
RwRaster_0 *__fastcall RwRasterSubRaster(RwRaster_0 *subRaster, RwRaster_0 *raster, RwRect_0 *rect)
{
  RwRaster_0 *v5; // r6

  if ( (char)subRaster->cFlags > -1 )
    return 0;
  v5 = 0;
  subRaster->width = rect->w;
  subRaster->height = rect->h;
  subRaster->nOffsetX = raster->nOffsetX + rect->x;
  subRaster->nOffsetY = raster->nOffsetY + rect->y;
  if ( (*((int (__fastcall **)(RwRaster_0 *, RwRaster_0 *, _DWORD))RwEngineInstance + 30))(subRaster, raster, 0) )
  {
    subRaster->parent = raster->parent;
    return subRaster;
  }
  return v5;
}

//----- (001DA9D0) --------------------------------------------------------
RwRaster_0 *__fastcall RwRasterCreate(RwInt32 width, RwInt32 height, RwInt32 depth, RwInt32 flags)
{
  RwRaster_0 *v8; // r4
  RwRaster_0 *result; // r0
  int (__fastcall *v10)(_DWORD, RwRaster_0 *, RwInt32); // r3

  v8 = (RwRaster_0 *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                       + rasterModule
                                                                                       + 96));
  result = 0;
  if ( v8 )
  {
    v10 = (int (__fastcall *)(_DWORD, RwRaster_0 *, RwInt32))*((_DWORD *)RwEngineInstance + 22);
    v8->cFlags = 0;
    v8->privateFlags = 0;
    *(_DWORD *)&v8->nOffsetX = 0;
    v8->dbEntry = 0;
    v8->parent = v8;
    v8->cpPixels = 0;
    v8->palette = 0;
    v8->width = width;
    v8->height = height;
    v8->depth = depth;
    if ( v10(0, v8, flags) )
    {
      _rwPluginRegistryInitObject(&rasterTKList, v8);
      return v8;
    }
    else
    {
      (*((void (__fastcall **)(_DWORD, RwRaster_0 *))RwEngineInstance + 80))(
        *(_DWORD *)((char *)RwEngineInstance + rasterModule + 96),
        v8);
      return 0;
    }
  }
  return result;
}
// 6BCF30: using guessed type int rasterModule;

//----- (001DAA74) --------------------------------------------------------
RwUInt8 *__fastcall RwRasterLock(RwRaster_0 *raster, RwUInt8 level, RwInt32 lockMode)
{
  RwUInt8 *result; // r0
  RwUInt8 *v4; // [sp+4h] [bp-Ch] BYREF

  result = (RwUInt8 *)(*((int (__fastcall **)(RwUInt8 **, RwRaster_0 *, int))RwEngineInstance + 33))(
                        &v4,
                        raster,
                        lockMode + (level << 8));
  if ( result )
    return v4;
  return result;
}

//----- (001DAAA4) --------------------------------------------------------
void *__fastcall _rwRasterClose(void *instance, RwInt32 offset, RwInt32 size)
{
  RwFreeList_0 *v4; // r0

  v4 = *(RwFreeList_0 **)((char *)RwEngineInstance + rasterModule + 96);
  if ( v4 )
  {
    RwFreeListDestroy(v4);
    *(_DWORD *)((char *)RwEngineInstance + rasterModule + 96) = 0;
  }
  --rasterModule;
  return instance;
}
// 6BCF30: using guessed type int rasterModule;
// 6BCF34: using guessed type int rasterModule;

//----- (001DAAF8) --------------------------------------------------------
void __fastcall RwRasterSetFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rwRasterFreeListPreallocBlocks = numBlocksToPrealloc;
  _rwRasterFreeListBlockSize = blockSize;
}

//----- (001DAB10) --------------------------------------------------------
void *__fastcall _rwRasterOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  void *v4; // r5
  char *v5; // r0
  _QWORD *v6; // r2
  _QWORD *v7; // r2
  RwFreeList_0 *v8; // r0
  int v9; // r1

  v4 = 0;
  rasterModule = offset;
  v5 = (char *)RwEngineInstance + offset;
  v6 = (char *)RwEngineInstance + offset + 76;
  *((_DWORD *)v5 + 23) = 0;
  *v6 = 0LL;
  v6[1] = 0LL;
  v7 = v5 + 60;
  v5 += 44;
  *v7 = 0LL;
  v7[1] = 0LL;
  *(_QWORD *)v5 = 0LL;
  *((_QWORD *)v5 + 1) = 0LL;
  *(_DWORD *)((char *)RwEngineInstance + offset + 56) = 0;
  *(_DWORD *)((char *)RwEngineInstance + offset + 60) = 0;
  *(_DWORD *)((char *)RwEngineInstance + offset + 64) = 0;
  *((_BYTE *)RwEngineInstance + offset + 77) = 0x80;
  *(_DWORD *)((char *)RwEngineInstance + offset + 48) = 0;
  *(_DWORD *)((char *)RwEngineInstance + offset + 52) = 0;
  *((_BYTE *)RwEngineInstance + offset + 76) = 0;
  *(_DWORD *)((char *)RwEngineInstance + offset + 40) = 0;
  *(_DWORD *)((char *)RwEngineInstance + offset) = (char *)RwEngineInstance + offset + 44;
  v8 = RwFreeListCreateAndPreallocateSpace(
         rasterTKList.sizeOfStruct,
         _rwRasterFreeListBlockSize,
         4,
         _rwRasterFreeListPreallocBlocks,
         &_rwRasterFreeList);
  v9 = rasterModule;
  *(_DWORD *)((char *)RwEngineInstance + rasterModule + 96) = v8;
  if ( *(_DWORD *)((char *)RwEngineInstance + v9 + 96) )
  {
    v4 = instance;
    ++rasterModule;
  }
  return v4;
}
// 6BCF30: using guessed type int rasterModule;
// 6BCF34: using guessed type int rasterModule;

//----- (001DAC00) --------------------------------------------------------
RwImage_0 *__fastcall RwImageResample(RwImage_0 *dstImage, const RwImage_0 *srcImage)
{
  RwRGBAReal_0 v2; // q0
  RwInt32 width; // r5
  RwInt32 height; // r3
  float v6; // s18
  float32x4_t v7; // q7
  int v8; // r10
  RwFixed v9; // r4
  signed int v10; // r2
  int v11; // r8
  RwFixed v12; // r6
  RwFixed v13; // r1
  RwRGBAReal_0 v14; // q5
  RwFixed v15; // r5
  float32x4_t v16; // q7
  float v17; // s0
  float32x4_t v18; // q8
  RwUInt8 *v19; // r0
  int v21; // [sp+Ch] [bp-ECh]
  RwReal red; // [sp+14h] [bp-E4h]
  RwInt32 v24; // [sp+18h] [bp-E0h]
  int v25; // [sp+1Ch] [bp-DCh]
  float32x4_t v26; // [sp+20h] [bp-D8h]
  RwInt32 v27; // [sp+3Ch] [bp-BCh]
  float32x4_t v28; // [sp+40h] [bp-B8h]
  int v29; // [sp+50h] [bp-A8h]
  RwReal blue; // [sp+60h] [bp-98h]
  RwUInt8 *v31; // [sp+68h] [bp-90h]
  int _nY; // [sp+6Ch] [bp-8Ch]
  RwRGBAReal_0 _rrpCol; // [sp+70h] [bp-88h] BYREF
  float32x4_t v34; // [sp+80h] [bp-78h] BYREF

  width = dstImage->width;
  height = dstImage->height;
  LODWORD(v2.red) = (int)(float)((float)((float)srcImage->height / (float)height) * 65536.0);
  LODWORD(v2.blue) = (int)(float)((float)((float)srcImage->width / (float)width) * 65536.0);
  dstImage->flags |= srcImage->flags & 2;
  v24 = height;
  if ( height >= 1 )
  {
    blue = v2.blue;
    red = v2.red;
    v21 = LODWORD(v2.red) - 1;
    v25 = 0;
    v27 = width;
    _nY = 0;
    v2.red = (float)(LODWORD(v2.red) - 1) * 0.000015259;
    v6 = 1.0 / v2.red;
    v7 = vdupq_lane_s32(*(int32x2_t *)&v2.red, 0);
    v26 = v7;
    do
    {
      if ( width >= 1 )
      {
        v8 = 0;
        v9 = 0;
        v31 = &dstImage->cpPixels[dstImage->stride * v25];
        v10 = (_nY & 0xFFFF0000) + 0x10000;
        v11 = (v21 + _nY) >> 16;
        v29 = v10 >> 16;
        v2.red = (float)(v10 - _nY) * 0.000015259;
        v28 = vdupq_lane_s32(*(int32x2_t *)&v2.red, 0);
        do
        {
          v12 = v9 + LODWORD(blue) - 1;
          if ( _nY >> 16 == v11 )
          {
            v13 = v9;
            v9 += LODWORD(blue);
            ImageResampleGetSpan(srcImage, v13, v12, _nY, &_rrpCol);
            v2 = (RwRGBAReal_0)vmulq_f32(v7, (float32x4_t)_rrpCol);
          }
          else
          {
            ImageResampleGetSpan(srcImage, v9, v9 + LODWORD(blue) - 1, _nY, &_rrpCol);
            v14 = (RwRGBAReal_0)vmulq_f32(v28, (float32x4_t)_rrpCol);
            _rrpCol = v14;
            v15 = (_nY & 0xFFFF0000) + 0x10000;
            ImageResampleGetSpan(srcImage, v9, v12, v15, (RwRGBAReal_0 *)&v34);
            if ( v29 != v11 )
            {
              do
              {
                v15 += 0x10000;
                v16 = v34;
                ImageResampleGetSpan(srcImage, v9, v12, v15, (RwRGBAReal_0 *)&v34);
                v14 = (RwRGBAReal_0)vaddq_f32(v16, (float32x4_t)v14);
              }
              while ( v11 != v15 >> 16 );
              v7 = v26;
              _rrpCol = v14;
            }
            v9 += LODWORD(blue);
            v17 = (float)(v21 + _nY - v15);
            width = v27;
            v18 = vmulq_n_f32(v34, v17 * 0.000015259);
            v2 = (RwRGBAReal_0)vaddq_f32(v18, (float32x4_t)v14);
            *(_DWORD *)((unsigned int)&v34 | 8) = v18.n128_u32[2];
            v34.n128_u64[0] = v18.n128_u64[0];
          }
          _rrpCol = v2;
          v31[4 * v8] = (int)(float)((float)((float)(v6 * v2.red) * 255.0) + 0.5);
          v19 = &v31[4 * v8++];
          v19[1] = (int)(float)((float)((float)(v6 * v2.green) * 255.0) + 0.5);
          v19[2] = (int)(float)((float)((float)(v6 * v2.blue) * 255.0) + 0.5);
          v19[3] = (int)(float)((float)((float)(v6 * v2.alpha) * 255.0) + 0.5);
        }
        while ( v8 != width );
      }
      _nY += LODWORD(red);
      ++v25;
    }
    while ( v25 != v24 );
  }
  return dstImage;
}
// 1DACBC: variable 'v2' is possibly undefined
// 1DAC00: using guessed type float32x4_t var_78;

//----- (001DAE90) --------------------------------------------------------
RwImage_0 *__fastcall RwImageCreateResample(const RwImage_0 *srcImage, RwInt32 width, RwInt32 height)
{
  RwImage_0 *v4; // r0
  RwImage_0 *v5; // r4
  RwImage_0 *v6; // r0
  RwImage_0 *v7; // r6

  v4 = RwImageCreate(width, height, 32);
  v5 = v4;
  if ( !v4 )
    return 0;
  if ( !RwImageAllocatePixels(v4) )
  {
LABEL_12:
    RwImageDestroy(v5);
    return 0;
  }
  if ( srcImage->depth != 32 )
  {
    v6 = RwImageCreate(srcImage->width, srcImage->height, 32);
    v7 = v6;
    if ( v6 )
    {
      if ( RwImageAllocatePixels(v6) )
      {
        RwImageCopy(v7, srcImage);
        RwImageResample(v5, v7);
        RwImageFreePixels(v7);
        RwImageDestroy(v7);
        if ( !v5 )
          goto LABEL_11;
        return v5;
      }
      RwImageDestroy(v7);
    }
LABEL_11:
    RwImageFreePixels(v5);
    goto LABEL_12;
  }
  RwImageResample(v5, srcImage);
  if ( !v5 )
    goto LABEL_11;
  return v5;
}

//----- (001DAF20) --------------------------------------------------------
void __fastcall ImageResampleGetSpan(
        const RwImage_0 *_image,
        RwFixed _nStartX,
        RwFixed _nEndX,
        RwFixed _nY,
        RwRGBAReal_0 *_rrpCol)
{
  uint8x8_t v5; // d18
  RwFixed v6; // r6
  __int64 v7; // kr00_8
  int v8; // r4
  float v9; // s0
  int v10; // r5
  RwReal *p_alpha; // r12
  RwReal *p_blue; // lr
  RwReal *p_green; // r11
  RwReal v14; // s2
  RwReal v15; // s6
  RwReal v16; // s8
  RwRGBAReal_0 v17; // q1
  float32x4_t v18; // q1
  int v19; // r4
  RwRGBAReal_0 v20; // q8
  float32x4_t v21; // q10
  float32x4_t v22; // q9
  unsigned __int32 *v23; // r5
  unsigned __int32 v24; // t1
  float v25; // s0

  v6 = _nStartX >> 16;
  v7 = *(_QWORD *)&_image->stride;
  v8 = HIDWORD(v7) + v7 * (_nY >> 16);
  v9 = (float)(_nEndX - _nStartX) * 0.000015259;
  v10 = v8 + 4 * (_nStartX >> 16);
  if ( _nStartX >> 16 == _nEndX >> 16 )
  {
    p_alpha = &_rrpCol->alpha;
    p_blue = &_rrpCol->blue;
    p_green = &_rrpCol->green;
    v14 = (float)*(unsigned __int8 *)(v8 + 4 * v6) * 0.0039216;
    _rrpCol->red = v14;
    v15 = (float)*(unsigned __int8 *)(v10 + 1) * 0.0039216;
    _rrpCol->green = v15;
    v16 = (float)*(unsigned __int8 *)(v10 + 2) * 0.0039216;
    _rrpCol->blue = v16;
    v17.green = v9 * v15;
    v17.red = v9 * v14;
    v17.blue = v9 * v16;
    v17.alpha = v9 * (float)((float)*(unsigned __int8 *)(v10 + 3) * 0.0039216);
    _rrpCol->red = v9 * v14;
    _rrpCol->green = v17.green;
    _rrpCol->blue = v9 * v16;
    _rrpCol->alpha = v17.alpha;
  }
  else
  {
    p_alpha = &_rrpCol->alpha;
    p_blue = &_rrpCol->blue;
    p_green = &_rrpCol->green;
    v18.n128_f32[0] = (float)*(unsigned __int8 *)(v8 + 4 * v6) * 0.0039216;
    LODWORD(_rrpCol->red) = v18.n128_u32[0];
    v18.n128_f32[1] = (float)*(unsigned __int8 *)(v10 + 1) * 0.0039216;
    LODWORD(_rrpCol->green) = v18.n128_u32[1];
    v18.n128_f32[2] = (float)*(unsigned __int8 *)(v10 + 2) * 0.0039216;
    LODWORD(_rrpCol->blue) = v18.n128_u32[2];
    v19 = (v6 << 16) + 0x10000;
    v18.n128_f32[3] = (float)*(unsigned __int8 *)(v10 + 3) * 0.0039216;
    v20 = (RwRGBAReal_0)vmulq_n_f32(v18, (float)(v19 - _nStartX) * 0.000015259);
    *_rrpCol = v20;
    v5.n64_u32[0] = *(_DWORD *)(v10 + 4);
    v21.n128_u64[0] = 0x3B8080813B808081LL;
    v21.n128_u64[1] = 0x3B8080813B808081LL;
    v22 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vmovl_u8(v5).n128_u64[0])), v21);
    if ( _nEndX >> 16 != v19 >> 16 )
    {
      v23 = (unsigned __int32 *)(v7 * (_nY >> 16) + 4 * v6 + HIDWORD(v7) + 8);
      do
      {
        v20 = (RwRGBAReal_0)vaddq_f32(v22, (float32x4_t)v20);
        v19 += 0x10000;
        *_rrpCol = v20;
        v24 = *v23++;
        v22.n128_u32[0] = v24;
        v22 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vmovl_u8((uint8x8_t)v22.n128_u64[0]).n128_u64[0])), v21);
      }
      while ( _nEndX >> 16 != v19 >> 16 );
    }
    v17 = (RwRGBAReal_0)vaddq_f32(vmulq_n_f32(v22, (float)(_nEndX - v19) * 0.000015259), (float32x4_t)v20);
    *_rrpCol = v17;
  }
  v25 = 1.0 / v9;
  _rrpCol->red = v25 * v17.red;
  *p_green = v25 * v17.green;
  *p_blue = v25 * v17.blue;
  *p_alpha = v25 * v17.alpha;
}
// 1DB048: variable 'v5' is possibly undefined

//----- (001DB108) --------------------------------------------------------
RwBool _rwFrameSyncDirty()
{
  _DWORD *v0; // r0
  char *v1; // r4
  char *v2; // r8
  char v3; // r10
  void (__fastcall **j)(int); // r5
  __int64 v5; // d16
  __int64 v6; // d17
  __int64 v7; // d18
  __int64 v8; // d19
  __int64 v9; // d20
  __int64 v10; // d21
  __int64 v11; // d23
  void (__fastcall **i)(int); // r5
  char *v13; // r0

  v0 = RwEngineInstance;
  v2 = (char *)RwEngineInstance + 188;
  v1 = (char *)*((_DWORD *)RwEngineInstance + 47);
  if ( v1 != (char *)RwEngineInstance + 188 )
  {
    do
    {
      v3 = *(v1 - 5);
      if ( (v3 & 1) != 0 )
      {
        if ( (*(v1 - 5) & 4) != 0 )
        {
          v5 = *((_QWORD *)v1 + 5);
          v6 = *((_QWORD *)v1 + 6);
          v7 = *((_QWORD *)v1 + 3);
          v8 = *((_QWORD *)v1 + 4);
          v9 = *((_QWORD *)v1 + 1);
          v10 = *((_QWORD *)v1 + 2);
          v11 = *((_QWORD *)v1 + 8);
          *((_QWORD *)v1 + 15) = *((_QWORD *)v1 + 7);
          *((_QWORD *)v1 + 16) = v11;
          *((_QWORD *)v1 + 13) = v5;
          *((_QWORD *)v1 + 14) = v6;
          *((_QWORD *)v1 + 11) = v7;
          *((_QWORD *)v1 + 12) = v8;
          *((_QWORD *)v1 + 9) = v9;
          *((_QWORD *)v1 + 10) = v10;
        }
        for ( i = (void (__fastcall **)(int))*((_DWORD *)v1 + 34);
              i != (void (__fastcall **)(int))(v1 + 136);
              i = (void (__fastcall **)(int))*i )
        {
          i[2]((int)(i - 2));
        }
        FrameSyncHierarchyRecurse(*((RwFrame_0 **)v1 + 36), v3 & 4);
      }
      else
      {
        for ( j = (void (__fastcall **)(int))*((_DWORD *)v1 + 34);
              j != (void (__fastcall **)(int))(v1 + 136);
              j = (void (__fastcall **)(int))*j )
        {
          j[2]((int)(j - 2));
        }
        FrameSyncHierarchyRecurseNoLTM(*((RwFrame_0 **)v1 + 36));
      }
      v13 = *(char **)v1;
      *(v1 - 5) = v3 & 0xF0;
      v1 = v13;
    }
    while ( v13 != v2 );
    v0 = RwEngineInstance;
  }
  v0[47] = v0 + 47;
  v0[48] = v0 + 47;
  return 1;
}

//----- (001DB1E8) --------------------------------------------------------
void __fastcall _rwFrameSyncHierarchyLTM(RwFrame_0 *frame)
{
  RwInt32 privateFlags; // r5
  __int64 v3; // d16
  __int64 v4; // d17
  __int64 v5; // d18
  __int64 v6; // d19
  __int64 v7; // d20
  __int64 v8; // d21
  __int64 v9; // d23

  privateFlags = frame->object.privateFlags;
  if ( (privateFlags & 4) != 0 )
  {
    v3 = *(_QWORD *)&frame->modelling.at.x;
    v4 = *(_QWORD *)&frame->modelling.at.z;
    v5 = *(_QWORD *)&frame->modelling.up.x;
    v6 = *(_QWORD *)&frame->modelling.up.z;
    v7 = *(_QWORD *)&frame->modelling.right.x;
    v8 = *(_QWORD *)&frame->modelling.right.z;
    v9 = *(_QWORD *)&frame->modelling.pos.z;
    *(_QWORD *)&frame->ltm.pos.x = *(_QWORD *)&frame->modelling.pos.x;
    *(_QWORD *)&frame->ltm.pos.z = v9;
    *(_QWORD *)&frame->ltm.at.x = v3;
    *(_QWORD *)&frame->ltm.at.z = v4;
    *(_QWORD *)&frame->ltm.up.x = v5;
    *(_QWORD *)&frame->ltm.up.z = v6;
    *(_QWORD *)&frame->ltm.right.x = v7;
    *(_QWORD *)&frame->ltm.right.z = v8;
  }
  FrameSyncHierarchyLTMRecurse(frame->child, privateFlags);
  frame->object.privateFlags = privateFlags & 0xFA;
}

//----- (001DB248) --------------------------------------------------------
void __fastcall FrameSyncHierarchyLTMRecurse(RwFrame_0 *frame, RwInt32 flags)
{
  RwFrame_0 *i; // r5
  int v4; // r6

  for ( i = frame; i; i = i->next )
  {
    v4 = i->object.privateFlags | flags;
    if ( (v4 & 4) != 0 )
    {
      RwMatrixMultiply(&i->ltm, &i->modelling, (const RwMatrix *)((char *)i->object.parent + 80));
      i->object.privateFlags &= ~4u;
    }
    FrameSyncHierarchyLTMRecurse(i->child, v4);
  }
}

//----- (001DB294) --------------------------------------------------------
void __fastcall FrameSyncHierarchyRecurse(RwFrame_0 *frame, RwInt32 flags)
{
  RwFrame_0 *i; // r4
  RwFrame_0 *child; // r0
  int v5; // r9
  RwLLLink *j; // r6

  for ( i = frame; i; i = i->next )
  {
    v5 = i->object.privateFlags | flags;
    if ( (v5 & 4) != 0 )
      RwMatrixMultiply(&i->ltm, &i->modelling, (const RwMatrix *)((char *)i->object.parent + 80));
    for ( j = i->objectList.link.next; j != (RwLLLink *)&i->objectList; j = j->next )
      ((void (__fastcall *)(RwLLLink *))j[1].next)(&j[-1]);
    child = i->child;
    i->object.privateFlags &= 0xF3u;
    FrameSyncHierarchyRecurse(child, v5);
  }
}

//----- (001DB2F8) --------------------------------------------------------
void __fastcall FrameSyncHierarchyRecurseNoLTM(RwFrame_0 *frame)
{
  RwFrame_0 *i; // r4
  RwFrame_0 *child; // r0
  RwLLLink *j; // r6

  for ( i = frame; i; i = i->next )
  {
    for ( j = i->objectList.link.next; j != (RwLLLink *)&i->objectList; j = j->next )
      ((void (__fastcall *)(RwLLLink *))j[1].next)(&j[-1]);
    child = i->child;
    i->object.privateFlags &= ~8u;
    FrameSyncHierarchyRecurseNoLTM(child);
  }
}

//----- (001DB33C) --------------------------------------------------------
RwBool __fastcall TextureAnnihilate(RwTexture_0 *texture)
{
  ++texture->refCount;
  _rwPluginRegistryDeInitObject(&textureTKList, texture);
  if ( texture->dict )
  {
    texture->lInDictionary.prev->next = texture->lInDictionary.next;
    texture->lInDictionary.next->prev = texture->lInDictionary.prev;
  }
  if ( texture->raster )
  {
    RwRasterDestroy(texture->raster);
    texture->raster = 0;
  }
  --texture->refCount;
  (*((void (__fastcall **)(_DWORD, RwTexture_0 *))RwEngineInstance + 80))(
    *(_DWORD *)((char *)RwEngineInstance + textureModule + 8),
    texture);
  return 1;
}
// 6BCF84: using guessed type int textureModule;

//----- (001DB3A4) --------------------------------------------------------
RwBool __fastcall RwTextureSetFindCallBack(RwTextureCallBackFind callBack)
{
  *(_DWORD *)((char *)RwEngineInstance + textureModule + 24) = callBack;
  return 1;
}
// 6BCF84: using guessed type int textureModule;

//----- (001DB3C4) --------------------------------------------------------
RwTextureCallBackFind RwTextureGetFindCallBack()
{
  return *(RwTextureCallBackFind *)((char *)RwEngineInstance + textureModule + 24);
}
// 6BCF84: using guessed type int textureModule;

//----- (001DB3E0) --------------------------------------------------------
RwBool __fastcall RwTextureSetReadCallBack(RwTextureCallBackRead fpCallBack)
{
  *(_DWORD *)((char *)RwEngineInstance + textureModule + 20) = fpCallBack;
  return 1;
}
// 6BCF84: using guessed type int textureModule;

//----- (001DB400) --------------------------------------------------------
RwTextureCallBackRead RwTextureGetReadCallBack()
{
  return *(RwTextureCallBackRead *)((char *)RwEngineInstance + textureModule + 20);
}
// 6BCF84: using guessed type int textureModule;

//----- (001DB41C) --------------------------------------------------------
RwBool __fastcall RwTextureSetMipmapping(RwBool enable)
{
  *(_DWORD *)((char *)RwEngineInstance + textureModule + 28) = enable;
  return 1;
}
// 6BCF84: using guessed type int textureModule;

//----- (001DB43C) --------------------------------------------------------
RwBool RwTextureGetMipmapping()
{
  return *(_DWORD *)((char *)RwEngineInstance + textureModule + 28);
}
// 6BCF84: using guessed type int textureModule;

//----- (001DB458) --------------------------------------------------------
RwBool __fastcall RwTextureSetAutoMipmapping(RwBool enable)
{
  *(_DWORD *)((char *)RwEngineInstance + textureModule + 32) = enable;
  return 1;
}
// 6BCF84: using guessed type int textureModule;

//----- (001DB478) --------------------------------------------------------
RwBool RwTextureGetAutoMipmapping()
{
  return *(_DWORD *)((char *)RwEngineInstance + textureModule + 32);
}
// 6BCF84: using guessed type int textureModule;

//----- (001DB494) --------------------------------------------------------
RwBool __fastcall _rwTextureSetAutoMipMapState(RwBool enable)
{
  int v1; // r2

  v1 = textureModule;
  *(_DWORD *)((char *)RwEngineInstance + textureModule + 28) = enable;
  *(_DWORD *)((char *)RwEngineInstance + v1 + 32) = enable;
  return 1;
}
// 6BCF84: using guessed type int textureModule;

//----- (001DB4B8) --------------------------------------------------------
RwBool _rwTextureGetAutoMipMapState()
{
  return *(_DWORD *)((char *)RwEngineInstance + textureModule + 32);
}
// 6BCF84: using guessed type int textureModule;

//----- (001DB4D4) --------------------------------------------------------
RwTexture_0 *__fastcall RwTextureSetRaster(RwTexture_0 *texture, RwRaster_0 *raster)
{
  RwTexture_0 *v2; // r4

  v2 = texture;
  if ( raster )
  {
    texture = (RwTexture_0 *)(*((int (__fastcall **)(RwTexture_0 *, RwRaster_0 *, _DWORD))RwEngineInstance + 26))(
                               texture,
                               raster,
                               0);
    if ( texture )
      return v2;
  }
  else
  {
    texture->raster = 0;
  }
  return texture;
}

//----- (001DB500) --------------------------------------------------------
RwTexDictionary_0 *RwTexDictionaryCreate()
{
  char *v0; // r4
  RwTexDictionary_0 *result; // r0
  int v2; // r1
  char *v3; // r2
  char *v4; // r3

  v0 = (char *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                 + textureModule
                                                                                 + 12));
  result = 0;
  if ( v0 )
  {
    v0[7] = 0;
    *(_WORD *)(v0 + 5) = 0;
    *(_DWORD *)(v0 + 1) = 0;
    *v0 = 6;
    v2 = textureModule;
    v3 = (char *)RwEngineInstance;
    v4 = (char *)RwEngineInstance + textureModule;
    *((_DWORD *)v0 + 4) = *(_DWORD *)((char *)RwEngineInstance + textureModule);
    *((_DWORD *)v0 + 5) = v4;
    *(_DWORD *)(*(_DWORD *)v4 + 4) = v0 + 16;
    *(_DWORD *)&v3[v2] = v0 + 16;
    *((_DWORD *)v0 + 2) = v0 + 8;
    *((_DWORD *)v0 + 3) = v0 + 8;
    _rwPluginRegistryInitObject(&texDictTKList, v0);
    return (RwTexDictionary_0 *)v0;
  }
  return result;
}
// 6BCF84: using guessed type int textureModule;

//----- (001DB588) --------------------------------------------------------
RwBool __fastcall RwTexDictionaryDestroy(RwTexDictionary_0 *dict)
{
  RwLinkList_0 *p_texturesInDict; // r4
  RwTexDictionary_0 *next; // r10
  RwTexDictionary_0 *v4; // r5
  RwRaster_0 **p_lInInstance; // r6
  int parent; // r0
  RwRaster_0 *v7; // r1
  bool v8; // zf
  TextureDatabaseEntry *dbEntry; // r0

  if ( *(RwTexDictionary_0 **)((char *)RwEngineInstance + textureModule + 16) == dict )
    *(_DWORD *)((char *)RwEngineInstance + textureModule + 16) = 0;
  p_texturesInDict = &dict->texturesInDict;
  next = (RwTexDictionary_0 *)dict->texturesInDict.link.next;
  if ( next != (RwTexDictionary_0 *)&dict->texturesInDict )
  {
    do
    {
      while ( 1 )
      {
        v4 = next;
        p_lInInstance = (RwRaster_0 **)&next[-1].lInInstance;
        parent = (int)next[3].object.parent;
        next = *(RwTexDictionary_0 **)&next->object.type;
        v4[3].object.parent = (void *)(parent - 1);
        if ( parent > 1 )
          break;
        v7 = *p_lInInstance;
        v8 = *p_lInInstance == 0;
        if ( *p_lInInstance )
          v8 = v7->dbEntry == 0;
        if ( v8 )
        {
          v4[3].object.parent = (void *)parent;
          _rwPluginRegistryDeInitObject(&textureTKList, p_lInInstance);
          if ( v4[-1].lInInstance.prev )
          {
            *(_DWORD *)v4->object.parent = *(_DWORD *)&v4->object.type;
            *(_DWORD *)(*(_DWORD *)&v4->object.type + 4) = v4->object.parent;
          }
          if ( *p_lInInstance )
          {
            RwRasterDestroy(*p_lInInstance);
            *p_lInInstance = 0;
          }
          --v4[3].object.parent;
          (*((void (__fastcall **)(_DWORD, RwRaster_0 **))RwEngineInstance + 80))(
            *(_DWORD *)((char *)RwEngineInstance + textureModule + 8),
            p_lInInstance);
          if ( next == (RwTexDictionary_0 *)p_texturesInDict )
            goto LABEL_21;
        }
        else
        {
          v4[3].object.parent = &dword_0 + 1;
          TextureDatabaseRuntime::CanUnloadTextureEntry(v7->dbEntry);
          if ( next == (RwTexDictionary_0 *)p_texturesInDict )
            goto LABEL_21;
        }
      }
      if ( parent == 2 )
      {
        if ( *p_lInInstance )
        {
          dbEntry = (*p_lInInstance)->dbEntry;
          if ( dbEntry )
            TextureDatabaseRuntime::CanUnloadTextureEntry(dbEntry);
        }
      }
    }
    while ( next != (RwTexDictionary_0 *)p_texturesInDict );
  }
LABEL_21:
  _rwPluginRegistryDeInitObject(&texDictTKList, dict);
  dict->lInInstance.prev->next = dict->lInInstance.next;
  dict->lInInstance.next->prev = dict->lInInstance.prev;
  (*((void (__fastcall **)(_DWORD, RwTexDictionary_0 *))RwEngineInstance + 80))(
    *(_DWORD *)((char *)RwEngineInstance + textureModule + 12),
    dict);
  return 1;
}
// 0: using guessed type int dword_0;
// 6BCF84: using guessed type int textureModule;

//----- (001DB6B4) --------------------------------------------------------
const RwTexDictionary_0 *__fastcall RwTexDictionaryForAllTextures(
        const RwTexDictionary_0 *dict,
        RwTextureCallBack fpCallBack,
        void *pData)
{
  RwLLLink *next; // r0
  RwLinkList_0 *p_texturesInDict; // r5
  RwLLLink *v8; // r4
  bool v9; // zf

  p_texturesInDict = &dict->texturesInDict;
  next = dict->texturesInDict.link.next;
  do
  {
    if ( next == (RwLLLink *)p_texturesInDict )
      break;
    v8 = next->next;
    v9 = (int)fpCallBack((RwTexture_0 *)&next[-1], pData) == 0;
    next = v8;
  }
  while ( !v9 );
  return dict;
}

//----- (001DB6E4) --------------------------------------------------------
RwBool __fastcall RwTextureDestroy(RwTexture_0 *texture)
{
  int refCount; // r0
  RwRaster_0 *v3; // r1
  bool v4; // zf
  RwRaster_0 *raster; // r0
  bool v6; // zf

  refCount = texture->refCount;
  texture->refCount = refCount - 1;
  if ( refCount > 1 )
  {
    if ( refCount != 2 )
      return 1;
    raster = texture->raster;
    v6 = texture->raster == 0;
    if ( texture->raster )
    {
      raster = (RwRaster_0 *)raster->dbEntry;
      v6 = raster == 0;
    }
    if ( v6 )
      return 1;
    goto LABEL_10;
  }
  v3 = texture->raster;
  v4 = texture->raster == 0;
  if ( texture->raster )
    v4 = v3->dbEntry == 0;
  if ( !v4 )
  {
    texture->refCount = 1;
    raster = (RwRaster_0 *)v3->dbEntry;
LABEL_10:
    TextureDatabaseRuntime::CanUnloadTextureEntry((TextureDatabaseEntry *)raster);
    return 1;
  }
  texture->refCount = refCount;
  _rwPluginRegistryDeInitObject(&textureTKList, texture);
  if ( texture->dict )
  {
    texture->lInDictionary.prev->next = texture->lInDictionary.next;
    texture->lInDictionary.next->prev = texture->lInDictionary.prev;
  }
  if ( texture->raster )
  {
    RwRasterDestroy(texture->raster);
    texture->raster = 0;
  }
  --texture->refCount;
  (*((void (__fastcall **)(_DWORD, RwTexture_0 *))RwEngineInstance + 80))(
    *(_DWORD *)((char *)RwEngineInstance + textureModule + 8),
    texture);
  return 1;
}
// 6BCF84: using guessed type int textureModule;

//----- (001DB77C) --------------------------------------------------------
RwBool __fastcall RwTexDictionaryForAllTexDictionaries(RwTexDictionaryCallBack fpCallBack, void *pData)
{
  char *v4; // r6
  char *v5; // r0
  char *v6; // r4
  bool v7; // zf

  v4 = (char *)RwEngineInstance + textureModule;
  v5 = *(char **)((char *)RwEngineInstance + textureModule);
  do
  {
    if ( v5 == v4 )
      break;
    v6 = *(char **)v5;
    v7 = (int)fpCallBack((RwTexDictionary_0 *)(v5 - 16), pData) == 0;
    v5 = v6;
  }
  while ( !v7 );
  return 1;
}
// 6BCF84: using guessed type int textureModule;

//----- (001DB7BC) --------------------------------------------------------
RwTexture_0 *__fastcall RwTextureCreate(RwRaster_0 *raster)
{
  RwTexture_0 *v2; // r0
  RwTexture_0 *v3; // r4
  int v4; // r2

  v2 = (RwTexture_0 *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                        + textureModule
                                                                                        + 8));
  v3 = v2;
  if ( v2 )
  {
    v2->name[0] = 0;
    v2->mask[0] = 0;
    v2->raster = raster;
    v2->dict = 0;
    v2->filterAddressing = 0;
    v2->refCount = 1;
    v4 = 4354;
    if ( raster->cType == 5 )
      v4 = 13058;
    v2->filterAddressing = v4;
    _rwPluginRegistryInitObject(&textureTKList, v2);
  }
  return v3;
}
// 6BCF84: using guessed type int textureModule;

//----- (001DB820) --------------------------------------------------------
RwTexture_0 *__fastcall RwTextureSetName(RwTexture_0 *texture, const RwChar *name)
{
  RwError_0 code; // [sp+8h] [bp-18h] BYREF

  (*((void (__fastcall **)(RwChar *, const RwChar *, int))RwEngineInstance + 63))(texture->name, name, 32);
  if ( (unsigned int)(*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(name) >= 0x20 )
  {
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483618, name, 32, 31, name[31]);
    RwErrorSet(&code);
    texture->name[31] = 0;
  }
  return texture;
}

//----- (001DB884) --------------------------------------------------------
RwTexture_0 *__fastcall RwTextureSetMaskName(RwTexture_0 *texture, const RwChar *maskName)
{
  RwError_0 code; // [sp+8h] [bp-18h] BYREF

  (*((void (__fastcall **)(RwChar *, const RwChar *, int))RwEngineInstance + 63))(texture->mask, maskName, 32);
  if ( (unsigned int)(*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(maskName) >= 0x20 )
  {
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483618, maskName, 32, 31, maskName[31]);
    RwErrorSet(&code);
    texture->mask[31] = 0;
  }
  return texture;
}

//----- (001DB8E8) --------------------------------------------------------
RwTexture_0 *__fastcall RwTexDictionaryAddTexture(RwTexDictionary_0 *dict, RwTexture_0 *texture)
{
  RwLLLink_0 *p_lInDictionary; // r2
  RwLinkList_0 *p_texturesInDict; // r0
  RwLLLink *next; // t1

  p_lInDictionary = &texture->lInDictionary;
  if ( texture->dict )
  {
    texture->lInDictionary.prev->next = texture->lInDictionary.next;
    texture->lInDictionary.next->prev = texture->lInDictionary.prev;
  }
  texture->dict = dict;
  next = dict->texturesInDict.link.next;
  p_texturesInDict = &dict->texturesInDict;
  texture->lInDictionary.next = next;
  texture->lInDictionary.prev = &p_texturesInDict->link;
  p_texturesInDict->link.next->prev = p_lInDictionary;
  p_texturesInDict->link.next = p_lInDictionary;
  return texture;
}

//----- (001DB916) --------------------------------------------------------
RwTexture_0 *__fastcall RwTexDictionaryRemoveTexture(RwTexture_0 *texture)
{
  RwLLLink_0 lInDictionary; // kr00_8

  if ( texture->dict )
  {
    lInDictionary = texture->lInDictionary;
    texture->dict = 0;
    lInDictionary.prev->next = lInDictionary.next;
    texture->lInDictionary.next->prev = texture->lInDictionary.prev;
  }
  return texture;
}

//----- (001DB930) --------------------------------------------------------
RwTexture_0 *__fastcall RwTexDictionaryFindNamedTexture(RwTexDictionary_0 *dict, const RwChar *name)
{
  RwLinkList_0 *p_texturesInDict; // r0
  RwLinkList_0 *v3; // r12
  RwLLLink *next; // t1
  RwLinkList_0 *v5; // lr
  const RwChar *v6; // r2
  unsigned __int8 v7; // r3
  RwChar v8; // r4

  next = dict->texturesInDict.link.next;
  p_texturesInDict = &dict->texturesInDict;
  v3 = (RwLinkList_0 *)next;
  if ( next == (RwLLLink *)p_texturesInDict )
    return 0;
  while ( 2 )
  {
    v5 = v3 + 1;
    v6 = name;
    while ( 1 )
    {
      v7 = (unsigned __int8)v5->link.next;
      v8 = *v6;
      if ( !LOBYTE(v5->link.next) )
        break;
      if ( *v6 )
      {
        ++v6;
        v5 = (RwLinkList_0 *)((char *)v5 + 1);
        if ( (unsigned __int8)(v8 - 97) < 0x1Au )
          v8 -= 32;
        if ( (unsigned __int8)(v7 - 97) < 0x1Au )
          v7 -= 32;
        if ( v7 == v8 )
          continue;
      }
      goto LABEL_12;
    }
    if ( !*v6 )
      return (RwTexture_0 *)&v3[-1];
LABEL_12:
    v3 = (RwLinkList_0 *)v3->link.next;
    if ( v3 != p_texturesInDict )
      continue;
    return 0;
  }
}

//----- (001DB98E) --------------------------------------------------------
RwInt32 __fastcall RwTexDictionaryGetNumTextures(RwTexDictionary_0 *dict)
{
  RwLinkList_0 *p_texturesInDict; // r1
  RwInt32 result; // r0
  RwLinkList_0 *next; // r2

  p_texturesInDict = &dict->texturesInDict;
  result = -1;
  next = p_texturesInDict;
  do
  {
    next = (RwLinkList_0 *)next->link.next;
    ++result;
  }
  while ( next != p_texturesInDict );
  return result;
}

//----- (001DB9A2) --------------------------------------------------------
RwTexture_0 *__fastcall RwTexDictionaryGetTextureByIndex(RwTexDictionary_0 *dict, RwInt32 index)
{
  RwLinkList_0 *p_texturesInDict; // r0
  RwLinkList_0 *v3; // r2
  RwLLLink *next; // t1
  int v6; // r1

  next = dict->texturesInDict.link.next;
  p_texturesInDict = &dict->texturesInDict;
  v3 = (RwLinkList_0 *)next;
  if ( next == (RwLLLink *)p_texturesInDict )
    return 0;
  v6 = index + 1;
  do
  {
    if ( !--v6 )
      return (RwTexture_0 *)&v3[-1];
    v3 = (RwLinkList_0 *)v3->link.next;
  }
  while ( v3 != p_texturesInDict );
  return 0;
}

//----- (001DB9C8) --------------------------------------------------------
RwTexDictionary_0 *__fastcall RwTexDictionarySetCurrent(RwTexDictionary_0 *dict)
{
  *(_DWORD *)((char *)RwEngineInstance + textureModule + 16) = dict;
  return dict;
}
// 6BCF84: using guessed type int textureModule;

//----- (001DB9E4) --------------------------------------------------------
RwTexDictionary_0 *RwTexDictionaryGetCurrent()
{
  return *(RwTexDictionary_0 **)((char *)RwEngineInstance + textureModule + 16);
}
// 6BCF84: using guessed type int textureModule;

//----- (001DBA00) --------------------------------------------------------
RwBool __fastcall RwTextureGenerateMipmapName(RwChar *name, RwChar *maskName, RwUInt8 mipLevel, RwInt32 format)
{
  int (__fastcall *v4)(RwChar *, RwChar *, RwUInt8, RwInt32); // r12

  v4 = *(int (__fastcall **)(RwChar *, RwChar *, RwUInt8, RwInt32))((char *)RwEngineInstance + textureModule + 48);
  if ( v4 )
    return v4(name, maskName, mipLevel, format);
  else
    return 0;
}
// 6BCF84: using guessed type int textureModule;

//----- (001DBA3C) --------------------------------------------------------
RwTexture_0 *__fastcall RwTextureRead(const RwChar *name, const RwChar *maskName)
{
  RwTexture_0 *result; // r0
  RwTexDictionary_0 *v5; // r1
  RwLLLink_0 *p_lInDictionary; // r2
  RwLLLink *p_link; // r1
  RwLLLink *next; // t1

  result = TextureDatabaseRuntime::GetTexture(name);
  if ( result
    || (result = (RwTexture_0 *)(*(int (__fastcall **)(const RwChar *))((char *)RwEngineInstance + textureModule + 24))(name)) != 0 )
  {
    ++result->refCount;
  }
  else
  {
    result = (RwTexture_0 *)(*(int (__fastcall **)(const RwChar *, const RwChar *))((char *)RwEngineInstance
                                                                                  + textureModule
                                                                                  + 20))(
                              name,
                              maskName);
    if ( result )
    {
      v5 = *(RwTexDictionary_0 **)((char *)RwEngineInstance + textureModule + 16);
      if ( v5 )
      {
        p_lInDictionary = &result->lInDictionary;
        if ( result->dict )
        {
          result->lInDictionary.prev->next = result->lInDictionary.next;
          result->lInDictionary.next->prev = result->lInDictionary.prev;
        }
        result->dict = v5;
        next = v5->texturesInDict.link.next;
        p_link = &v5->texturesInDict.link;
        result->lInDictionary.next = next;
        result->lInDictionary.prev = p_link;
        p_link->next->prev = p_lInDictionary;
        p_link->next = p_lInDictionary;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}
// 6BCF84: using guessed type int textureModule;

//----- (001DBAE0) --------------------------------------------------------
RwInt32 __fastcall RwTextureRegisterPlugin(
        RwInt32 size,
        RwUInt32 pluginID,
        RwPluginObjectConstructor constructCB,
        RwPluginObjectDestructor destructCB,
        RwPluginObjectCopy copyCB)
{
  return _rwPluginRegistryAddPlugin(&textureTKList, size, pluginID, constructCB, destructCB, copyCB);
}

//----- (001DBB0C) --------------------------------------------------------
RwInt32 __fastcall RwTextureGetPluginOffset(RwUInt32 pluginID)
{
  return sub_18F574(&textureTKList, pluginID);
}

//----- (001DBB1C) --------------------------------------------------------
RwBool __fastcall RwTextureValidatePlugins(const RwTexture_0 *texture)
{
  return 1;
}

//----- (001DBB20) --------------------------------------------------------
RwInt32 __fastcall RwTexDictionaryRegisterPlugin(
        RwInt32 size,
        RwUInt32 pluginID,
        RwPluginObjectConstructor constructCB,
        RwPluginObjectDestructor destructCB,
        RwPluginObjectCopy copyCB)
{
  return _rwPluginRegistryAddPlugin(&texDictTKList, size, pluginID, constructCB, destructCB, copyCB);
}

//----- (001DBB4C) --------------------------------------------------------
RwInt32 __fastcall RwTexDictionaryGetPluginOffset(RwUInt32 pluginID)
{
  return sub_18F574(&texDictTKList, pluginID);
}

//----- (001DBB5C) --------------------------------------------------------
RwBool __fastcall RwTexDictionaryValidatePlugins(const RwTexDictionary_0 *dict)
{
  return 1;
}

//----- (001DBB60) --------------------------------------------------------
RwBool __fastcall RwTextureSetMipmapGenerationCallBack(RwTextureCallBackMipmapGeneration callback)
{
  *(_DWORD *)((char *)RwEngineInstance + textureModule + 44) = callback;
  return 1;
}
// 6BCF84: using guessed type int textureModule;

//----- (001DBB80) --------------------------------------------------------
RwTextureCallBackMipmapGeneration RwTextureGetMipmapGenerationCallBack()
{
  return *(RwTextureCallBackMipmapGeneration *)((char *)RwEngineInstance + textureModule + 44);
}
// 6BCF84: using guessed type int textureModule;

//----- (001DBB9C) --------------------------------------------------------
RwBool __fastcall RwTextureSetMipmapNameCallBack(RwTextureCallBackMipmapName callback)
{
  *(_DWORD *)((char *)RwEngineInstance + textureModule + 48) = callback;
  return 1;
}
// 6BCF84: using guessed type int textureModule;

//----- (001DBBBC) --------------------------------------------------------
RwTextureCallBackMipmapName RwTextureGetMipmapNameCallBack()
{
  return *(RwTextureCallBackMipmapName *)((char *)RwEngineInstance + textureModule + 48);
}
// 6BCF84: using guessed type int textureModule;

//----- (001DBBD8) --------------------------------------------------------
RwBool __fastcall RwTextureRasterGenerateMipmaps(RwRaster_0 *raster, RwImage_0 *image)
{
  return (*(int (__fastcall **)(RwRaster_0 *, RwImage_0 *))((char *)RwEngineInstance + textureModule + 44))(
           raster,
           image) != 0;
}
// 6BCF84: using guessed type int textureModule;

//----- (001DBC00) --------------------------------------------------------
void *__fastcall _rwTextureClose(void *instance, RwInt32 offset, RwInt32 size)
{
  int v4; // r2
  char *v5; // r3
  char *v6; // r5
  RwFreeList_0 *v7; // r0
  char *v8; // r4
  RwFreeList_0 *v9; // r0

  v4 = textureModule;
  v5 = (char *)RwEngineInstance;
  if ( *(_DWORD *)((char *)RwEngineInstance + textureModule + 36) )
  {
    (*((void (**)(void))RwEngineInstance + 76))();
    v4 = textureModule;
    *(_DWORD *)((char *)RwEngineInstance + textureModule + 36) = 0;
    *(_WORD *)((char *)RwEngineInstance + v4 + 40) = 0;
    v5 = (char *)RwEngineInstance;
  }
  v6 = &v5[v4];
  v7 = *(RwFreeList_0 **)&v5[v4 + 8];
  if ( v7 )
  {
    if ( !*((_DWORD *)v6 + 3) )
      goto LABEL_10;
    v8 = &v5[v4];
    while ( 1 )
    {
      v8 = *(char **)v8;
      if ( v8 == v6 )
        break;
      if ( dummyTexDict == (RwTexDictionary_0 *)(v8 - 16) )
      {
        RwTexDictionaryDestroy(dummyTexDict);
        v4 = textureModule;
        v5 = (char *)RwEngineInstance;
        dummyTexDict = 0;
        v7 = *(RwFreeList_0 **)((char *)RwEngineInstance + textureModule + 8);
        break;
      }
    }
    if ( v7 )
    {
LABEL_10:
      RwFreeListDestroy(v7);
      v4 = textureModule;
      *(_DWORD *)((char *)RwEngineInstance + textureModule + 8) = 0;
      v5 = (char *)RwEngineInstance;
    }
  }
  v9 = *(RwFreeList_0 **)&v5[v4 + 12];
  if ( v9 )
  {
    RwFreeListDestroy(v9);
    *(_DWORD *)((char *)RwEngineInstance + textureModule + 12) = 0;
  }
  --textureModule;
  return instance;
}
// 6BCF84: using guessed type int textureModule;
// 6BCF88: using guessed type int textureModule;

//----- (001DBD00) --------------------------------------------------------
void __fastcall RwTextureSetFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rwTextureFreeListPreallocBlocks = numBlocksToPrealloc;
  _rwTextureFreeListBlockSize = blockSize;
}

//----- (001DBD18) --------------------------------------------------------
void __fastcall RwTexDictionarySetFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rwTexDictionaryFreeListPreallocBlocks = numBlocksToPrealloc;
  _rwTexDictionaryFreeListBlockSize = blockSize;
}

//----- (001DBD30) --------------------------------------------------------
void *__fastcall _rwTextureOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  RwFreeList_0 *v4; // r0
  int v5; // r2
  RwFreeList_0 *v6; // r0
  int v7; // r1
  RwFreeList_0 **v8; // r0
  char *v9; // r0
  RwTexDictionary_0 *v10; // r5
  RwTexDictionary_0 *v11; // r1
  int v12; // r2
  char *v13; // r1
  char *v14; // r6
  int v15; // r0
  RwFreeList_0 **v16; // r1
  char *v17; // r0
  int v18; // r0

  textureModule = offset;
  v4 = RwFreeListCreateAndPreallocateSpace(
         textureTKList.sizeOfStruct,
         _rwTextureFreeListBlockSize,
         4,
         _rwTextureFreeListPreallocBlocks,
         &_rwTextureFreeList);
  v5 = textureModule;
  *(_DWORD *)((char *)RwEngineInstance + textureModule + 8) = v4;
  if ( !*(_DWORD *)((char *)RwEngineInstance + v5 + 8) )
    return 0;
  v6 = RwFreeListCreateAndPreallocateSpace(
         texDictTKList.sizeOfStruct,
         _rwTexDictionaryFreeListBlockSize,
         4,
         _rwTexDictionaryFreeListPreallocBlocks,
         &_rwTexDictionaryFreeList);
  v7 = textureModule;
  *(_DWORD *)((char *)RwEngineInstance + textureModule + 12) = v6;
  v8 = (RwFreeList_0 **)((char *)RwEngineInstance + v7);
  if ( !*(_DWORD *)((char *)RwEngineInstance + v7 + 12) )
  {
    RwFreeListDestroy(v8[2]);
    instance = 0;
    v17 = (char *)RwEngineInstance + textureModule;
LABEL_10:
    *((_DWORD *)v17 + 2) = 0;
    return instance;
  }
  *v8 = (RwFreeList_0 *)v8;
  *(_DWORD *)((char *)RwEngineInstance + v7 + 4) = (char *)RwEngineInstance + v7;
  ++textureModule;
  v9 = (char *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + v7 + 12));
  v10 = (RwTexDictionary_0 *)v9;
  v11 = 0;
  if ( v9 )
  {
    v9[7] = 0;
    *(_WORD *)(v9 + 5) = 0;
    *(_DWORD *)(v9 + 1) = 0;
    *v9 = 6;
    v12 = textureModule;
    v13 = (char *)RwEngineInstance;
    v14 = (char *)RwEngineInstance + textureModule;
    *((_DWORD *)v9 + 4) = *(_DWORD *)((char *)RwEngineInstance + textureModule);
    *((_DWORD *)v9 + 5) = v14;
    *(_DWORD *)(*(_DWORD *)v14 + 4) = v9 + 16;
    *(_DWORD *)&v13[v12] = v9 + 16;
    *((_DWORD *)v9 + 2) = v9 + 8;
    *((_DWORD *)v9 + 3) = v9 + 8;
    _rwPluginRegistryInitObject(&texDictTKList, v9);
    v11 = v10;
  }
  v15 = textureModule;
  dummyTexDict = v11;
  *(_DWORD *)((char *)RwEngineInstance + textureModule + 16) = v11;
  v16 = (RwFreeList_0 **)((char *)RwEngineInstance + v15);
  if ( !*(_DWORD *)((char *)RwEngineInstance + v15 + 16) )
  {
    RwFreeListDestroy(v16[3]);
    instance = 0;
    v18 = textureModule;
    *(_DWORD *)((char *)RwEngineInstance + textureModule + 12) = 0;
    RwFreeListDestroy(*(RwFreeList_0 **)((char *)RwEngineInstance + v18 + 8));
    v17 = (char *)RwEngineInstance + textureModule;
    goto LABEL_10;
  }
  v16[7] = 0;
  *(_DWORD *)((char *)RwEngineInstance + v15 + 32) = 0;
  *(_DWORD *)((char *)RwEngineInstance + v15 + 24) = TextureDefaultFind;
  *(_DWORD *)((char *)RwEngineInstance + v15 + 20) = TextureDefaultRead;
  *(_DWORD *)((char *)RwEngineInstance + v15 + 44) = TextureRasterDefaultBuildMipmaps;
  *(_DWORD *)((char *)RwEngineInstance + v15 + 48) = TextureDefaultMipmapName;
  *(_DWORD *)((char *)RwEngineInstance + v15 + 36) = 0;
  *(_WORD *)((char *)RwEngineInstance + v15 + 40) = 0;
  return instance;
}
// 6BCF84: using guessed type int textureModule;
// 6BCF88: using guessed type int textureModule;

//----- (001DBF58) --------------------------------------------------------
RwTexture_0 *__fastcall TextureDefaultFind(const RwChar *name)
{
  _DWORD **v1; // r12
  int v2; // lr
  _DWORD *v3; // r1
  _DWORD *v4; // lr
  _DWORD *v5; // t1
  unsigned __int8 *v6; // r3
  const RwChar *v7; // r2
  unsigned __int8 v8; // r4
  RwChar v9; // r5
  _DWORD *v10; // lr
  _DWORD *v11; // r3
  unsigned __int8 *v12; // r1
  const RwChar *v13; // r4
  unsigned __int8 v14; // r5
  RwChar v15; // r6

  v1 = (_DWORD **)((char *)RwEngineInstance + textureModule);
  v2 = *(_DWORD *)((char *)RwEngineInstance + textureModule + 16);
  if ( v2 )
  {
    v5 = *(_DWORD **)(v2 + 8);
    v4 = (_DWORD *)(v2 + 8);
    v3 = v5;
    if ( v5 == v4 )
      return 0;
LABEL_6:
    v6 = (unsigned __int8 *)(v3 + 2);
    v7 = name;
    while ( 1 )
    {
      v8 = *v6;
      v9 = *v7;
      if ( !*v6 )
        break;
      if ( *v7 )
      {
        ++v7;
        ++v6;
        if ( (unsigned __int8)(v9 - 97) < 0x1Au )
          v9 -= 32;
        if ( (unsigned __int8)(v8 - 97) < 0x1Au )
          v8 -= 32;
        if ( v8 == v9 )
          continue;
      }
LABEL_5:
      v3 = (_DWORD *)*v3;
      if ( v3 == v4 )
        return 0;
      goto LABEL_6;
    }
    if ( *v7 )
      goto LABEL_5;
    return (RwTexture_0 *)(v3 - 2);
  }
  else
  {
    v10 = *v1;
    if ( *v1 == v1 )
      return 0;
    while ( 1 )
    {
      v11 = (_DWORD *)*(v10 - 2);
      if ( v11 != v10 - 2 )
        break;
LABEL_17:
      v10 = (_DWORD *)*v10;
      if ( v10 == v1 )
        return 0;
    }
LABEL_22:
    v12 = (unsigned __int8 *)(v11 + 2);
    v13 = name;
    while ( 1 )
    {
      v14 = *v12;
      v15 = *v13;
      if ( !*v12 )
        break;
      if ( *v13 )
      {
        ++v13;
        ++v12;
        if ( (unsigned __int8)(v15 - 97) < 0x1Au )
          v15 -= 32;
        if ( (unsigned __int8)(v14 - 97) < 0x1Au )
          v14 -= 32;
        if ( v14 == v15 )
          continue;
      }
LABEL_21:
      v11 = (_DWORD *)*v11;
      if ( v11 == v10 - 2 )
        goto LABEL_17;
      goto LABEL_22;
    }
    if ( *v13 )
      goto LABEL_21;
    return (RwTexture_0 *)(v11 - 2);
  }
}
// 6BCF84: using guessed type int textureModule;

//----- (001DC04C) --------------------------------------------------------
RwTexture_0 *__fastcall TextureDefaultRead(const RwChar *name, const RwChar *maskName)
{
  const RwChar *v2; // r10
  bool v4; // zf
  char *v5; // r0
  RwInt32 v6; // r8
  bool v7; // zf
  void (__fastcall *v8)(RwChar *, RwChar *, _DWORD, int); // r6
  RwTexture_0 *v9; // r4
  RwImage_0 *pluginID; // r6
  RwRaster_0 *v11; // r0
  RwRaster_0 *v12; // r5
  int cFormat; // r0
  RwInt32 v14; // r0
  RwTexture_0 *v15; // r0
  int v16; // r2
  void (__fastcall *v17)(RwChar *, const RwChar *, int); // r3
  RwInt32 v18; // r0
  void (__fastcall *v19)(RwChar *, RwChar *, _DWORD, RwInt32); // r6
  RwRaster_0 *v20; // r9
  int v21; // r6
  bool v22; // zf
  const RwChar *v23; // r4
  void (__fastcall *v24)(RwChar *, RwChar *, _DWORD, RwInt32); // r5
  RwImage_0 *v25; // r0
  int v26; // r0
  int v27; // r11
  RwInt32 v28; // r0
  RwTexture_0 *v29; // r0
  int v30; // r2
  void (__fastcall *v31)(RwChar *, const RwChar *, int); // r3
  RwInt32 v32; // r0
  RwRaster_0 *v33; // r0
  RwError_0 *p_code; // r0
  RwRaster_0 *v35; // r0
  RwError_0 *v36; // r4
  int v37; // r5
  RwImage_0 *v38; // t1
  int v39; // r8
  RwInt32 *p_errorCode; // r4
  int v41; // r5
  RwUInt8 *v42; // r0
  RwImage_0 *v43; // r6
  int v44; // r4
  int v45; // r0
  int v46; // r5
  RwImage_0 *v47; // t1
  const RwChar *v49; // [sp+1Ch] [bp-684h]
  const RwChar *v50; // [sp+1Ch] [bp-684h]
  int totalMipLevels; // [sp+20h] [bp-680h]
  const RwChar *v52; // [sp+24h] [bp-67Ch]
  RwRGBA_0 MipPalette; // [sp+28h] [bp-678h] BYREF
  RwError_0 code; // [sp+428h] [bp-278h] BYREF
  RwError_0 mipArray; // [sp+468h] [bp-238h] BYREF
  RwInt32 flags; // [sp+470h] [bp-230h] BYREF
  RwInt32 depth; // [sp+474h] [bp-22Ch] BYREF
  RwInt32 height; // [sp+478h] [bp-228h] BYREF
  RwInt32 rasterWidth; // [sp+47Ch] [bp-224h] BYREF
  RwChar v60[255]; // [sp+480h] [bp-220h] BYREF
  char v61; // [sp+57Fh] [bp-121h]
  RwChar v62[255]; // [sp+580h] [bp-120h] BYREF
  char v63; // [sp+67Fh] [bp-21h]

  v2 = name;
  if ( !*(_DWORD *)((char *)RwEngineInstance + textureModule + 28) )
  {
    (*((void (__fastcall **)(RwChar *, const RwChar *, int))RwEngineInstance + 63))(v62, name, 256);
    if ( (unsigned int)(*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(v2) >= 0x100 )
    {
      code.pluginID = 0;
      code.errorCode = _rwerror(-2147483618, v2, 256, 255, v2[255]);
      RwErrorSet(&code);
      v63 = 0;
    }
    v7 = maskName == 0;
    v60[0] = 0;
    if ( maskName )
      v7 = *maskName == 0;
    if ( !v7 )
    {
      (*((void (__fastcall **)(RwChar *, const RwChar *, int))RwEngineInstance + 63))(v60, maskName, 256);
      if ( (unsigned int)(*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(maskName) >= 0x100 )
      {
        code.pluginID = 0;
        code.errorCode = _rwerror(-2147483618, maskName, 256, 255, maskName[255]);
        RwErrorSet(&code);
        v61 = 0;
      }
    }
    v8 = *(void (__fastcall **)(RwChar *, RwChar *, _DWORD, int))((char *)RwEngineInstance + textureModule + 48);
    if ( v8 )
      v8(v62, v60, 0, 4);
    v9 = 0;
    rasterWidth = 0;
    height = 0;
    pluginID = TextureImageReadAndSize(v62, v60, 4, &rasterWidth, &height, &depth, &flags);
    mipArray.pluginID = (RwInt32)pluginID;
    if ( !pluginID )
      return v9;
    v49 = maskName;
    v11 = RwRasterCreate(rasterWidth, height, depth, flags);
    v12 = v11;
    if ( !v11 )
      goto LABEL_78;
    cFormat = v11->cFormat;
    if ( ((cFormat << 8) & 0x6000) != 0 )
    {
      if ( (cFormat & 0x40) != 0 )
        v14 = 4;
      else
        v14 = 8;
      PalettizeMipmaps(&MipPalette, 0, (RwImage_0 **)&mipArray, 1, v14);
      pluginID = (RwImage_0 *)mipArray.pluginID;
      *(_DWORD *)(mipArray.pluginID + 24) = &MipPalette;
    }
    RwImageGammaCorrect(pluginID);
    if ( !RwRasterSetFromImage(v12, pluginID) )
    {
      v33 = v12;
LABEL_77:
      RwRasterDestroy(v33);
LABEL_78:
      RwImageDestroy(pluginID);
      return 0;
    }
    RwImageDestroy(pluginID);
    v15 = (RwTexture_0 *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                           + textureModule
                                                                                           + 8));
    v9 = v15;
    if ( v15 )
    {
      v15->raster = v12;
      v15->dict = 0;
      v16 = 4354;
      v15->filterAddressing = 0;
      v15->refCount = 1;
      v15->mask[0] = 0;
      v15->name[0] = 0;
      if ( v12->cType == 5 )
        v16 = 13058;
      v15->filterAddressing = v16;
      _rwPluginRegistryInitObject(&textureTKList, v15);
      (*((void (__fastcall **)(RwChar *, const RwChar *, int))RwEngineInstance + 63))(v9->name, v2, 32);
      if ( (unsigned int)(*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(v2) > 0x1F )
      {
        code.pluginID = 0;
        code.errorCode = _rwerror(-2147483618, v2, 32, 31, v2[31]);
        RwErrorSet(&code);
        v9->name[31] = 0;
      }
      v17 = (void (__fastcall *)(RwChar *, const RwChar *, int))*((_DWORD *)RwEngineInstance + 63);
      if ( v49 )
      {
        v17(v9->mask, v49, 32);
        if ( (unsigned int)(*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(v49) < 0x20 )
          return v9;
        code.pluginID = 0;
        v18 = _rwerror(-2147483618, v49, 32, 31, v49[31]);
      }
      else
      {
        v17(v9->mask, (const RwChar *)&byte_61CADE, 32);
        if ( (unsigned int)(*((int (__fastcall **)(char *))RwEngineInstance + 70))(&byte_61CADE) < 0x20 )
          return v9;
        code.pluginID = 0;
        v18 = _rwerror(-2147483618, &byte_61CADE, 32, 31, 0);
      }
      code.errorCode = v18;
      p_code = &code;
      goto LABEL_86;
    }
    v35 = v12;
LABEL_105:
    RwRasterDestroy(v35);
    return 0;
  }
  (*((void (__fastcall **)(RwChar *, const RwChar *, int))RwEngineInstance + 63))(v62, name, 256);
  if ( (unsigned int)(*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(v2) >= 0x100 )
  {
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483618, v2, 256, 255, v2[255]);
    RwErrorSet(&code);
    v63 = 0;
  }
  v4 = maskName == 0;
  v60[0] = 0;
  if ( maskName )
    v4 = *maskName == 0;
  if ( !v4 )
  {
    (*((void (__fastcall **)(RwChar *, const RwChar *, int))RwEngineInstance + 63))(v60, maskName, 256);
    if ( (unsigned int)(*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(maskName) >= 0x100 )
    {
      code.pluginID = 0;
      code.errorCode = _rwerror(-2147483618, maskName, 256, 255, maskName[255]);
      RwErrorSet(&code);
      v61 = 0;
    }
  }
  v5 = (char *)RwEngineInstance + textureModule;
  if ( *(_DWORD *)((char *)RwEngineInstance + textureModule + 28) )
  {
    v6 = 36868;
    if ( !*((_DWORD *)v5 + 8) )
      v6 = 32772;
  }
  else
  {
    v6 = 4;
  }
  v19 = (void (__fastcall *)(RwChar *, RwChar *, _DWORD, RwInt32))*((_DWORD *)v5 + 12);
  if ( v19 )
    v19(v62, v60, 0, v6);
  v9 = 0;
  rasterWidth = 0;
  height = 0;
  pluginID = TextureImageReadAndSize(v62, v60, v6, &rasterWidth, &height, &depth, &flags);
  code.pluginID = (RwInt32)pluginID;
  if ( !pluginID )
    return v9;
  v20 = RwRasterCreate(rasterWidth, height, depth, flags);
  if ( !v20 )
    goto LABEL_78;
  v52 = v2;
  if ( (flags & 0x8000) == 0 )
  {
    RwImageGammaCorrect(pluginID);
LABEL_65:
    if ( RwRasterSetFromImage(v20, pluginID) )
    {
      v50 = maskName;
      RwImageDestroy(pluginID);
      goto LABEL_67;
    }
    v33 = v20;
    goto LABEL_77;
  }
  if ( (flags & 0x1000) != 0 )
    goto LABEL_65;
  totalMipLevels = RwRasterGetNumLevels(v20);
  if ( totalMipLevels > 1 )
  {
    v21 = 1;
    while ( 1 )
    {
      (*((void (__fastcall **)(RwChar *, const RwChar *, int))RwEngineInstance + 63))(v62, v2, 256);
      if ( (unsigned int)(*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(v2) >= 0x100 )
      {
        mipArray.pluginID = 0;
        mipArray.errorCode = _rwerror(-2147483618, v2, 256, 255, v2[255]);
        RwErrorSet(&mipArray);
        v63 = 0;
      }
      v22 = maskName == 0;
      v60[0] = 0;
      if ( maskName )
        v22 = *maskName == 0;
      if ( !v22 )
      {
        (*((void (__fastcall **)(RwChar *, const RwChar *, int))RwEngineInstance + 63))(v60, maskName, 256);
        if ( (unsigned int)(*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(maskName) >= 0x100 )
        {
          mipArray.pluginID = 0;
          mipArray.errorCode = _rwerror(-2147483618, maskName, 256, 255, maskName[255]);
          RwErrorSet(&mipArray);
          v61 = 0;
        }
      }
      v23 = maskName;
      v24 = *(void (__fastcall **)(RwChar *, RwChar *, _DWORD, RwInt32))((char *)RwEngineInstance + textureModule + 48);
      if ( v24 )
        v24(v62, v60, (unsigned __int8)v21, v6);
      RwRasterLock(v20, v21, 5);
      rasterWidth = v20->width;
      height = v20->height;
      depth = v20->depth;
      flags = v20->cType | (v20->cFormat << 8);
      RwRasterUnlock(v20);
      v25 = TextureImageReadAndSize(v62, v60, v6, &rasterWidth, &height, &depth, &flags);
      *(&code.pluginID + v21) = (RwInt32)v25;
      if ( !v25 )
        break;
      ++v21;
      v2 = v52;
      maskName = v23;
      if ( v21 >= totalMipLevels )
        goto LABEL_59;
    }
    if ( v21 >= 1 )
    {
      v44 = v21 - 1;
      do
      {
        RwImageDestroy(*((RwImage_0 **)&code.pluginID + v44));
        v45 = v44-- + 1;
      }
      while ( v45 > 1 );
    }
LABEL_104:
    v35 = v20;
    goto LABEL_105;
  }
LABEL_59:
  v26 = v20->cFormat;
  v50 = maskName;
  if ( ((v26 << 8) & 0x6000) == 0 )
  {
    v27 = totalMipLevels;
    if ( totalMipLevels < 1 )
      goto LABEL_67;
    v36 = &code;
    v37 = totalMipLevels;
    do
    {
      v38 = (RwImage_0 *)v36->pluginID;
      v36 = (RwError_0 *)((char *)v36 + 4);
      RwImageGammaCorrect(v38);
      --v37;
    }
    while ( v37 );
LABEL_90:
    v39 = v27 - 1;
    p_errorCode = &code.errorCode;
    v41 = 0;
    while ( 1 )
    {
      v42 = RwRasterLock(v20, v41, 5);
      v43 = (RwImage_0 *)*(p_errorCode - 1);
      if ( v42 )
      {
        if ( !RwRasterSetFromImage(v20, (RwImage_0 *)*(p_errorCode - 1)) )
        {
          if ( v41 < v27 )
          {
            RwImageDestroy(v43);
            if ( v39 != v41 )
            {
              v46 = v39 - v41;
              do
              {
                v47 = (RwImage_0 *)*p_errorCode++;
                RwImageDestroy(v47);
                --v46;
              }
              while ( v46 );
            }
          }
          goto LABEL_104;
        }
        RwRasterUnlock(v20);
      }
      RwImageDestroy(v43);
      ++v41;
      ++p_errorCode;
      if ( v41 >= v27 )
        goto LABEL_67;
    }
  }
  v27 = totalMipLevels;
  if ( (v26 & 0x40) != 0 )
    v28 = 4;
  else
    v28 = 8;
  PalettizeMipmaps(&MipPalette, 0, (RwImage_0 **)&code, totalMipLevels, v28);
  RwImageGammaCorrect((RwImage_0 *)code.pluginID);
  if ( totalMipLevels >= 1 )
    goto LABEL_90;
LABEL_67:
  v29 = (RwTexture_0 *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                         + textureModule
                                                                                         + 8));
  v9 = v29;
  if ( !v29 )
    goto LABEL_104;
  v29->raster = v20;
  v29->dict = 0;
  v30 = 4354;
  v29->filterAddressing = 0;
  v29->refCount = 1;
  v29->mask[0] = 0;
  v29->name[0] = 0;
  if ( v20->cType == 5 )
    v30 = 13058;
  v29->filterAddressing = v30;
  _rwPluginRegistryInitObject(&textureTKList, v29);
  (*((void (__fastcall **)(RwChar *, const RwChar *, int))RwEngineInstance + 63))(v9->name, v52, 32);
  if ( (unsigned int)(*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(v52) > 0x1F )
  {
    mipArray.pluginID = 0;
    mipArray.errorCode = _rwerror(-2147483618, v52, 32, 31, v52[31]);
    RwErrorSet(&mipArray);
    v9->name[31] = 0;
  }
  v31 = (void (__fastcall *)(RwChar *, const RwChar *, int))*((_DWORD *)RwEngineInstance + 63);
  if ( v50 )
  {
    v31(v9->mask, v50, 32);
    if ( (unsigned int)(*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(v50) >= 0x20 )
    {
      mipArray.pluginID = 0;
      v32 = _rwerror(-2147483618, v50, 32, 31, v50[31]);
LABEL_81:
      mipArray.errorCode = v32;
      p_code = &mipArray;
LABEL_86:
      RwErrorSet(p_code);
      v9->mask[31] = 0;
    }
  }
  else
  {
    v31(v9->mask, (const RwChar *)&byte_61CADE, 32);
    if ( (unsigned int)(*((int (__fastcall **)(char *))RwEngineInstance + 70))(&byte_61CADE) >= 0x20 )
    {
      mipArray.pluginID = 0;
      v32 = _rwerror(-2147483618, &byte_61CADE, 32, 31, 0);
      goto LABEL_81;
    }
  }
  return v9;
}
// 1DC7EA: conditional instruction was optimized away because %totalMipLevels.4>=1
// 61CADE: using guessed type char byte_61CADE;
// 6BCF84: using guessed type int textureModule;

//----- (001DC914) --------------------------------------------------------
RwRaster_0 *__fastcall TextureRasterDefaultBuildMipmaps(RwRaster_0 *raster, RwImage_0 *sourceImage)
{
  RwRaster_0 *v2; // r4
  __int64 v4; // r0
  RwImage_0 *Resample; // r5
  RwImage_0 *v6; // r0
  RwImage_0 *v7; // r0
  RwUInt8 cFormat; // r0
  int NumLevels; // r11
  int v10; // r10
  int v11; // r0
  RwBool v12; // r0
  int v13; // r5
  RwImage_0 *v14; // r0
  RwImage_0 **v16; // r5
  int v17; // r6
  RwImage_0 *v18; // t1
  RwBool v19; // r0
  int i; // r6
  RwUInt8 *v21; // r0
  RwImage_0 *v22; // r5
  char v24; // [sp+8h] [bp-460h]
  RwRGBA_0 MipPalette; // [sp+Ch] [bp-45Ch] BYREF
  RwImage_0 *image[2]; // [sp+40Ch] [bp-5Ch] BYREF

  v2 = raster;
  v4 = *(_QWORD *)&raster->width;
  if ( sourceImage )
  {
    if ( sourceImage->depth == 32 )
    {
      Resample = sourceImage;
      image[0] = sourceImage;
    }
    else
    {
      v7 = RwImageCreate(v4, SHIDWORD(v4), 32);
      Resample = v7;
      image[0] = v7;
      if ( !v7 || !RwImageAllocatePixels(v7) )
        return 0;
      RwImageCopy(Resample, sourceImage);
    }
  }
  else
  {
    v6 = RwImageCreate(v4, SHIDWORD(v4), 32);
    Resample = v6;
    image[0] = v6;
    if ( !v6 || !RwImageAllocatePixels(v6) )
      return 0;
    RwImageSetFromRaster(Resample, v2);
  }
  cFormat = v2->cFormat;
  v2->cFormat = ((cFormat | 0xEF) ^ 0x10) & cFormat;
  v24 = cFormat & 0x10;
  NumLevels = RwRasterGetNumLevels(v2);
  if ( NumLevels >= 2 )
  {
    v10 = 1;
    while ( 1 )
    {
      image[v10] = 0;
      if ( !RwRasterLock(v2, v10, 2) )
        break;
      Resample = RwImageCreateResample(Resample, v2->width, v2->height);
      image[v10] = Resample;
      RwRasterUnlock(v2);
      if ( !Resample )
        break;
      if ( ++v10 >= NumLevels )
        goto LABEL_15;
    }
    if ( v10 >= 1 )
    {
      v13 = v10 - 1;
      do
      {
        v14 = image[v13];
        if ( v14 != sourceImage )
          RwImageDestroy(v14);
      }
      while ( v13-- + 1 > 1 );
    }
    goto LABEL_35;
  }
LABEL_15:
  v11 = v2->cFormat;
  if ( ((v11 << 8) & 0x6000) == 0 )
  {
    if ( NumLevels >= 1 )
    {
      v16 = image;
      v17 = NumLevels;
      do
      {
        v18 = *v16++;
        RwImageGammaCorrect(v18);
        --v17;
      }
      while ( v17 );
LABEL_38:
      for ( i = 0; i != NumLevels; ++i )
      {
        v21 = RwRasterLock(v2, i, 5);
        v22 = image[i];
        if ( v21 )
        {
          RwRasterSetFromImage(v2, image[i]);
          RwRasterUnlock(v2);
        }
        if ( v22 != sourceImage )
          RwImageDestroy(v22);
      }
    }
LABEL_44:
    v2->cFormat |= v24;
    return v2;
  }
  if ( (v11 & 0x40) != 0 )
  {
    v19 = PalettizeMipmaps(&MipPalette, sourceImage, image, NumLevels, 4);
    if ( NumLevels < 1 || v19 )
    {
LABEL_37:
      RwImageGammaCorrect(image[0]);
      if ( NumLevels >= 1 )
        goto LABEL_38;
      goto LABEL_44;
    }
  }
  else
  {
    v12 = PalettizeMipmaps(&MipPalette, sourceImage, image, NumLevels, 8);
    if ( NumLevels < 1 || v12 )
      goto LABEL_37;
  }
  if ( image[0] != sourceImage )
    RwImageDestroy(image[0]);
LABEL_35:
  v2->cFormat |= v24;
  return 0;
}
// 1DCA68: conditional instruction was optimized away because r11.4>=1

//----- (001DCAFC) --------------------------------------------------------
RwBool __fastcall TextureDefaultMipmapName(RwChar *name, RwChar *maskName, RwUInt8 mipLevel, RwInt32 format)
{
  bool v5; // zf
  char v7; // [sp+5h] [bp-Bh] BYREF
  __int16 v8; // [sp+6h] [bp-Ah]

  v7 = 109;
  if ( (unsigned __int8)(mipLevel - 1) >= 0xFu )
  {
    v8 = 0;
  }
  else
  {
    v8 = (unsigned __int8)CalculateIndexCharacter(unsigned char)::character[mipLevel];
    (*((void (__fastcall **)(RwChar *, char *))RwEngineInstance + 64))(name, &v7);
    v5 = maskName == 0;
    if ( maskName )
      v5 = *maskName == 0;
    if ( !v5 )
      (*((void (__fastcall **)(RwChar *, char *))RwEngineInstance + 64))(maskName, &v7);
  }
  return 1;
}

//----- (001DCB7C) --------------------------------------------------------
RwImage_0 *__fastcall TextureImageReadAndSize(
        const RwChar *name,
        const RwChar *maskName,
        RwInt32 format,
        RwInt32 *rasterWidth,
        RwInt32 *rasterHeight,
        RwInt32 *rasterDepth,
        RwInt32 *rasterFlags)
{
  bool v11; // zf
  RwImage_0 *MaskedImage; // r6
  RwInt32 v13; // r0
  bool v14; // zf
  RwInt32 depth; // r8
  RwImage_0 *v16; // r5
  int v17; // r4
  RwImage_0 *v18; // r0
  RwImage_0 *v19; // r0
  RwImage_0 *v20; // r4
  RwInt32 v21; // r1
  RwImage_0 *v22; // r0
  RwError_0 v24; // [sp+Ch] [bp-22Ch] BYREF
  RwImage_0 *v25; // [sp+14h] [bp-224h] BYREF
  RwError_0 code; // [sp+18h] [bp-220h] BYREF
  char v27; // [sp+117h] [bp-121h]
  RwChar imageName[256]; // [sp+118h] [bp-120h] BYREF

  (*((void (__fastcall **)(RwChar *, const RwChar *, int))RwEngineInstance + 63))(imageName, name, 256);
  if ( (unsigned int)(*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(name) >= 0x100 )
  {
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483618, name, 256, 255, name[255]);
    RwErrorSet(&code);
    imageName[255] = 0;
  }
  if ( RwImageFindFileType(name) )
    (*((void (__fastcall **)(RwChar *))RwEngineInstance + 64))(imageName);
  v11 = maskName == 0;
  LOBYTE(code.pluginID) = 0;
  if ( maskName )
    v11 = *maskName == 0;
  if ( !v11 )
  {
    (*((void (__fastcall **)(RwError_0 *, const RwChar *, int))RwEngineInstance + 63))(&code, maskName, 256);
    if ( (unsigned int)(*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(maskName) >= 0x100 )
    {
      v24.pluginID = 0;
      v24.errorCode = _rwerror(-2147483618, maskName, 256, 255, maskName[255]);
      RwErrorSet(&v24);
      v27 = 0;
    }
    if ( RwImageFindFileType(maskName) )
      (*((void (__fastcall **)(RwError_0 *))RwEngineInstance + 64))(&code);
  }
  MaskedImage = RwImageReadMaskedImage(imageName, (const RwChar *)&code);
  v25 = MaskedImage;
  if ( !MaskedImage )
    return 0;
  v13 = *rasterWidth;
  v14 = *rasterWidth == 0;
  if ( *rasterWidth )
    v14 = *rasterHeight == 0;
  if ( !v14 )
  {
LABEL_19:
    if ( MaskedImage->width == v13 && MaskedImage->height == *rasterHeight )
      return v25;
    depth = MaskedImage->depth;
    if ( depth == 32 )
    {
      v16 = MaskedImage;
      goto LABEL_27;
    }
    v18 = RwImageCreate(MaskedImage->width, MaskedImage->height, 32);
    v16 = v18;
    v25 = v18;
    if ( v18 )
    {
      if ( RwImageAllocatePixels(v18) )
      {
        RwImageCopy(v16, MaskedImage);
        RwImageDestroy(MaskedImage);
        v13 = *rasterWidth;
LABEL_27:
        v19 = RwImageCreate(v13, *rasterHeight, 32);
        v20 = v19;
        if ( v19 )
        {
          if ( RwImageAllocatePixels(v19) )
          {
            RwImageResample(v20, v16);
            RwImageDestroy(v16);
            v25 = v20;
            if ( depth == 8 )
            {
              v21 = 8;
            }
            else
            {
              if ( depth != 4 )
                return v25;
              v21 = 4;
            }
            PalettizeImage(&v25, v21);
            return v25;
          }
          RwImageDestroy(v20);
          v22 = v16;
        }
        else
        {
          v22 = v16;
        }
        goto LABEL_37;
      }
      RwImageDestroy(v16);
    }
    v22 = MaskedImage;
LABEL_37:
    RwImageDestroy(v22);
    return 0;
  }
  if ( RwImageFindRasterFormat(MaskedImage, format, rasterWidth, rasterHeight, rasterDepth, rasterFlags) )
  {
    v13 = *rasterWidth;
    goto LABEL_19;
  }
  RwImageDestroy(MaskedImage);
  v17 = 0;
  v24.pluginID = 0;
  v24.errorCode = _rwerror(-2147483639);
  RwErrorSet(&v24);
  return (RwImage_0 *)v17;
}

//----- (001DCDBC) --------------------------------------------------------
RwBool __fastcall PalettizeMipmaps(
        RwRGBA_0 *MipPalette,
        RwImage_0 *sourceImage,
        RwImage_0 **mipArray,
        RwInt32 totalMipLevels,
        RwInt32 a5)
{
  RwImage_0 *v6; // r12
  RwRGBA_0 *v8; // r1
  int v9; // r2
  RwRGBA_0 *v10; // r4
  int v11; // r5
  int v12; // r5
  int v13; // r8
  RwImage_0 *v14; // r4
  RwImage_0 *v15; // r0
  RwImage_0 *v16; // r10
  rwPalQuant_0 pq; // [sp+14h] [bp-2Ch] BYREF

  v6 = *mipArray;
  v8 = (*mipArray)->palette;
  if ( v8 )
  {
    v9 = 1;
    if ( totalMipLevels >= 2 )
    {
      while ( 1 )
      {
        v10 = mipArray[v9]->palette;
        if ( !v10 )
          break;
        if ( a5 != 31 )
        {
          v11 = 0;
          while ( *(_DWORD *)&v8[v11] == *(_DWORD *)&v10[v11] )
          {
            if ( ++v11 >= 1 << a5 )
              goto LABEL_10;
          }
          v9 = 64;
        }
LABEL_10:
        if ( ++v9 >= totalMipLevels )
          goto LABEL_11;
      }
      if ( totalMipLevels != 64 )
        goto LABEL_14;
LABEL_12:
      qmemcpy(MipPalette, v8, 4 << v6->depth);
      return 1;
    }
LABEL_11:
    if ( v9 == totalMipLevels )
      goto LABEL_12;
  }
LABEL_14:
  if ( !_rwPalQuantInit(&pq) )
    return 0;
  if ( totalMipLevels >= 1 )
  {
    v12 = 0;
    do
      _rwPalQuantAddImage(&pq, mipArray[v12++], 1.0);
    while ( totalMipLevels != v12 );
    _rwPalQuantResolvePalette(MipPalette, 1 << a5, &pq);
    v13 = 0;
    while ( 1 )
    {
      v14 = mipArray[v13];
      v15 = RwImageCreate(v14->width, v14->height, a5);
      v16 = v15;
      if ( !v15 )
        return 0;
      RwImageAllocatePixels(v15);
      _rwPalQuantMatchImage(v16->cpPixels, v16->stride, v16->depth, 0, &pq, v14);
      v16->palette = MipPalette;
      mipArray[v13] = v16;
      if ( v14 != sourceImage )
        RwImageDestroy(v14);
      if ( ++v13 >= totalMipLevels )
        goto LABEL_26;
    }
  }
  _rwPalQuantResolvePalette(MipPalette, 1 << a5, &pq);
LABEL_26:
  _rwPalQuantTerm(&pq);
  return 1;
}
// 1DCE6A: conditional instruction was optimized away because r9.4>=1

//----- (001DCEE0) --------------------------------------------------------
void __fastcall PalettizeImage(RwImage_0 **image, RwInt32 depth)
{
  int v4; // r6
  RwImage_0 *v5; // r0
  RwImage_0 *v6; // r5
  rwPalQuant_0 pq; // [sp+8h] [bp-420h] BYREF
  RwRGBA_0 palette; // [sp+18h] [bp-410h] BYREF

  if ( _rwPalQuantInit(&pq) )
  {
    _rwPalQuantAddImage(&pq, *image, 1.0);
    v4 = 1 << depth;
    _rwPalQuantResolvePalette(&palette, 1 << depth, &pq);
    v5 = RwImageCreate((*image)->width, (*image)->height, depth);
    v6 = v5;
    if ( v5 )
    {
      RwImageAllocatePixels(v5);
      _rwPalQuantMatchImage(v6->cpPixels, v6->stride, v6->depth, 0, &pq, *image);
      qmemcpy(v6->palette, &palette, 4 * v4);
      RwImageDestroy(*image);
      *image = v6;
      _rwPalQuantTerm(&pq);
    }
  }
}

//----- (001DCF64) --------------------------------------------------------
void __fastcall _rwObjectHasFrameSetFrame(void *object, RwFrame_0 *frame)
{
  RwLLLink *v2; // r0

  if ( *((_DWORD *)object + 1) )
  {
    **((_DWORD **)object + 3) = *((_DWORD *)object + 2);
    *(_DWORD *)(*((_DWORD *)object + 2) + 4) = *((_DWORD *)object + 3);
  }
  *((_DWORD *)object + 1) = frame;
  if ( frame )
  {
    *((_DWORD *)object + 2) = frame->objectList.link.next;
    v2 = (RwLLLink *)((char *)object + 8);
    v2->prev = &frame->objectList.link;
    frame->objectList.link.next->prev = v2;
    frame->objectList.link.next = v2;
    sub_1928A8(frame);
  }
}

//----- (001DCF96) --------------------------------------------------------
void __fastcall _rwObjectHasFrameReleaseFrame(void *object)
{
  if ( *((_DWORD *)object + 1) )
  {
    **((_DWORD **)object + 3) = *((_DWORD *)object + 2);
    *(_DWORD *)(*((_DWORD *)object + 2) + 4) = *((_DWORD *)object + 3);
  }
}

//----- (001DCFAC) --------------------------------------------------------
void *__fastcall RwIm3DTransform(RwIm3DVertex *pVerts, RwUInt32 numVerts, RwMatrix *ltm, RwUInt32 flags)
{
  void *result; // r0
  RwError_0 v6; // [sp+0h] [bp-18h] BYREF

  if ( numVerts < 0x10001 )
  {
    *(_WORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 56) = numVerts;
    *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 60) = pVerts;
    *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 64) = 36;
    *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 72) = ltm;
    *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 68) = flags | 0x18;
    result = RxPipelineExecute(
               *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset),
               (char *)RwEngineInstance + rwIm3DModule.globalsOffset + 56,
               1);
    if ( result )
      return pVerts;
  }
  else
  {
    v6.errorCode = _rwerror(50, numVerts, ltm, flags, 0);
    RwErrorSet(&v6);
    return 0;
  }
  return result;
}

//----- (001DD03C) --------------------------------------------------------
RwBool RwIm3DEnd()
{
  _QWORD *v1; // r0

  if ( !*(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 60) )
    return 0;
  v1 = (char *)RwEngineInstance + rwIm3DModule.globalsOffset + 56;
  *(_QWORD *)((char *)v1 + 44) = 0LL;
  *(_QWORD *)((char *)v1 + 52) = 0LL;
  v1[4] = 0LL;
  v1[5] = 0LL;
  *v1 = 0LL;
  v1[1] = 0LL;
  v1 += 2;
  *v1 = 0LL;
  v1[1] = 0LL;
  return 1;
}

//----- (001DD084) --------------------------------------------------------
RwBool __fastcall RwIm3DRenderIndexedPrimitive(
        RwPrimitiveType_0 primType,
        RwImVertexIndex *indices,
        RwInt32 numIndices)
{
  _DWORD *v3; // r4
  _DWORD *v4; // r4
  RxPipeline_0 *v5; // r0
  RwError_0 v7[2]; // [sp+0h] [bp-10h] BYREF

  if ( *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 60) )
  {
    v3 = (char *)RwEngineInstance + rwIm3DModule.globalsOffset + 56;
    v3[11] = 0;
    v3[12] = primType;
    v3[13] = indices;
    v3[14] = numIndices;
    v4 = v3 + 3;
    switch ( primType )
    {
      case rwPRIMTYPELINELIST:
        v5 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 16);
        v4[11] = (numIndices + ((unsigned int)numIndices >> 31)) & 0xFFFFFFFE;
        goto LABEL_10;
      case rwPRIMTYPEPOLYLINE:
        v5 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 20);
        goto LABEL_10;
      case rwPRIMTYPETRILIST:
        v5 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 4);
        v4[11] = 3 * (numIndices / 3);
        goto LABEL_10;
      case rwPRIMTYPETRISTRIP:
        v5 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 12);
        goto LABEL_10;
      case rwPRIMTYPETRIFAN:
        v5 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 8);
LABEL_10:
        v4[8] = v5;
        break;
      default:
        v7[0].pluginID = 0;
        v7[0].errorCode = _rwerror(37, primType);
        RwErrorSet(v7);
        v5 = (RxPipeline_0 *)v4[8];
        break;
    }
    if ( RxPipelineExecute(v5, v4, 0) )
      return 1;
  }
  else
  {
    v7[0].errorCode = _rwerror(35, indices, numIndices, primType, 0);
    RwErrorSet(v7);
  }
  return 0;
}

//----- (001DD1C4) --------------------------------------------------------
RwBool __fastcall RwIm3DRenderPrimitive(RwPrimitiveType_0 primType)
{
  int v2; // r4
  _DWORD *v3; // r3
  _DWORD *v4; // r4
  RxPipeline_0 *v5; // r0
  RwError_0 v7[2]; // [sp+0h] [bp-10h] BYREF

  v2 = *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 60);
  RxHeapGetGlobalHeap();
  if ( v2 )
  {
    v3 = (char *)RwEngineInstance + rwIm3DModule.globalsOffset;
    v4 = (char *)RwEngineInstance + rwIm3DModule.globalsOffset + 68;
    v3[25] = 0;
    v3[26] = primType;
    v3[27] = 0;
    v3[28] = *(unsigned __int16 *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 56);
    switch ( primType )
    {
      case rwPRIMTYPELINELIST:
        v5 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 16);
        goto LABEL_10;
      case rwPRIMTYPEPOLYLINE:
        v5 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 20);
        goto LABEL_10;
      case rwPRIMTYPETRILIST:
        v5 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 4);
        goto LABEL_10;
      case rwPRIMTYPETRISTRIP:
        v5 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 12);
        goto LABEL_10;
      case rwPRIMTYPETRIFAN:
        v5 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 8);
LABEL_10:
        v4[8] = v5;
        break;
      default:
        v7[0].pluginID = 0;
        v7[0].errorCode = _rwerror(37, primType);
        RwErrorSet(v7);
        v5 = (RxPipeline_0 *)v4[8];
        break;
    }
    if ( RxPipelineExecute(v5, v4, 0) )
      return 1;
  }
  else
  {
    v7[0].pluginID = 0;
    v7[0].errorCode = _rwerror(35);
    RwErrorSet(v7);
  }
  return 0;
}

//----- (001DD308) --------------------------------------------------------
RwBool __fastcall RwIm3DRenderTriangle(RwInt32 vert1, RwInt32 vert2, RwInt32 vert3)
{
  __int16 v3; // r9
  __int16 v4; // r4
  __int16 v5; // r8
  int v6; // r6
  RxHeap_0 *GlobalHeap; // r0
  RxHeap_0 *v8; // r5
  char *v9; // r6
  _WORD *v10; // r0
  RxPipeline_0 *v11; // r4
  RwError_0 v13; // [sp+0h] [bp-20h] BYREF

  v3 = vert2;
  v4 = vert1;
  v5 = vert3;
  v6 = *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 60);
  GlobalHeap = RxHeapGetGlobalHeap();
  v8 = GlobalHeap;
  if ( v6 )
  {
    v9 = (char *)RwEngineInstance + rwIm3DModule.globalsOffset;
    *((_DWORD *)v9 + 25) = *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 4);
    *((_DWORD *)v9 + 26) = 3;
    *((_DWORD *)v9 + 27) = 0;
    *((_DWORD *)v9 + 28) = 3;
    v10 = RxHeapAlloc(GlobalHeap, 6u);
    *((_DWORD *)v9 + 27) = v10;
    *v10 = v4;
    *(_WORD *)(*((_DWORD *)v9 + 27) + 2) = v3;
    *(_WORD *)(*((_DWORD *)v9 + 27) + 4) = v5;
    v11 = RxPipelineExecute(*((RxPipeline_0 **)v9 + 25), v9 + 68, 0);
    RxHeapFree(v8, *((void **)v9 + 27));
    if ( v11 )
      return 1;
  }
  else
  {
    v13.pluginID = 0;
    v13.errorCode = _rwerror(35);
    RwErrorSet(&v13);
  }
  return 0;
}

//----- (001DD3B4) --------------------------------------------------------
RwBool __fastcall RwIm3DRenderLine(RwInt32 vert1, RwInt32 vert2)
{
  __int16 v2; // r8
  __int16 v3; // r6
  RxHeap_0 *GlobalHeap; // r9
  char *v5; // r5
  RwBool v6; // r4
  _WORD *v7; // r0
  RxPipeline_0 *v8; // r6
  RwError_0 v10; // [sp+0h] [bp-20h] BYREF

  v2 = vert2;
  v3 = vert1;
  GlobalHeap = RxHeapGetGlobalHeap();
  v5 = (char *)RwEngineInstance + rwIm3DModule.globalsOffset;
  if ( *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 60) )
  {
    v6 = 1;
    *((_DWORD *)v5 + 25) = *((_DWORD *)v5 + 4);
    *((_DWORD *)v5 + 26) = 1;
    *((_DWORD *)v5 + 27) = 0;
    *((_DWORD *)v5 + 28) = 2;
    v7 = RxHeapAlloc(GlobalHeap, 4u);
    *((_DWORD *)v5 + 27) = v7;
    *v7 = v3;
    *(_WORD *)(*((_DWORD *)v5 + 27) + 2) = v2;
    v8 = RxPipelineExecute(*((RxPipeline_0 **)v5 + 25), v5 + 68, 0);
    RxHeapFree(GlobalHeap, *((void **)v5 + 27));
    if ( !v8 )
      return 0;
  }
  else
  {
    v10.pluginID = 0;
    v10.errorCode = _rwerror(35);
    RwErrorSet(&v10);
    return 0;
  }
  return v6;
}

//----- (001DD448) --------------------------------------------------------
RxPipeline_0 *RwIm3DGetTransformPipeline()
{
  return *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset);
}

//----- (001DD464) --------------------------------------------------------
RxPipeline_0 *__fastcall RwIm3DGetRenderPipeline(RwPrimitiveType_0 primType)
{
  RxPipeline_0 *v1; // r4
  RwError_0 v3; // [sp+0h] [bp-10h] BYREF

  switch ( primType )
  {
    case rwPRIMTYPELINELIST:
      v1 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 16);
      break;
    case rwPRIMTYPEPOLYLINE:
      v1 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 20);
      break;
    case rwPRIMTYPETRILIST:
      v1 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 4);
      break;
    case rwPRIMTYPETRISTRIP:
      v1 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 12);
      break;
    case rwPRIMTYPETRIFAN:
      v1 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 8);
      break;
    case rwPRIMTYPEPOINTLIST:
      v1 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 24);
      break;
    default:
      v1 = 0;
      v3.pluginID = 0;
      v3.errorCode = _rwerror(37);
      RwErrorSet(&v3);
      break;
  }
  return v1;
}

//----- (001DD548) --------------------------------------------------------
RxPipeline_0 *__fastcall RwIm3DSetTransformPipeline(RxPipeline_0 *pipeline)
{
  char *v1; // r1

  v1 = (char *)RwEngineInstance + rwIm3DModule.globalsOffset;
  if ( !pipeline )
    pipeline = (RxPipeline_0 *)*((_DWORD *)v1 + 7);
  *(_DWORD *)v1 = pipeline;
  return *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset);
}

//----- (001DD588) --------------------------------------------------------
RxPipeline_0 *__fastcall RwIm3DSetRenderPipeline(RxPipeline_0 *pipeline, RwPrimitiveType_0 primType)
{
  RxPipeline_0 *v2; // r4
  RwError_0 v4; // [sp+0h] [bp-10h] BYREF

  v2 = pipeline;
  if ( pipeline )
  {
    switch ( primType )
    {
      case rwPRIMTYPELINELIST:
        *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 16) = pipeline;
        break;
      case rwPRIMTYPEPOLYLINE:
        *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 20) = pipeline;
        break;
      case rwPRIMTYPETRILIST:
        *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 4) = pipeline;
        break;
      case rwPRIMTYPETRISTRIP:
        *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 12) = pipeline;
        break;
      case rwPRIMTYPETRIFAN:
        *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 8) = pipeline;
        break;
      case rwPRIMTYPEPOINTLIST:
        *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 24) = pipeline;
        break;
      default:
        goto LABEL_6;
    }
  }
  else
  {
    switch ( primType )
    {
      case rwPRIMTYPELINELIST:
        *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 16) = *(_DWORD *)((char *)RwEngineInstance
                                                                                            + rwIm3DModule.globalsOffset
                                                                                            + 44);
        v2 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 44);
        break;
      case rwPRIMTYPEPOLYLINE:
        *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 20) = *(_DWORD *)((char *)RwEngineInstance
                                                                                            + rwIm3DModule.globalsOffset
                                                                                            + 48);
        v2 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 48);
        break;
      case rwPRIMTYPETRILIST:
        *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 4) = *(_DWORD *)((char *)RwEngineInstance
                                                                                           + rwIm3DModule.globalsOffset
                                                                                           + 32);
        v2 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 4);
        break;
      case rwPRIMTYPETRISTRIP:
        *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 12) = *(_DWORD *)((char *)RwEngineInstance
                                                                                            + rwIm3DModule.globalsOffset
                                                                                            + 40);
        v2 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 40);
        break;
      case rwPRIMTYPETRIFAN:
        *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 8) = *(_DWORD *)((char *)RwEngineInstance
                                                                                           + rwIm3DModule.globalsOffset
                                                                                           + 36);
        v2 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 8);
        break;
      case rwPRIMTYPEPOINTLIST:
        *(_DWORD *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 24) = *(_DWORD *)((char *)RwEngineInstance
                                                                                            + rwIm3DModule.globalsOffset
                                                                                            + 52);
        v2 = *(RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 52);
        break;
      default:
LABEL_6:
        v2 = 0;
        v4.pluginID = 0;
        v4.errorCode = _rwerror(37);
        RwErrorSet(&v4);
        break;
    }
  }
  return v2;
}

//----- (001DD76C) --------------------------------------------------------
rwIm3DPool_0 *_rwIm3DGetPool()
{
  return (rwIm3DPool_0 *)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 56);
}

//----- (001DD78C) --------------------------------------------------------
void *__fastcall _rwIm3DClose(void *instance, RwInt32 offset, RwInt32 size)
{
  _rwIm3DDestroyPlatformRenderPipelines((rwIm3DRenderPipelines_0 *)((char *)RwEngineInstance
                                                                  + rwIm3DModule.globalsOffset
                                                                  + 32));
  _rwIm3DDestroyPlatformTransformPipeline((RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 28));
  --rwIm3DModule.numInstances;
  return instance;
}

//----- (001DD7D0) --------------------------------------------------------
void *__fastcall _rwIm3DOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  char *v4; // r4

  rwIm3DModule.globalsOffset = offset;
  v4 = (char *)RwEngineInstance + offset;
  rwIm3DGlobals = (rwImmediGlobals_0 *)((char *)RwEngineInstance + offset);
  ++rwIm3DModule.numInstances;
  *((_DWORD *)v4 + 28) = 0;
  *((_QWORD *)v4 + 12) = 0LL;
  *((_QWORD *)v4 + 13) = 0LL;
  *((_QWORD *)v4 + 10) = 0LL;
  *((_QWORD *)v4 + 11) = 0LL;
  *((_QWORD *)v4 + 8) = 0LL;
  *((_QWORD *)v4 + 9) = 0LL;
  *((_QWORD *)v4 + 6) = 0LL;
  *((_QWORD *)v4 + 7) = 0LL;
  *((_QWORD *)v4 + 4) = 0LL;
  *((_QWORD *)v4 + 5) = 0LL;
  *(_QWORD *)v4 = 0LL;
  *((_QWORD *)v4 + 1) = 0LL;
  v4 += 16;
  *(_QWORD *)v4 = 0LL;
  *((_QWORD *)v4 + 1) = 0LL;
  if ( !_rwIm3DCreatePlatformTransformPipeline((RxPipeline_0 **)((char *)RwEngineInstance + offset + 28))
    || !_rwIm3DCreatePlatformRenderPipelines((rwIm3DRenderPipelines_0 *)((char *)RwEngineInstance
                                                                       + rwIm3DModule.globalsOffset
                                                                       + 32)) )
  {
    _rwIm3DDestroyPlatformRenderPipelines((rwIm3DRenderPipelines_0 *)((char *)RwEngineInstance
                                                                    + rwIm3DModule.globalsOffset
                                                                    + 32));
    _rwIm3DDestroyPlatformTransformPipeline((RxPipeline_0 **)((char *)RwEngineInstance + rwIm3DModule.globalsOffset + 28));
    instance = 0;
    --rwIm3DModule.numInstances;
  }
  return instance;
}

//----- (001DD8A8) --------------------------------------------------------
void *__fastcall _rwRenderPipelineOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  rxPipelineGlobalsOffset = offset;
  if ( !_rxPipelineOpen() )
    return 0;
  return instance;
}

//----- (001DD8C8) --------------------------------------------------------
void *__fastcall _rwRenderPipelineClose(void *instance, RwInt32 offset, RwInt32 size)
{
  _rxPipelineClose();
  return instance;
}

//----- (001DD8D6) --------------------------------------------------------
RwBool _rwPipeAttach()
{
  return 1;
}

//----- (001DD8DC) --------------------------------------------------------
RwBool __fastcall _rwIm3DCreatePlatformTransformPipeline(RxPipeline_0 **globalPipe)
{
  RxPipeline_0 *v2; // r0
  RxPipeline_0 *v3; // r5
  RxPipeline_0 *v4; // r6
  RxNodeDefinition_0 *OpenGLImmInstance; // r0
  RxPipeline_0 *v6; // r0
  RxPipeline_0 *v7; // r0

  v2 = RxPipelineCreate();
  v3 = v2;
  if ( v2 )
  {
    v2->pluginId = 1;
    v4 = RxPipelineLock(v2);
    if ( v4 )
    {
      OpenGLImmInstance = RxNodeDefinitionGetOpenGLImmInstance();
      v3 = 0;
      v6 = RxLockedPipeAddFragment(v4, 0, OpenGLImmInstance, 0);
      v7 = RxLockedPipeUnlock(v6);
      if ( v7 )
      {
        *globalPipe = v7;
        RwIm3DSetTransformPipeline(v7);
        return 1;
      }
    }
    _rxPipelineDestroy(v3);
  }
  return 0;
}

//----- (001DD930) --------------------------------------------------------
RwBool __fastcall _rwIm3DCreatePlatformRenderPipelines(rwIm3DRenderPipelines_0 *globalPipes)
{
  RxPipeline_0 *v2; // r0
  RxPipeline_0 *v3; // r5
  RxPipeline_0 *v4; // r6
  RxNodeDefinition_0 *OpenGLSubmitNoLight; // r0
  RxPipeline_0 *v6; // r0
  RxPipeline_0 *v7; // r0
  RxPipeline_0 *v8; // r6
  RwBool v9; // r4

  v2 = RxPipelineCreate();
  v3 = v2;
  if ( !v2 )
    return 0;
  v2->pluginId = 1;
  v4 = RxPipelineLock(v2);
  if ( !v4
    || (OpenGLSubmitNoLight = RxNodeDefinitionGetOpenGLSubmitNoLight(),
        v3 = 0,
        v6 = RxLockedPipeAddFragment(v4, 0, OpenGLSubmitNoLight, 0),
        v7 = RxLockedPipeUnlock(v6),
        (v8 = v7) == 0) )
  {
    _rxPipelineDestroy(v3);
    return 0;
  }
  *(int32x4_t *)&globalPipes->triList = vdupq_n_s32((unsigned int)v7);
  globalPipes->polyLine = v7;
  RwIm3DSetRenderPipeline(v7, rwPRIMTYPETRILIST);
  RwIm3DSetRenderPipeline(v8, rwPRIMTYPETRIFAN);
  RwIm3DSetRenderPipeline(v8, rwPRIMTYPETRISTRIP);
  v9 = 1;
  RwIm3DSetRenderPipeline(v8, rwPRIMTYPELINELIST);
  RwIm3DSetRenderPipeline(v8, rwPRIMTYPEPOLYLINE);
  return v9;
}

//----- (001DD9B0) --------------------------------------------------------
void __fastcall _rwIm3DDestroyPlatformTransformPipeline(RxPipeline_0 **globalPipe)
{
  RwIm3DSetTransformPipeline(0);
  if ( *globalPipe )
  {
    _rxPipelineDestroy(*globalPipe);
    *globalPipe = 0;
  }
}

//----- (001DD9CE) --------------------------------------------------------
void __fastcall _rwIm3DDestroyPlatformRenderPipelines(rwIm3DRenderPipelines_0 *globalPipes)
{
  RwIm3DSetRenderPipeline(0, rwPRIMTYPETRILIST);
  RwIm3DSetRenderPipeline(0, rwPRIMTYPETRIFAN);
  RwIm3DSetRenderPipeline(0, rwPRIMTYPETRISTRIP);
  RwIm3DSetRenderPipeline(0, rwPRIMTYPELINELIST);
  RwIm3DSetRenderPipeline(0, rwPRIMTYPEPOLYLINE);
  if ( globalPipes->triList )
  {
    _rxPipelineDestroy(globalPipes->triList);
    *(_QWORD *)&globalPipes->triList = 0LL;
    *(_QWORD *)&globalPipes->triStrip = 0LL;
    globalPipes->polyLine = 0;
  }
}

//----- (001DDA20) --------------------------------------------------------
RxNodeDefinition_0 *RxNodeDefinitionGetOpenGLImmInstance()
{
  return &RxNodeDefinitionGetOpenGLImmInstance(void)::nodeOpenGLImmInstanceCSL;
}

//----- (001DDA2C) --------------------------------------------------------
RwBool __fastcall openGLImmInstanceNode(RxPipelineNodeInstance *self, const RxPipelineNodeParam_0 *params)
{
  openGLImmPool = (rwIm3DPool_0 *)params->dataParam;
  return 1;
}

//----- (001DDA3C) --------------------------------------------------------
RxNodeDefinition_0 *RxNodeDefinitionGetOpenGLSubmitNoLight()
{
  return &RxNodeDefinitionGetOpenGLSubmitNoLight(void)::nodeOpenGLSubmitNoLight;
}

//----- (001DDA48) --------------------------------------------------------
RwBool __fastcall openGLSubmitNoLightNode(RxPipelineNodeInstance *self, const RxPipelineNodeParam_0 *params)
{
  rwIm3DPool_0 *v2; // r4
  char *elements; // r10
  RwMatrix *ltm; // r0
  unsigned int v5; // r8
  RxVertexIndex *indices; // r6
  int v7; // r0
  RwUInt32 numIndices; // r4
  int v9; // t1
  const GLubyte *v10; // r5
  int v11; // r1
  int numElements; // r4
  int v13; // t1
  char *v14; // r5
  int flags_low; // r1
  RwUInt32 v16; // r4
  const GLubyte *v17; // r5
  const GLubyte *v18; // r5
  unsigned int v19; // r9
  const GLubyte *v20; // r5
  const GLubyte *v21; // r5
  const GLubyte *v22; // r5
  int v23; // r1
  int v24; // r4
  unsigned int v25; // r0
  unsigned int v26; // r5
  char *v27; // r5
  char *v28; // r5
  char *v29; // r5
  char *v30; // r5
  char *v31; // r5
  RwError_0 v33; // [sp+0h] [bp-20h] BYREF

  v2 = openGLImmPool;
  elements = (char *)openGLImmPool->elements;
  emu_glMatrixMode(0x1700u);
  ltm = v2->stash.ltm;
  if ( ltm )
  {
    v5 = ((ltm->flags & 0x20000) >> 17) ^ 1;
    if ( (ltm->flags & 0x20000) == 0 )
      emu_glPushAndLoadMatrix(&ltm->right.x);
  }
  else
  {
    v5 = 0;
  }
  indices = v2->stash.indices;
  emu_glBegin(openGLPrimConvTbl[v2->stash.primType]);
  if ( indices )
  {
    switch ( v2->stash.primType )
    {
      case rwPRIMTYPELINELIST:
        flags_low = LOBYTE(v2->stash.flags);
        v16 = v2->stash.numIndices >> 1;
        if ( flags_low << 31 )
        {
          if ( v16 << 16 )
          {
            do
            {
              v27 = &elements[36 * *indices];
              emu_glColor4ubv((const GLubyte *)v27 + 24);
              emu_glTexCoord2fv((const GLfloat *)v27 + 7);
              emu_glVertex3fv((const GLfloat *)v27);
              v28 = &elements[36 * indices[1]];
              emu_glColor4ubv((const GLubyte *)v28 + 24);
              emu_glTexCoord2fv((const GLfloat *)v28 + 7);
              emu_glVertex3fv((const GLfloat *)v28);
              --v16;
              indices += 2;
            }
            while ( (_WORD)v16 );
          }
        }
        else if ( v16 << 16 )
        {
          do
          {
            v17 = (const GLubyte *)&elements[36 * *indices];
            emu_glColor4ubv(v17 + 24);
            emu_glVertex3fv((const GLfloat *)v17);
            v18 = (const GLubyte *)&elements[36 * indices[1]];
            emu_glColor4ubv(v18 + 24);
            emu_glVertex3fv((const GLfloat *)v18);
            --v16;
            indices += 2;
          }
          while ( (_WORD)v16 );
        }
        break;
      case rwPRIMTYPEPOLYLINE:
      case rwPRIMTYPETRISTRIP:
      case rwPRIMTYPETRIFAN:
        v7 = LOBYTE(v2->stash.flags);
        numIndices = v2->stash.numIndices;
        if ( v7 << 31 )
        {
          if ( numIndices << 16 )
          {
            do
            {
              v13 = *indices++;
              v14 = &elements[36 * v13];
              emu_glColor4ubv((const GLubyte *)v14 + 24);
              emu_glTexCoord2fv((const GLfloat *)v14 + 7);
              emu_glVertex3fv((const GLfloat *)v14);
              --numIndices;
            }
            while ( (_WORD)numIndices );
          }
        }
        else if ( numIndices << 16 )
        {
          do
          {
            v9 = *indices++;
            v10 = (const GLubyte *)&elements[36 * v9];
            emu_glColor4ubv(v10 + 24);
            emu_glVertex3fv((const GLfloat *)v10);
            --numIndices;
          }
          while ( (_WORD)numIndices );
        }
        break;
      case rwPRIMTYPETRILIST:
        v19 = v2->stash.numIndices / 3;
        if ( LOBYTE(v2->stash.flags) << 31 )
        {
          if ( v19 << 16 )
          {
            do
            {
              v29 = &elements[36 * *indices];
              emu_glColor4ubv((const GLubyte *)v29 + 24);
              emu_glTexCoord2fv((const GLfloat *)v29 + 7);
              emu_glVertex3fv((const GLfloat *)v29);
              v30 = &elements[36 * indices[1]];
              emu_glColor4ubv((const GLubyte *)v30 + 24);
              emu_glTexCoord2fv((const GLfloat *)v30 + 7);
              emu_glVertex3fv((const GLfloat *)v30);
              v31 = &elements[36 * indices[2]];
              emu_glColor4ubv((const GLubyte *)v31 + 24);
              emu_glTexCoord2fv((const GLfloat *)v31 + 7);
              emu_glVertex3fv((const GLfloat *)v31);
              --v19;
              indices += 3;
            }
            while ( (_WORD)v19 );
          }
        }
        else if ( v19 << 16 )
        {
          do
          {
            v20 = (const GLubyte *)&elements[36 * *indices];
            emu_glColor4ubv(v20 + 24);
            emu_glVertex3fv((const GLfloat *)v20);
            v21 = (const GLubyte *)&elements[36 * indices[1]];
            emu_glColor4ubv(v21 + 24);
            emu_glVertex3fv((const GLfloat *)v21);
            v22 = (const GLubyte *)&elements[36 * indices[2]];
            emu_glColor4ubv(v22 + 24);
            emu_glVertex3fv((const GLfloat *)v22);
            --v19;
            indices += 3;
          }
          while ( (_WORD)v19 );
        }
        break;
      default:
        goto LABEL_17;
    }
  }
  else
  {
    switch ( v2->stash.primType )
    {
      case rwPRIMTYPELINELIST:
        v23 = LOBYTE(v2->stash.flags);
        v24 = openGLImmPool->numElements >> 1;
        if ( v23 << 31 )
        {
          if ( v24 )
          {
            do
            {
              emu_glColor4ubv((const GLubyte *)elements + 24);
              emu_glTexCoord2fv((const GLfloat *)elements + 7);
              emu_glVertex3fv((const GLfloat *)elements);
              emu_glColor4ubv((const GLubyte *)elements + 60);
              emu_glTexCoord2fv((const GLfloat *)elements + 16);
              emu_glVertex3fv((const GLfloat *)elements + 9);
              --v24;
              elements += 72;
            }
            while ( (_WORD)v24 );
          }
        }
        else if ( v24 )
        {
          do
          {
            emu_glColor4ubv((const GLubyte *)elements + 24);
            emu_glVertex3fv((const GLfloat *)elements);
            emu_glColor4ubv((const GLubyte *)elements + 60);
            emu_glVertex3fv((const GLfloat *)elements + 9);
            --v24;
            elements += 72;
          }
          while ( (_WORD)v24 );
        }
        break;
      case rwPRIMTYPEPOLYLINE:
      case rwPRIMTYPETRISTRIP:
      case rwPRIMTYPETRIFAN:
        v11 = LOBYTE(v2->stash.flags);
        numElements = openGLImmPool->numElements;
        if ( v11 << 31 )
        {
          if ( openGLImmPool->numElements )
          {
            do
            {
              emu_glColor4ubv((const GLubyte *)elements + 24);
              emu_glTexCoord2fv((const GLfloat *)elements + 7);
              emu_glVertex3fv((const GLfloat *)elements);
              --numElements;
              elements += 36;
            }
            while ( (_WORD)numElements );
          }
        }
        else if ( openGLImmPool->numElements )
        {
          do
          {
            emu_glColor4ubv((const GLubyte *)elements + 24);
            emu_glVertex3fv((const GLfloat *)elements);
            --numElements;
            elements += 36;
          }
          while ( (_WORD)numElements );
        }
        break;
      case rwPRIMTYPETRILIST:
        v25 = openGLImmPool->numElements;
        v26 = v25 / 3;
        if ( LOBYTE(v2->stash.flags) << 31 )
        {
          if ( v25 >= 3 )
          {
            do
            {
              emu_glColor4ubv((const GLubyte *)elements + 24);
              emu_glTexCoord2fv((const GLfloat *)elements + 7);
              emu_glVertex3fv((const GLfloat *)elements);
              emu_glColor4ubv((const GLubyte *)elements + 60);
              emu_glTexCoord2fv((const GLfloat *)elements + 16);
              emu_glVertex3fv((const GLfloat *)elements + 9);
              emu_glColor4ubv((const GLubyte *)elements + 96);
              emu_glTexCoord2fv((const GLfloat *)elements + 25);
              emu_glVertex3fv((const GLfloat *)elements + 18);
              --v26;
              elements += 108;
            }
            while ( (_WORD)v26 );
          }
        }
        else if ( v25 >= 3 )
        {
          do
          {
            emu_glColor4ubv((const GLubyte *)elements + 24);
            emu_glVertex3fv((const GLfloat *)elements);
            emu_glColor4ubv((const GLubyte *)elements + 60);
            emu_glVertex3fv((const GLfloat *)elements + 9);
            emu_glColor4ubv((const GLubyte *)elements + 96);
            emu_glVertex3fv((const GLfloat *)elements + 18);
            --v26;
            elements += 108;
          }
          while ( (_WORD)v26 );
        }
        break;
      default:
LABEL_17:
        v33.pluginID = 0;
        v33.errorCode = _rwerror(37);
        RwErrorSet(&v33);
        break;
    }
  }
  emu_glEnd();
  if ( v5 )
    emu_glPopMatrix();
  return 1;
}

//----- (001DDEB0) --------------------------------------------------------
RwBool __fastcall openGLSubmitNoLightNodeInit(RxNodeDefinition_0 *self)
{
  *(_QWORD *)openGLPrimConvTbl = 0LL;
  *(_QWORD *)&openGLPrimConvTbl[5] = 6LL;
  *(_QWORD *)&openGLPrimConvTbl[1] = 0x300000001LL;
  *(_QWORD *)&openGLPrimConvTbl[3] = 0x500000004LL;
  return 1;
}

//----- (001DDEF4) --------------------------------------------------------
void __fastcall _rxEmbeddedPacketBetweenPipelines(RxPipeline_0 *fromPipeline, RxPipeline_0 *toPipeline)
{
  RxPacket_0 *embeddedPacket; // r8
  RwUInt32 numInputRequirements; // r11
  RxPacket_0 *v5; // r9
  RwUInt32 i; // r2
  unsigned int numClusters; // r5
  RxPipelineRequiresCluster_0 *inputRequirements; // r1
  unsigned int v9; // r6
  RxPipelineCluster_0 **p_clusterRef; // r0
  char *v11; // r0
  _DWORD *v12; // r6
  __int64 *v13; // r3
  __int64 *v14; // r0
  __int64 v15; // d18
  __int64 v16; // d19
  RxPipelineRequiresCluster_0 *v17; // r1
  __int64 v18; // d16
  __int64 v19; // d17
  RxCluster_0 *v20; // r3
  RxPipelineCluster_0 **v21; // r5
  int v22; // r6
  void *v23; // r1

  if ( fromPipeline->embeddedPacketState >= rxPKST_INUSE )
  {
    numInputRequirements = toPipeline->numInputRequirements;
    embeddedPacket = toPipeline->embeddedPacket;
    v5 = fromPipeline->embeddedPacket;
    if ( numInputRequirements )
    {
      for ( i = 0; i < numInputRequirements; ++i )
      {
        numClusters = v5->numClusters;
        inputRequirements = toPipeline->inputRequirements;
        if ( v5->numClusters )
        {
          v9 = 0;
          p_clusterRef = &v5->clusters[0].clusterRef;
          do
          {
            if ( *p_clusterRef && (*p_clusterRef)->clusterRef == inputRequirements[i].clusterDef )
              break;
            ++v9;
            p_clusterRef += 7;
          }
          while ( v9 < numClusters );
          if ( v9 != numClusters )
          {
            v11 = (char *)v5 + 28 * v9;
            v12 = v11 + 24;
            if ( *((_DWORD *)v11 + 6) )
            {
              v13 = (__int64 *)(v11 + 20);
              v14 = (__int64 *)(v11 + 32);
              v15 = *v13;
              v16 = v13[1];
              v17 = &inputRequirements[i];
              v18 = *v14;
              v19 = v14[1];
              v20 = &embeddedPacket->clusters[v17->slotIndex];
              *(_QWORD *)&v20->flags = v15;
              *(_QWORD *)&v20->currentData = v16;
              v20 = (RxCluster_0 *)((char *)v20 + 12);
              *(_QWORD *)&v20->flags = v18;
              *(_QWORD *)&v20->currentData = v19;
              embeddedPacket->clusters[v17->slotIndex].clusterRef = toPipeline->nodes->slotClusterRefs[v17->slotIndex];
              *v12 = 0;
              numInputRequirements = toPipeline->numInputRequirements;
            }
          }
        }
      }
    }
    v21 = &v5->clusters[0].clusterRef;
    v5->pipeline->embeddedPacketState = rxPKST_UNUSED;
    v22 = -v5->numClusters;
    do
    {
      if ( *v21 )
      {
        v23 = *(v21 - 4);
        if ( v23 )
        {
          if ( (*(_BYTE *)(v21 - 5) & 2) == 0 )
            RxHeapFree(rxHeapGlobal, v23);
        }
        *(v21 - 5) = 0;
        *(v21 - 4) = 0;
        *(v21 - 2) = 0;
        *(v21 - 1) = 0;
        *v21 = 0;
      }
      v21 += 7;
      ++v22;
    }
    while ( v22 );
    v5->flags = 0;
    embeddedPacket->slotClusterRefs = toPipeline->nodes->slotClusterRefs;
    embeddedPacket->inputToClusterSlot = toPipeline->nodes->inputToClusterSlot;
    embeddedPacket->slotsContinue = toPipeline->nodes->slotsContinue;
    toPipeline->embeddedPacketState = rxPKST_PENDING;
  }
}

//----- (001DE034) --------------------------------------------------------
void __fastcall _rxPacketDestroy(RxPacket_0 *packet)
{
  RxPipelineCluster_0 **p_clusterRef; // r5
  int v3; // r6
  void *v4; // r1

  p_clusterRef = &packet->clusters[0].clusterRef;
  packet->pipeline->embeddedPacketState = rxPKST_UNUSED;
  v3 = -packet->numClusters;
  do
  {
    if ( *p_clusterRef )
    {
      v4 = *(p_clusterRef - 4);
      if ( v4 && (*(_BYTE *)(p_clusterRef - 5) & 2) == 0 )
        RxHeapFree(rxHeapGlobal, v4);
      *(p_clusterRef - 5) = 0;
      *(p_clusterRef - 4) = 0;
      *(p_clusterRef - 2) = 0;
      *(p_clusterRef - 1) = 0;
      *p_clusterRef = 0;
    }
    p_clusterRef += 7;
    ++v3;
  }
  while ( v3 );
  packet->flags = 0;
}

//----- (001DE094) --------------------------------------------------------
RxPipelineNode_0 *__fastcall _rxEmbeddedPacketBetweenNodes(
        RxPipeline_0 *pipeline,
        RxPipelineNode_0 *nodeFrom,
        RwUInt32 whichOutput)
{
  RwUInt32 v4; // r0
  RxPipelineNode_0 *v5; // r9
  RxPacket_0 *embeddedPacket; // r6
  int v7; // r10
  RwUInt32 *slotsContinue; // r0
  int numClusters; // r4
  RxPipeline_0 **i; // r5
  void *v11; // r1

  v4 = nodeFrom->outputs[whichOutput];
  if ( v4 == -1 )
    return 0;
  v5 = &pipeline->nodes[v4];
  if ( pipeline->embeddedPacketState >= rxPKST_INUSE )
  {
    embeddedPacket = pipeline->embeddedPacket;
    v7 = 1 << whichOutput;
    slotsContinue = embeddedPacket->slotsContinue;
    if ( (*slotsContinue & (1 << whichOutput)) == 0 )
    {
      numClusters = embeddedPacket->numClusters;
      for ( i = &embeddedPacket->pipeline + 7 * numClusters; ; i -= 7 )
      {
        if ( (slotsContinue[numClusters] & v7) == 0 && i[2] )
        {
          v11 = *(i - 2);
          if ( v11 && (*(_BYTE *)(i - 3) & 2) == 0 )
            RxHeapFree(rxHeapGlobal, v11);
          *(i - 3) = 0;
          *(i - 2) = 0;
          *i = 0;
          i[1] = 0;
          i[2] = 0;
        }
        if ( numClusters == 1 )
          break;
        --numClusters;
        slotsContinue = embeddedPacket->slotsContinue;
      }
    }
    embeddedPacket->inputToClusterSlot = v5->inputToClusterSlot;
    embeddedPacket->slotsContinue = v5->slotsContinue;
    embeddedPacket->slotClusterRefs = v5->slotClusterRefs;
    pipeline->embeddedPacketState = rxPKST_PENDING;
  }
  return v5;
}

//----- (001DE154) --------------------------------------------------------
RwBool _rxPipelineClose()
{
  if ( RxPipelineInstanced )
  {
    RwFreeListDestroy(*(RwFreeList_0 **)((char *)RwEngineInstance + rxPipelineGlobalsOffset));
    *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset) = 0;
    RxHeapDestroy(rxHeapGlobal);
    rxHeapGlobal = 0;
    RxPipelineInstanced = 0;
  }
  return 1;
}

//----- (001DE1B4) --------------------------------------------------------
void __fastcall RxPipelineSetFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rxPipesFreeListPreallocBlocks = numBlocksToPrealloc;
  _rxPipesFreeListBlockSize = blockSize;
}

//----- (001DE1CC) --------------------------------------------------------
RwBool _rxPipelineOpen()
{
  RwBool result; // r0

  if ( RxPipelineInstanced )
    return 0;
  rxHeapGlobal = RxHeapCreate(rxHeapInitialSize);
  if ( !rxHeapGlobal )
    return 0;
  *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset) = RwFreeListCreateAndPreallocateSpace(
                                                                      52,
                                                                      _rxPipesFreeListBlockSize,
                                                                      4,
                                                                      _rxPipesFreeListPreallocBlocks,
                                                                      &_rxPipesFreeList);
  if ( *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset) )
  {
    *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 56) = rxPipelineMaxNodes;
    RxRenderStateVectorSetDefaultRenderStateVector((RxRenderStateVector_0 *)((char *)RwEngineInstance
                                                                           + rxPipelineGlobalsOffset
                                                                           + 4));
    *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 52) = 0;
    *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 48) = 0;
    result = 1;
    RxPipelineInstanced = 1;
  }
  else
  {
    RxHeapDestroy(rxHeapGlobal);
    result = 0;
    rxHeapGlobal = 0;
  }
  return result;
}

//----- (001DE2C0) --------------------------------------------------------
RxPipelineNode_0 *__fastcall PipelineNodeDestroy(RxPipelineNode_0 *node, RxPipeline_0 *pipeline)
{
  RwUInt32 numNodes; // r2
  RwUInt32 *p_numNodes; // r9
  RxPipelineNode_0 *nodes; // r0
  unsigned int v7; // r5
  unsigned int v8; // r4
  int v9; // r0
  int v10; // r6
  RwUInt32 v11; // r1
  unsigned int v12; // r2
  char *v13; // r0
  unsigned int v14; // r2
  __int64 v15; // d16
  unsigned int v16; // r2
  unsigned int v17; // r0
  RxPipelineNode_0 *v18; // r1
  __int64 v19; // d16
  __int64 v20; // d17
  __int64 v21; // d20
  __int64 v22; // d21
  RxPipelineNode_0 *v23; // r1
  RxNodeDefinition_0 *nodeDef; // r0
  RxPipelineNodeTermFn pipelineNodeTerm; // r1
  RxNodeDefinition_0 *v26; // r0
  void (*nodeTerm)(void); // r1
  RwUInt32 *v28; // r10
  RwUInt32 v29; // t1
  RxPipelineNode_0 *v30; // r1
  unsigned int v31; // r0
  RwUInt32 v32; // r3
  RwUInt32 *outputs; // r6
  unsigned int v34; // r4
  int v35; // r1

  if ( pipeline->locked )
  {
    if ( node->initializationData )
    {
      (*((void (**)(void))RwEngineInstance + 76))();
      node->initializationData = 0;
      node->initializationDataSize = 0;
    }
    if ( !node->nodeDef->InputPipesCnt && node->nodeDef->editable )
    {
      (*((void (**)(void))RwEngineInstance + 76))();
      node->nodeDef = 0;
    }
    p_numNodes = &pipeline->numNodes;
    numNodes = pipeline->numNodes;
    nodes = pipeline->nodes;
    v7 = -858993459 * (((char *)node - (char *)nodes) >> 3);
    if ( v7 < numNodes - 1 )
    {
      v8 = -858993459 * (((char *)node - (char *)nodes) >> 3);
      v9 = (int)nodes
         + 1717986944 * (((char *)node - (char *)nodes) >> 3)
         + 40 * *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 56);
      do
      {
        v10 = v9 + 128;
        qmemcpy((void *)v9, (const void *)(v9 + 128), 0x80u);
        v11 = *p_numNodes;
        ++v8;
        v9 = v10;
        v12 = *p_numNodes - 1;
      }
      while ( v8 < v12 );
      if ( v7 < v12 )
      {
        v13 = (char *)pipeline->nodes + 168 * *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 56);
        v14 = v7;
        do
        {
          v15 = *(_QWORD *)(v13 + 12);
          ++v14;
          *((_DWORD *)v13 + 2) = *((_DWORD *)v13 + 5);
          *(_QWORD *)v13 = v15;
          v13 += 12;
          v11 = *p_numNodes;
        }
        while ( v14 < *p_numNodes - 1 );
      }
      if ( v7 < v11 - 1 )
      {
        v16 = v7;
        v17 = v7;
        do
        {
          ++v16;
          v18 = &pipeline->nodes[v17];
          v19 = *(_QWORD *)&v18[1].nodeDef;
          v20 = *(_QWORD *)&v18[1].outputs;
          v21 = *(_QWORD *)&v18[1].slotsContinue;
          v22 = *(_QWORD *)&v18[1].inputToClusterSlot;
          *(_QWORD *)&v18->initializationData = *(_QWORD *)&v18[1].initializationData;
          *(_QWORD *)&v18->nodeDef = v19;
          *(_QWORD *)&v18->outputs = v20;
          v18 = (RxPipelineNode_0 *)((char *)v18 + 16);
          *(_QWORD *)&v18->nodeDef = v21;
          *(_QWORD *)&v18->outputs = v22;
          pipeline->nodes[v17].outputs -= 32;
          v23 = &pipeline->nodes[v17++];
          --v23->topSortData;
          v11 = pipeline->numNodes;
        }
        while ( v16 < v11 - 1 );
      }
      if ( v11 == 1 )
      {
        numNodes = 1;
      }
      else
      {
        v30 = pipeline->nodes;
        v31 = 0;
        do
        {
          if ( v30[v31].numOutputs )
          {
            v32 = 0;
            do
            {
              outputs = v30[v31].outputs;
              v34 = outputs[v32];
              if ( v34 >= v7 )
              {
                v35 = v34 - 1;
                if ( v34 == v7 )
                  v35 = -1;
                outputs[v32] = v35;
                v30 = pipeline->nodes;
              }
              ++v32;
            }
            while ( v32 < v30[v31].numOutputs );
          }
          numNodes = *p_numNodes;
          ++v31;
        }
        while ( v31 < *p_numNodes - 1 );
      }
    }
    v28 = &pipeline->numNodes;
  }
  else
  {
    nodeDef = node->nodeDef;
    pipelineNodeTerm = node->nodeDef->nodeMethods.pipelineNodeTerm;
    if ( pipelineNodeTerm )
    {
      pipelineNodeTerm(node);
      nodeDef = node->nodeDef;
    }
    --nodeDef->InputPipesCnt;
    v26 = node->nodeDef;
    if ( !node->nodeDef->InputPipesCnt )
    {
      nodeTerm = (void (*)(void))v26->nodeMethods.nodeTerm;
      if ( nodeTerm )
      {
        nodeTerm();
        v26 = node->nodeDef;
      }
      if ( v26->editable )
      {
        (*((void (**)(void))RwEngineInstance + 76))();
        node->nodeDef = 0;
      }
    }
    if ( node->initializationData )
    {
      (*((void (**)(void))RwEngineInstance + 76))();
      node->initializationData = 0;
      node->initializationDataSize = 0;
    }
    node->initializationDataSize = 0;
    *(_QWORD *)&node->nodeDef = 0LL;
    *(_QWORD *)&node->outputs = 0LL;
    *(_QWORD *)&node->slotsContinue = 0LL;
    *(_QWORD *)&node->inputToClusterSlot = 0LL;
    node->initializationData = 0;
    v29 = pipeline->numNodes;
    v28 = &pipeline->numNodes;
    numNodes = v29;
  }
  *v28 = numNodes - 1;
  return node;
}

//----- (001DE504) --------------------------------------------------------
RxHeap_0 *RxHeapGetGlobalHeap()
{
  return rxHeapGlobal;
}

//----- (001DE514) --------------------------------------------------------
RxPacket_0 *__fastcall RxPacketCreate(RxPipelineNode_0 *self)
{
  RxPacket_0 *embeddedPacket; // r1

  embeddedPacket = rxExecCtxGlobal.pipeline->embeddedPacket;
  rxExecCtxGlobal.pipeline->embeddedPacketState = rxPKST_INUSE;
  embeddedPacket->inputToClusterSlot = self->inputToClusterSlot;
  embeddedPacket->slotsContinue = self->slotsContinue;
  embeddedPacket->slotClusterRefs = self->slotClusterRefs;
  return embeddedPacket;
}

//----- (001DE538) --------------------------------------------------------
RxCluster_0 *__fastcall RxClusterSetStride(RxCluster_0 *cluster, RwInt32 stride)
{
  cluster->stride = stride;
  return cluster;
}

//----- (001DE53C) --------------------------------------------------------
RxCluster_0 *__fastcall RxClusterSetExternalData(RxCluster_0 *cluster, void *data, RwInt32 stride, RwInt32 numElements)
{
  void *v6; // r1
  RwUInt16 v8; // r8
  bool v9; // zf
  RwUInt16 flags; // r0

  v6 = cluster->data;
  v8 = stride;
  v9 = v6 == 0;
  if ( v6 )
    v9 = v6 == data;
  if ( !v9 && (cluster->flags & 2) == 0 )
  {
    RxHeapFree(rxHeapGlobal, v6);
    cluster->data = 0;
  }
  cluster->stride = v8;
  flags = cluster->flags;
  cluster->data = data;
  cluster->currentData = data;
  cluster->numAlloced = numElements;
  cluster->numUsed = numElements;
  cluster->flags = flags | 3;
  return cluster;
}

//----- (001DE590) --------------------------------------------------------
RxCluster_0 *__fastcall RxClusterSetData(RxCluster_0 *cluster, void *data, RwInt32 stride, RwInt32 numElements)
{
  void *v6; // r1
  RwUInt16 v8; // r8
  bool v9; // zf
  RwUInt16 flags; // r0

  v6 = cluster->data;
  v8 = stride;
  v9 = v6 == 0;
  if ( v6 )
    v9 = v6 == data;
  if ( !v9 && (cluster->flags & 2) == 0 )
  {
    RxHeapFree(rxHeapGlobal, v6);
    cluster->data = 0;
  }
  cluster->stride = v8;
  flags = cluster->flags;
  cluster->data = data;
  cluster->currentData = data;
  cluster->numAlloced = numElements;
  cluster->numUsed = numElements;
  cluster->flags = flags | 1;
  return cluster;
}

//----- (001DE5E4) --------------------------------------------------------
RxCluster_0 *__fastcall RxClusterInitializeData(RxCluster_0 *cluster, RwUInt32 numElements, RwUInt16 stride)
{
  RwUInt32 v5; // r8
  void *data; // r1
  void *v8; // r0

  v5 = stride * numElements;
  data = cluster->data;
  if ( data && (cluster->flags & 2) == 0 )
    RxHeapFree(rxHeapGlobal, data);
  v8 = RxHeapAlloc(rxHeapGlobal, v5);
  cluster->data = v8;
  cluster->currentData = v8;
  cluster->numAlloced = numElements;
  cluster->numUsed = 0;
  LOWORD(v8) = cluster->flags;
  cluster->stride = stride;
  cluster->flags = (unsigned __int16)v8 | 1;
  return cluster;
}

//----- (001DE640) --------------------------------------------------------
RxCluster_0 *__fastcall RxClusterResizeData(RxCluster_0 *cluster, RwUInt32 numElements)
{
  void *v4; // r0
  RwUInt16 flags; // r1
  RwUInt32 numUsed; // r0
  bool v7; // cc
  RxCluster_0 *result; // r0

  v4 = RxHeapRealloc(rxHeapGlobal, cluster->data, cluster->stride * numElements, 1);
  flags = cluster->flags;
  cluster->data = v4;
  cluster->currentData = v4;
  numUsed = cluster->numUsed;
  cluster->flags = flags | 1;
  v7 = numUsed > numElements;
  result = cluster;
  if ( v7 )
    cluster->numUsed = numElements;
  cluster->numAlloced = numElements;
  return result;
}

//----- (001DE67C) --------------------------------------------------------
RxCluster_0 *__fastcall RxClusterDestroyData(RxCluster_0 *cluster)
{
  if ( (cluster->flags & 2) == 0 )
    RxHeapFree(rxHeapGlobal, cluster->data);
  cluster->data = 0;
  cluster->numAlloced = 0;
  cluster->numUsed = 0;
  cluster->flags = 0;
  return 0;
}

//----- (001DE6A8) --------------------------------------------------------
RxCluster_0 *__fastcall RxClusterLockWrite(RxPacket_0 *packet, RwUInt32 clusterIndex, RxPipelineNode_0 *node)
{
  RwUInt32 v3; // r1
  char *v4; // r6
  RxCluster_0 *v5; // r4
  RxPipelineCluster_0 *v6; // r0
  const void **v7; // r11
  RwUInt16 v8; // r0
  const void *v9; // r8
  __int64 v10; // kr00_8
  int v11; // r5
  void *v12; // r0

  v3 = packet->inputToClusterSlot[clusterIndex];
  if ( v3 == -1 )
    return 0;
  v4 = (char *)packet + 28 * v3;
  v5 = (RxCluster_0 *)(v4 + 20);
  if ( !*((_DWORD *)v4 + 10) )
  {
    v6 = packet->slotClusterRefs[v3];
    *((_DWORD *)v4 + 10) = v6;
    *((_DWORD *)v4 + 11) = v6->creationAttributes;
  }
  v7 = (const void **)(v4 + 24);
  v8 = v5->flags | 8;
  v5->flags = v8;
  if ( (v8 & 6) == 2 )
  {
    v9 = *v7;
    v10 = *((_QWORD *)v4 + 4);
    v5->flags = v8 & 0xFFFD;
    *v7 = 0;
    v11 = *((unsigned __int16 *)v4 + 11);
    v12 = RxHeapAlloc(rxHeapGlobal, v10 * v11);
    *v7 = v12;
    v5->flags |= 1u;
    *((_DWORD *)v4 + 7) = v12;
    *((_QWORD *)v4 + 4) = v10;
    *((_WORD *)v4 + 11) = v11;
    qmemcpy(v12, v9, HIDWORD(v10) * v11);
  }
  *((_DWORD *)v4 + 7) = *v7;
  return v5;
}

//----- (001DE756) --------------------------------------------------------
RwUInt32 __fastcall RxPipelineNodeSendConfigMsg(
        RxPipelineNode_0 *dest,
        RwUInt32 msg,
        RwUInt32 intparam,
        void *ptrparam)
{
  int (*configMsgHandler)(void); // r12

  if ( !dest )
    return -1;
  configMsgHandler = (int (*)(void))dest->nodeDef->nodeMethods.configMsgHandler;
  if ( configMsgHandler )
    return configMsgHandler();
  else
    return 0;
}

//----- (001DE774) --------------------------------------------------------
RxPipelineNode_0 *__fastcall RxPipelineNodeForAllConnectedOutputs(
        RxPipelineNode_0 *node,
        RxPipeline_0 *pipeline,
        RxPipelineNodeOutputCallBack callbackfn,
        void *callbackdata)
{
  bool v5; // zf
  RxPipeline_0 *v6; // r5
  RxPipelineNode_0 *result; // r0
  RxPipelineNode_0 *nodes; // r2
  bool v11; // cc
  RwUInt32 numOutputs; // r0
  int v13; // r6
  unsigned int v14; // r2

  v5 = node == 0;
  v6 = pipeline;
  result = 0;
  if ( !v5 )
    v5 = pipeline == 0;
  if ( !v5 )
  {
    nodes = pipeline->nodes;
    result = 0;
    if ( nodes <= node )
    {
      v11 = callbackfn != 0;
      if ( callbackfn )
      {
        pipeline = (RxPipeline_0 *)pipeline->numNodes;
        v11 = &nodes[(_DWORD)pipeline] > node;
      }
      if ( v11 )
      {
        numOutputs = node->numOutputs;
        if ( numOutputs )
        {
          v13 = 0;
          while ( 1 )
          {
            v14 = node->outputs[v13];
            if ( v14 < (unsigned int)pipeline )
            {
              if ( !(int)callbackfn(node, &v6->nodes[v14], callbackdata) )
                return node;
              numOutputs = node->numOutputs;
            }
            if ( ++v13 >= numOutputs )
              break;
            pipeline = (RxPipeline_0 *)v6->numNodes;
          }
        }
        return node;
      }
    }
  }
  return result;
}

//----- (001DE7E4) --------------------------------------------------------
RxPipelineCluster_0 *__fastcall RxPipelineNodeGetPipelineCluster(
        RxPipelineNode_0 *node,
        RwUInt32 clustersOfInterestIndex)
{
  bool v2; // cc
  RwUInt32 v4; // r1

  v2 = node != 0;
  if ( node )
    v2 = node->nodeDef->io.numClustersOfInterest > clustersOfInterestIndex;
  if ( !v2 )
    return 0;
  v4 = node->inputToClusterSlot[clustersOfInterestIndex];
  if ( v4 == -1 )
    return 0;
  else
    return node->slotClusterRefs[v4];
}

//----- (001DE80A) --------------------------------------------------------
RwUInt32 __fastcall RxPipelineClusterGetCreationAttributes(RxPipelineCluster_0 *cluster)
{
  if ( cluster )
    return cluster->creationAttributes;
  else
    return -1;
}

//----- (001DE816) --------------------------------------------------------
RxPipelineCluster_0 *__fastcall RxPipelineClusterSetCreationAttributes(
        RxPipelineCluster_0 *cluster,
        RwUInt32 creationAttributes)
{
  if ( !cluster )
    return 0;
  cluster->creationAttributes = creationAttributes;
  return cluster;
}

//----- (001DE820) --------------------------------------------------------
RwUInt32 __fastcall RxClusterGetAttributes(RxCluster_0 *cluster)
{
  if ( cluster )
    return cluster->attributes;
  else
    return -1;
}

//----- (001DE82C) --------------------------------------------------------
RxCluster_0 *__fastcall RxClusterSetAttributes(RxCluster_0 *cluster, RwUInt32 attributes)
{
  if ( !cluster )
    return 0;
  cluster->attributes = attributes;
  return cluster;
}

//----- (001DE838) --------------------------------------------------------
RxPipeline_0 *__fastcall RxPipelineExecute(RxPipeline_0 *pipeline, void *data, RwBool heapReset)
{
  RxPipelineNode_0 *nodes; // r0
  RxPacket_0 *embeddedPacket; // r0

  if ( heapReset && rxHeapGlobal->dirty )
    _rxHeapReset(rxHeapGlobal);
  rxExecCtxGlobal.pipeline = pipeline;
  rxExecCtxGlobal.exitCode = 1;
  rxExecCtxGlobal.params.heap = rxHeapGlobal;
  rxExecCtxGlobal.params.dataParam = data;
  nodes = pipeline->nodes;
  pipeline->embeddedPacketState = rxPKST_PACKETLESS;
  if ( !nodes->nodeDef->nodeMethods.nodeBody(nodes, &rxExecCtxGlobal.params) )
    rxExecCtxGlobal.exitCode = 0;
  if ( pipeline->embeddedPacketState >= rxPKST_INUSE )
  {
    embeddedPacket = pipeline->embeddedPacket;
    pipeline->embeddedPacketState = rxPKST_INUSE;
    _rxPacketDestroy(embeddedPacket);
  }
  rxExecCtxGlobal.pipeline = 0;
  rxExecCtxGlobal.params.dataParam = 0;
  rxExecCtxGlobal.params.heap = 0;
  if ( !rxExecCtxGlobal.exitCode )
    return (RxPipeline_0 *)rxExecCtxGlobal.exitCode;
  return pipeline;
}

//----- (001DE8C4) --------------------------------------------------------
RxPipeline_0 *RxPipelineCreate()
{
  int v0; // r0
  int v1; // r4
  RwError_0 v3; // [sp+0h] [bp-10h] BYREF

  v0 = (*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                         + rxPipelineGlobalsOffset));
  v1 = v0;
  if ( v0 )
  {
    *(_DWORD *)(v0 + 48) = 0;
    *(_QWORD *)(v0 + 32) = 0LL;
    *(_QWORD *)(v0 + 40) = 0LL;
    *(_QWORD *)v0 = 0LL;
    *(_QWORD *)(v0 + 8) = 0LL;
    *(_QWORD *)(v0 + 16) = 0LL;
    *(_QWORD *)(v0 + 24) = 0LL;
  }
  else
  {
    v1 = 0;
    v3.pluginID = 0;
    v3.errorCode = _rwerror(-2147483629, 52);
    RwErrorSet(&v3);
  }
  return (RxPipeline_0 *)v1;
}

//----- (001DE928) --------------------------------------------------------
void __fastcall _rxPipelineDestroy(RxPipeline_0 *Pipeline)
{
  RwUInt32 numNodes; // r5
  RxPipelineNode_0 *nodes; // r0
  void *superBlock; // r0

  if ( Pipeline )
  {
    numNodes = Pipeline->numNodes;
    if ( numNodes )
    {
      nodes = Pipeline->nodes;
      do
      {
        --numNodes;
        nodes = PipelineNodeDestroy(nodes, Pipeline) + 1;
      }
      while ( numNodes );
    }
    superBlock = Pipeline->superBlock;
    Pipeline->nodes = 0;
    if ( superBlock )
    {
      (*((void (**)(void))RwEngineInstance + 76))();
      Pipeline->superBlock = 0;
      Pipeline->superBlockSize = 0;
    }
    (*((void (__fastcall **)(_DWORD, RxPipeline_0 *))RwEngineInstance + 80))(
      *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset),
      Pipeline);
  }
}

//----- (001DE98C) --------------------------------------------------------
void *__fastcall StalacTiteAlloc(RwUInt32 size)
{
  int v1; // r2
  void *v2; // r4
  RwError_0 v4; // [sp+0h] [bp-10h] BYREF

  v1 = gMemoryLimits;
  gMemoryLimits -= (size + 3) & 0xFFFFFFFC;
  v2 = (void *)gMemoryLimits;
  if ( gMemoryLimits < (unsigned int)gMemoryLimits )
  {
    v2 = 0;
    v4.pluginID = 0;
    gMemoryLimits = v1;
    v4.errorCode = _rwerror(-2147483629);
    RwErrorSet(&v4);
  }
  return v2;
}
// 6BD008: using guessed type int gMemoryLimits;
// 6BD00C: using guessed type int gMemoryLimits;

//----- (001DE9DC) --------------------------------------------------------
void *__fastcall StalacMiteAlloc(RwUInt32 size)
{
  void *v1; // r4
  RwError_0 v3; // [sp+0h] [bp-10h] BYREF

  v1 = (void *)gMemoryLimits;
  gMemoryLimits += (size + 3) & 0xFFFFFFFC;
  if ( gMemoryLimits > (unsigned int)gMemoryLimits )
  {
    gMemoryLimits = (int)v1;
    v1 = 0;
    v3.pluginID = 0;
    v3.errorCode = _rwerror(-2147483629);
    RwErrorSet(&v3);
  }
  return v1;
}
// 6BD008: using guessed type int gMemoryLimits;
// 6BD00C: using guessed type int gMemoryLimits;

//----- (001DEA2C) --------------------------------------------------------
RwUInt32 __fastcall PipelineCalcNumUniqueClusters(RxPipeline_0 *pipeline)
{
  RwUInt32 numNodes; // lr
  RwUInt32 v2; // r2
  unsigned int v3; // r10
  RwUInt32 v4; // r12
  RwUInt32 v5; // r9
  unsigned int v6; // r3
  RxNodeDefinition_0 *nodeDef; // r4
  RwUInt32 numClustersOfInterest; // r5
  RxClusterRef_0 *clustersOfInterest; // r6
  RwUInt32 i; // r4
  unsigned int v11; // r2
  unsigned int clusterDef; // t1
  unsigned int v13; // r1

  numNodes = pipeline->numNodes;
  v2 = 0;
  v3 = 0;
  do
  {
    v4 = v2;
    if ( !numNodes )
      break;
    v5 = 0;
    v6 = -1;
    do
    {
      nodeDef = pipeline->nodes[v5].nodeDef;
      numClustersOfInterest = nodeDef->io.numClustersOfInterest;
      if ( numClustersOfInterest )
      {
        clustersOfInterest = nodeDef->io.clustersOfInterest;
        for ( i = 0; i < numClustersOfInterest; ++i )
        {
          clusterDef = (unsigned int)clustersOfInterest->clusterDef;
          ++clustersOfInterest;
          v11 = clusterDef;
          v13 = v6;
          if ( clusterDef < v6 )
            v13 = v11;
          if ( v11 > v3 )
            v6 = v13;
        }
      }
      ++v5;
    }
    while ( v5 < numNodes );
    v2 = v4 + 1;
    v3 = v6;
  }
  while ( v6 != -1 );
  return v4;
}

//----- (001DEA94) --------------------------------------------------------
RxNodeDefinition_0 *__fastcall RxPipelineNodeCloneDefinition(
        RxPipelineNode_0 *node,
        RxClusterDefinition_0 *cluster2add)
{
  RxNodeDefinition_0 *nodeDef; // r2
  RwUInt32 numClustersOfInterest; // r12
  bool v4; // zf
  RxClusterDefinition_0 **p_clusterDef; // lr
  RwUInt32 v6; // r2

  if ( node )
  {
    v4 = cluster2add == 0;
    if ( cluster2add )
    {
      nodeDef = node->nodeDef;
      numClustersOfInterest = node->nodeDef->io.numClustersOfInterest;
      v4 = numClustersOfInterest == 0;
    }
    if ( v4 )
      return _NodeClone(node, cluster2add);
    p_clusterDef = &nodeDef->io.clustersOfInterest->clusterDef;
    v6 = 0;
    while ( *p_clusterDef != cluster2add )
    {
      ++v6;
      p_clusterDef += 3;
      if ( v6 >= numClustersOfInterest )
        return _NodeClone(node, cluster2add);
    }
  }
  return 0;
}
// 1DEAAA: variable 'nodeDef' is possibly undefined
// 1DEAC0: variable 'numClustersOfInterest' is possibly undefined

//----- (001DEACC) --------------------------------------------------------
RxNodeDefinition_0 *__fastcall _NodeClone(RxPipelineNode_0 *node, RxClusterDefinition_0 *cluster2add)
{
  RxNodeDefinition_0 *nodeDef; // r8
  RwUInt32 numClustersOfInterest; // r5
  RwUInt32 numOutputs; // r9
  size_t v7; // r0
  unsigned int v8; // r6
  const char **outputs; // r5
  RwUInt32 i; // r4
  const char *v11; // t1
  _DWORD *v12; // r0
  _DWORD *v13; // r4
  _DWORD *v14; // r6
  size_t v15; // r11
  __int64 v16; // d16
  __int64 v17; // d17
  __int64 v18; // d18
  __int64 v19; // d19
  size_t v20; // r2
  char *v21; // r9
  int v22; // r5
  RxClusterDefinition_0 *v23; // r6
  int v24; // r1
  unsigned int j; // r0
  int v26; // r0
  char *v27; // r0
  RwUInt32 v28; // r1
  unsigned int v29; // r10
  int v30; // r9
  char *v31; // r11
  size_t v32; // r5
  char *v33; // r5
  RxPipelineNode_0 *v35; // [sp+4h] [bp-34h]
  RwUInt32 v36; // [sp+8h] [bp-30h]
  RwUInt32 v37; // [sp+8h] [bp-30h]
  RxClusterDefinition_0 *v38; // [sp+Ch] [bp-2Ch]
  int v39; // [sp+10h] [bp-28h]
  RwError_0 code; // [sp+14h] [bp-24h] BYREF

  nodeDef = node->nodeDef;
  numClustersOfInterest = node->nodeDef->io.numClustersOfInterest;
  numOutputs = node->nodeDef->io.numOutputs;
  v7 = strlen((const char *)node->nodeDef->name) + 68;
  v38 = cluster2add;
  if ( cluster2add )
    ++numClustersOfInterest;
  v36 = numClustersOfInterest;
  v8 = (v7 & 0xFFFFFFFC) + 16 * numClustersOfInterest + 12 * numOutputs;
  v39 = 4 * numClustersOfInterest;
  if ( numOutputs )
  {
    outputs = (const char **)nodeDef->io.outputs;
    for ( i = 0; i < numOutputs; ++i )
    {
      v11 = *outputs;
      outputs += 3;
      v8 += v39 + ((strlen(v11) + 4) & 0xFFFFFFFC);
    }
  }
  v12 = (_DWORD *)(*((int (__fastcall **)(unsigned int))RwEngineInstance + 75))(v8);
  v13 = v12;
  if ( !v12 )
  {
    v13 = 0;
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483629, v8);
    RwErrorSet(&code);
    return (RxNodeDefinition_0 *)v13;
  }
  v14 = v12 + 16;
  v35 = node;
  *v12 = v12 + 16;
  v15 = strlen((const char *)nodeDef->name);
  strcpy((char *)v13 + 64, (const char *)nodeDef->name);
  v16 = *(_QWORD *)&nodeDef->nodeMethods.nodeBody;
  v17 = *(_QWORD *)&nodeDef->nodeMethods.nodeTerm;
  v18 = *(_QWORD *)&nodeDef->nodeMethods.pipelineNodeInit;
  v19 = *(_QWORD *)&nodeDef->nodeMethods.pipelineNodeConfig;
  v20 = (size_t)v14 + ((v15 + 4) & 0xFFFFFFFC);
  v21 = (char *)(v20 + 12 * v36);
  v13[8] = v36;
  v13[9] = v20;
  *((_QWORD *)v13 + 2) = v18;
  *((_QWORD *)v13 + 3) = v19;
  *(_QWORD *)(v13 + 1) = v16;
  *(_QWORD *)(v13 + 3) = v17;
  if ( nodeDef->io.numClustersOfInterest )
  {
    v23 = v38;
    v22 = v39;
    v24 = 0;
    for ( j = 1; ; ++j )
    {
      *(_DWORD *)(v20 + v24 * 12 + 4) = nodeDef->io.clustersOfInterest[v24].forcePresent;
      *(_DWORD *)(v13[9] + v24 * 12) = nodeDef->io.clustersOfInterest[v24].clusterDef;
      *(_DWORD *)(v13[9] + v24 * 12 + 8) = nodeDef->io.clustersOfInterest[v24].reserved;
      if ( j >= nodeDef->io.numClustersOfInterest )
        break;
      v20 = v13[9];
      ++v24;
    }
    if ( !v38 )
      goto LABEL_13;
  }
  else
  {
    v23 = v38;
    v22 = v39;
    j = 0;
    if ( !v38 )
      goto LABEL_13;
  }
  v26 = 3 * j;
  *(_DWORD *)(v13[9] + 4 * v26 + 4) = 0;
  *(_DWORD *)(v13[9] + 4 * v26) = v23;
  *(_DWORD *)(v13[9] + 4 * v26 + 8) = 0;
LABEL_13:
  v13[10] = v21;
  qmemcpy(v21, nodeDef->io.inputRequirements, 4 * nodeDef->io.numClustersOfInterest);
  v27 = &v21[v22];
  if ( v23 )
    *(_DWORD *)(v13[10] + 4 * v36 - 4) = 0;
  v13[11] = nodeDef->io.numOutputs;
  v13[12] = v27;
  v28 = nodeDef->io.numOutputs;
  if ( v28 )
  {
    v29 = 1;
    v30 = 0;
    v31 = &v27[12 * v28];
    v37 = v36 - 1;
    while ( 1 )
    {
      *(_DWORD *)&v27[v30 * 12] = v31;
      v32 = strlen((const char *)nodeDef->io.outputs[v30].name);
      strcpy(*(char **)(v13[12] + v30 * 12), (const char *)nodeDef->io.outputs[v30].name);
      v33 = &v31[(v32 + 4) & 0xFFFFFFFC];
      *(_DWORD *)(v13[12] + v30 * 12 + 4) = v33;
      qmemcpy(
        *(void **)(v13[12] + v30 * 12 + 4),
        nodeDef->io.outputs[v30].outputClusters,
        4 * nodeDef->io.numClustersOfInterest);
      if ( v38 )
        *(_DWORD *)(*(_DWORD *)(v13[12] + v30 * 12 + 4) + 4 * v37) = nodeDef->io.outputs[v30].allOtherClusters;
      *(_DWORD *)(v13[12] + v30 * 12 + 8) = nodeDef->io.outputs[v30].allOtherClusters;
      if ( v29 >= nodeDef->io.numOutputs )
        break;
      ++v30;
      ++v29;
      v31 = &v33[v39];
      v27 = (char *)v13[12];
    }
  }
  v13[13] = nodeDef->pipelineNodePrivateDataSize;
  v13[14] = 1;
  v13[15] = 0;
  if ( !nodeDef->InputPipesCnt && nodeDef->editable )
    (*((void (__fastcall **)(RxNodeDefinition_0 *))RwEngineInstance + 76))(nodeDef);
  v35->nodeDef = (RxNodeDefinition_0 *)v13;
  return (RxNodeDefinition_0 *)v13;
}

//----- (001DED50) --------------------------------------------------------
RwUInt32 *__fastcall RxPipelineNodeFindOutputByName(RxPipelineNode_0 *node, const RwChar *outputname)
{
  const RwChar *v3; // r11
  RwUInt32 *result; // r0
  bool v5; // zf
  int v6; // r10
  unsigned int v7; // r4
  int v8; // r9
  int v9; // r5

  v3 = outputname;
  result = 0;
  if ( node )
  {
    v5 = outputname == 0;
    if ( outputname )
    {
      outputname = (const RwChar *)node->nodeDef;
      v5 = node->nodeDef == 0;
    }
    if ( !v5 )
    {
      v6 = *((_DWORD *)outputname + 11);
      if ( v6 < 1 )
      {
        return 0;
      }
      else
      {
        v7 = 0;
        v8 = *((_DWORD *)outputname + 12);
        v9 = 0;
        while ( (*((int (__fastcall **)(_DWORD, const RwChar *))RwEngineInstance + 68))(*(_DWORD *)(v8 + 3 * v7), v3) )
        {
          ++v9;
          v7 += 4;
          if ( v9 >= v6 )
            return 0;
        }
        return &node->outputs[v7 / 4];
      }
    }
  }
  return result;
}

//----- (001DEDC0) --------------------------------------------------------
RwUInt32 *__fastcall RxPipelineNodeFindOutputByIndex(RxPipelineNode_0 *node, RwUInt32 outputindex)
{
  bool v2; // cc

  if ( !node )
    return 0;
  v2 = node->nodeDef != 0;
  if ( node->nodeDef )
    v2 = node->numOutputs > outputindex;
  if ( v2 )
    return &node->outputs[outputindex];
  else
    return 0;
}

//----- (001DEDDA) --------------------------------------------------------
RxPipelineNode_0 *__fastcall RxPipelineNodeFindInput(RxPipelineNode_0 *node)
{
  bool v1; // zf

  v1 = node == 0;
  if ( node )
    v1 = node->nodeDef == 0;
  if ( v1 )
    return 0;
  return node;
}

//----- (001DEDEA) --------------------------------------------------------
RxPipeline_0 *__fastcall RxPipelineNodeRequestCluster(
        RxPipeline_0 *pipeline,
        RxPipelineNode_0 *node,
        RxClusterDefinition_0 *clusterDef)
{
  RxNodeDefinition_0 *locked; // r3
  RxPipeline_0 *result; // r0
  bool v6; // zf
  bool v7; // zf
  RwUInt32 numClustersOfInterest; // r0
  RxClusterDefinition_0 **p_clusterDef; // r3
  RwUInt32 v10; // r4
  RxNodeDefinition_0 *v11; // r0

  result = 0;
  if ( pipeline )
  {
    v6 = node == 0;
    if ( node )
    {
      locked = (RxNodeDefinition_0 *)pipeline->locked;
      v6 = pipeline->locked == 0;
    }
    if ( !v6 )
    {
      v7 = clusterDef == 0;
      result = 0;
      if ( clusterDef )
      {
        locked = node->nodeDef;
        v7 = node->nodeDef == 0;
      }
      if ( !v7 )
      {
        numClustersOfInterest = locked->io.numClustersOfInterest;
        if ( numClustersOfInterest )
        {
          p_clusterDef = &locked->io.clustersOfInterest->clusterDef;
          v10 = 0;
          while ( *p_clusterDef != clusterDef )
          {
            ++v10;
            p_clusterDef += 3;
            if ( v10 >= numClustersOfInterest )
              goto LABEL_12;
          }
          return 0;
        }
LABEL_12:
        v11 = _NodeClone(node, clusterDef);
        if ( !v11 )
          return 0;
        v11->io.inputRequirements[v11->io.numClustersOfInterest - 1] = rxCLREQ_OPTIONAL;
        return pipeline;
      }
    }
  }
  return result;
}
// 1DEE10: variable 'locked' is possibly undefined

//----- (001DEE4E) --------------------------------------------------------
RxPipeline_0 *__fastcall RxPipelineNodeReplaceCluster(
        RxPipeline_0 *pipeline,
        RxPipelineNode_0 *node,
        RxClusterDefinition_0 *oldClusterDef,
        RxClusterDefinition_0 *newClusterDef)
{
  bool v5; // zf
  RxClusterDefinition_0 *v6; // r8
  RxPipeline_0 *v7; // r6
  bool v8; // zf
  bool v9; // zf
  RwChar *name; // r0
  RxClusterDefinition_0 **defaultStride; // r3
  RwChar *i; // r4
  RxNodeDefinition_0 *v13; // r0

  v5 = pipeline == 0;
  v6 = newClusterDef;
  v7 = 0;
  if ( pipeline )
    v5 = node == 0;
  if ( !v5 )
  {
    v8 = pipeline->locked == 0;
    if ( pipeline->locked )
    {
      v7 = 0;
      v8 = newClusterDef == 0;
    }
    if ( !v8 )
    {
      v9 = oldClusterDef == 0;
      if ( oldClusterDef )
      {
        newClusterDef = (RxClusterDefinition_0 *)node->nodeDef;
        v9 = node->nodeDef == 0;
      }
      if ( !v9 )
      {
        name = newClusterDef[2].name;
        if ( name )
        {
          defaultStride = (RxClusterDefinition_0 **)newClusterDef[2].defaultStride;
          for ( i = 0; i < name; ++i )
          {
            if ( *defaultStride == oldClusterDef )
              break;
            defaultStride += 3;
          }
        }
        else
        {
          i = 0;
        }
        v7 = 0;
        if ( i != name )
        {
          v13 = _NodeClone(node, 0);
          if ( v13 )
          {
            v13->io.clustersOfInterest[(_DWORD)i].clusterDef = v6;
            return pipeline;
          }
        }
      }
    }
  }
  return v7;
}

//----- (001DEEC0) --------------------------------------------------------
void *__fastcall RxPipelineNodeCreateInitData(RxPipelineNode_0 *node, RwUInt32 size)
{
  void *v4; // r6
  RwError_0 v6; // [sp+0h] [bp-18h] BYREF

  if ( node->initializationData )
  {
    (*((void (**)(void))RwEngineInstance + 76))();
    node->initializationData = 0;
    node->initializationDataSize = 0;
  }
  v4 = (void *)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(size);
  node->initializationData = v4;
  if ( v4 )
  {
    node->initializationDataSize = size;
  }
  else
  {
    v4 = 0;
    v6.pluginID = 0;
    v6.errorCode = _rwerror(-2147483629, size);
    RwErrorSet(&v6);
  }
  return v4;
}

//----- (001DEF2C) --------------------------------------------------------
void *__fastcall RxPipelineNodeGetInitData(RxPipelineNode_0 *node)
{
  return node->initializationData;
}

//----- (001DEF30) --------------------------------------------------------
RxPipeline_0 *__fastcall RxLockedPipeUnlock(RxPipeline_0 *pipeline)
{
  RwUInt32 numNodes; // r8
  RwUInt32 entryPoint; // r1
  RxPipelineNode_0 *nodes; // lr
  int v5; // r1
  unsigned int v6; // r3
  int v7; // r12
  int v8; // r5
  unsigned int v9; // r0
  RxNodeDefinition_0 *nodeDef; // r1
  RwUInt32 numClustersOfInterest; // r4
  RxClusterRef_0 *clustersOfInterest; // r2
  unsigned int v13; // r1
  unsigned int clusterDef; // t1
  unsigned int v15; // r6
  int v16; // r3
  int v17; // r0
  int v18; // r9
  RwUInt32 v19; // r1
  unsigned int v20; // r11
  RxPipelineNode_0 *v21; // r2
  int v22; // r4
  RxNodeDefinition_0 *v23; // t1
  RwUInt32 v24; // r2
  void *superBlock; // r3
  RxPipelineNodeTopSortData_0 **p_topSortData; // r1
  RwUInt32 numOutputs; // r3
  int v28; // r0
  bool v29; // zf
  RwUInt32 *outputs; // r1
  RxPipelineNodeTopSortData_0 *topSortData; // r0
  RwUInt32 v32; // r1
  RwInt32 v33; // r0
  RxPipeline_0 *v34; // r5
  RwInt32 v35; // r0
  RwInt32 v36; // r0
  RxPipelineNodeTopSortData_0 **v38; // r0
  RwUInt32 v39; // r3
  signed int v40; // r1
  unsigned int v41; // r2
  RxPipelineNode_0 *v42; // r0
  int v43; // r3
  int v44; // r2
  RxPipelineNode_0 *v45; // r8
  int v46; // r9
  int v47; // r0
  RxNodeDefinition_0 *v48; // r2
  __int64 v49; // d16
  RwBool (*v50)(RxNodeDefinition_0 *); // r3
  RwUInt32 v51; // r4
  int v52; // r6
  int v53; // r11
  RxPipelineNode_0 *v54; // r5
  int v55; // r1
  RxPipelineNode_0 *v56; // r1
  int v57; // r2
  RwBool v58; // r0
  RwUInt32 v59; // r1
  int v60; // r1
  RwUInt32 v61; // r2
  RwUInt32 v62; // r6
  int v63; // r4
  RxPipelineNode_0 *v64; // r8
  _DWORD *v65; // r5
  int v66; // r0
  int (__fastcall *v67)(_DWORD *); // r1
  int (__fastcall *v68)(char *); // r1
  bool v69; // cc
  int v70; // r4
  int v71; // r5
  RxPipelineNode_0 *v72; // r0
  int (__fastcall *pipelineNodeConfig)(char *, RxPipeline_0 *); // r2
  int v74; // r0
  void (__fastcall *v75)(_DWORD *); // r1
  RwUInt32 v76; // r0
  RwUInt32 v77; // r4
  int v78; // r6
  RxPipelineNode_0 *v79; // r0
  _DWORD *v80; // r5
  void (__fastcall *v81)(char *); // r1
  int v82; // r0
  void (__fastcall *v83)(_DWORD *); // r1
  RxPipelineNode_0 *v84; // r3
  int v85; // r2
  RxPipelineNode_0 *v86; // r0
  int v87; // r2
  int v88; // r3
  RxNodeDefinition_0 *v89; // r1
  int v90; // r3
  RxNodeDefinition_0 *v91; // r0
  int v92; // r1
  RwUInt32 v93; // r2
  RwError_0 code; // [sp+4h] [bp-2Ch] BYREF
  RwError_0 v95; // [sp+Ch] [bp-24h] BYREF

  if ( !pipeline )
  {
    v34 = 0;
    v95.pluginID = 0;
    v35 = _rwerror(-2147483626);
LABEL_51:
    v95.errorCode = v35;
    RwErrorSet(&v95);
    return v34;
  }
  if ( !pipeline->locked )
  {
    v34 = 0;
    v36 = 52;
LABEL_50:
    v95.pluginID = 0;
    v35 = _rwerror(v36);
    goto LABEL_51;
  }
  numNodes = pipeline->numNodes;
  if ( !numNodes )
    goto LABEL_99;
  entryPoint = pipeline->entryPoint;
  if ( entryPoint >= numNodes || (nodes = pipeline->nodes, !nodes[entryPoint].nodeDef) )
  {
    v34 = 0;
    v36 = 36;
    goto LABEL_50;
  }
  v5 = 0;
  v6 = 0;
  do
  {
    v7 = v5;
    v8 = 0;
    v9 = -1;
    do
    {
      nodeDef = nodes[v8].nodeDef;
      numClustersOfInterest = nodeDef->io.numClustersOfInterest;
      if ( numClustersOfInterest )
      {
        clustersOfInterest = nodeDef->io.clustersOfInterest;
        do
        {
          clusterDef = (unsigned int)clustersOfInterest->clusterDef;
          ++clustersOfInterest;
          v13 = clusterDef;
          v15 = v9;
          if ( clusterDef < v9 )
            v15 = v13;
          if ( v13 > v6 )
            v9 = v15;
          --numClustersOfInterest;
        }
        while ( numClustersOfInterest );
      }
      ++v8;
    }
    while ( v8 != numNodes );
    v5 = v7 + 1;
    v6 = v9;
  }
  while ( v9 != -1 );
  v16 = numNodes * ((8 * v7) | 4) + 20 * v7;
  v17 = *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 56);
  v19 = pipeline->numNodes;
  v20 = 180 * v17;
  v21 = pipeline->nodes;
  v22 = 12 * v17;
  do
  {
    v23 = v21->nodeDef;
    ++v21;
    --v19;
    v16 += v23->pipelineNodePrivateDataSize + 4 * v23->io.numClustersOfInterest;
  }
  while ( v19 );
  if ( v7 )
    v16 += 28 * v7 + 20;
  v18 = 4 * numNodes * nodes->numOutputs + 40 * numNodes;
  if ( v18 + v22 + 20 * numNodes + v16 + 52 * v7 * numNodes > v20 )
    v20 = v18 + v22 + 20 * numNodes + v16 + 52 * v7 * numNodes;
  if ( v20 > pipeline->superBlockSize )
  {
    if ( !ReallocAndFixupSuperBlock(pipeline, v20) )
      return 0;
    nodes = pipeline->nodes;
    numNodes = pipeline->numNodes;
  }
  v24 = 0;
  superBlock = pipeline->superBlock;
  gMemoryLimits = 0;
  gMemoryLimits = (int)superBlock + v20;
  v95.pluginID = (RwInt32)pipeline;
  v95.errorCode = 0;
  if ( numNodes )
  {
    p_topSortData = &nodes->topSortData;
    numOutputs = 0;
    do
    {
      v28 = (int)*(p_topSortData - 7);
      ++numOutputs;
      if ( v28 )
      {
        (*p_topSortData)->numInsVisited = 0;
        (*p_topSortData)->numIns = 0;
      }
      p_topSortData += 10;
      if ( v28 )
        numNodes = pipeline->numNodes;
    }
    while ( numOutputs < numNodes );
    nodes = pipeline->nodes;
    v24 = 0;
    if ( numNodes )
    {
      do
      {
        v29 = nodes->nodeDef == 0;
        if ( nodes->nodeDef )
        {
          numOutputs = nodes->numOutputs;
          v29 = numOutputs == 0;
        }
        if ( !v29 )
        {
          outputs = nodes->outputs;
          do
          {
            if ( *outputs != -1 )
            {
              topSortData = pipeline->nodes[*outputs].topSortData;
              ++topSortData->numIns;
            }
            --numOutputs;
            ++outputs;
          }
          while ( numOutputs );
          numNodes = pipeline->numNodes;
        }
        ++v24;
        ++nodes;
      }
      while ( v24 < numNodes );
      nodes = pipeline->nodes;
      v24 = numNodes;
    }
  }
  v32 = pipeline->entryPoint;
  if ( nodes[v32].topSortData->numIns )
  {
    code.pluginID = 0;
    v33 = _rwerror(36);
LABEL_46:
    code.errorCode = v33;
    RwErrorSet(&code);
    return 0;
  }
  if ( v24 )
  {
    v38 = &nodes->topSortData;
    v39 = 0;
    while ( v32 == v39 || (*v38)->numIns )
    {
      ++v39;
      v38 += 10;
      if ( v39 >= v24 )
        goto LABEL_58;
    }
    code.pluginID = 0;
    v33 = _rwerror(34);
    goto LABEL_46;
  }
LABEL_58:
  PipelineTopSort((TopSortData *)&v95, v32);
  v40 = pipeline->numNodes;
  if ( v40 )
  {
    v41 = 0;
    v42 = pipeline->nodes;
    v43 = 28;
    while ( **(RxNodeBodyFn **)((char *)&v42->nodeDef + v43) == (*(RxNodeDefinition_0 **)((char *)&v42->nodeDef + v43))->nodeMethods.nodeBody )
    {
      ++v41;
      v43 += 40;
      if ( v41 >= v40 )
      {
        pipeline->entryPoint = 0;
        goto LABEL_64;
      }
    }
    code.pluginID = 0;
    v33 = _rwerror(28);
    goto LABEL_46;
  }
  pipeline->entryPoint = 0;
  v42 = pipeline->nodes;
LABEL_64:
  v44 = *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 56);
  v45 = &v42[v44];
  v46 = (int)v45 + 128 * v44 + 12 * v40 - 12;
  if ( v40 - 1 >= 0 )
  {
    v47 = 40 * v40 - 12;
    v48 = (RxNodeDefinition_0 *)((char *)pipeline->superBlock + v20 - 12);
    do
    {
      v49 = *(_QWORD *)v46;
      --v40;
      v50 = *(RwBool (**)(RxNodeDefinition_0 *))(v46 + 8);
      v46 -= 12;
      v48->nodeMethods.nodeInit = v50;
      *(_QWORD *)&v48->name = v49;
      *(RxNodeDefinition_0 **)((char *)&pipeline->nodes->nodeDef + v47) = v48;
      v47 -= 40;
      v48 = (RxNodeDefinition_0 *)((char *)v48 - 12);
    }
    while ( v40 > 0 );
    v42 = pipeline->nodes;
    v40 = pipeline->numNodes;
  }
  if ( v40 )
  {
    v51 = 0;
    v52 = 4;
    v53 = 0;
    v54 = &v42[v40];
    do
    {
      v55 = *(int *)((char *)&v42->nodeDef + v52);
      if ( v55 )
      {
        qmemcpy(v54, v45, 4 * v55);
        v42 = pipeline->nodes;
        v56 = v54;
      }
      else
      {
        v56 = 0;
      }
      ++v51;
      v45 = (RxPipelineNode_0 *)((char *)v45 + 128);
      *(RwUInt32 *)((char *)&v42->numOutputs + v52) = (RwUInt32)v56;
      v42 = pipeline->nodes;
      v57 = *(int *)((char *)&v42->nodeDef + v52);
      v52 += 40;
      v53 += v57;
      v54 = (RxPipelineNode_0 *)((char *)v54 + 4 * v57);
    }
    while ( v51 < pipeline->numNodes );
  }
  else
  {
    v53 = 0;
  }
  gMemoryLimits = v46;
  gMemoryLimits = (int)v45 + 4 * v53;
  if ( _rxChaseDependencies(pipeline) )
    return 0;
  v58 = ReallocAndFixupSuperBlock(pipeline, gMemoryLimits - (unsigned int)pipeline->superBlock);
  v59 = pipeline->numNodes;
  if ( v58 )
  {
    if ( v59 )
    {
      v60 = 28;
      v61 = 0;
      do
      {
        ++v61;
        *(RxNodeDefinition_0 **)((char *)&pipeline->nodes->nodeDef + v60) = 0;
        v60 += 40;
        v62 = pipeline->numNodes;
      }
      while ( v61 < v62 );
      if ( (int)(v62 - 1) >= 0 )
      {
        v63 = 40 * v62 - 40;
        while ( 1 )
        {
          v64 = pipeline->nodes;
          v65 = *(RxNodeDefinition_0 **)((char *)&v64->nodeDef + v63);
          v66 = v65[15];
          v65[15] = v66 + 1;
          if ( !v66 )
          {
            v67 = (int (__fastcall *)(_DWORD *))v65[2];
            if ( v67 )
            {
              if ( !v67(v65) )
                break;
            }
          }
          v68 = (int (__fastcall *)(char *))v65[4];
          if ( v68 && !v68((char *)v64 + v63) )
          {
            v74 = v65[15] - 1;
            v65[15] = v74;
            if ( !v74 )
            {
              v75 = (void (__fastcall *)(_DWORD *))v65[3];
              if ( v75 )
                v75(v65);
            }
            break;
          }
          v63 -= 40;
          v69 = (int)(v62 - 2) <= -1;
          --v62;
          if ( v69 )
          {
            v62 = pipeline->numNodes;
            goto LABEL_94;
          }
        }
        v59 = pipeline->numNodes;
        v76 = v59 - v62;
        goto LABEL_105;
      }
LABEL_94:
      v70 = v62 - 1;
      if ( (int)(v62 - 1) >= 0 )
      {
        v71 = 40 * v62 - 40;
        while ( 1 )
        {
          v72 = pipeline->nodes;
          pipelineNodeConfig = (int (__fastcall *)(char *, RxPipeline_0 *))(*(RxNodeDefinition_0 **)((char *)&v72->nodeDef + v71))->nodeMethods.pipelineNodeConfig;
          if ( pipelineNodeConfig )
          {
            if ( !pipelineNodeConfig((char *)v72 + v71, pipeline) )
              break;
          }
          --v70;
          v71 -= 40;
          if ( v70 <= -1 )
            goto LABEL_99;
        }
        v59 = pipeline->numNodes;
        v76 = v59;
LABEL_105:
        v77 = v59 - v76;
        if ( v59 - v76 < v59 )
        {
          v78 = 40 * v59 - 40 * v76;
          do
          {
            v79 = pipeline->nodes;
            v80 = *(RxNodeDefinition_0 **)((char *)&v79->nodeDef + v78);
            v81 = (void (__fastcall *)(char *))v80[5];
            if ( v81 )
              v81((char *)v79 + v78);
            v82 = v80[15] - 1;
            v80[15] = v82;
            if ( !v82 )
            {
              v83 = (void (__fastcall *)(_DWORD *))v80[3];
              if ( v83 )
                v83(v80);
            }
            v59 = pipeline->numNodes;
            ++v77;
            v78 += 40;
          }
          while ( v77 < v59 );
        }
        goto LABEL_113;
      }
    }
LABEL_99:
    v34 = pipeline;
    pipeline->locked = 0;
    return v34;
  }
LABEL_113:
  v84 = pipeline->nodes;
  v85 = *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 56);
  v86 = &v84[v85];
  if ( (int)(v59 - 1) >= 0 )
  {
    v84[v59 - 1].outputs = (RwUInt32 *)((char *)&v86[-3] + 128 * v59 - 8);
    v87 = v59 - 2;
    if ( (int)(v59 - 2) >= 0 )
    {
      v88 = 5 * v59;
      v89 = (RxNodeDefinition_0 *)((char *)&v86[-6] + 128 * v59 - 16);
      v90 = 8 * v88 - 72;
      do
      {
        --v87;
        *(RxNodeDefinition_0 **)((char *)&pipeline->nodes->nodeDef + v90) = v89;
        v90 -= 40;
        v89 -= 2;
      }
      while ( v87 > -1 );
    }
    v59 = pipeline->numNodes;
    v85 = *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 56);
  }
  if ( !v59 )
    return 0;
  v34 = 0;
  v91 = (RxNodeDefinition_0 *)((char *)v86 + 128 * v85);
  v92 = 28;
  v93 = 0;
  do
  {
    v91->name = 0;
    v91->nodeMethods.nodeBody = 0;
    ++v93;
    v91->nodeMethods.nodeInit = 0;
    *(RxNodeDefinition_0 **)((char *)&pipeline->nodes->nodeDef + v92) = v91;
    v91 = (RxNodeDefinition_0 *)((char *)v91 + 12);
    v92 += 40;
  }
  while ( v93 < pipeline->numNodes );
  return v34;
}
// 6BD008: using guessed type int gMemoryLimits;
// 6BD00C: using guessed type int gMemoryLimits;

//----- (001DF488) --------------------------------------------------------
RwBool __fastcall ReallocAndFixupSuperBlock(RxPipeline_0 *pipeline, RwUInt32 newSize)
{
  _BYTE *superBlock; // r6
  RxPipelineNode_0 *nodes; // r0
  RxPacket_0 *embeddedPacket; // r3
  int v7; // r1
  RwUInt32 numNodes; // r2
  RxPipelineRequiresCluster_0 *inputRequirements; // r3
  RwUInt32 v10; // r2
  int i; // r3
  RwUInt32 *outputs; // r5
  RxPipelineCluster_0 **slotClusterRefs; // r5
  RwUInt32 *slotsContinue; // r5
  char *privateData; // r5
  RwUInt32 *inputToClusterSlot; // r5
  RxPipelineNode_0 *v17; // r0
  RxPipelineNodeTopSortData_0 *topSortData; // r6
  RwBool v19; // r4
  RwError_0 v21; // [sp+0h] [bp-18h] BYREF

  superBlock = pipeline->superBlock;
  nodes = (RxPipelineNode_0 *)(*((int (__fastcall **)(_BYTE *))RwEngineInstance + 77))(superBlock);
  if ( nodes )
  {
    embeddedPacket = pipeline->embeddedPacket;
    v7 = (char *)nodes - superBlock;
    numNodes = pipeline->numNodes;
    pipeline->superBlock = nodes;
    pipeline->superBlockSize = newSize;
    pipeline->nodes = nodes;
    if ( embeddedPacket )
      pipeline->embeddedPacket = (RxPacket_0 *)((char *)embeddedPacket + v7);
    inputRequirements = pipeline->inputRequirements;
    if ( inputRequirements )
      pipeline->inputRequirements = (RxPipelineRequiresCluster_0 *)((char *)inputRequirements + v7);
    if ( numNodes )
    {
      v10 = numNodes - 1;
      for ( i = 0; ; ++i )
      {
        outputs = nodes[i].outputs;
        if ( outputs )
        {
          nodes[i].outputs = (RwUInt32 *)((char *)outputs + v7);
          nodes = pipeline->nodes;
        }
        slotClusterRefs = nodes[i].slotClusterRefs;
        if ( slotClusterRefs )
        {
          nodes[i].slotClusterRefs = (RxPipelineCluster_0 **)((char *)slotClusterRefs + v7);
          nodes = pipeline->nodes;
        }
        slotsContinue = nodes[i].slotsContinue;
        if ( slotsContinue )
        {
          nodes[i].slotsContinue = (RwUInt32 *)((char *)slotsContinue + v7);
          nodes = pipeline->nodes;
        }
        privateData = (char *)nodes[i].privateData;
        if ( privateData )
        {
          nodes[i].privateData = &privateData[v7];
          nodes = pipeline->nodes;
        }
        inputToClusterSlot = nodes[i].inputToClusterSlot;
        if ( inputToClusterSlot )
        {
          nodes[i].inputToClusterSlot = (RwUInt32 *)((char *)inputToClusterSlot + v7);
          nodes = pipeline->nodes;
        }
        v17 = &nodes[i];
        topSortData = v17->topSortData;
        if ( topSortData )
          v17->topSortData = (RxPipelineNodeTopSortData_0 *)((char *)topSortData + v7);
        if ( !v10 )
          break;
        nodes = pipeline->nodes;
        --v10;
      }
    }
    return 1;
  }
  else
  {
    v19 = 0;
    v21.pluginID = 0;
    v21.errorCode = _rwerror(-2147483629, newSize);
    RwErrorSet(&v21);
  }
  return v19;
}

//----- (001DF558) --------------------------------------------------------
RxPipeline_0 *__fastcall RxPipelineLock(RxPipeline_0 *pipeline)
{
  RxPipeline_0 *v1; // r9
  RxPipelineNode_0 *nodes; // r3
  int v4; // r1
  RwUInt32 v5; // r5
  RwUInt32 numNodes; // r2
  RxPipelineNode_0 *v7; // r0
  int v8; // r1
  int v9; // r3
  int v10; // r2
  int v11; // r3
  int v12; // r2
  RxNodeDefinition_0 *v13; // r0
  RwUInt32 v14; // r3
  int v15; // r0
  bool v16; // zf
  unsigned int v17; // r6
  int i; // r5
  int v19; // r4
  void (__fastcall *v20)(int); // r1
  int v21; // r0
  int v22; // r1
  void (__fastcall *v23)(RxNodeDefinition_0 *); // r1
  RwError_0 v24; // [sp+0h] [bp-20h] BYREF

  v1 = pipeline;
  if ( !pipeline->locked )
  {
    nodes = pipeline->nodes;
    v4 = *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 56);
    v5 = 180 * v4;
    if ( nodes )
    {
      if ( v5 > pipeline->superBlockSize )
      {
        if ( !ReallocAndFixupSuperBlock(pipeline, 180 * v4) )
          return 0;
        nodes = v1->nodes;
        v4 = *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 56);
      }
      numNodes = v1->numNodes;
      v7 = &nodes[v4];
      if ( (int)(numNodes - 1) >= 0 )
      {
        nodes[numNodes - 1].outputs = (RwUInt32 *)((char *)&v7[-3] + 128 * numNodes - 8);
        v8 = numNodes - 2;
        if ( (int)(numNodes - 2) >= 0 )
        {
          v9 = 5 * numNodes;
          v10 = (int)&v7[-6] + 128 * numNodes - 16;
          v11 = 8 * v9 - 72;
          do
          {
            --v8;
            *(RxNodeDefinition_0 **)((char *)&v1->nodes->nodeDef + v11) = (RxNodeDefinition_0 *)v10;
            v11 -= 40;
            v10 -= 128;
          }
          while ( v8 > -1 );
        }
        numNodes = v1->numNodes;
        v4 = *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 56);
      }
      if ( numNodes )
      {
        v12 = 28;
        v13 = (RxNodeDefinition_0 *)((char *)v7 + 128 * v4);
        v14 = 0;
        do
        {
          v13->name = 0;
          v13->nodeMethods.nodeBody = 0;
          ++v14;
          v13->nodeMethods.nodeInit = 0;
          *(RxNodeDefinition_0 **)((char *)&v1->nodes->nodeDef + v12) = v13;
          v13 = (RxNodeDefinition_0 *)((char *)v13 + 12);
          v12 += 40;
        }
        while ( v14 < v1->numNodes );
      }
      v15 = (int)v1->nodes;
    }
    else
    {
      v15 = (*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(v5);
      v1->superBlock = (void *)v15;
      if ( !v15 )
      {
        v1 = 0;
        v24.pluginID = 0;
        v24.errorCode = _rwerror(-2147483629, v5);
        RwErrorSet(&v24);
        return v1;
      }
      v1->nodes = (RxPipelineNode_0 *)v15;
      v1->superBlockSize = v5;
    }
    v16 = v15 == 0;
    v1->locked = 1;
    if ( v15 )
      v16 = v1->numNodes == 0;
    if ( !v16 )
    {
      v17 = 1;
      for ( i = 0; ; ++i )
      {
        v19 = *(_DWORD *)(v15 + i * 40);
        v20 = *(void (__fastcall **)(int))(v19 + 20);
        if ( v20 )
        {
          v20(v15 + i * 40);
          v15 = (int)v1->nodes;
        }
        v21 = *(_DWORD *)(v15 + i * 40);
        v22 = *(_DWORD *)(v21 + 60) - 1;
        *(_DWORD *)(v21 + 60) = v22;
        if ( !v22 )
        {
          v23 = *(void (__fastcall **)(RxNodeDefinition_0 *))(v19 + 12);
          if ( v23 )
            v23(v1->nodes[i].nodeDef);
        }
        v1->nodes[i].slotClusterRefs = 0;
        if ( v17 >= v1->numNodes )
          break;
        ++v17;
        v15 = (int)v1->nodes;
      }
    }
  }
  return v1;
}

//----- (001DF714) --------------------------------------------------------
RxPipeline_0 *__fastcall RxPipelineClone(RxPipeline_0 *pipeline)
{
  RxPipeline_0 *v2; // r11
  RxPipeline_0 *v4; // r0
  RwUInt32 numNodes; // r0
  int v6; // r6
  int v7; // r5
  char *v8; // r0
  char *v9; // r1
  __int64 v10; // d16
  __int64 v11; // d17
  __int64 v12; // d18
  __int64 v13; // d19
  __int64 v14; // d20
  char *v15; // r0
  char *v16; // r1
  void *v17; // r0
  RxPipelineNode_0 *nodes; // r10
  RwUInt32 v19; // r0
  int v20; // r8
  int v21; // r4
  int v22; // r5
  int v23; // r1
  RxPipelineNode_0 *v24; // r0
  int v25; // r6
  const void *v26; // r1
  int v27; // r1
  int v28; // r2
  RwUInt32 v29; // r3
  RxNodeDefinition_0 *v30; // r0
  RwError_0 code; // [sp+4h] [bp-24h] BYREF

  if ( pipeline )
  {
    if ( !pipeline->locked )
    {
      v4 = RxPipelineCreate();
      v2 = v4;
      if ( v4 )
      {
        v4->pluginId = pipeline->pluginId;
        v4->pluginData = pipeline->pluginData;
        if ( !pipeline->numNodes )
          return v2;
        if ( !RxPipelineLock(v4) )
          goto LABEL_31;
        if ( v2 != pipeline )
        {
          numNodes = pipeline->numNodes;
          v6 = numNodes - 1;
          if ( (int)(numNodes - 1) >= 0 )
          {
            v7 = 40 * numNodes - 20;
            while ( 1 )
            {
              v8 = (char *)pipeline->nodes + v7;
              v9 = (char *)v2->nodes + v7;
              v10 = *(_QWORD *)(v8 - 20);
              v11 = *(_QWORD *)(v8 - 12);
              v12 = *(_QWORD *)(v8 - 4);
              v13 = *(_QWORD *)(v8 + 4);
              v14 = *(_QWORD *)(v8 + 12);
              v15 = v9 - 20;
              *(_QWORD *)(v9 - 4) = v12;
              *(_QWORD *)(v9 + 4) = v13;
              *(_QWORD *)v15 = v10;
              *((_QWORD *)v15 + 1) = v11;
              *(_QWORD *)(v9 + 12) = v14;
              *(_DWORD *)((char *)v2->nodes + v7 - 8) = 0;
              *(_DWORD *)((char *)v2->nodes + v7 - 4) = 0;
              *(RxNodeDefinition_0 **)((char *)&v2->nodes->nodeDef + v7) = 0;
              *(RwUInt32 *)((char *)&v2->nodes->numOutputs + v7) = 0;
              if ( *(RwUInt32 **)((char *)&v2->nodes->slotsContinue + v7) )
              {
                *(RxPipelineCluster_0 ***)((char *)&v2->nodes->slotClusterRefs + v7) = (RxPipelineCluster_0 **)(*((int (**)(void))RwEngineInstance + 75))();
                v16 = (char *)v2->nodes + v7;
                v17 = (void *)*((_DWORD *)v16 + 3);
                if ( !v17 )
                {
                  code.pluginID = 0;
                  code.errorCode = _rwerror(-2147483629, *((_DWORD *)v16 + 4));
                  RwErrorSet(&code);
                  goto LABEL_31;
                }
                qmemcpy(v17, *(const void **)((char *)&pipeline->nodes->slotClusterRefs + v7), *((_DWORD *)v16 + 4));
              }
              --v6;
              v7 -= 40;
              if ( v6 <= -1 )
              {
                numNodes = pipeline->numNodes;
                break;
              }
            }
          }
          v2->numNodes = numNodes;
        }
        nodes = v2->nodes;
        v19 = pipeline->numNodes;
        v20 = *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 56);
        if ( (int)(v19 - 1) < 0 )
        {
          v27 = *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 56);
          if ( !v19 )
          {
LABEL_28:
            if ( RxLockedPipeUnlock(v2) )
              return v2;
LABEL_31:
            _rxPipelineDestroy(v2);
            return 0;
          }
        }
        else
        {
          v21 = v19 - 2;
          v22 = 40 * v19 - 32;
          v23 = (int)nodes + 128 * v19 + 40 * v20;
          v24 = v2->nodes;
          v25 = v23 - 128;
          while ( 1 )
          {
            *(RxNodeDefinition_0 **)((char *)&v24->nodeDef + v22) = (RxNodeDefinition_0 *)v25;
            v26 = *(RxNodeDefinition_0 **)((char *)&pipeline->nodes->nodeDef + v22);
            if ( v26 )
              qmemcpy(*(void **)((char *)&v2->nodes->nodeDef + v22), v26, 0x80u);
            if ( v21 < 0 )
              break;
            v25 -= 128;
            v22 -= 40;
            v24 = v2->nodes;
            --v21;
          }
          v27 = *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 56);
          if ( !pipeline->numNodes )
            goto LABEL_28;
        }
        v28 = 28;
        v29 = 0;
        v30 = (RxNodeDefinition_0 *)((char *)nodes + 128 * v27 + 40 * v20);
        do
        {
          v30->name = 0;
          v30->nodeMethods.nodeBody = 0;
          ++v29;
          v30->nodeMethods.nodeInit = 0;
          *(RxNodeDefinition_0 **)((char *)&v2->nodes->nodeDef + v28) = v30;
          v30 = (RxNodeDefinition_0 *)((char *)v30 + 12);
          v28 += 40;
        }
        while ( v29 < pipeline->numNodes );
        goto LABEL_28;
      }
    }
  }
  return 0;
}

//----- (001DF928) --------------------------------------------------------
RxPipelineNode_0 *__fastcall RxPipelineFindNodeByName(
        RxPipeline_0 *pipeline,
        const RwChar *name,
        RxPipelineNode_0 *start,
        RwInt32 *nodeIndex)
{
  const RwChar *v5; // r9
  bool v6; // zf
  RxPipelineNode_0 *nodes; // r0
  const RwChar *v8; // r4
  RxPipelineNode_0 *v9; // r6
  bool v10; // cc

  v5 = name;
  if ( !pipeline )
    goto LABEL_16;
  v6 = name == 0;
  if ( name )
  {
    name = (const RwChar *)pipeline->numNodes;
    v6 = name == 0;
  }
  if ( v6 )
    goto LABEL_16;
  nodes = pipeline->nodes;
  if ( !start )
  {
    v9 = nodes;
    v8 = name;
    if ( (int)name >= 1 )
      goto LABEL_12;
    goto LABEL_16;
  }
  do
  {
    v8 = name - 1;
    v9 = nodes + 1;
    if ( start == nodes )
      break;
    v10 = (int)name <= 0;
    ++nodes;
    --name;
  }
  while ( !v10 );
  if ( (int)v8 < 1 )
  {
LABEL_16:
    v9 = 0;
    if ( nodeIndex )
      *nodeIndex = -1;
    return v9;
  }
LABEL_12:
  while ( !v9->nodeDef
       || (*((int (__fastcall **)(RwChar *, const RwChar *))RwEngineInstance + 68))(v9->nodeDef->name, v5) )
  {
    v10 = (int)v8-- <= 1;
    ++v9;
    if ( v10 )
      goto LABEL_16;
  }
  if ( nodeIndex )
    *nodeIndex = (RwInt32)v8;
  return v9;
}

//----- (001DF9B0) --------------------------------------------------------
RxPipelineNode_0 *__fastcall RxPipelineFindNodeByIndex(RxPipeline_0 *pipeline, RwUInt32 nodeindex)
{
  bool v2; // cc

  v2 = pipeline != 0;
  if ( pipeline )
    v2 = pipeline->numNodes > nodeindex;
  if ( v2 )
    return &pipeline->nodes[nodeindex];
  else
    return 0;
}

//----- (001DF9CC) --------------------------------------------------------
RxPipeline_0 *RxLockedPipeAddFragment(RxPipeline_0 *pipeline, RwUInt32 *firstIndex, RxNodeDefinition_0 *nodeDef0, ...)
{
  RxPipeline_0 *v3; // r4
  int v4; // r5
  va_list v5; // r6
  int v6; // r3
  RwUInt32 numNodes; // r12
  RwInt32 v8; // r0
  RwInt32 v9; // r0
  RxPipelineNode_0 *v10; // r8
  int v11; // r6
  int v12; // r11
  RxPipelineNode_0 *nodes; // r10
  RxPipelineNode_0 *v14; // r9
  unsigned int *outputs; // r0
  bool v16; // zf
  int v17; // r1
  bool v18; // zf
  bool v19; // zf
  unsigned int v20; // r1
  RwUInt32 v21; // r12
  RwUInt32 v22; // r0
  RxNodeDefinition_0 **ap; // r0
  int v24; // r5
  RwUInt32 v27; // [sp+8h] [bp-2Ch]
  RwError_0 code; // [sp+Ch] [bp-28h] BYREF
  va_list v29; // [sp+14h] [bp-20h]
  va_list va; // [sp+3Ch] [bp+8h] BYREF

  va_start(va, nodeDef0);
  v3 = pipeline;
  if ( !pipeline )
  {
    v3 = 0;
    code.pluginID = 0;
    v9 = _rwerror(-2147483626, firstIndex, nodeDef0);
LABEL_12:
    code.errorCode = v9;
    RwErrorSet(&code);
    return v3;
  }
  if ( !pipeline->locked )
  {
    v3 = 0;
    v8 = 52;
    goto LABEL_11;
  }
  va_copy(v29, va);
  if ( !nodeDef0 )
    return 0;
  v4 = 0;
  v5.__ap = (char *)v29.__ap + 4;
  do
  {
    v29.__ap = v5.__ap;
    --v4;
    v6 = *((_DWORD *)v5.__ap - 1);
    v5.__ap = (char *)v5.__ap + 4;
  }
  while ( v6 );
  if ( !v4 )
    return 0;
  numNodes = pipeline->numNodes;
  if ( numNodes - v4 > *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 56) )
  {
    v3 = 0;
    v8 = 42;
LABEL_11:
    code.pluginID = 0;
    v9 = _rwerror(v8, firstIndex, nodeDef0);
    goto LABEL_12;
  }
  va_copy(v29, va);
  v10 = 0;
  v11 = 0;
  v27 = numNodes;
  v12 = numNodes;
  while ( 1 )
  {
    nodes = v3->nodes;
    v14 = &nodes[v12];
    if ( !_NodeCreate(v3, &nodes[v12], nodeDef0) )
      goto LABEL_44;
    if ( !v10 )
      goto LABEL_36;
    if ( v10->nodeDef )
    {
      if ( v10->numOutputs )
        outputs = v10->outputs;
      else
        outputs = 0;
    }
    else
    {
      outputs = 0;
    }
    v16 = v14 == 0;
    if ( v14 )
      v16 = nodes[v12].nodeDef == 0;
    if ( v16 )
    {
      v17 = 0;
      if ( !outputs )
        break;
    }
    else
    {
      v17 = (int)&nodes[v12];
      if ( !outputs )
        break;
    }
    v18 = v3->locked == 0;
    if ( v3->locked )
      v18 = v17 == 0;
    if ( v18 || *outputs != -1 )
      break;
    v19 = *(_DWORD *)v17 == 0;
    if ( *(_DWORD *)v17 )
    {
      v17 -= (int)v3->nodes;
      v19 = v17 == -40;
    }
    if ( v19 )
      break;
    v20 = -858993459 * (v17 >> 3);
    if ( v20 >= v3->numNodes )
      break;
    *outputs = v20;
LABEL_36:
    v21 = v27;
    ++v12;
    v22 = v11 + v27;
    ++v11;
    v10 = &nodes[v22];
    ap = (RxNodeDefinition_0 **)v29.__ap;
    v29.__ap = (char *)v29.__ap + 4;
    nodeDef0 = *ap;
    if ( !*ap )
    {
      if ( !(v11 + v4) )
        goto LABEL_45;
      goto LABEL_38;
    }
  }
  PipelineNodeDestroy(&nodes[v12], v3);
LABEL_44:
  v21 = v27;
  if ( !(v11 + v4) )
  {
LABEL_45:
    if ( firstIndex )
      *firstIndex = v21;
    return v3;
  }
LABEL_38:
  if ( v11 )
  {
    v24 = 40 * (v11 + v21) - 40;
    do
    {
      PipelineNodeDestroy((RxPipelineNode_0 *)((char *)v3->nodes + v24), v3);
      v24 -= 40;
      --v11;
    }
    while ( v11 );
  }
  return 0;
}
// 1DFA56: conditional instruction was optimized away because r2.4!=0

//----- (001DFB6C) --------------------------------------------------------
RwBool __fastcall _NodeCreate(RxPipeline_0 *pipeline, RxPipelineNode_0 *node, RxNodeDefinition_0 *nodespec)
{
  RwUInt32 numOutputs; // r6
  RwBool v7; // r4
  RwInt32 v8; // r0
  char *v9; // r1
  RwUInt32 v10; // r3
  __int64 v11; // kr00_8
  int v12; // r3
  RwUInt32 v13; // r1
  __int64 v14; // kr08_8
  int v15; // r0
  RxPipelineNodeTopSortData_0 *v16; // r0
  RwError_0 v18[4]; // [sp+0h] [bp-20h] BYREF

  numOutputs = nodespec->io.numOutputs;
  v7 = 0;
  node->initializationData = 0;
  node->initializationDataSize = 0;
  *(_QWORD *)&node->nodeDef = 0LL;
  *(_QWORD *)&node->outputs = 0LL;
  *(_QWORD *)&node->slotsContinue = 0LL;
  *(_QWORD *)&node->inputToClusterSlot = 0LL;
  if ( numOutputs < 0x21 )
  {
    v7 = 1;
  }
  else
  {
    v18[0].pluginID = 0;
    v18[0].errorCode = _rwerror(41);
    RwErrorSet(v18);
  }
  if ( nodespec->io.numClustersOfInterest >= 0x21 )
  {
    v7 = 0;
    v18[0].pluginID = 0;
    v18[0].errorCode = _rwerror(40);
    RwErrorSet(v18);
  }
  v8 = rxPipelineGlobalsOffset;
  v9 = (char *)RwEngineInstance;
  v10 = *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 56);
  if ( numOutputs >= v10 )
  {
    v7 = 0;
    v18[0].pluginID = 0;
    v18[0].errorCode = _rwerror(42);
    RwErrorSet(v18);
  }
  else if ( v7 )
  {
    v11 = *(_QWORD *)&pipeline->numNodes;
    v12 = HIDWORD(v11) + 40 * v10;
    node->numOutputs = numOutputs;
    node->outputs = (RwUInt32 *)(v12 + ((_DWORD)v11 << 7));
    if ( numOutputs )
    {
      v13 = 0;
      do
        *(_DWORD *)(v12 + ((_DWORD)v11 << 7) + 4 * v13++) = -1;
      while ( v13 < node->numOutputs );
      v8 = rxPipelineGlobalsOffset;
      v9 = (char *)RwEngineInstance;
    }
    v14 = *(_QWORD *)&pipeline->numNodes;
    v15 = HIDWORD(v14) + 40 * *(_DWORD *)&v9[v8 + 56] + (*(_DWORD *)&v9[v8 + 56] << 7);
    *(_DWORD *)(v15 + 12 * v14) = 0;
    v16 = (RxPipelineNodeTopSortData_0 *)(v15 + 12 * v14);
    v16->numInsVisited = 0;
    v16->req = 0;
    node->topSortData = v16;
    node->initializationData = 0;
    node->initializationDataSize = 0;
    node->nodeDef = nodespec;
    ++pipeline->numNodes;
  }
  else
  {
    return 0;
  }
  return v7;
}

//----- (001DFC90) --------------------------------------------------------
RxPipeline_0 *__fastcall RxLockedPipeAddPath(RxPipeline_0 *pipeline, RwUInt32 *out, RxPipelineNode_0 *in)
{
  bool v4; // zf
  RxPipeline_0 *result; // r0
  bool v6; // zf
  int v7; // r2
  unsigned int v8; // r2

  v4 = pipeline == 0;
  result = 0;
  if ( !v4 )
    v4 = out == 0;
  if ( !v4 )
  {
    v6 = pipeline->locked == 0;
    if ( pipeline->locked )
    {
      result = 0;
      v6 = in == 0;
    }
    if ( !v6 && *out == -1 )
    {
      if ( in->nodeDef )
      {
        v7 = (char *)in - (char *)pipeline->nodes;
        result = 0;
        if ( v7 != -40 )
        {
          v8 = -858993459 * (v7 >> 3);
          if ( v8 < pipeline->numNodes )
          {
            *out = v8;
            return pipeline;
          }
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

//----- (001DFCF2) --------------------------------------------------------
RxPipeline_0 *__fastcall RxLockedPipeReplaceNode(
        RxPipeline_0 *pipeline,
        RxPipelineNode_0 *node,
        RxNodeDefinition_0 *nodeDef)
{
  RxPipeline_0 *result; // r0
  bool v6; // zf
  bool v7; // zf
  RxPipelineNode_0 *v8; // r9
  RwUInt32 numOutputs; // r1
  RxPipelineNode_0 *v10; // r0
  RwUInt32 v11; // r5
  RxPipelineNode_0 *nodes; // r0
  RwUInt32 v13; // r12
  int v14; // r1
  int v15; // r2
  RwUInt32 v16; // r5
  RwUInt32 *outputs; // r4

  result = 0;
  if ( pipeline )
  {
    v6 = node == 0;
    if ( node )
      v6 = pipeline->locked == 0;
    if ( !v6 )
    {
      v7 = nodeDef == 0;
      result = 0;
      if ( nodeDef )
        v7 = node->nodeDef == 0;
      if ( !v7 )
      {
        v8 = &pipeline->nodes[pipeline->numNodes];
        if ( _NodeCreate(pipeline, v8, nodeDef) )
        {
          numOutputs = v8->numOutputs;
          v10 = node;
          if ( numOutputs < node->numOutputs )
            v10 = v8;
          v11 = v10->numOutputs;
          if ( v11 )
          {
            qmemcpy(v8->outputs, node->outputs, 4 * v11);
            numOutputs = v8->numOutputs;
          }
          if ( numOutputs > v11 )
            memset(&node->outputs[v11], 255, 4 * (numOutputs - v11));
          if ( pipeline->numNodes )
          {
            nodes = pipeline->nodes;
            v13 = 0;
            v14 = -858993459 * (((char *)node - (char *)nodes) >> 3);
            v15 = -858993459 * (((char *)v8 - (char *)nodes) >> 3);
            do
            {
              if ( nodes[v13].numOutputs )
              {
                v16 = 0;
                do
                {
                  outputs = nodes[v13].outputs;
                  if ( outputs[v16] == v14 )
                  {
                    outputs[v16] = v15;
                    nodes = pipeline->nodes;
                  }
                  ++v16;
                }
                while ( v16 < nodes[v13].numOutputs );
              }
              ++v13;
            }
            while ( v13 < pipeline->numNodes );
          }
          PipelineNodeDestroy(node, pipeline);
          return pipeline;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

//----- (001DFDF2) --------------------------------------------------------
RxPipeline_0 *__fastcall RxLockedPipeDeleteNode(RxPipeline_0 *pipeline, RxPipelineNode_0 *node)
{
  RxPipeline_0 *result; // r0
  bool v4; // zf

  result = 0;
  if ( pipeline )
  {
    v4 = node == 0;
    if ( node )
      v4 = pipeline->locked == 0;
    if ( !v4 )
    {
      if ( node->nodeDef )
      {
        PipelineNodeDestroy(node, pipeline);
        return pipeline;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

//----- (001DFE1E) --------------------------------------------------------
RxPipeline_0 *__fastcall RxLockedPipeSetEntryPoint(RxPipeline_0 *pipeline, RxPipelineNode_0 *in)
{
  RxPipeline_0 *result; // r0
  bool v4; // zf
  int v5; // r1
  unsigned int v6; // r1

  result = 0;
  if ( pipeline )
  {
    v4 = in == 0;
    if ( in )
      v4 = pipeline->locked == 0;
    if ( !v4 )
    {
      if ( in->nodeDef )
      {
        v5 = (char *)in - (char *)pipeline->nodes;
        result = 0;
        if ( v5 != -40 )
        {
          v6 = -858993459 * (v5 >> 3);
          if ( v6 < pipeline->numNodes )
          {
            pipeline->entryPoint = v6;
            return pipeline;
          }
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

//----- (001DFE62) --------------------------------------------------------
RxPipelineNode_0 *__fastcall RxLockedPipeGetEntryPoint(RxPipeline_0 *pipeline)
{
  bool v1; // zf
  RwUInt32 entryPoint; // r1
  char v3; // cc

  v1 = pipeline == 0;
  if ( pipeline )
    v1 = pipeline->locked == 0;
  if ( v1 )
    return 0;
  entryPoint = pipeline->entryPoint;
  v3 = (entryPoint != -1) & __CFADD__(entryPoint, 1);
  if ( entryPoint != -1 )
    v3 = pipeline->numNodes > entryPoint;
  if ( v3 )
    return &pipeline->nodes[entryPoint];
  else
    return 0;
}

//----- (001DFE88) --------------------------------------------------------
RxPipeline_0 *__fastcall RxLockedPipeDeletePath(RxPipeline_0 *pipeline, RwUInt32 *out, RxPipelineNode_0 *in)
{
  bool v4; // zf
  RxPipeline_0 *result; // r0
  bool v6; // zf

  v4 = pipeline == 0;
  result = 0;
  if ( !v4 )
    v4 = in == 0;
  if ( !v4 )
  {
    v6 = out == 0;
    if ( out )
      v6 = pipeline->locked == 0;
    if ( !v6 )
    {
      if ( &pipeline->nodes[*out] == in )
      {
        *out = -1;
        return pipeline;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

//----- (001DFEC4) --------------------------------------------------------
RxPipeline_0 *__fastcall RxPipelineInsertDebugNode(
        RxPipeline_0 *pipeline,
        RxPipelineNode_0 *before,
        RxPipelineNode_0 *after,
        RxNodeDefinition_0 *debugNodeDef)
{
  bool v8; // zf
  RwUInt32 v9; // r5
  RxPipelineNode_0 *nodes; // r0
  int v11; // r0
  RwUInt32 v12; // r0
  bool v13; // zf
  RwUInt32 numOutputs; // r1
  RwUInt32 *outputs; // r2
  RwUInt32 v16; // r3
  int v17; // r6
  RwUInt32 packetNumClusterSlots; // r12
  unsigned int v19; // r11
  RwUInt32 i; // r1
  RxPipelineCluster_0 *v21; // r2
  RxClusterDefinition_0 *clusterRef; // r2
  unsigned int j; // r3
  bool v24; // zf
  RwUInt32 v25; // r1
  RxPipelineCluster_0 *v26; // r2
  RxClusterDefinition_0 *v27; // r2
  unsigned int k; // r3
  RxPipeline_0 *v29; // r0
  RxPipeline_0 *v30; // r0
  RxClusterDefinition_0 **nodeDef; // r2
  RxPipelineNode_0 *v32; // lr
  int m; // r10
  bool v34; // zf
  RxClusterDefinition_0 *v35; // r1
  bool v36; // zf
  RxClusterDefinition_0 *v37; // r0
  unsigned int v38; // r3
  RxNodeDefinition_0 *v39; // r0
  RxNodeDefinition_0 *v40; // r0
  RwUInt32 *v41; // r1
  bool v43; // zf
  bool v44; // zf
  RwUInt32 *v45; // r0
  bool v46; // zf
  bool v47; // zf
  int v48; // r1
  bool v49; // zf
  unsigned int v50; // r1
  RwUInt32 *v51; // r0
  bool v52; // zf
  int v53; // r1
  bool v54; // zf
  unsigned int v55; // r1
  RxPipeline_0 *v56; // [sp+0h] [bp-30h]
  RwError_0 code; // [sp+8h] [bp-28h] BYREF
  RwUInt32 firstIndex[8]; // [sp+10h] [bp-20h] BYREF

  if ( !pipeline )
    return 0;
  v8 = ((unsigned int)before | (unsigned int)after) == 0;
  v9 = 0;
  if ( (unsigned int)before | (unsigned int)after )
    v8 = debugNodeDef == 0;
  if ( !v8 )
  {
    firstIndex[0] = -1;
    if ( before )
    {
      nodes = pipeline->nodes;
      v9 = 0;
      if ( (char *)before - (char *)nodes == -40
        || -858993459 * (((char *)before - (char *)nodes) >> 3) >= pipeline->numNodes )
      {
        return (RxPipeline_0 *)v9;
      }
    }
    else
    {
      nodes = pipeline->nodes;
      if ( nodes != after )
        return 0;
    }
    if ( after )
    {
      v11 = (char *)after - (char *)nodes;
      v9 = 0;
      if ( v11 == -40 )
        return (RxPipeline_0 *)v9;
      v12 = -858993459 * (v11 >> 3);
      if ( v12 >= pipeline->numNodes )
        return (RxPipeline_0 *)v9;
    }
    else
    {
      if ( before->numOutputs )
        return 0;
      v12 = -1;
    }
    v13 = before == 0;
    v9 = -1;
    if ( before )
      v13 = after == 0;
    if ( v13 )
      goto LABEL_127;
    numOutputs = before->numOutputs;
    v9 = 0;
    if ( !numOutputs )
      return (RxPipeline_0 *)v9;
    outputs = before->outputs;
    v16 = 1;
    if ( *outputs == v12 )
      v16 = numOutputs + 1;
    else
      v9 = -1;
    for ( ; v16 < numOutputs; ++v16 )
    {
      if ( outputs[v16] == v12 )
      {
        v9 = v16;
        v16 = before->numOutputs;
      }
    }
    if ( v9 != -1 )
    {
LABEL_127:
      v17 = (*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(8 * pipeline->packetNumClusterSlots);
      if ( !v17 )
      {
        v9 = 0;
        code.pluginID = 0;
        code.errorCode = _rwerror(-2147483629, 8 * pipeline->packetNumClusterSlots);
        RwErrorSet(&code);
        return (RxPipeline_0 *)v9;
      }
      if ( before )
      {
        packetNumClusterSlots = pipeline->packetNumClusterSlots;
        v19 = 0;
        if ( packetNumClusterSlots )
        {
          for ( i = 0; i < packetNumClusterSlots; ++i )
          {
            v21 = before->slotClusterRefs[i];
            if ( v21 )
            {
              clusterRef = v21->clusterRef;
              for ( j = 0; j < v19; ++j )
              {
                if ( *(RxClusterDefinition_0 **)(v17 + 4 * j) == clusterRef )
                  j = v19 + 1;
              }
              if ( j == v19 )
              {
                *(_DWORD *)(v17 + 4 * v19) = clusterRef;
                packetNumClusterSlots = pipeline->packetNumClusterSlots;
                ++v19;
              }
            }
          }
        }
      }
      else
      {
        v19 = 0;
      }
      v24 = after == 0;
      if ( after )
      {
        packetNumClusterSlots = pipeline->packetNumClusterSlots;
        v24 = packetNumClusterSlots == 0;
      }
      if ( !v24 )
      {
        v25 = 0;
        do
        {
          v26 = after->slotClusterRefs[v25];
          if ( v26 )
          {
            v27 = v26->clusterRef;
            for ( k = 0; k < v19; ++k )
            {
              if ( *(RxClusterDefinition_0 **)(v17 + 4 * k) == v27 )
                k = v19 + 1;
            }
            if ( k == v19 )
            {
              *(_DWORD *)(v17 + 4 * v19) = v27;
              packetNumClusterSlots = pipeline->packetNumClusterSlots;
              ++v19;
            }
          }
          ++v25;
        }
        while ( v25 < packetNumClusterSlots );
      }
      v29 = RxPipelineLock(pipeline);
      if ( v29 )
      {
        v30 = RxLockedPipeAddFragment(v29, firstIndex, debugNodeDef, 0);
        nodeDef = (RxClusterDefinition_0 **)firstIndex[0];
        v56 = v30;
        v32 = &v30->nodes[firstIndex[0]];
        if ( v19 )
        {
          for ( m = 0; m != v19; ++m )
          {
            v34 = v32 == 0;
            if ( v32 )
              v34 = pipeline->locked == 0;
            if ( !v34 )
            {
              v35 = *(RxClusterDefinition_0 **)(v17 + 4 * m);
              v36 = v35 == 0;
              if ( v35 )
              {
                nodeDef = (RxClusterDefinition_0 **)v32->nodeDef;
                v36 = v32->nodeDef == 0;
              }
              if ( !v36 )
              {
                v37 = nodeDef[8];
                if ( v37 )
                {
                  nodeDef = (RxClusterDefinition_0 **)nodeDef[9];
                  v38 = 0;
                  while ( *nodeDef != v35 )
                  {
                    ++v38;
                    nodeDef += 3;
                    if ( v38 >= (unsigned int)v37 )
                      goto LABEL_68;
                  }
                }
                else
                {
LABEL_68:
                  v39 = _NodeClone(v32, v35);
                  if ( v39 )
                    v39->io.inputRequirements[v39->io.numClustersOfInterest - 1] = rxCLREQ_OPTIONAL;
                }
              }
            }
          }
        }
        if ( before )
        {
          v40 = before->nodeDef;
          if ( before->nodeDef )
          {
            if ( before->numOutputs <= v9 )
              v41 = 0;
            else
              v41 = &before->outputs[v9];
          }
          else
          {
            v41 = 0;
          }
          v43 = v56 == 0;
          if ( v56 )
            v43 = after == 0;
          if ( !v43 )
          {
            v44 = v41 == 0;
            if ( v41 )
              v44 = v56->locked == 0;
            if ( !v44 && &v56->nodes[*v41] == after )
            {
              *v41 = -1;
              v40 = before->nodeDef;
            }
          }
          if ( v40 )
          {
            if ( before->numOutputs <= v9 )
              v45 = 0;
            else
              v45 = &before->outputs[v9];
          }
          else
          {
            v45 = 0;
          }
          v46 = v56 == 0;
          if ( v56 )
            v46 = v45 == 0;
          if ( !v46 )
          {
            v47 = v56->locked == 0;
            if ( v56->locked )
              v47 = v32 == 0;
            if ( !v47 && *v45 == -1 )
            {
              v48 = (int)v32->nodeDef;
              v49 = v32->nodeDef == 0;
              if ( v32->nodeDef )
              {
                v48 = (char *)v32 - (char *)v56->nodes;
                v49 = v48 == -40;
              }
              if ( !v49 )
              {
                v50 = -858993459 * (v48 >> 3);
                if ( v50 < v56->numNodes )
                  *v45 = v50;
              }
            }
          }
        }
        if ( !after )
          goto LABEL_122;
        if ( v32 && v32->nodeDef )
        {
          if ( v32->numOutputs )
            v51 = v32->outputs;
          else
            v51 = 0;
          if ( !v56 )
          {
LABEL_122:
            v9 = (RwUInt32)RxLockedPipeUnlock(v56);
            if ( !v9 )
              _rxPipelineDestroy(v56);
            (*((void (__fastcall **)(int))RwEngineInstance + 76))(v17);
            return (RxPipeline_0 *)v9;
          }
        }
        else
        {
          v51 = 0;
          if ( !v56 )
            goto LABEL_122;
        }
        v52 = v51 == 0;
        if ( v51 )
          v52 = v56->locked == 0;
        if ( !v52 && *v51 == -1 )
        {
          v53 = (int)after->nodeDef;
          v54 = after->nodeDef == 0;
          if ( after->nodeDef )
          {
            v53 = (char *)after - (char *)v56->nodes;
            v54 = v53 == -40;
          }
          if ( !v54 )
          {
            v55 = -858993459 * (v53 >> 3);
            if ( v55 < v56->numNodes )
              *v51 = v55;
          }
        }
        goto LABEL_122;
      }
    }
    return 0;
  }
  return (RxPipeline_0 *)v9;
}
// 1E007E: variable 'packetNumClusterSlots' is possibly undefined
// 1E00CC: variable 'nodeDef' is possibly undefined
// 1DFEC4: using guessed type RwUInt32 firstIndex[8];

//----- (001E0250) --------------------------------------------------------
void __fastcall PipelineTopSort(TopSortData *data, RwUInt32 nodeIndex)
{
  RwUInt32 nodesArraySlot; // r9
  RxPipeline_0 *pipeline; // r3
  RxPipelineNode_0 *nodes; // r0
  unsigned int outputs; // r3
  unsigned int v7; // r2
  bool v8; // cf
  int i; // r4
  int v10; // r0
  __int64 v11; // d17
  __int64 v12; // d18
  __int64 v13; // d19
  __int64 v14; // d17
  __int64 v15; // d18
  __int64 v16; // d19
  __int64 v17; // d16
  __int64 v18; // d17
  __int64 v19; // d18
  __int64 v20; // d19
  __int64 v21; // d16
  __int64 v22; // d17
  __int64 v23; // d18
  __int64 v24; // d19
  __int64 v25; // d16
  __int64 v26; // d17
  __int64 v27; // d18
  __int64 v28; // d19
  __int64 v29; // d16
  __int64 v30; // d17
  __int64 v31; // d18
  __int64 v32; // d19
  __int64 v33; // d16
  __int64 v34; // d17
  __int64 v35; // d18
  __int64 v36; // d19
  __int64 v37; // d16
  __int64 v38; // d17
  __int64 v39; // d18
  __int64 v40; // d19
  RxPipelineNode_0 *v41; // r0
  RxPipelineNodeTopSortData_0 *topSortData; // r2
  RxPipelineNodeTopSortData_0 *v43; // r0
  __int64 v44; // d16
  RxPipelineNode_0 *v45; // r0
  RxPipelineNode_0 *v46; // r2
  RxPipelineNode_0 *v47; // r4
  __int64 v48; // d17
  __int64 v49; // d18
  __int64 v50; // d20
  __int64 v51; // d21
  RxPipelineNode_0 *v52; // r0
  RwUInt32 v53; // r12
  int v54; // lr
  unsigned int v55; // r6
  unsigned int *v56; // lr
  unsigned int v57; // t1
  RwUInt32 **p_outputs; // r3
  unsigned int v59; // r4
  RwUInt32 v60; // r0
  RwUInt32 v61; // r5
  RxPipelineNode_0 *v62; // r2
  RxPipelineNode_0 *v63; // r5
  RwUInt32 *p_numOutputs; // r5
  RwUInt32 numOutputs; // t1
  RwUInt32 **v66; // r6
  unsigned int v67; // r4
  RwUInt32 v68; // r1
  RxPipelineNode_0 *v69; // r0
  __int64 v70; // [sp+0h] [bp-50h]
  __int64 v71; // [sp+8h] [bp-48h]
  __int64 v72; // [sp+10h] [bp-40h]
  __int64 v73; // [sp+18h] [bp-38h]
  __int64 v74; // [sp+20h] [bp-30h]
  __int64 v75; // [sp+28h] [bp-28h]
  rxReq_0 *req; // [sp+30h] [bp-20h]

  nodesArraySlot = data->nodesArraySlot;
  if ( nodesArraySlot == nodeIndex )
  {
    pipeline = data->pipeline;
  }
  else
  {
    nodes = data->pipeline->nodes;
    outputs = (unsigned int)nodes[nodesArraySlot].outputs;
    v7 = (unsigned int)nodes[nodeIndex].outputs;
    v8 = outputs >= v7 + 128;
    if ( outputs < v7 + 128 )
      v8 = v7 >= outputs + 128;
    if ( v8 )
    {
      v11 = *(_QWORD *)(v7 + 8);
      v12 = *(_QWORD *)outputs;
      v13 = *(_QWORD *)(outputs + 8);
      *(_QWORD *)outputs = *(_QWORD *)v7;
      *(_QWORD *)(outputs + 8) = v11;
      *(_QWORD *)v7 = v12;
      *(_QWORD *)(v7 + 8) = v13;
      v14 = *(_QWORD *)(v7 + 24);
      v15 = *(_QWORD *)(outputs + 16);
      v16 = *(_QWORD *)(outputs + 24);
      *(_QWORD *)(outputs + 16) = *(_QWORD *)(v7 + 16);
      *(_QWORD *)(outputs + 24) = v14;
      v17 = *(_QWORD *)(v7 + 32);
      v18 = *(_QWORD *)(v7 + 40);
      *(_QWORD *)(v7 + 16) = v15;
      *(_QWORD *)(v7 + 24) = v16;
      v19 = *(_QWORD *)(outputs + 32);
      v20 = *(_QWORD *)(outputs + 40);
      *(_QWORD *)(outputs + 32) = v17;
      *(_QWORD *)(outputs + 40) = v18;
      v21 = *(_QWORD *)(v7 + 48);
      v22 = *(_QWORD *)(v7 + 56);
      *(_QWORD *)(v7 + 32) = v19;
      *(_QWORD *)(v7 + 40) = v20;
      v23 = *(_QWORD *)(outputs + 48);
      v24 = *(_QWORD *)(outputs + 56);
      *(_QWORD *)(outputs + 48) = v21;
      *(_QWORD *)(outputs + 56) = v22;
      v25 = *(_QWORD *)(v7 + 64);
      v26 = *(_QWORD *)(v7 + 72);
      *(_QWORD *)(v7 + 48) = v23;
      *(_QWORD *)(v7 + 56) = v24;
      v27 = *(_QWORD *)(outputs + 64);
      v28 = *(_QWORD *)(outputs + 72);
      *(_QWORD *)(outputs + 64) = v25;
      *(_QWORD *)(outputs + 72) = v26;
      v29 = *(_QWORD *)(v7 + 80);
      v30 = *(_QWORD *)(v7 + 88);
      *(_QWORD *)(v7 + 64) = v27;
      *(_QWORD *)(v7 + 72) = v28;
      v31 = *(_QWORD *)(outputs + 80);
      v32 = *(_QWORD *)(outputs + 88);
      *(_QWORD *)(outputs + 80) = v29;
      *(_QWORD *)(outputs + 88) = v30;
      v33 = *(_QWORD *)(v7 + 96);
      v34 = *(_QWORD *)(v7 + 104);
      *(_QWORD *)(v7 + 80) = v31;
      *(_QWORD *)(v7 + 88) = v32;
      v35 = *(_QWORD *)(outputs + 96);
      v36 = *(_QWORD *)(outputs + 104);
      *(_QWORD *)(outputs + 96) = v33;
      *(_QWORD *)(outputs + 104) = v34;
      v37 = *(_QWORD *)(v7 + 112);
      v38 = *(_QWORD *)(v7 + 120);
      *(_QWORD *)(v7 + 96) = v35;
      *(_QWORD *)(v7 + 104) = v36;
      v39 = *(_QWORD *)(outputs + 112);
      v40 = *(_QWORD *)(outputs + 120);
      *(_QWORD *)(outputs + 112) = v37;
      *(_QWORD *)(outputs + 120) = v38;
      *(_QWORD *)(v7 + 112) = v39;
      *(_QWORD *)(v7 + 120) = v40;
    }
    else
    {
      for ( i = 0; i != 32; ++i )
      {
        v10 = *(_DWORD *)(outputs + 4 * i);
        *(_DWORD *)(outputs + 4 * i) = *(_DWORD *)(v7 + 4 * i);
        *(_DWORD *)(v7 + 4 * i) = v10;
      }
    }
    data->pipeline->nodes[nodesArraySlot].outputs = (RwUInt32 *)v7;
    data->pipeline->nodes[nodeIndex].outputs = (RwUInt32 *)outputs;
    v41 = data->pipeline->nodes;
    topSortData = v41[nodesArraySlot].topSortData;
    v43 = v41[nodeIndex].topSortData;
    req = topSortData->req;
    v75 = *(_QWORD *)&topSortData->numIns;
    v44 = *(_QWORD *)&v43->numIns;
    topSortData->req = v43->req;
    *(_QWORD *)&topSortData->numIns = v44;
    v43->req = req;
    *(_QWORD *)&v43->numIns = v75;
    data->pipeline->nodes[nodesArraySlot].topSortData = v43;
    data->pipeline->nodes[nodeIndex].topSortData = topSortData;
    v45 = data->pipeline->nodes;
    v46 = &v45[nodesArraySlot];
    v47 = &v45[nodeIndex];
    v70 = *(_QWORD *)&v46->nodeDef;
    v71 = *(_QWORD *)&v46->outputs;
    v72 = *(_QWORD *)&v46->slotsContinue;
    v73 = *(_QWORD *)&v46->inputToClusterSlot;
    v74 = *(_QWORD *)&v46->initializationData;
    v48 = *(_QWORD *)&v47->outputs;
    v49 = *(_QWORD *)&v47->initializationData;
    v50 = *(_QWORD *)&v47->slotsContinue;
    v51 = *(_QWORD *)&v47->inputToClusterSlot;
    *(_QWORD *)&v46->nodeDef = *(_QWORD *)&v47->nodeDef;
    *(_QWORD *)&v46->outputs = v48;
    *(_QWORD *)&v46->initializationData = v49;
    *(_QWORD *)&v46->slotsContinue = v50;
    *(_QWORD *)&v46->inputToClusterSlot = v51;
    v52 = &data->pipeline->nodes[nodeIndex];
    *(_QWORD *)&v52->initializationData = v74;
    *(_QWORD *)&v52->nodeDef = v70;
    *(_QWORD *)&v52->outputs = v71;
    v52 = (RxPipelineNode_0 *)((char *)v52 + 16);
    *(_QWORD *)&v52->nodeDef = v72;
    *(_QWORD *)&v52->outputs = v73;
    pipeline = data->pipeline;
    if ( data->pipeline->numNodes )
    {
      v53 = 0;
      do
      {
        v54 = (int)&pipeline->nodes[v53];
        v57 = *(_DWORD *)(v54 + 4);
        v56 = (unsigned int *)(v54 + 4);
        v55 = v57;
        if ( v57 )
        {
          p_outputs = &pipeline->nodes[v53].outputs;
          v59 = 0;
          do
          {
            v60 = nodeIndex;
            v61 = (*p_outputs)[v59];
            if ( v61 == nodesArraySlot || (v60 = nodesArraySlot, v61 == nodeIndex) )
            {
              (*p_outputs)[v59] = v60;
              v55 = *v56;
            }
            ++v59;
          }
          while ( v59 < v55 );
          pipeline = data->pipeline;
        }
        ++v53;
      }
      while ( v53 < pipeline->numNodes );
    }
    nodeIndex = data->nodesArraySlot;
  }
  v62 = pipeline->nodes;
  data->nodesArraySlot = nodeIndex + 1;
  v63 = &v62[nodeIndex];
  numOutputs = v63->numOutputs;
  p_numOutputs = &v63->numOutputs;
  if ( numOutputs )
  {
    v66 = &v62[nodeIndex].outputs;
    v67 = 0;
    do
    {
      v68 = (*v66)[v67];
      if ( v68 != -1 )
      {
        v69 = &data->pipeline->nodes[v68];
        if ( v69->topSortData->numIns == ++v69->topSortData->numInsVisited )
          PipelineTopSort(data, v68);
      }
      ++v67;
    }
    while ( v67 < *p_numOutputs );
  }
}

//----- (001E04E8) --------------------------------------------------------
RwUInt32 __fastcall _rxChaseDependencies(RxPipeline_0 *pipeline)
{
  RxPipeline_0 *v1; // r9
  RwUInt32 numNodes; // r8
  RxPipelineNode_0 *v3; // r10
  RwUInt32 numClustersOfInterest; // r0
  RxClusterRef_0 *clustersOfInterest; // r12
  RwUInt32 v6; // r2
  RxClusterRef_0 *v7; // r3
  RxClusterRef_0 *v8; // r4
  RwUInt32 v9; // r5
  RxClusterDefinition_0 *clusterDef; // r6
  RwUInt32 v11; // r5
  rxReq_0 *v12; // r6
  RwReqEntry_0 *v13; // r0
  RwUInt32 numOutputs; // r0
  RxNodeDefinition_0 *v15; // lr
  unsigned int v16; // r3
  RwUInt32 v17; // r1
  rxReq_0 *req; // r1
  RwUInt32 v19; // r9
  RxOutputSpec_0 *v20; // r0
  RxClusterValid_0 *p_allOtherClusters; // r10
  RwReqEntry_0 *reqentries; // r12
  RwUInt32 v23; // r3
  RxClusterValid_0 *v24; // r6
  RxClusterDefinition_0 *v25; // r2
  int v26; // r6
  unsigned int v27; // r4
  RwReqEntry_0 *v28; // r0
  RxClusterValid_0 v29; // r1
  RxClusterValidityReq_0 required; // r4
  int originatingNode; // r12
  RxPipelineNodeTopSortData_0 *topSortData; // r1
  RwUInt32 numIns; // lr
  rxReq_0 *v34; // r1
  unsigned int numused; // r5
  RwReqEntry_0 *v36; // r6
  int *p_originatingNode; // r0
  unsigned int v38; // r3
  RwReqEntry_0 *v39; // r0
  RwUInt32 v40; // r0
  RxClusterValidityReq_0 v41; // r8
  RxPipelineNodeTopSortData_0 *v42; // r2
  RwUInt32 v43; // r12
  rxReq_0 *v44; // r2
  RxPipelineNode_0 *v45; // r6
  RwUInt32 v46; // r4
  RwReqEntry_0 *v47; // lr
  RxPipelineNode_0 **v48; // r3
  unsigned int v49; // r5
  RwReqEntry_0 *v50; // r1
  RwUInt32 v51; // r8
  RxPipelineNode_0 *nodes; // r10
  RxNodeDefinition_0 *v53; // r11
  RwUInt32 v54; // r12
  RwUInt32 i; // r0
  RxClusterRef_0 *v56; // r1
  RxClusterDefinition_0 *v57; // r6
  rxReq_0 *v58; // r3
  RwUInt32 v59; // r1
  RwReqEntry_0 *v60; // lr
  unsigned int v61; // r2
  RwReqEntry_0 *v62; // r4
  RwUInt32 v63; // r2
  int v64; // r1
  RwReqEntry_0 *v65; // r1
  int v66; // r1
  RwUInt32 v67; // r0
  int v68; // r0
  int v69; // r3
  _DWORD *v70; // r1
  int v71; // r6
  int v72; // r0
  int *v73; // r10
  int v74; // r0
  RwUInt32 v75; // r1
  RxClusterDefinition_0 *v76; // r12
  int *v77; // r0
  int v78; // r0
  unsigned int v79; // r5
  int v80; // r0
  rxReq_0 *v81; // r9
  unsigned int v82; // r8
  RwReqEntry_0 *v83; // r3
  unsigned int v84; // r0
  RwReqEntry_0 *v85; // lr
  unsigned int v86; // r0
  RxPipelineNode_0 *v87; // r9
  RwUInt32 v88; // r11
  RxPipelineNodeTopSortData_0 *v89; // r1
  rxReq_0 *v90; // r0
  RwUInt32 v91; // r5
  int v92; // r11
  int v93; // r4
  int v94; // r6
  RwReqEntry_0 *v95; // r8
  RwScopeTrace_0 *v96; // r0
  RwUInt32 v97; // lr
  RwUInt32 v98; // r0
  int v99; // r8
  int v100; // r8
  int v101; // t1
  unsigned int *v102; // r2
  unsigned int v103; // r3
  _DWORD *v104; // r5
  rxReq_0 *v105; // r0
  unsigned int v106; // r2
  RwUInt32 *p_outbf; // r4
  unsigned int v108; // r0
  bool v109; // zf
  _DWORD *v110; // r6
  _DWORD *v111; // r2
  _DWORD *v112; // r0
  _DWORD *v113; // r4
  _DWORD *v114; // r5
  _DWORD *v115; // r2
  int *v116; // r0
  int *v117; // r2
  int v118; // r1
  int **v119; // r10
  RwUInt32 v120; // r12
  int v121; // r4
  unsigned int v122; // r3
  int *v123; // r2
  int j; // r6
  RwUInt32 v125; // r5
  _DWORD *v126; // r3
  _DWORD *v127; // r6
  int v128; // r0
  int v129; // r6
  RxPipelineNode_0 *v130; // r0
  unsigned int *p_numused; // r1
  unsigned int v132; // r0
  unsigned int v133; // r1
  int *v134; // r1
  unsigned int v135; // r2
  int v136; // t1
  RwUInt32 v137; // r5
  RwInt32 v138; // r0
  unsigned int v140; // r8
  int **v141; // r0
  int **v142; // r2
  _BYTE *v143; // r9
  void *v144; // r0
  RwUInt32 packetNumClusterSlots; // r1
  RwUInt32 v146; // r0
  RxPacket_0 *v147; // r0
  RwUInt32 v148; // r1
  int **v149; // r4
  int v150; // r6
  int **v151; // r0
  _DWORD *v152; // r0
  _DWORD *v153; // r1
  RxPipeline_0 *v154; // r10
  int v155; // r5
  __int64 v156; // kr20_8
  void *v157; // r0
  int v158; // r1
  _DWORD *v159; // r9
  _DWORD *v160; // r4
  int v161; // r0
  int v162; // r0
  unsigned int *v163; // r2
  unsigned int v164; // r3
  int v165; // r1
  unsigned int v166; // r6
  _DWORD *v167; // r2
  unsigned int v168; // r10
  int v169; // r5
  unsigned int v170; // r5
  _DWORD *v171; // lr
  unsigned int v172; // r2
  RwUInt32 v173; // r3
  int v174; // r6
  _DWORD *v175; // r1
  void **p_inputRequirements; // r12
  RxPipelineNode_0 *v177; // lr
  RxPipelineNodeTopSortData_0 *v178; // r8
  rxReq_0 *v179; // r2
  int v180; // r3
  unsigned int v181; // r4
  RwUInt32 v182; // r1
  RwReqEntry_0 *v183; // r0
  RwReqEntry_0 *v184; // r2
  char *v185; // r6
  RxClusterDefinition_0 *v186; // r8
  int v187; // r0
  char *v188; // r0
  RwUInt32 v189; // [sp+Ch] [bp-4Ch]
  int v190; // [sp+10h] [bp-48h]
  RxOutputSpec_0 *outputs; // [sp+14h] [bp-44h]
  RwUInt32 v192; // [sp+14h] [bp-44h]
  int v193; // [sp+18h] [bp-40h]
  int v194; // [sp+18h] [bp-40h]
  RxPipeline_0 *v195; // [sp+1Ch] [bp-3Ch]
  RxPipeline_0 *v196; // [sp+1Ch] [bp-3Ch]
  RxPipelineNode_0 *v197; // [sp+20h] [bp-38h]
  _DWORD *v198; // [sp+20h] [bp-38h]
  RxClusterValid_0 **p_outputClusters; // [sp+24h] [bp-34h]
  int v200; // [sp+24h] [bp-34h]
  RxPipelineNode_0 *v201; // [sp+28h] [bp-30h]
  int *v202; // [sp+28h] [bp-30h]
  int v203; // [sp+28h] [bp-30h]
  RxNodeDefinition_0 *nodeDef; // [sp+2Ch] [bp-2Ch]
  RxPipelineNode_0 *v205; // [sp+2Ch] [bp-2Ch]
  _DWORD *v206; // [sp+2Ch] [bp-2Ch]
  int **v207; // [sp+30h] [bp-28h] BYREF
  RwError_0 code; // [sp+34h] [bp-24h] BYREF

  v1 = pipeline;
  v207 = 0;
  numNodes = pipeline->numNodes;
  v3 = &pipeline->nodes[numNodes - 1];
  do
  {
    numClustersOfInterest = v3->nodeDef->io.numClustersOfInterest;
    if ( numClustersOfInterest )
    {
      clustersOfInterest = v3->nodeDef->io.clustersOfInterest;
      v6 = 0;
      v7 = clustersOfInterest + 1;
      do
      {
        v8 = v7;
        v9 = v6;
        clusterDef = clustersOfInterest[v6].clusterDef;
        if ( !clusterDef )
        {
          v137 = 31;
          code.pluginID = 0;
          v138 = _rwerror(31, v3->nodeDef->name, v6);
          goto LABEL_163;
        }
        while ( ++v9 < numClustersOfInterest )
        {
          v109 = clusterDef == v8->clusterDef;
          ++v8;
          if ( v109 )
          {
            v137 = 30;
            code.pluginID = 0;
            v138 = _rwerror(30, v3->nodeDef->name, clusterDef->name);
            goto LABEL_163;
          }
        }
        ++v6;
        ++v7;
      }
      while ( v6 < numClustersOfInterest );
    }
    nodeDef = v3->nodeDef;
    v11 = PipelineCalcNumUniqueClusters(v1);
    v12 = (rxReq_0 *)StalacTiteAlloc(0x14u);
    if ( !v12 || (v13 = (RwReqEntry_0 *)StalacTiteAlloc(36 * v11), (v12->reqentries = v13) == 0) )
    {
      v3->topSortData->req = 0;
      code.pluginID = 0;
      goto LABEL_162;
    }
    v189 = numNodes;
    v12->node = v3;
    v12->numused = 0;
    v12->numalloced = v11;
    v12->unavailslots = 0;
    v3->topSortData->req = v12;
    numOutputs = v3->numOutputs;
    v15 = nodeDef;
    if ( numOutputs )
    {
      v16 = 0;
      v195 = v1;
      v201 = v3;
      do
      {
        v17 = v3->outputs[v16];
        if ( v17 != -1 )
        {
          v197 = &v1->nodes[v17];
          req = v197->topSortData->req;
          if ( req->numused )
          {
            v19 = 0;
            v193 = v16;
            v190 = v16;
            outputs = v3->nodeDef->io.outputs;
            v20 = &outputs[v16];
            p_allOtherClusters = &v20->allOtherClusters;
            p_outputClusters = &v20->outputClusters;
            do
            {
              reqentries = req->reqentries;
              v23 = v15->io.numClustersOfInterest;
              v24 = p_allOtherClusters;
              v25 = reqentries[v19].clusterDef;
              if ( v23 )
              {
                v26 = 0;
                v27 = 0;
                while ( v15->io.clustersOfInterest[v26].clusterDef != v25 )
                {
                  ++v27;
                  ++v26;
                  if ( v27 >= v23 )
                  {
                    v24 = p_allOtherClusters;
                    goto LABEL_23;
                  }
                }
                v24 = &(*p_outputClusters)[v26];
              }
LABEL_23:
              v28 = &reqentries[v19];
              v29 = *v24;
              if ( *v24 )
              {
                if ( v28->required == rxCLREQ_REQUIRED )
                {
                  if ( v29 != rxCLVALID_VALID )
                  {
                    code.pluginID = 0;
                    v137 = 29;
                    v138 = _rwerror(
                             29,
                             v28->clusterDef->name,
                             v28->originatingNode->nodeDef->name,
                             v201->nodeDef->name,
                             v193,
                             outputs[v190].name);
                    goto LABEL_163;
                  }
                }
                else if ( v29 == rxCLVALID_INVALID )
                {
                  _PropDownElimPath(v195, v197, v25);
                  v15 = nodeDef;
                }
              }
              else
              {
                required = v28->required;
                originatingNode = (int)v28->originatingNode;
                topSortData = v201->topSortData;
                numIns = topSortData->numIns;
                v34 = topSortData->req;
                numused = v34->numused;
                v36 = v34->reqentries;
                if ( !v34->numused )
                  goto LABEL_38;
                p_originatingNode = (int *)&v36->originatingNode;
                v38 = 0;
                while ( (RxClusterDefinition_0 *)*(p_originatingNode - 8) != v25 )
                {
                  ++v38;
                  p_originatingNode += 9;
                  if ( v38 >= numused )
                    goto LABEL_38;
                }
                if ( p_originatingNode == &dword_20 )
                {
LABEL_38:
                  v34->numused = numused + 1;
                  v36[numused].clusterDef = v25;
                  v39 = &v36[numused];
                  v39->required = required;
                  v39->inputs = numIns;
                  v39->st = 0;
                  v39->next = 0;
                  v39->req = v34;
                  v39->outbf = 0;
                  v39->assignedslot = -1;
                  v39->originatingNode = (RxPipelineNode_0 *)originatingNode;
                  v15 = nodeDef;
                  if ( !v39 )
                    goto LABEL_161;
                }
                else
                {
                  v15 = nodeDef;
                  if ( required == rxCLREQ_REQUIRED )
                  {
                    *p_originatingNode = originatingNode;
                    *(p_originatingNode - 7) = 1;
                  }
                }
              }
              ++v19;
              req = v197->topSortData->req;
            }
            while ( v19 < req->numused );
            v3 = v201;
            numOutputs = v201->numOutputs;
            v16 = v193;
            v1 = v195;
          }
        }
        ++v16;
      }
      while ( v16 < numOutputs );
    }
    if ( v15->io.numClustersOfInterest )
    {
      v40 = 0;
      do
      {
        v41 = v15->io.inputRequirements[v40];
        if ( v41 )
        {
          v42 = v3->topSortData;
          v43 = v42->numIns;
          v44 = v42->req;
          v45 = (RxPipelineNode_0 *)v15->io.clustersOfInterest[v40].clusterDef;
          v46 = v44->numused;
          v47 = v44->reqentries;
          if ( !v44->numused )
            goto LABEL_54;
          v48 = &v47->originatingNode;
          v49 = 0;
          while ( *(v48 - 8) != v45 )
          {
            ++v49;
            v48 += 9;
            if ( v49 >= v46 )
              goto LABEL_54;
          }
          if ( v48 == (RxPipelineNode_0 **)&dword_20 )
          {
LABEL_54:
            v44->numused = v46 + 1;
            v47[v46].clusterDef = (RxClusterDefinition_0 *)v45;
            v50 = &v47[v46];
            v50->required = v41;
            v50->inputs = v43;
            v50->st = 0;
            v50->next = 0;
            *(_QWORD *)&v50->req = (unsigned int)v44;
            v50->assignedslot = -1;
            v50->originatingNode = v3;
            v15 = nodeDef;
            if ( !v50 )
              goto LABEL_161;
          }
          else
          {
            v15 = nodeDef;
            if ( v41 == rxCLREQ_REQUIRED )
            {
              *v48 = v3;
              *(v48 - 7) = (RxPipelineNode_0 *)(&dword_0 + 1);
            }
          }
        }
        ++v40;
      }
      while ( v40 < v15->io.numClustersOfInterest );
    }
    --v3;
    numNodes = v189 - 1;
  }
  while ( v189 != 1 );
  nodes = v1->nodes;
  v51 = v1->numNodes;
  v196 = v1;
  do
  {
    v53 = nodes->nodeDef;
    v54 = nodes->nodeDef->io.numClustersOfInterest;
    if ( v54 )
    {
      for ( i = 0; i < v54; ++i )
      {
        v56 = v53->io.clustersOfInterest;
        if ( v56[i].forcePresent )
        {
          v57 = v56[i].clusterDef;
          v58 = nodes->topSortData->req;
          v59 = v58->numused;
          v60 = v58->reqentries;
          if ( !v58->numused )
            goto LABEL_67;
          v61 = 0;
          v62 = v58->reqentries;
          while ( v62->clusterDef != v57 )
          {
            ++v61;
            ++v62;
            if ( v61 >= v59 )
              goto LABEL_67;
          }
          if ( !v62 )
          {
LABEL_67:
            v63 = v59 + 1;
            v64 = v59;
            v58->numused = v63;
            v60[v64].clusterDef = v57;
            v65 = &v60[v64];
            v65->required = rxCLREQ_DONTWANT;
            v65->inputs = 1;
            v65->st = 0;
            v65->next = 0;
            v65->req = v58;
            v65->outbf = 0;
            v65->assignedslot = -1;
            v65->originatingNode = nodes;
            if ( !v65 )
              goto LABEL_161;
            v54 = v53->io.numClustersOfInterest;
          }
        }
      }
    }
    v192 = v51;
    if ( nodes->numOutputs )
    {
      v66 = 0;
      v205 = nodes;
      while ( 1 )
      {
        v194 = v66;
        v67 = nodes->outputs[v66];
        if ( v67 != -1 )
        {
          v68 = (int)&v196->nodes[v67];
          v69 = *(_DWORD *)(v68 + 28);
          v202 = (int *)(v68 + 28);
          v70 = *(_DWORD **)(v69 + 8);
          if ( *v70 )
            break;
        }
LABEL_99:
        nodes = v205;
        v66 = v194 + 1;
        if ( v194 + 1 >= v205->numOutputs )
          goto LABEL_100;
      }
      v71 = 0;
      v72 = (int)&v205->nodeDef->io.outputs[v194];
      v73 = (int *)(v72 + 8);
      v198 = (_DWORD *)(v72 + 4);
      while ( 1 )
      {
        v74 = v70[3];
        v75 = v53->io.numClustersOfInterest;
        v76 = *(RxClusterDefinition_0 **)(v74 + 36 * v71);
        v77 = v73;
        if ( v75 )
        {
          v78 = 0;
          v79 = 0;
          while ( v53->io.clustersOfInterest[v78].clusterDef != v76 )
          {
            ++v79;
            ++v78;
            if ( v79 >= v75 )
            {
              v77 = v73;
              goto LABEL_83;
            }
          }
          v77 = (int *)(v78 * 4 + *v198);
        }
LABEL_83:
        v80 = *v77;
        if ( v80 == 2 )
          goto LABEL_98;
        v81 = v205->topSortData->req;
        v82 = v81->numused;
        if ( v80 )
        {
          v83 = v81->reqentries;
          if ( !v82 )
            goto LABEL_96;
          v84 = 0;
          v85 = v81->reqentries;
          while ( v85->clusterDef != v76 )
          {
            ++v84;
            ++v85;
            if ( v84 >= v82 )
              goto LABEL_96;
          }
          if ( !v85 )
          {
LABEL_96:
            v81->numused = v82 + 1;
            v85 = &v83[v82];
            v85->clusterDef = v76;
            v85->required = rxCLREQ_DONTWANT;
            *(_QWORD *)&v85->inputs = 1LL;
            v85->next = 0;
            v85->req = v81;
            v85->outbf = 0;
            v85->assignedslot = -1;
            v85->originatingNode = v205;
            if ( !v85 )
              goto LABEL_161;
          }
        }
        else
        {
          if ( !v82 )
            goto LABEL_98;
          v85 = v81->reqentries;
          v86 = 0;
          while ( v85->clusterDef != v76 )
          {
            ++v86;
            ++v85;
            if ( v86 >= v82 )
              goto LABEL_98;
          }
          if ( !v85 )
            goto LABEL_98;
        }
        v85->outbf |= 1 << v194;
        v69 = *v202;
LABEL_98:
        v70 = *(_DWORD **)(v69 + 8);
        if ( (unsigned int)++v71 >= *v70 )
          goto LABEL_99;
      }
    }
LABEL_100:
    ++nodes;
    v51 = v192 - 1;
  }
  while ( v192 != 1 );
  v87 = v196->nodes;
  v88 = v196->numNodes;
  while ( 1 )
  {
    v89 = v87->topSortData;
    v90 = v89->req;
    if ( v90->numused )
      break;
LABEL_109:
    if ( v87->numOutputs )
    {
      v97 = 0;
      do
      {
        v98 = v87->outputs[v97];
        if ( v98 != -1 )
        {
          v99 = (int)&v196->nodes[v98];
          v101 = *(_DWORD *)(v99 + 28);
          v100 = v99 + 28;
          v102 = *(unsigned int **)(v101 + 8);
          if ( *v102 )
          {
            v103 = 0;
            do
            {
              v104 = (_DWORD *)(v102[3] + 36 * v103);
              if ( v104[1] )
              {
                v105 = v87->topSortData->req;
                v106 = v105->numused;
                if ( v105->numused )
                {
                  p_outbf = &v105->reqentries->outbf;
                  v108 = 0;
                  while ( *(p_outbf - 6) != *v104 )
                  {
                    ++v108;
                    p_outbf += 9;
                    if ( v108 >= v106 )
                      goto LABEL_133;
                  }
                  v109 = p_outbf == (RwUInt32 *)&off_18;
                  if ( p_outbf != (RwUInt32 *)&off_18 )
                    v109 = (*p_outbf & (1 << v97)) == 0;
                  if ( !v109 )
                  {
                    v110 = (_DWORD *)*(p_outbf - 3);
                    v111 = (_DWORD *)v104[3];
                    if ( v111 )
                    {
                      do
                      {
                        v112 = v111;
                        v111 = (_DWORD *)v111[3];
                      }
                      while ( v111 );
                      do
                      {
                        v113 = v110;
                        v110 = (_DWORD *)v110[3];
                      }
                      while ( v110 );
                      if ( v112 != v113 )
                      {
                        v114 = v112;
                        do
                        {
                          v115 = v114;
                          v114 = (_DWORD *)v114[1];
                        }
                        while ( v114 );
                        v115[1] = v113;
                        v113[3] = v112;
                        v116 = (int *)&v207;
                        do
                        {
                          v117 = v116;
                          v118 = *v116;
                          v116 = (int *)(*v116 + 8);
                        }
                        while ( (_DWORD *)v118 != v113 );
                        *v117 = *v116;
                      }
                    }
                    else
                    {
                      v104[4] = *v110;
                      *v110 = v104;
                      v104[3] = *(p_outbf - 3);
                    }
                  }
                }
              }
LABEL_133:
              ++v103;
              v102 = *(unsigned int **)(*(_DWORD *)v100 + 8);
            }
            while ( v103 < *v102 );
          }
        }
        ++v97;
      }
      while ( v97 < v87->numOutputs );
    }
    --v88;
    ++v87;
    if ( !v88 )
    {
      v119 = v207;
      v120 = 0;
      if ( v207 )
      {
        v121 = (int)v207;
        do
        {
          v122 = 0;
          v123 = (int *)v121;
          do
          {
            for ( j = *v123; j; j = *(_DWORD *)(j + 16) )
              v122 |= *(_DWORD *)(*(_DWORD *)(j + 20) + 8);
            v123 = (int *)v123[1];
          }
          while ( v123 );
          v125 = 0;
          if ( v122 << 31 )
          {
            do
            {
              ++v125;
              v109 = ((v122 >> 1) & 1) == 0;
              v122 >>= 1;
            }
            while ( !v109 );
          }
          v126 = (_DWORD *)v121;
          do
          {
            v127 = (_DWORD *)*v126;
            if ( *v126 )
            {
              do
              {
                v128 = v127[5];
                v127[7] = v125;
                *(_DWORD *)(v128 + 8) |= 1 << v125;
                v127 = (_DWORD *)v127[4];
              }
              while ( v127 );
            }
            v126 = (_DWORD *)v126[1];
          }
          while ( v126 );
          v121 = *(_DWORD *)(v121 + 8);
          if ( v125 >= v120 )
            v120 = v125 + 1;
        }
        while ( v121 );
      }
      v129 = 0;
      v130 = v196->nodes;
      v196->packetNumClusterSlots = v120;
      p_numused = &v130->topSortData->req->numused;
      v132 = *p_numused;
      if ( *p_numused )
      {
        v133 = p_numused[3];
        if ( (unsigned int)(*(_DWORD *)(v133 + 4) - 1) < 2 )
          v129 = 1;
        if ( v132 != 1 )
        {
          v134 = (int *)(v133 + 40);
          v135 = 1;
          do
          {
            v136 = *v134;
            v134 += 9;
            ++v135;
            if ( (unsigned int)(v136 - 1) < 2 )
              ++v129;
          }
          while ( v135 < v132 );
        }
      }
      else
      {
        v129 = 0;
      }
      v140 = 0;
      v200 = v129;
      v206 = 0;
      if ( v119 )
      {
        v141 = v119;
        do
        {
          if ( v141 == v119 )
          {
LABEL_175:
            ++v140;
          }
          else
          {
            v142 = v119;
            while ( **v142 != **v141 )
            {
              v142 = (int **)v142[2];
              if ( v142 == v141 )
                goto LABEL_175;
            }
          }
          v141 = (int **)v141[2];
        }
        while ( v141 );
      }
      v143 = StalacTiteAlloc(0);
      v144 = StalacMiteAlloc(0);
      memset(v144, 0, v143 - (_BYTE *)v144);
      packetNumClusterSlots = v196->packetNumClusterSlots;
      v146 = 28 * packetNumClusterSlots + 20;
      if ( !packetNumClusterSlots )
        v146 = 48;
      v147 = (RxPacket_0 *)StalacMiteAlloc(v146);
      v148 = v196->packetNumClusterSlots;
      v196->embeddedPacket = v147;
      v147->numClusters = v148;
      v196->embeddedPacket->pipeline = v196;
      v196->embeddedPacketState = rxPKST_PACKETLESS;
      if ( v119 )
      {
        v149 = v119;
        v206 = 0;
        do
        {
          if ( v149 == v119 )
          {
            v150 = **v119;
LABEL_187:
            v152 = StalacMiteAlloc(8u);
            *v152 = v150;
            v152[1] = *(_DWORD *)(v150 + 8);
            v153 = v206;
            if ( !v206 )
              v153 = v152;
            v206 = v153;
          }
          else
          {
            v150 = **v149;
            v151 = v119;
            while ( **v151 != v150 )
            {
              v151 = (int **)v151[2];
              if ( v151 == v149 )
                goto LABEL_187;
            }
          }
          v149 = (int **)v149[2];
        }
        while ( v149 );
      }
      v154 = v196;
      if ( v196->numNodes )
      {
        v155 = 0;
        do
        {
          v156 = *(_QWORD *)&v154->nodes;
          if ( HIDWORD(v156) )
            *(_DWORD *)(v156 + 40 * v155 + 12) = StalacMiteAlloc(4 * HIDWORD(v156));
          v157 = StalacMiteAlloc(4 * HIDWORD(v156) + 4);
          v203 = v155;
          v158 = *(_DWORD *)(v156 + 40 * v155);
          v159 = (_DWORD *)(v156 + 40 * v155);
          v159[4] = v157;
          v160 = v159 + 4;
          v161 = *(_DWORD *)(v158 + 32);
          if ( v161 )
          {
            v159[6] = StalacMiteAlloc(4 * v161);
            v158 = *v159;
          }
          v162 = *(_DWORD *)(v158 + 52);
          if ( v162 )
            v159[5] = StalacMiteAlloc((v162 + 3) & 0xFFFFFFFC);
          v163 = *(unsigned int **)(v159[7] + 8);
          if ( *v163 )
          {
            v164 = 0;
            v165 = -1;
            do
            {
              v166 = v163[3];
              if ( v140 )
              {
                v167 = v206;
                v168 = 0;
                while ( *v167 != *(_DWORD *)(v166 + 36 * v164) )
                {
                  ++v168;
                  v167 += 2;
                  if ( v168 >= v140 )
                  {
                    v167 = 0;
                    break;
                  }
                }
                v154 = v196;
              }
              else
              {
                v167 = 0;
              }
              v169 = 9 * v164++;
              v170 = v166 + 4 * v169;
              *(_DWORD *)(v159[3] + 4 * *(_DWORD *)(v170 + 28)) = v167;
              *(_DWORD *)(*v160 + 4 * *(_DWORD *)(v170 + 28) + 4) = *(_DWORD *)(v170 + 24);
              v163 = *(unsigned int **)(v159[7] + 8);
              v165 &= *(_DWORD *)(v170 + 24);
            }
            while ( v164 < *v163 );
          }
          else
          {
            v165 = -1;
          }
          *(_DWORD *)*v160 = v165;
          if ( *(_DWORD *)(*v159 + 32) )
          {
            v171 = v159 + 6;
            v172 = 0;
            do
            {
              *(_DWORD *)(*v171 + 4 * v172) = -1;
              v173 = v154->packetNumClusterSlots;
              if ( v173 )
              {
                v174 = 0;
                while ( 1 )
                {
                  v175 = *(_DWORD **)(v159[3] + 4 * v174);
                  if ( v175 )
                  {
                    if ( *v175 == *(_DWORD *)(*(_DWORD *)(*v159 + 36) + 12 * v172) )
                      break;
                  }
                  if ( ++v174 >= v173 )
                    goto LABEL_220;
                }
                *(_DWORD *)(*v171 + 4 * v172) = v174;
              }
LABEL_220:
              ++v172;
            }
            while ( v172 < *(_DWORD *)(*v159 + 32) );
          }
          v155 = v203 + 1;
        }
        while ( v203 + 1 < v154->numNodes );
      }
      if ( v200 )
        v196->inputRequirements = (RxPipelineRequiresCluster_0 *)StalacMiteAlloc(12 * v200);
      p_inputRequirements = (void **)&v196->inputRequirements;
      v137 = 0;
      v177 = v196->nodes;
      v178 = v177->topSortData;
      v179 = v178->req;
      if ( v179->numused )
      {
        v180 = 0;
        v181 = 0;
        v182 = 0;
        do
        {
          v183 = v179->reqentries;
          v184 = &v183[v180];
          if ( (unsigned int)(v183[v180].required - 1) <= 1 )
          {
            v185 = (char *)*p_inputRequirements;
            v186 = v183[v180].clusterDef;
            v187 = 3 * v182++;
            *((_DWORD *)*p_inputRequirements + v187) = v186;
            v188 = &v185[4 * v187];
            *((_DWORD *)v188 + 1) = v184->required;
            *((_DWORD *)v188 + 2) = v184->assignedslot;
            v178 = v177->topSortData;
          }
          v179 = v178->req;
          ++v180;
          ++v181;
        }
        while ( v181 < v179->numused );
      }
      else
      {
        v182 = 0;
      }
      v196->numInputRequirements = v182;
      _rx_rxRadixExchangeSort(*p_inputRequirements, v182, 0xCu, 0, 0, 0xFFFFFFFF);
      return v137;
    }
  }
  v91 = v88;
  v92 = (int)v207;
  v93 = 0;
  v94 = 0;
  while ( 2 )
  {
    v95 = &v90->reqentries[v93];
    if ( v95->st )
    {
LABEL_107:
      v90 = v89->req;
      ++v93;
      if ( ++v94 >= v90->numused )
      {
        v207 = (int **)v92;
        v88 = v91;
        goto LABEL_109;
      }
      continue;
    }
    break;
  }
  v96 = (RwScopeTrace_0 *)StalacTiteAlloc(0x10u);
  if ( v96 )
  {
    v96->head = 0;
    v96->continuation = 0;
    v96->next = (RwScopeTrace *)v92;
    v96->parent = 0;
    v92 = (int)v96;
    v95->st = v96;
    v95->next = v96->head;
    v96->head = v95;
    v89 = v87->topSortData;
    goto LABEL_107;
  }
  v207 = (int **)v92;
  v95->st = 0;
LABEL_161:
  code.pluginID = 0;
LABEL_162:
  v137 = 32;
  v138 = _rwerror(32);
LABEL_163:
  code.errorCode = v138;
  RwErrorSet(&code);
  return v137;
}
// 0: using guessed type int dword_0;
// 18: using guessed type int (*off_18)();
// 20: using guessed type int dword_20;

//----- (001E0EE0) --------------------------------------------------------
void __fastcall _PropDownElimPath(RxPipeline_0 *pipeline, RxPipelineNode_0 *node, RxClusterDefinition_0 *clusterDef)
{
  rxReq_0 *req; // r0
  RwUInt32 numused; // r1
  RxNodeDefinition_0 *nodeDef; // r9
  int v9; // r2
  RwReqEntry_0 *i; // r0
  int v11; // r1
  rxReq_0 *v12; // r1
  RwUInt32 v13; // r2
  RwReqEntry_0 *reqentries; // r3
  int v15; // r3
  RxPipelineNode_0 *v16; // r2
  __int64 v17; // d16
  __int64 v18; // d17
  __int64 v19; // d18
  __int64 v20; // d19
  RwUInt32 numOutputs; // r12
  RwUInt32 j; // r6
  RwUInt32 v23; // r11
  RwUInt32 numClustersOfInterest; // r3
  RxOutputSpec_0 *outputs; // lr
  int v26; // r0
  RwUInt32 v27; // r2
  RxClusterValid_0 *p_allOtherClusters; // r0

  req = node->topSortData->req;
  numused = req->numused;
  if ( req->numused )
  {
    nodeDef = node->nodeDef;
    v9 = 0;
    for ( i = req->reqentries; i->clusterDef != clusterDef; ++i )
    {
      if ( ++v9 >= numused )
        return;
    }
    if ( i )
    {
      v11 = i->inputs - 1;
      i->inputs = v11;
      if ( !v11 )
      {
        v12 = node->topSortData->req;
        v13 = v12->numused;
        reqentries = v12->reqentries;
        if ( (RwReqEntry_0 *)((char *)i - (int)reqentries - 36 * v12->numused) != (RwReqEntry_0 *)-36 )
        {
          v15 = (int)&reqentries[v12->numused - 1];
          v16 = *(RxPipelineNode_0 **)(v15 + 32);
          v17 = *(_QWORD *)v15;
          v18 = *(_QWORD *)(v15 + 8);
          v15 += 16;
          v19 = *(_QWORD *)v15;
          v20 = *(_QWORD *)(v15 + 8);
          *(_QWORD *)&i->clusterDef = v17;
          *(_QWORD *)&i->inputs = v18;
          *(_QWORD *)&i->next = v19;
          *(_QWORD *)&i->outbf = v20;
          i->originatingNode = v16;
          v13 = v12->numused;
        }
        v12->numused = v13 - 1;
        numOutputs = node->numOutputs;
        if ( numOutputs )
        {
          for ( j = 0; j < numOutputs; ++j )
          {
            v23 = node->outputs[j];
            if ( v23 != -1 )
            {
              numClustersOfInterest = nodeDef->io.numClustersOfInterest;
              outputs = node->nodeDef->io.outputs;
              if ( numClustersOfInterest )
              {
                v26 = 0;
                v27 = 0;
                while ( nodeDef->io.clustersOfInterest[v26].clusterDef != clusterDef )
                {
                  ++v27;
                  ++v26;
                  if ( v27 >= numClustersOfInterest )
                    goto LABEL_17;
                }
                p_allOtherClusters = &outputs[j].outputClusters[v26];
              }
              else
              {
LABEL_17:
                p_allOtherClusters = &outputs[j].allOtherClusters;
              }
              if ( *p_allOtherClusters == rxCLVALID_NOCHANGE )
              {
                _PropDownElimPath(pipeline, &pipeline->nodes[v23], clusterDef);
                numOutputs = node->numOutputs;
              }
            }
          }
        }
      }
    }
  }
}

//----- (001E0FE4) --------------------------------------------------------
void __fastcall RxHeapFree(RxHeap_0 *heap, void *block)
{
  int v3; // r1
  rxHeapBlockHeader_0 *v4; // r6
  _BOOL4 v5; // r3
  int v6; // r2
  _BOOL4 v7; // r5
  RwUInt32 entriesUsed; // r3
  rxHeapFreeBlock_0 *v9; // r1
  rxHeapFreeBlock_0 *v10; // r2
  rxHeapBlockHeader_0 *ptr; // r2
  rxHeapFreeBlock_0 v12; // kr00_8
  rxHeapBlockHeader **v13; // r0
  rxHeapBlockHeader_0 **v14; // r0
  rxHeapFreeBlock_0 *v15; // r0

  v4 = (rxHeapBlockHeader_0 *)((char *)block - 32);
  v3 = *((_DWORD *)block - 8);
  if ( v3 )
    v5 = *(_DWORD *)(v3 + 12) != 0;
  else
    v5 = 0;
  v6 = *((_DWORD *)block - 7);
  if ( v6 )
  {
    v7 = *(_DWORD *)(v6 + 12) != 0;
    if ( v5 )
    {
LABEL_6:
      if ( v7 )
      {
        entriesUsed = heap->entriesUsed;
        v9 = *(rxHeapFreeBlock_0 **)(v6 + 12);
        v10 = &heap->freeBlocks[entriesUsed - 1];
        if ( v10 != v9 )
        {
          v12 = *v10;
          ptr = heap->freeBlocks[entriesUsed - 1].ptr;
          *v9 = (rxHeapFreeBlock_0)__PAIR64__((unsigned int)ptr, v12.size);
          ptr->freeEntry = v9;
          entriesUsed = heap->entriesUsed;
        }
        heap->entriesUsed = entriesUsed - 1;
        *(_DWORD *)(*((_DWORD *)block - 8) + 8) += *(_DWORD *)(*((_DWORD *)block - 7) + 8) + *((_DWORD *)block - 6) + 64;
        **(_DWORD **)(*((_DWORD *)block - 8) + 12) = *(_DWORD *)(*((_DWORD *)block - 8) + 8);
        *(_DWORD *)(*((_DWORD *)block - 8) + 4) = *(_DWORD *)(*((_DWORD *)block - 7) + 4);
        v13 = *(rxHeapBlockHeader ***)(*((_DWORD *)block - 7) + 4);
      }
      else
      {
        *(_DWORD *)(v3 + 8) += *((_DWORD *)block - 6) + 32;
        **(_DWORD **)(*((_DWORD *)block - 8) + 12) = *(_DWORD *)(*((_DWORD *)block - 8) + 8);
        *(_DWORD *)(*((_DWORD *)block - 8) + 4) = *((_DWORD *)block - 7);
        v13 = (rxHeapBlockHeader **)*((_DWORD *)block - 7);
      }
      if ( v13 )
        *v13 = v4->prev;
      return;
    }
  }
  else
  {
    v7 = 0;
    if ( v5 )
      goto LABEL_6;
  }
  if ( v7 )
  {
    *((_DWORD *)block - 6) += *(_DWORD *)(v6 + 8) + 32;
    *((_DWORD *)block - 5) = *(_DWORD *)(v6 + 12);
    *(_DWORD *)(*(_DWORD *)(v6 + 12) + 4) = v4;
    **(_DWORD **)(*((_DWORD *)block - 7) + 12) = *((_DWORD *)block - 6);
    v14 = *(rxHeapBlockHeader_0 ***)(*((_DWORD *)block - 7) + 4);
    *((_DWORD *)block - 7) = v14;
    if ( v14 )
      *v14 = v4;
  }
  else
  {
    v15 = HeapFreeBlocksNewEntry(heap);
    if ( v15 )
    {
      v15->ptr = v4;
      v15->size = *((_DWORD *)block - 6);
      *((_DWORD *)block - 5) = v15;
    }
  }
}

//----- (001E10F8) --------------------------------------------------------
rxHeapFreeBlock_0 *__fastcall HeapFreeBlocksNewEntry(RxHeap_0 *heap)
{
  RwUInt32 entriesAlloced; // r0
  rxHeapFreeBlock_0 *v3; // r5
  __int64 v4; // kr00_8
  RwUInt32 entriesUsed; // r6
  RwUInt32 v6; // r0
  int (__fastcall *v7)(_DWORD, RwUInt32); // r2
  bool v8; // zf
  rxHeapFreeBlock_0 *v9; // r0
  RwUInt32 v10; // r0
  RwError_0 v12; // [sp+0h] [bp-18h] BYREF

  v4 = *(_QWORD *)&heap->freeBlocks;
  entriesAlloced = heap->entriesAlloced;
  v3 = (rxHeapFreeBlock_0 *)v4;
  entriesUsed = heap->entriesUsed;
  if ( entriesAlloced <= entriesUsed )
  {
    v6 = entriesAlloced + 32;
    v7 = (int (__fastcall *)(_DWORD, RwUInt32))*((_DWORD *)RwEngineInstance + 77);
    heap->entriesAlloced = v6;
    v3 = (rxHeapFreeBlock_0 *)v7(v4, 8 * v6);
    if ( !v3 )
    {
      v12.pluginID = 0;
      v12.errorCode = _rwerror(-2147483629, 8 * heap->entriesAlloced);
      RwErrorSet(&v12);
      heap->entriesAlloced -= 32;
      return 0;
    }
    v8 = entriesUsed == 0;
    if ( entriesUsed )
      v8 = heap->freeBlocks == v3;
    if ( !v8 )
    {
      v9 = v3;
      do
      {
        --entriesUsed;
        v9->ptr->freeEntry = v9;
        ++v9;
      }
      while ( entriesUsed );
    }
    heap->freeBlocks = v3;
  }
  if ( v3 )
  {
    v10 = heap->entriesUsed;
    heap->entriesUsed = v10 + 1;
    return &v3[v10];
  }
  return 0;
}
// 1E1172: conditional instruction was optimized away because r5.4==0

//----- (001E1184) --------------------------------------------------------
void *__fastcall RxHeapAlloc(RxHeap_0 *heap, RwUInt32 size)
{
  int v3; // r3
  RwUInt32 v4; // r5
  RwUInt32 entriesUsed; // r6
  rxHeapFreeBlock_0 *v6; // r0
  RwUInt32 v7; // r2
  rxHeapFreeBlock_0 *v8; // r1
  RwUInt32 superBlockSize; // r8
  unsigned int *v10; // r0
  rxHeapSuperBlockDescriptor_0 *v11; // r6
  rxHeapSuperBlockDescriptor_0 *head; // r9
  rxHeapFreeBlock_0 *v13; // r0
  _DWORD *v14; // r1
  __int64 *start; // r3
  int v16; // r2
  int v17; // r4
  __int64 v18; // d18
  __int64 v19; // d19
  _QWORD *v20; // r3
  _QWORD *v21; // r3
  int v22; // r3
  int v23; // r0
  rxHeapSuperBlockDescriptor_0 *v24; // r0
  __int64 v25; // kr08_8
  void *v26; // r0
  rxHeapFreeBlock_0 *v27; // r1
  rxHeapBlockHeader_0 *ptr; // r0
  unsigned int v29; // r3
  RwUInt32 v30; // r2
  rxHeapFreeBlock_0 *v31; // r3
  rxHeapFreeBlock_0 v32; // r2
  RwUInt32 v33; // r1
  rxHeapFreeBlock_0 *v34; // lr
  rxHeapFreeBlock_0 *v35; // r12
  unsigned int v36; // r2
  rxHeapBlockHeader_0 *v37; // r6
  rxHeapBlockHeader_0 *v38; // r4
  rxHeapBlockHeader_0 *v39; // r1
  rxHeapBlockHeader *next; // r2
  rxHeapBlockHeader_0 **v41; // r2
  rxHeapBlockHeader_0 *v42; // r2
  rxHeapBlockHeader *v43; // r3
  rxHeapBlockHeader_0 **v44; // r3
  RwError_0 code; // [sp+4h] [bp-11Ch] BYREF

  v3 = 0;
  v4 = (size + 31) & 0xFFFFFFE0;
  entriesUsed = heap->entriesUsed;
  v6 = &heap->freeBlocks[entriesUsed];
  v7 = entriesUsed;
  v8 = v6 - 1;
  do
  {
    if ( v8[v3].size >= v4 )
    {
      v34 = &v6[v3];
      heap->dirty = 1;
      v35 = &v8[v3];
      ptr = v6[v3 - 1].ptr;
      v36 = v8[v3].size - v4;
      if ( v36 <= 0xFF )
      {
        if ( v3 * 8 )
        {
          v37 = v8->ptr;
          v8[v3].size = v8->size;
          v35->ptr = v37;
          v37->freeEntry = v35;
          entriesUsed = heap->entriesUsed;
        }
        v33 = entriesUsed - 1;
        goto LABEL_20;
      }
      v38 = ptr + 1;
      v39 = (rxHeapBlockHeader_0 *)((char *)v38 + v4);
      *(rxHeapBlockHeader **)((char *)&v38->prev + v4) = ptr;
      v39->size = v36 - 32;
      next = ptr->next;
      v39->freeEntry = v35;
      v39->next = next;
      ptr->next = (rxHeapBlockHeader_0 *)((char *)ptr + v4 + 32);
      ptr->size = v4;
      v41 = *(rxHeapBlockHeader_0 ***)((char *)&ptr[1].next + v4);
      if ( v41 )
        *v41 = v39;
      v34[-1].ptr = v39;
      v35->size = v39->size;
      goto LABEL_29;
    }
    --v3;
    --v7;
  }
  while ( v7 );
  superBlockSize = v4 + 96;
  if ( v4 + 96 < heap->superBlockSize )
    superBlockSize = heap->superBlockSize;
  v10 = (unsigned int *)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(superBlockSize + 139);
  v11 = (rxHeapSuperBlockDescriptor_0 *)v10;
  if ( !v10 )
  {
LABEL_25:
    v38 = 0;
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483629, v4);
    RwErrorSet(&code);
    return v38;
  }
  *v10 = ((unsigned int)v10 + 139) & 0xFFFFFF80;
  v10[1] = superBlockSize;
  v10[2] = 0;
  head = heap->head;
  v13 = HeapFreeBlocksNewEntry(heap);
  if ( !v13 )
  {
    (*((void (__fastcall **)(rxHeapSuperBlockDescriptor_0 *))RwEngineInstance + 76))(v11);
    goto LABEL_25;
  }
  start = (__int64 *)v11->start;
  v14 = v11->start;
  v16 = (int)v11->start + v11->size;
  v17 = (int)v11->start + 32;
  *start = 0LL;
  start[1] = 0LL;
  start += 2;
  v18 = *start;
  v19 = start[1];
  v20 = (_QWORD *)(v16 - 16);
  *v20 = v18;
  v20[1] = v19;
  v21 = (_QWORD *)(v16 - 32);
  *v21 = 0LL;
  v21[1] = 0LL;
  v14[1] = v17;
  v14[8] = v14;
  v14[9] = v16 - 32;
  *(_DWORD *)(v16 - 32) = v17;
  v14[11] = v13;
  v14[10] = v16 - 32 - (_DWORD)(v14 + 16);
  v22 = 0;
  v13->ptr = (rxHeapBlockHeader_0 *)v17;
  v13->size = v14[10];
  if ( head )
  {
    v23 = (int)head->start + head->size;
    *(_DWORD *)(v23 - 28) = v14;
    *v14 = v23 - 32;
  }
  v11->next = heap->head;
  v24 = v11;
  heap->head = v11;
  do
  {
    v25 = *(_QWORD *)&v24->size;
    v24 = v24->next;
    v22 += v25;
  }
  while ( v24 );
  (*((void (__fastcall **)(RwError_0 *, const char *, RwUInt32))RwEngineInstance + 60))(
    &code,
    "Heap resized from %d to %d bytes",
    v22 - superBlockSize);
  v26 = v11->start;
  heap->dirty = 1;
  v27 = (rxHeapFreeBlock_0 *)*((_DWORD *)v26 + 11);
  ptr = v27->ptr;
  v29 = v27->size - v4;
  if ( v29 <= 0xFF )
  {
    v30 = heap->entriesUsed;
    v31 = &heap->freeBlocks[v30 - 1];
    if ( v31 != v27 )
    {
      v32 = *v31;
      *v27 = v32;
      v32.ptr->freeEntry = v27;
      v30 = heap->entriesUsed;
    }
    v33 = v30 - 1;
LABEL_20:
    heap->entriesUsed = v33;
    ptr->freeEntry = 0;
    return &ptr[1];
  }
  v38 = ptr + 1;
  v42 = (rxHeapBlockHeader_0 *)((char *)v38 + v4);
  *(rxHeapBlockHeader **)((char *)&v38->prev + v4) = ptr;
  v42->size = v29 - 32;
  v43 = ptr->next;
  v42->freeEntry = v27;
  v42->next = v43;
  ptr->next = (rxHeapBlockHeader_0 *)((char *)ptr + v4 + 32);
  ptr->size = v4;
  v44 = *(rxHeapBlockHeader_0 ***)((char *)&ptr[1].next + v4);
  if ( v44 )
    *v44 = v42;
  v27->ptr = v42;
  v27->size = v42->size;
LABEL_29:
  ptr->freeEntry = 0;
  return v38;
}

//----- (001E13E0) --------------------------------------------------------
void *__fastcall RxHeapRealloc(RxHeap_0 *heap, void *block, RwUInt32 newSize, RwBool allowCopy)
{
  _DWORD *v4; // r4
  rxHeapFreeBlock_0 *v6; // r0
  int v7; // r1
  RwUInt32 v8; // r5
  char *v9; // r9
  int v10; // r6
  int v11; // r2
  bool v12; // zf
  unsigned int v13; // r2
  void *v14; // r0
  void *v15; // r6
  rxHeapFreeBlock_0 *v16; // r0
  rxHeapBlockHeader_0 *v17; // r1
  rxHeapBlockHeader *v18; // r2
  rxHeapBlockHeader_0 **v19; // r2
  int v20; // r1
  RwUInt32 entriesUsed; // r2
  rxHeapFreeBlock_0 *v22; // r3
  rxHeapFreeBlock_0 v23; // r2
  int v24; // r0
  _DWORD *v25; // r0
  _DWORD *v26; // r1
  int v27; // r0
  _DWORD *v28; // r0
  RwError_0 v30; // [sp+0h] [bp-20h] BYREF

  v4 = block;
  v6 = (rxHeapFreeBlock_0 *)(newSize + 31);
  v7 = *((_DWORD *)block - 6);
  v8 = (newSize + 31) & 0xFFFFFFE0;
  v9 = (char *)(v4 - 8);
  v10 = v8 - v7;
  if ( (int)(v8 - v7) < 1 )
  {
    if ( v10 <= -256 )
    {
      v16 = HeapFreeBlocksNewEntry(heap);
      if ( v16 )
      {
        v17 = (rxHeapBlockHeader_0 *)((char *)v4 + v8);
        *(_DWORD *)((char *)v4 + v8) = v9;
        v17->size = -32 - v10;
        v18 = (rxHeapBlockHeader *)*(v4 - 7);
        v17->freeEntry = v16;
        v17->next = v18;
        *(v4 - 7) = (char *)v4 + v8;
        *(v4 - 6) = v8;
        v19 = *(rxHeapBlockHeader_0 ***)((char *)v4 + v8 + 4);
        if ( v19 )
          *v19 = v17;
        v16->ptr = v17;
        v16->size = v17->size;
      }
    }
  }
  else
  {
    v11 = *(v4 - 7);
    v12 = v11 == 0;
    if ( v11 )
    {
      v6 = *(rxHeapFreeBlock_0 **)(v11 + 12);
      v12 = v6 == 0;
    }
    if ( v12 || (v13 = *(_DWORD *)(v11 + 8) + 32, v13 < v10) )
    {
      v14 = RxHeapAlloc(heap, v8);
      v15 = v14;
      if ( v14 )
      {
        qmemcpy(v14, v4, *(v4 - 6));
        RxHeapFree(heap, v4);
        return v15;
      }
      else
      {
        v4 = 0;
        v30.pluginID = 0;
        v30.errorCode = _rwerror(-2147483629, v8);
        RwErrorSet(&v30);
      }
    }
    else
    {
      v20 = v7 + v13;
      if ( v20 - v8 > 0xFF )
      {
        v26 = (_DWORD *)((char *)v4 + v8);
        v26[3] = v6;
        v27 = *(_DWORD *)(*(v4 - 7) + 8);
        *(_DWORD *)((char *)v4 + v8) = v9;
        v26[2] = v27 - v10;
        v28 = *(_DWORD **)(*(v4 - 7) + 4);
        v26[1] = v28;
        if ( v28 )
          *v28 = v26;
        *(v4 - 7) = v26;
        *(v4 - 6) = v8;
        *(_DWORD *)(v26[3] + 4) = v26;
        *(_DWORD *)v26[3] = v26[2];
      }
      else
      {
        entriesUsed = heap->entriesUsed;
        v22 = &heap->freeBlocks[entriesUsed - 1];
        if ( v22 != v6 )
        {
          v23 = *v22;
          *v6 = v23;
          v23.ptr->freeEntry = v6;
          entriesUsed = heap->entriesUsed;
        }
        heap->entriesUsed = entriesUsed - 1;
        v24 = *(v4 - 7);
        *(v4 - 6) = v20;
        v25 = *(_DWORD **)(v24 + 4);
        *(v4 - 7) = v25;
        if ( v25 )
          *v25 = v9;
      }
    }
  }
  return v4;
}

//----- (001E1510) --------------------------------------------------------
RwBool __fastcall _rxHeapReset(RxHeap_0 *heap)
{
  rxHeapSuperBlockDescriptor *v2; // r5
  rxHeapSuperBlockDescriptor_0 *head; // r6
  rxHeapSuperBlockDescriptor *next; // r0
  rxHeapSuperBlockDescriptor *v5; // r6
  rxHeapFreeBlock_0 *v6; // r0
  _DWORD *start; // r1
  __int64 v8; // kr00_8
  int v9; // r2
  int v10; // r4
  __int64 v11; // d17
  _QWORD *v12; // r3
  _QWORD *v13; // r3
  int v14; // r0
  rxHeapFreeBlock_0 *v15; // r0
  _DWORD *v16; // r1
  __int64 v17; // kr08_8
  int v18; // r2
  int v19; // r4
  __int64 v20; // d19
  _QWORD *v21; // r3
  _QWORD *v22; // r3
  int v23; // r0

  v2 = 0;
  head = heap->head;
  heap->entriesUsed = 0;
  next = head->next;
  if ( next )
  {
    v5 = 0;
    while ( 1 )
    {
      v2 = next;
      v6 = HeapFreeBlocksNewEntry(heap);
      if ( !v6 )
        return 0;
      v8 = *(_QWORD *)&v2->start;
      start = v2->start;
      v9 = (int)v2->start + v2->size;
      v10 = (int)v2->start + 32;
      *(_QWORD *)v8 = 0LL;
      *(_QWORD *)(v8 + 8) = 0LL;
      v11 = *(_QWORD *)(v8 + 24);
      v12 = (_QWORD *)(v9 - 16);
      *v12 = *(_QWORD *)(v8 + 16);
      v12[1] = v11;
      v13 = (_QWORD *)(v9 - 32);
      *v13 = 0LL;
      v13[1] = 0LL;
      start[1] = v10;
      start[8] = start;
      start[9] = v9 - 32;
      *(_DWORD *)(v9 - 32) = v10;
      start[11] = v6;
      start[10] = v9 - 32 - (_DWORD)(start + 16);
      v6->ptr = (rxHeapBlockHeader_0 *)v10;
      v6->size = start[10];
      if ( v5 )
      {
        v14 = (int)v5->start + v5->size;
        *(_DWORD *)(v14 - 28) = start;
        *start = v14 - 32;
      }
      else
      {
        heap->headBlock = (rxHeapBlockHeader_0 *)v2->start;
      }
      next = v2->next;
      v5 = v2;
      if ( !next )
      {
        head = heap->head;
        break;
      }
    }
  }
  v15 = HeapFreeBlocksNewEntry(heap);
  if ( !v15 )
    return 0;
  v17 = *(_QWORD *)&head->start;
  v16 = head->start;
  v18 = (int)head->start + head->size;
  v19 = (int)head->start + 32;
  *(_QWORD *)v17 = 0LL;
  *(_QWORD *)(v17 + 8) = 0LL;
  v20 = *(_QWORD *)(v17 + 24);
  v21 = (_QWORD *)(v18 - 16);
  *v21 = *(_QWORD *)(v17 + 16);
  v21[1] = v20;
  v22 = (_QWORD *)(v18 - 32);
  *v22 = 0LL;
  v22[1] = 0LL;
  v16[1] = v19;
  v16[8] = v16;
  v16[9] = v18 - 32;
  *(_DWORD *)(v18 - 32) = v19;
  v16[11] = v15;
  v16[10] = v18 - 32 - (_DWORD)(v16 + 16);
  v15->ptr = (rxHeapBlockHeader_0 *)v19;
  v15->size = v16[10];
  if ( v2 )
  {
    v23 = (int)v2->start + v2->size;
    *(_DWORD *)(v23 - 28) = v16;
    *v16 = v23 - 32;
  }
  else
  {
    heap->headBlock = (rxHeapBlockHeader_0 *)head->start;
  }
  heap->dirty = 0;
  return 1;
}

//----- (001E1620) --------------------------------------------------------
void __fastcall RxHeapDestroy(RxHeap_0 *heap)
{
  rxHeapSuperBlockDescriptor_0 *head; // r0
  rxHeapSuperBlockDescriptor_0 *next; // r6

  if ( heap )
  {
    if ( heap->freeBlocks )
    {
      (*((void (**)(void))RwEngineInstance + 76))();
      heap->freeBlocks = 0;
    }
    head = heap->head;
    if ( head )
    {
      do
      {
        next = head->next;
        (*((void (**)(void))RwEngineInstance + 76))();
        head = next;
      }
      while ( next );
    }
    (*((void (__fastcall **)(RxHeap_0 *))RwEngineInstance + 76))(heap);
  }
}

//----- (001E1688) --------------------------------------------------------
RxHeap_0 *__fastcall RxHeapCreate(RwUInt32 size)
{
  int v2; // r4
  RwUInt32 v3; // r6
  unsigned int *v4; // r0
  unsigned int *v5; // r5

  v2 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(28);
  if ( !v2 )
    return 0;
  if ( size <= 0x400 )
    size = 1024;
  v3 = (size + 31) & 0xFFFFFFE0;
  if ( v3 <= 0x80 )
    v3 = 128;
  v4 = (unsigned int *)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(v3 + 139);
  v5 = v4;
  if ( !v4 )
  {
LABEL_9:
    (*((void (__fastcall **)(int))RwEngineInstance + 76))(v2);
    return 0;
  }
  *v4 = ((unsigned int)v4 + 139) & 0xFFFFFF80;
  v4[1] = v3;
  v4[2] = 0;
  *(_DWORD *)v2 = v3;
  *(_DWORD *)(v2 + 4) = v4;
  *(_DWORD *)(v2 + 12) = 0;
  *(_DWORD *)(v2 + 16) = 0;
  *(_QWORD *)(v2 + 20) = 0x100000000LL;
  if ( !_rxHeapReset((RxHeap_0 *)v2) )
  {
    (*((void (__fastcall **)(unsigned int *))RwEngineInstance + 76))(v5);
    goto LABEL_9;
  }
  return (RxHeap_0 *)v2;
}

//----- (001E1734) --------------------------------------------------------
int __fastcall _rxNotAFunction17(int x)
{
  return x * x;
}

//----- (001E1740) --------------------------------------------------------
RxRenderStateVector_0 *__fastcall RxRenderStateVectorSetDefaultRenderStateVector(RxRenderStateVector_0 *rsvp)
{
  RwInt32 v2; // r0
  RxRenderStateVector_0 *v3; // r1
  __int64 v4; // d16
  __int64 v5; // d17
  __int64 v6; // d18
  __int64 v7; // d19
  __int64 v8; // d21
  RwInt32 pluginID; // r0
  RwError_0 code; // [sp+8h] [bp-10h] BYREF

  v2 = -2147483626;
  if ( !rsvp )
  {
    rsvp = 0;
LABEL_7:
    code.pluginID = 0;
    code.errorCode = _rwerror(v2);
    RwErrorSet(&code);
    return rsvp;
  }
  v3 = (RxRenderStateVector_0 *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 4);
  if ( *((_DWORD *)RwEngineInstance + 82) != 3 )
  {
    if ( v3 == rsvp )
    {
      CRGBA::CRGBA((CRGBA *)&code, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
      rsvp->AddressModeU = rwTEXTUREADDRESSWRAP;
      rsvp->AddressModeV = rwTEXTUREADDRESSWRAP;
      rsvp->FilterMode = rwFILTERLINEAR;
      *(_QWORD *)&rsvp->Flags = 0x200000007LL;
      *(_QWORD *)&rsvp->SrcBlend = 0x600000005LL;
      rsvp->TextureRaster = 0;
      pluginID = code.pluginID;
      rsvp->FogType = rwFOGTYPENAFOGTYPE;
      rsvp->BorderColor = (RwRGBA_0)pluginID;
      rsvp->FogColor = (RwRGBA_0)pluginID;
      return rsvp;
    }
    rsvp = 0;
    v2 = -2147483624;
    goto LABEL_7;
  }
  v4 = *(_QWORD *)&v3->Flags;
  v5 = *(_QWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 12);
  v6 = *(_QWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 20);
  v7 = *(_QWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 28);
  v8 = *(_QWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 40);
  *(_QWORD *)&rsvp->FilterMode = *(_QWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 32);
  *(_QWORD *)&rsvp->FogType = v8;
  *(_QWORD *)&rsvp->Flags = v4;
  *(_QWORD *)&rsvp->SrcBlend = v5;
  *(_QWORD *)&rsvp->TextureRaster = v6;
  *(_QWORD *)&rsvp->AddressModeV = v7;
  return rsvp;
}

//----- (001E1808) --------------------------------------------------------
const RxRenderStateVector_0 *RxRenderStateVectorGetDefaultRenderStateVector()
{
  int v0; // r4
  RwError_0 v2; // [sp+0h] [bp-10h] BYREF

  if ( *((_DWORD *)RwEngineInstance + 82) == 3 )
    return (const RxRenderStateVector_0 *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 4);
  v0 = 0;
  v2.pluginID = 0;
  v2.errorCode = _rwerror(-2147483624);
  RwErrorSet(&v2);
  return (const RxRenderStateVector_0 *)v0;
}

//----- (001E1850) --------------------------------------------------------
RxRenderStateVector_0 *__fastcall RxRenderStateVectorCreate(RwBool current)
{
  int v2; // r0
  RxRenderStateVector_0 *v3; // r4
  RwInt32 v4; // r0
  __int64 v6; // d16
  __int64 v7; // d17
  __int64 v8; // d21
  __int64 v9; // d18
  __int64 v10; // d19
  RwError_0 v11; // [sp+0h] [bp-18h] BYREF

  if ( *((_DWORD *)RwEngineInstance + 82) != 3 )
  {
    v3 = 0;
    v11.pluginID = 0;
    v4 = _rwerror(-2147483624);
LABEL_8:
    v11.errorCode = v4;
    RwErrorSet(&v11);
    return v3;
  }
  v2 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(44);
  v3 = (RxRenderStateVector_0 *)v2;
  if ( !v2 )
  {
    v3 = 0;
    v11.pluginID = 0;
    v4 = _rwerror(-2147483629, 44);
    goto LABEL_8;
  }
  if ( current )
  {
    if ( !RxRenderStateVectorLoadDriverState((RxRenderStateVector_0 *)v2) )
      (*((void (__fastcall **)(RxRenderStateVector_0 *))RwEngineInstance + 76))(v3);
  }
  else
  {
    v6 = *(_QWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 4);
    v7 = *(_QWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 12);
    v8 = *(_QWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 40);
    v9 = *(_QWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 20);
    v10 = *(_QWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 28);
    *(_QWORD *)(v2 + 28) = *(_QWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 32);
    *(_QWORD *)(v2 + 36) = v8;
    *(_QWORD *)v2 = v6;
    *(_QWORD *)(v2 + 8) = v7;
    *(_QWORD *)(v2 + 16) = v9;
    *(_QWORD *)(v2 + 24) = v10;
  }
  return v3;
}

//----- (001E1910) --------------------------------------------------------
RxRenderStateVector_0 *__fastcall RxRenderStateVectorLoadDriverState(RxRenderStateVector_0 *rsvp)
{
  RxRenderStateVector_0 *v1; // r4
  RwError_0 code; // [sp+4h] [bp-14h] BYREF
  int value[3]; // [sp+Ch] [bp-Ch] BYREF

  v1 = rsvp;
  if ( rsvp )
  {
    rsvp->Flags = 0;
    RwRenderStateGet(rwRENDERSTATETEXTUREPERSPECTIVE, value);
    if ( value[0] )
      v1->Flags |= 1u;
    RwRenderStateGet(rwRENDERSTATEZTESTENABLE, value);
    if ( value[0] )
      v1->Flags |= 2u;
    RwRenderStateGet(rwRENDERSTATEZWRITEENABLE, value);
    if ( value[0] )
      v1->Flags |= 4u;
    RwRenderStateGet(rwRENDERSTATEVERTEXALPHAENABLE, value);
    if ( value[0] )
      v1->Flags |= 8u;
    RwRenderStateGet(rwRENDERSTATESHADEMODE, &v1->ShadeMode);
    RwRenderStateGet(rwRENDERSTATESRCBLEND, &v1->SrcBlend);
    RwRenderStateGet(rwRENDERSTATEDESTBLEND, &v1->DestBlend);
    RwRenderStateGet(rwRENDERSTATETEXTURERASTER, &v1->TextureRaster);
    if ( RwRenderStateGet(rwRENDERSTATETEXTUREADDRESS, &v1->AddressModeU) )
      v1->AddressModeV = v1->AddressModeU;
    RwRenderStateGet(rwRENDERSTATETEXTUREFILTER, &v1->FilterMode);
    RwRenderStateGet(rwRENDERSTATEBORDERCOLOR, &v1->BorderColor);
    RwRenderStateGet(rwRENDERSTATEFOGTYPE, &v1->FogType);
    RwRenderStateGet(rwRENDERSTATEFOGCOLOR, &v1->FogColor);
  }
  else
  {
    v1 = 0;
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483626);
    RwErrorSet(&code);
  }
  return v1;
}

//----- (001E19F8) --------------------------------------------------------
void __fastcall RxRenderStateVectorDestroy(RxRenderStateVector_0 *rsvp)
{
  RwError_0 v1; // [sp+0h] [bp-10h] BYREF

  if ( rsvp )
  {
    (*((void (**)(void))RwEngineInstance + 76))();
  }
  else
  {
    v1.pluginID = 0;
    v1.errorCode = _rwerror(-2147483626);
    RwErrorSet(&v1);
  }
}

//----- (001E1A2C) --------------------------------------------------------
void __fastcall _rx_rxRadixExchangeSort(
        void *elements,
        RwUInt32 numElements,
        RwUInt32 elementSize,
        RwUInt32 elementKeyOffset,
        RwUInt32 keyLo,
        RwUInt32 a6)
{
  RwUInt32 v6; // r5
  RwUInt32 v8; // r2
  bool v9; // cf
  RwUInt32 v10; // r2
  char v11; // r1
  RwUInt32 v12; // r4
  RwUInt32 v13; // r2
  RwUInt32 v14; // r8
  int *v15; // r5
  unsigned int v16; // t1
  unsigned int v17; // r11
  unsigned int v18; // lr
  unsigned int v19; // r9
  unsigned int v20; // r10
  RwUInt32 v21; // r2
  int *v22; // r1
  int *v23; // r0
  int v24; // r2
  RwUInt32 v25; // r8
  _QWORD *v26; // r5
  __int64 *v27; // r4
  __int64 v28; // d16
  __int64 v29; // d17
  __int64 v30; // d18
  __int64 v31; // d19
  int v32; // r4
  int v33; // r1
  unsigned int v34; // r5
  RwUInt32 v35; // r10
  int v36; // r2
  unsigned int v37; // r6
  unsigned int *v38; // r5
  unsigned int v39; // r4
  char *v40; // r6
  RwUInt32 v41; // r2
  RwUInt32 v42; // r5
  int v43; // r8
  RwUInt32 v44; // r9
  RwUInt32 v45; // lr
  unsigned int v46; // r5
  char *v47; // r2
  RwUInt32 v48; // r0
  _QWORD *v49; // r4
  _QWORD *v50; // r5
  __int64 v51; // d17
  __int64 v52; // d18
  __int64 v53; // d19
  int v54; // r5
  RwUInt32 v55; // r1
  char *v56; // r4
  RwUInt32 v57; // r6
  RwUInt32 v58; // r2
  RwUInt32 v59; // lr
  int *v60; // r0
  unsigned int v61; // r5
  unsigned int v62; // r9
  int v63; // r11
  int *v64; // r8
  RwUInt32 v65; // r5
  RwUInt32 v66; // r4
  unsigned int v67; // lr
  int *v68; // r10
  _QWORD *v69; // r6
  int *v70; // r2
  __int64 v71; // d16
  __int64 v72; // d17
  __int64 v73; // d19
  RwUInt32 v74; // r5
  int v75; // r2
  RwUInt32 v76; // [sp+0h] [bp-1DCh]
  RwUInt32 v77; // [sp+4h] [bp-1D8h]
  RwUInt32 v78; // [sp+8h] [bp-1D4h]
  int v79; // [sp+Ch] [bp-1D0h]
  RwUInt32 v81; // [sp+10h] [bp-1CCh]
  int v82; // [sp+14h] [bp-1C8h]
  RwUInt32 v83; // [sp+14h] [bp-1C8h]
  RwUInt32 v84; // [sp+18h] [bp-1C4h]
  int v85; // [sp+1Ch] [bp-1C0h]
  char *v86; // [sp+20h] [bp-1BCh]
  int *v87; // [sp+24h] [bp-1B8h]
  RwUInt32 v88; // [sp+28h] [bp-1B4h]
  int v89; // [sp+28h] [bp-1B4h]
  RwUInt32 v90; // [sp+2Ch] [bp-1B0h]
  int *v91; // [sp+34h] [bp-1A8h]
  unsigned int v92; // [sp+38h] [bp-1A4h]
  unsigned int v93; // [sp+3Ch] [bp-1A0h]
  RwUInt32 v94; // [sp+3Ch] [bp-1A0h]
  _DWORD v95[3]; // [sp+40h] [bp-19Ch] BYREF
  int v96; // [sp+4Ch] [bp-190h] BYREF

  v8 = numElements;
  if ( !elements )
    return;
  v9 = elementKeyOffset + 4 >= elementSize;
  if ( elementKeyOffset + 4 <= elementSize )
  {
    v6 = a6;
    v9 = keyLo >= a6;
  }
  if ( v9 )
    return;
  v86 = (char *)elements;
  if ( numElements >= 6 )
  {
    v10 = (numElements - 1) * elementSize;
    v11 = -1;
    do
    {
      ++v11;
      v6 >>= 1;
    }
    while ( v6 );
    v12 = 5 * elementSize;
    v95[0] = elements;
    v95[1] = (char *)elements + v10;
    v95[2] = 1 << v11;
    v13 = (elementSize - 4) & 0xFFFFFFFC;
    v14 = ((elementSize - 4) >> 2) + 1;
    v85 = v14 & 3;
    v84 = elementSize - 4 - v13 + 4 * v85;
    v15 = &v96;
    v90 = v14 - v85;
    v88 = v13 + 4;
    v82 = 4 * (v14 - v85);
    do
    {
      v16 = *(v15 - 3);
      v15 -= 3;
      v18 = v15[2];
      v17 = v15[1];
      v93 = v16;
      v92 = v16 + v12;
      do
      {
        v19 = v93;
        v20 = v17;
        do
        {
          while ( (*(_DWORD *)(v19 + elementKeyOffset) & v18) == 0 )
          {
            v19 += elementSize;
            if ( v19 > v20 )
              goto LABEL_27;
          }
          while ( (*(_DWORD *)(v20 + elementKeyOffset) & v18) != 0 )
          {
            v20 -= elementSize;
            if ( v19 > v20 )
              goto LABEL_27;
          }
          v91 = v15;
          if ( elementSize >= 4 )
          {
            v21 = elementSize;
            v22 = (int *)v20;
            v23 = (int *)v19;
            if ( v14 < 4 )
              goto LABEL_75;
            v21 = elementSize;
            v22 = (int *)v20;
            v23 = (int *)v19;
            if ( !v90 )
              goto LABEL_75;
            if ( v20 < v88 + v19 )
            {
              v21 = elementSize;
              v22 = (int *)v20;
              v23 = (int *)v19;
              if ( v19 < v88 + v20 )
                goto LABEL_75;
            }
            v24 = 0;
            v25 = v90;
            v23 = (int *)(v19 + v82);
            v22 = (int *)(v82 + v20);
            do
            {
              v26 = (_QWORD *)(v19 + v24);
              v27 = (__int64 *)(v20 + v24);
              v28 = *(_QWORD *)(v19 + v24);
              v29 = *(_QWORD *)(v19 + v24 + 8);
              v25 -= 4;
              v24 += 16;
              v30 = *v27;
              v31 = v27[1];
              *v27 = v28;
              v27[1] = v29;
              *v26 = v30;
              v26[1] = v31;
            }
            while ( v25 );
            v14 = ((elementSize - 4) >> 2) + 1;
            v21 = v84;
            if ( v85 )
            {
LABEL_75:
              do
              {
                v32 = *v22;
                v21 -= 4;
                *v22++ = *v23;
                *v23++ = v32;
              }
              while ( v21 > 3 );
            }
          }
          v12 = 5 * elementSize;
          v15 = v91;
          v20 -= elementSize;
          v19 += elementSize;
        }
        while ( v19 <= v20 );
LABEL_27:
        if ( !(v18 >> 1) )
          break;
        v18 >>= 1;
        if ( v17 >= v20 + elementSize + v12 )
        {
          *v15 = v20 + elementSize;
          v15[1] = v17;
          v15[2] = v18;
          v15 += 3;
        }
        v17 = v19 - elementSize;
      }
      while ( v19 - elementSize >= v92 );
    }
    while ( v15 != v95 );
    elements = v86;
    v8 = numElements;
  }
  if ( v8 < 2 )
    return;
  v33 = v8 - 1;
  v34 = -v8;
  v35 = v8 - 1;
  if ( v8 - 1 >= 4 )
    v33 = 4;
  if ( v34 <= 0xFFFFFFFB )
    v34 = -5;
  v36 = -2 - v34;
  v37 = *(_DWORD *)((char *)elements + v33 * elementSize + elementKeyOffset);
  v38 = (unsigned int *)((char *)elements + elementKeyOffset + elementSize * (-2 - v34));
  do
  {
    v39 = *v38;
    v38 = (unsigned int *)((char *)v38 - elementSize);
    if ( v39 < v37 )
      v33 = v36;
    --v36;
    if ( v39 < v37 )
      v37 = v39;
  }
  while ( v36 != -1 );
  if ( v33 && elementSize >= 4 )
  {
    v40 = &v86[v33 * elementSize];
    v41 = elementSize - 4;
    v42 = ((elementSize - 4) >> 2) + 1;
    if ( v42 < 4 || (v43 = v42 & 3, v44 = v42 - v43, v42 == v43) )
    {
      v48 = elementSize;
      v47 = v86;
    }
    else
    {
      v45 = v33 * elementSize;
      v46 = v41 & 0xFFFFFFFC;
      if ( v40 >= &v86[(v41 & 0xFFFFFFFC) + 4] || (v47 = v86, v48 = elementSize, &v86[v45 + 4 + v46] <= v86) )
      {
        v40 += 4 * v44;
        v47 = &v86[4 * v44];
        v48 = elementSize + 4 * v43 - 4 - v46;
        v49 = v86;
        do
        {
          v44 -= 4;
          v51 = v49[1];
          v50 = (_QWORD *)((char *)v49 + v45);
          v52 = *(_QWORD *)((char *)v49 + v45);
          v53 = *(_QWORD *)((char *)v49 + v45 + 8);
          *v50 = *v49;
          v50[1] = v51;
          *v49 = v52;
          v49[1] = v53;
          v49 += 2;
        }
        while ( v44 );
        if ( !v43 )
          goto LABEL_56;
      }
    }
    do
    {
      v54 = *(_DWORD *)v40;
      v48 -= 4;
      *(_DWORD *)v40 = *(_DWORD *)v47;
      v40 += 4;
      *(_DWORD *)v47 = v54;
      v47 += 4;
    }
    while ( v48 > 3 );
  }
LABEL_56:
  v55 = -elementSize;
  v56 = v86;
  v57 = v35;
  if ( v35 )
  {
    v58 = (elementSize - 4) & 0xFFFFFFFC;
    v87 = (int *)v86;
    v83 = (((elementSize - 4) >> 2) + 1) & 3;
    v81 = elementSize - 4 - v58 + 4 * v83;
    v59 = ((elementSize - 4) >> 2) + 1;
    v77 = v58 + elementSize + 4;
    v76 = v58 + 4;
    v89 = 0;
    v94 = v59 - v83;
    v79 = 4 * (v59 - v83);
    while ( 1 )
    {
      v60 = v87;
      v78 = v57;
      v61 = *(int *)((char *)v87 + elementKeyOffset);
      v87 = (int *)((char *)v87 + elementSize);
      v62 = *(int *)((char *)v87 + elementKeyOffset);
      if ( v61 > v62 )
        break;
LABEL_72:
      v57 = v78 - 1;
      ++v89;
      if ( v78 == 1 )
        return;
    }
    v63 = 0;
    v64 = v87;
    while ( 1 )
    {
      v68 = v64;
      v64 = v60;
      if ( elementSize >= 4 )
      {
        if ( v59 >= 4
          && v94
          && (&v56[elementSize + v89 * elementSize + v63 * v55] >= &v56[v76 + v89 * elementSize + v63 * v55]
           || &v56[v89 * elementSize + v63 * v55] >= &v56[v77 + v89 * elementSize + v63 * v55]) )
        {
          v65 = (RwUInt32)v60 + elementSize;
          v66 = v94;
          v67 = 0;
          v60 = (int *)((char *)v60 + v79);
          v68 = (int *)((char *)v68 + v79);
          do
          {
            v69 = (_QWORD *)(v65 + v67);
            v70 = &v64[v67 / 4];
            v71 = *(_QWORD *)(v65 + v67);
            v72 = *(_QWORD *)(v65 + v67 + 8);
            v66 -= 4;
            v67 += 16;
            v73 = *((_QWORD *)v70 + 1);
            *v69 = *(_QWORD *)v70;
            v69[1] = v73;
            *(_QWORD *)v70 = v71;
            *((_QWORD *)v70 + 1) = v72;
          }
          while ( v66 );
          v74 = v81;
          v56 = v86;
          v59 = ((elementSize - 4) >> 2) + 1;
          v55 = -elementSize;
          if ( !v83 )
            goto LABEL_71;
        }
        else
        {
          v74 = elementSize;
        }
        do
        {
          v75 = *v68;
          v74 -= 4;
          *v68++ = *v60;
          *v60++ = v75;
        }
        while ( v74 > 3 );
      }
LABEL_71:
      v60 = (int *)((char *)v64 + v55);
      ++v63;
      if ( *(int *)((char *)v64 + v55 + elementKeyOffset) <= v62 )
        goto LABEL_72;
    }
  }
}
// 1E1A6E: variable 'v6' is possibly undefined

//----- (001E1DDA) --------------------------------------------------------
void __fastcall _rxSelectionSort(
        void *elements,
        RwUInt32 numElements,
        RwUInt32 elementSize,
        RwUInt32 elementKeyOffset,
        RwUInt32 keyLo,
        RwUInt32 keyHi)
{
  RwUInt32 v6; // r4
  int v7; // r10
  RwUInt32 v8; // r0
  char *v9; // r9
  char *v10; // lr
  _DWORD *v11; // r8
  int v12; // r11
  unsigned int v13; // r12
  _DWORD *v14; // r4
  unsigned int v15; // r0
  RwUInt32 v16; // r1
  char *v17; // r6
  RwUInt32 v18; // r1
  int v19; // r0
  _QWORD *v20; // r4
  char *v21; // r5
  __int64 v22; // d16
  __int64 v23; // d17
  __int64 v24; // d18
  __int64 v25; // d19
  int v26; // r0
  int v27; // [sp+0h] [bp-3Ch]
  RwUInt32 v28; // [sp+4h] [bp-38h]
  int v29; // [sp+8h] [bp-34h]
  RwUInt32 v30; // [sp+Ch] [bp-30h]
  RwUInt32 v31; // [sp+14h] [bp-28h]
  RwUInt32 v33; // [sp+1Ch] [bp-20h]

  if ( elements && elementKeyOffset + 4 <= elementSize && numElements >= 2 && keyLo < keyHi )
  {
    v6 = (elementSize - 4) & 0xFFFFFFFC;
    v7 = 0;
    v8 = ((elementSize - 4) >> 2) + 1;
    v28 = elementSize - 4 - v6 + 4 * (v8 & 3);
    v29 = v8 & 3;
    v9 = (char *)elements;
    v30 = v8 - v29;
    v10 = (char *)elements + elementSize;
    v27 = 4 * (v8 - v29);
    v31 = v6 + 4;
    do
    {
      if ( numElements == 1 )
        return;
      v33 = numElements - 1;
      v11 = 0;
      v12 = 1;
      v13 = *(_DWORD *)&v9[elementKeyOffset];
      v14 = v10;
      do
      {
        v15 = *(_DWORD *)((char *)v14 + elementKeyOffset);
        ++v12;
        if ( v15 < v13 )
          v11 = v14;
        v14 = (_DWORD *)((char *)v14 + elementSize);
        if ( v15 < v13 )
          v13 = v15;
      }
      while ( numElements != v12 );
      if ( v11 && elementSize >= 4 )
      {
        if ( ((elementSize - 4) >> 2) + 1 >= 4 && v30 )
        {
          if ( (char *)elements + v7 * elementSize >= (char *)v11 + v31
            || (v16 = elementSize, v17 = v9, v11 >= (_DWORD *)((char *)elements + v31 + v7 * elementSize)) )
          {
            v18 = v30;
            v17 = &v9[v27];
            v19 = 0;
            do
            {
              v20 = &v11[v19];
              v21 = &v9[v19 * 4];
              v22 = *(_QWORD *)&v11[v19];
              v23 = *(_QWORD *)&v11[v19 + 2];
              v18 -= 4;
              v19 += 4;
              v24 = *(_QWORD *)v21;
              v25 = *((_QWORD *)v21 + 1);
              *(_QWORD *)v21 = v22;
              *((_QWORD *)v21 + 1) = v23;
              *v20 = v24;
              v20[1] = v25;
            }
            while ( v18 );
            v11 = (_DWORD *)((char *)v11 + v27);
            v16 = v28;
            if ( !v29 )
              goto LABEL_25;
          }
        }
        else
        {
          v16 = elementSize;
          v17 = v9;
        }
        do
        {
          v26 = *(_DWORD *)v17;
          v16 -= 4;
          *(_DWORD *)v17 = *v11;
          v17 += 4;
          *v11++ = v26;
        }
        while ( v16 > 3 );
      }
LABEL_25:
      numElements = v33;
      v10 += elementSize;
      v9 += elementSize;
      ++v7;
    }
    while ( v33 );
  }
}

//----- (001E1EF4) --------------------------------------------------------
RwBool __fastcall _rwStreamReadChunkHeader(
        RwStream_0 *stream,
        RwUInt32 *type,
        RwUInt32 *length,
        RwUInt32 *version,
        RwUInt32 *buildNum)
{
  RwUInt32 v8; // r1
  RwError_0 code; // [sp+4h] [bp-24h] BYREF
  int buffer[2]; // [sp+Ch] [bp-1Ch] BYREF
  unsigned int v12; // [sp+14h] [bp-14h]

  if ( RwStreamRead(stream, buffer, 0xCu) != 12 )
  {
    code.pluginID = 1;
    code.errorCode = _rwerror(-2147483622);
    RwErrorSet(&code);
    return 0;
  }
  if ( type )
    *type = buffer[0];
  if ( length )
    *length = buffer[1];
  LOWORD(v8) = v12;
  if ( HIWORD(v12) )
  {
    if ( version )
      *version = (((unsigned int)&stru_3FEFC.st_value & (v12 >> 14)) + 196608) | HIWORD(v12) & 0x3F;
    if ( !buildNum )
      return 1;
    v8 = (unsigned __int16)v8;
  }
  else
  {
    if ( version )
      *version = v12 << 8;
    if ( !buildNum )
      return 1;
    v8 = 0;
  }
  *buildNum = v8;
  return 1;
}
// 3FEFC: using guessed type Elf32_Sym stru_3FEFC;

//----- (001E1F82) --------------------------------------------------------
RwStream_0 *__fastcall _rwStreamWriteVersionedChunkHeader(
        RwStream_0 *stream,
        RwInt32 type,
        RwInt32 size,
        RwUInt32 version,
        RwUInt32 buildNum)
{
  _DWORD buffer[5]; // [sp+4h] [bp-14h] BYREF

  buffer[0] = type;
  buffer[1] = size;
  buffer[2] = (version << 16) & 0x3F0000 | (unsigned __int16)buildNum | ((version << 14) + 0x40000000) & 0xFFC00000;
  return RwStreamWrite(stream, buffer, 0xCu);
}

//----- (001E1FBA) --------------------------------------------------------
RwBool __fastcall RwStreamFindChunk(RwStream_0 *stream, RwUInt32 type, RwUInt32 *lengthOut, RwUInt32 *versionOut)
{
  unsigned int v8; // r0
  bool v9; // zf
  RwBool v10; // r4
  char *v12; // r2
  RwError_0 v13; // [sp+0h] [bp-30h] BYREF
  RwError_0 buffer; // [sp+8h] [bp-28h] BYREF
  unsigned int v15; // [sp+10h] [bp-20h]

  while ( 1 )
  {
    if ( RwStreamRead(stream, &buffer, 0xCu) != 12 )
    {
      v13.pluginID = 1;
      v13.errorCode = _rwerror(-2147483622);
      RwErrorSet(&v13);
      return 0;
    }
    if ( HIWORD(v15) )
      v8 = HIWORD(v15) & 0x3F | (((unsigned int)&stru_3FEFC.st_value & (v15 >> 14)) + 196608);
    else
      v8 = v15 << 8;
    v9 = buffer.pluginID == 43;
    if ( buffer.pluginID != 43 )
      v9 = buffer.pluginID == type;
    if ( !v9 && buffer.pluginID > 0x14u )
      return 0;
    if ( buffer.pluginID == type )
      break;
    if ( !RwStreamSkip(stream, buffer.errorCode) )
      return 0;
  }
  if ( v8 >> 14 > 0xC )
  {
    v12 = (char *)&stru_35FFC.st_value + 3;
    v10 = 1;
    if ( v8 < (unsigned int)&stru_35FFC.st_value + 3 )
      v12 = (char *)v8;
    if ( lengthOut )
      *lengthOut = buffer.errorCode;
    if ( versionOut )
      *versionOut = (RwUInt32)v12;
  }
  else
  {
    v10 = 0;
    buffer.pluginID = 0;
    buffer.errorCode = _rwerror(-2147483644, buffer.errorCode);
    RwErrorSet(&buffer);
  }
  return v10;
}
// 35FFC: using guessed type Elf32_Sym stru_35FFC;
// 3FEFC: using guessed type Elf32_Sym stru_3FEFC;

//----- (001E2094) --------------------------------------------------------
RwStream_0 *__fastcall RwStreamWriteReal(RwStream_0 *stream, const RwReal *reals, RwUInt32 numBytes)
{
  size_t v6; // r4
  RwStream_0 *v7; // r0
  _BYTE v9[260]; // [sp+0h] [bp-120h] BYREF

  while ( numBytes )
  {
    v6 = numBytes;
    if ( numBytes >= 0x100 )
      v6 = 256;
    qmemcpy(v9, reals, v6);
    v7 = RwStreamWrite(stream, v9, v6);
    reals = (const RwReal *)((char *)reals + v6);
    if ( v7 )
      numBytes -= v6;
    if ( !v7 )
      return 0;
  }
  return stream;
}

//----- (001E2108) --------------------------------------------------------
RwStream_0 *__fastcall RwStreamWriteInt32(RwStream_0 *stream, const RwInt32 *ints, RwUInt32 numBytes)
{
  RwStreamWrite(stream, ints, numBytes);
  return stream;
}

//----- (001E2116) --------------------------------------------------------
RwStream_0 *__fastcall RwStreamWriteInt16(RwStream_0 *stream, const RwInt16 *ints, RwUInt32 numBytes)
{
  RwStreamWrite(stream, ints, numBytes);
  return stream;
}

//----- (001E2124) --------------------------------------------------------
RwStream_0 *__fastcall RwStreamReadInt16(RwStream_0 *stream, RwInt16 *ints, RwUInt32 numBytes)
{
  RwStream_0 *v3; // r4
  RwError_0 v5; // [sp+0h] [bp-10h] BYREF

  v3 = stream;
  if ( !RwStreamRead(stream, ints, numBytes) )
  {
    v3 = 0;
    v5.pluginID = 0;
    v5.errorCode = _rwerror(-2147483622);
    RwErrorSet(&v5);
  }
  return v3;
}

//----- (001E214E) --------------------------------------------------------
RwStream_0 *__fastcall RwStreamReadReal(RwStream_0 *stream, RwReal *reals, RwUInt32 numBytes)
{
  RwStream_0 *v3; // r4
  RwError_0 v5; // [sp+0h] [bp-10h] BYREF

  v3 = stream;
  if ( !RwStreamRead(stream, reals, numBytes) )
  {
    v3 = 0;
    v5.pluginID = 0;
    v5.errorCode = _rwerror(-2147483622);
    RwErrorSet(&v5);
  }
  return v3;
}

//----- (001E2178) --------------------------------------------------------
RwStream_0 *__fastcall RwStreamReadInt32(RwStream_0 *stream, RwInt32 *ints, RwUInt32 numBytes)
{
  RwStream_0 *v3; // r4
  RwError_0 v5; // [sp+0h] [bp-10h] BYREF

  v3 = stream;
  if ( !RwStreamRead(stream, ints, numBytes) )
  {
    v3 = 0;
    v5.pluginID = 0;
    v5.errorCode = _rwerror(-2147483622);
    RwErrorSet(&v5);
  }
  return v3;
}

//----- (001E21A4) --------------------------------------------------------
RwStream_0 *__fastcall RwStreamReadChunkHeaderInfo(RwStream_0 *stream, RwChunkHeaderInfo_0 *chunkHeaderInfo)
{
  RwStream_0 *v3; // r4
  int v4; // r0
  RwUInt32 v5; // r12
  __int64 v6; // r2
  unsigned int v7; // r0
  RwBool v8; // r0
  RwError_0 code; // [sp+4h] [bp-1Ch] BYREF
  _DWORD buffer[2]; // [sp+Ch] [bp-14h] BYREF
  unsigned int v12; // [sp+14h] [bp-Ch]

  v3 = stream;
  if ( RwStreamRead(stream, buffer, 0xCu) == 12 )
  {
    v4 = buffer[0];
    v5 = buffer[1];
    if ( HIWORD(v12) )
    {
      HIDWORD(v6) = (unsigned __int16)v12;
      LODWORD(v6) = (((unsigned int)&stru_3FEFC.st_value & (v12 >> 14)) + 196608) | HIWORD(v12) & 0x3F;
    }
    else
    {
      v6 = v12 << 8;
    }
    chunkHeaderInfo->type = buffer[0];
    chunkHeaderInfo->length = v5;
    v7 = v4 - 5;
    *(_QWORD *)&chunkHeaderInfo->version = v6;
    if ( v7 > 0x15 )
      v8 = 0;
    else
      v8 = dword_5EC850[v7];
    chunkHeaderInfo->isComplex = v8;
  }
  else
  {
    code.pluginID = 1;
    code.errorCode = _rwerror(-2147483622);
    RwErrorSet(&code);
    return 0;
  }
  return v3;
}
// 3FEFC: using guessed type Elf32_Sym stru_3FEFC;
// 5EC850: using guessed type _DWORD dword_5EC850[22];
// 1E21A4: using guessed type _DWORD buffer[2];

//----- (001E2228) --------------------------------------------------------
RwUInt32 __fastcall RwMatrixStreamGetSize(const RwMatrix *matrix)
{
  return 64;
}

//----- (001E222C) --------------------------------------------------------
const RwMatrix *__fastcall RwMatrixStreamWrite(const RwMatrix *matrix, RwStream_0 *stream)
{
  const RwMatrix *v2; // r4
  __int64 v4; // d16
  __int64 v5; // d17
  __int64 v6; // d18
  __int64 v7; // d19
  __int64 v8; // d20
  __int64 v9; // d21
  __int64 v10; // d23
  RwError_0 *p_mem; // r0
  int v13[2]; // [sp+8h] [bp-98h] BYREF
  RwMatrix dst; // [sp+10h] [bp-90h] BYREF
  double mem; // [sp+50h] [bp-50h] BYREF
  RwReal z; // [sp+58h] [bp-48h]
  RwV3d_0 up; // [sp+5Ch] [bp-44h] BYREF
  RwV3d_0 at; // [sp+68h] [bp-38h] BYREF
  RwV3d_0 pos; // [sp+74h] [bp-2Ch] BYREF
  int v20; // [sp+80h] [bp-20h]

  v2 = matrix;
  dst.flags = 0;
  if ( (matrix->flags & 3) == 3 )
  {
    RwMatrixOrthoNormalize(&dst, matrix);
  }
  else
  {
    v4 = *(_QWORD *)&matrix->right.x;
    v5 = *(_QWORD *)&matrix->right.z;
    v6 = *(_QWORD *)&matrix->up.x;
    v7 = *(_QWORD *)&matrix->up.z;
    v8 = *(_QWORD *)&matrix->at.x;
    v9 = *(_QWORD *)&matrix->at.z;
    v10 = *(_QWORD *)&matrix->pos.z;
    *(_QWORD *)&dst.pos.x = *(_QWORD *)&matrix->pos.x;
    *(_QWORD *)&dst.pos.z = v10;
    *(_QWORD *)&dst.at.x = v8;
    *(_QWORD *)&dst.at.z = v9;
    *(_QWORD *)&dst.right.x = v4;
    *(_QWORD *)&dst.right.z = v5;
    *(_QWORD *)&dst.up.x = v6;
    *(_QWORD *)&dst.up.z = v7;
  }
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 13, 64, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu)
    || !_rwStreamWriteVersionedChunkHeader(stream, 1, 52, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
  {
    v2 = 0;
    LODWORD(mem) = 0;
    HIDWORD(mem) = _rwerror(-2147483620);
    p_mem = (RwError_0 *)&mem;
    goto LABEL_9;
  }
  z = dst.right.z;
  up = dst.up;
  at = dst.at;
  v20 = dst.flags & 3;
  mem = *(double *)&dst.right.x;
  pos = dst.pos;
  RwMemRealToFloat32(&mem, 0xCu);
  RwMemRealToFloat32(&up, 0xCu);
  RwMemRealToFloat32(&at, 0xCu);
  RwMemRealToFloat32(&pos, 0xCu);
  RwMemLittleEndian32(&mem, 0x34u);
  if ( !RwStreamWrite(stream, &mem, 0x34u) )
  {
    v2 = 0;
    v13[0] = 0;
    v13[1] = _rwerror(-2147483620);
    p_mem = (RwError_0 *)v13;
LABEL_9:
    RwErrorSet(p_mem);
  }
  return v2;
}
// 35FFC: using guessed type Elf32_Sym stru_35FFC;

//----- (001E235E) --------------------------------------------------------
RwMatrixChunkInfo *__fastcall RwMatrixChunkInfoRead(
        RwStream_0 *stream,
        RwMatrixChunkInfo *matrixChunkInfo,
        RwInt32 *bytesRead)
{
  RwMatrixChunkInfo *v6; // r5
  RwUInt32 v7; // r0
  RwError_0 code; // [sp+4h] [bp-24h] BYREF
  RwUInt32 lengthOut[7]; // [sp+Ch] [bp-1Ch] BYREF

  v6 = 0;
  if ( !RwStreamFindChunk(stream, 1u, lengthOut, 0) )
    goto LABEL_5;
  matrixChunkInfo->type = 0;
  *(_QWORD *)&matrixChunkInfo->at.z = 0LL;
  *(_QWORD *)&matrixChunkInfo->pos.y = 0LL;
  *(_QWORD *)&matrixChunkInfo->right.x = 0LL;
  *(_QWORD *)&matrixChunkInfo->right.z = 0LL;
  *(_QWORD *)&matrixChunkInfo->up.y = 0LL;
  *(_QWORD *)&matrixChunkInfo->at.x = 0LL;
  if ( RwStreamRead(stream, matrixChunkInfo, 0x34u) != 52 )
  {
    v6 = 0;
LABEL_5:
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483622);
    RwErrorSet(&code);
    return v6;
  }
  v7 = lengthOut[0];
  *bytesRead = lengthOut[0] + 12;
  RwStreamSkip(stream, v7 - 52);
  RwMemNative32(matrixChunkInfo, 0x34u);
  RwMemFloat32ToReal(matrixChunkInfo, 0xCu);
  RwMemFloat32ToReal(&matrixChunkInfo->up, 0xCu);
  RwMemFloat32ToReal(&matrixChunkInfo->at, 0xCu);
  RwMemFloat32ToReal(&matrixChunkInfo->pos, 0xCu);
  return matrixChunkInfo;
}
// 1E235E: using guessed type RwUInt32 lengthOut[7];

//----- (001E240E) --------------------------------------------------------
RwMatrix *__fastcall RwMatrixStreamRead(RwStream_0 *stream, RwMatrix *matrix)
{
  RwUInt32 v4; // r0
  char v5; // r0
  RwError_0 v6; // d16
  int v7; // r0
  __int64 v8; // d16
  __int64 v9; // d16
  __int64 v10; // d16
  RwInt32 v11; // r0
  RwError_0 v13; // [sp+0h] [bp-60h] BYREF
  RwError_0 buffer; // [sp+8h] [bp-58h] BYREF
  __int128 v15; // [sp+10h] [bp-50h] BYREF
  __int64 v16; // [sp+20h] [bp-40h] BYREF
  __int128 v17; // [sp+28h] [bp-38h] BYREF
  int v18; // [sp+38h] [bp-28h]
  RwUInt32 versionOut; // [sp+40h] [bp-20h] BYREF
  RwUInt32 lengthOut[7]; // [sp+44h] [bp-1Ch] BYREF

  if ( !RwStreamFindChunk(stream, 1u, lengthOut, &versionOut) )
  {
    matrix = 0;
    v11 = -2147483622;
LABEL_10:
    buffer.pluginID = 0;
    buffer.errorCode = _rwerror(v11);
    RwErrorSet(&buffer);
    return matrix;
  }
  if ( versionOut - 212992 > 0x2003 )
  {
    matrix = 0;
    v11 = -2147483644;
    goto LABEL_10;
  }
  buffer = 0LL;
  v15 = 0uLL;
  v17 = 0uLL;
  v16 = 0LL;
  v18 = 0;
  v4 = RwStreamRead(stream, &buffer, lengthOut[0]);
  if ( lengthOut[0] != v4 )
  {
    v13.pluginID = 0;
    v13.errorCode = _rwerror(-2147483622);
    RwErrorSet(&v13);
    return 0;
  }
  RwMemNative32(&buffer, 0x34u);
  RwMemFloat32ToReal(&buffer, 0xCu);
  RwMemFloat32ToReal((char *)&v15 + 4, 0xCu);
  RwMemFloat32ToReal(&v16, 0xCu);
  RwMemFloat32ToReal((char *)&v17 + 4, 0xCu);
  if ( !matrix )
  {
    matrix = RwMatrixCreate();
    if ( !matrix )
      return 0;
  }
  v5 = v18;
  matrix->flags = 0;
  v6 = buffer;
  v7 = v5 & 3;
  LODWORD(matrix->right.z) = v15;
  *(RwError_0 *)&matrix->right.x = v6;
  v8 = *(_QWORD *)((char *)&v15 + 4);
  matrix->up.z = *((RwReal *)&v15 + 3);
  *(_QWORD *)&matrix->up.x = v8;
  v9 = v16;
  LODWORD(matrix->at.z) = v17;
  *(_QWORD *)&matrix->at.x = v9;
  v10 = *(_QWORD *)((char *)&v17 + 4);
  matrix->pos.z = *((RwReal *)&v17 + 3);
  *(_QWORD *)&matrix->pos.x = v10;
  matrix->flags = v7;
  if ( v7 == 3 )
    RwMatrixOrthoNormalize(matrix, matrix);
  return matrix;
}
// 1E240E: using guessed type RwUInt32 lengthOut[7];

//----- (001E2534) --------------------------------------------------------
void *__fastcall _rwColorOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  ++colorModule;
  return instance;
}
// 6BD010: using guessed type int colorModule;

//----- (001E2544) --------------------------------------------------------
void *__fastcall _rwColorClose(void *instance, RwInt32 offset, RwInt32 size)
{
  --colorModule;
  return instance;
}
// 6BD010: using guessed type int colorModule;

//----- (001E2554) --------------------------------------------------------
void *__fastcall _rwErrorOpen(void *object, RwInt32 offset, RwInt32 size)
{
  errorModule = offset;
  ++errorModule;
  *(_DWORD *)((char *)RwEngineInstance + offset) = 0;
  *(_DWORD *)((char *)RwEngineInstance + offset + 4) = 0x80000000;
  return object;
}
// 6BD014: using guessed type int errorModule;
// 6BD018: using guessed type int errorModule;

//----- (001E2598) --------------------------------------------------------
void *__fastcall _rwErrorClose(void *object, RwInt32 offset, RwInt32 size)
{
  --errorModule;
  return object;
}
// 6BD018: using guessed type int errorModule;

//----- (001E25A8) --------------------------------------------------------
RwError_0 *__fastcall RwErrorSet(RwError_0 *code)
{
  int v1; // r1
  RwInt32 pluginID; // r12

  v1 = errorModule;
  if ( !*(_DWORD *)((char *)RwEngineInstance + errorModule)
    && *(_DWORD *)((char *)RwEngineInstance + errorModule + 4) == 0x80000000 )
  {
    if ( code->errorCode < 0 )
      pluginID = 0;
    else
      pluginID = code->pluginID;
    *(_DWORD *)((char *)RwEngineInstance + errorModule) = pluginID;
    *(_DWORD *)((char *)RwEngineInstance + v1 + 4) = code->errorCode;
  }
  return code;
}
// 6BD014: using guessed type int errorModule;

//----- (001E25F8) --------------------------------------------------------
RwError_0 *__fastcall RwErrorGet(RwError_0 *code)
{
  int v1; // r2
  RwInt32 v2; // r3

  v1 = errorModule;
  v2 = *(_DWORD *)((char *)RwEngineInstance + errorModule + 4);
  code->pluginID = *(_DWORD *)((char *)RwEngineInstance + errorModule);
  code->errorCode = v2;
  *(_DWORD *)((char *)RwEngineInstance + v1) = 0;
  *(_DWORD *)((char *)RwEngineInstance + v1 + 4) = 0x80000000;
  return code;
}
// 6BD014: using guessed type int errorModule;

//----- (001E2634) --------------------------------------------------------
RwFileFunctions_0 *RwOsGetFileInterface()
{
  return (RwFileFunctions_0 *)((char *)RwEngineInstance + 196);
}

//----- (001E2644) --------------------------------------------------------
int __fastcall _rwES2fclose(void *fptr)
{
  return OS_FileClose(fptr) != OSFE_NoError;
}

//----- (001E2654) --------------------------------------------------------
size_t __fastcall _rwES2fread(void *addr, size_t size, size_t count, void *fptr)
{
  size_t v4; // r4

  v4 = count;
  lastError = OS_FileRead(fptr, addr, count * size);
  if ( lastError )
    return 0;
  return v4;
}

//----- (001E267C) --------------------------------------------------------
size_t __fastcall _rwES2fwrite(const void *addr, size_t size, size_t count, void *fptr)
{
  size_t v4; // r4

  v4 = count;
  if ( OS_FileWrite(fptr, addr, count * size) )
    return 0;
  return v4;
}

//----- (001E269C) --------------------------------------------------------
RwChar *__fastcall _rwES2fgets(RwChar *buffer, int maxLen, void *fptr)
{
  int v5; // r9
  int v6; // r10
  int v7; // r0
  RwChar *result; // r0

  if ( maxLen < 2 )
    return 0;
  v5 = maxLen - 1;
  v6 = 0;
  while ( 1 )
  {
    lastError = OS_FileRead(fptr, &buffer[v6], 1);
    if ( lastError )
      break;
    v7 = buffer[v6];
    if ( v7 != 13 )
    {
      ++v6;
      if ( v7 == 10 || v6 >= v5 )
        break;
    }
  }
  result = 0;
  if ( v6 >= 1 )
  {
    buffer[v6] = 0;
    return buffer;
  }
  return result;
}

//----- (001E2700) --------------------------------------------------------
int __fastcall _rwES2fputs(const RwChar *buffer, void *fptr)
{
  return 0;
}

//----- (001E2704) --------------------------------------------------------
int __fastcall _rwES2feof(void *fptr)
{
  return lastError == OSFE_EndOfFile;
}

//----- (001E2718) --------------------------------------------------------
int __fastcall _rwES2fseek(void *fptr, int offset, int origin)
{
  int Position; // r0
  int result; // r0

  if ( origin == 1 )
    Position = OS_FileGetPosition(fptr);
  else
    Position = 0;
  result = OS_FileSetPosition(fptr, Position + offset);
  lastError = result;
  if ( result )
    return -1;
  return result;
}

//----- (001E2750) --------------------------------------------------------
int __fastcall _rwES2fflush(void *fptr)
{
  return 0;
}

//----- (001E2754) --------------------------------------------------------
RwBool _rwFileSystemOpen()
{
  _DWORD *v0; // r0

  v0 = RwEngineInstance;
  *((_DWORD *)RwEngineInstance + 51) = _rwES2fclose;
  v0[50] = rwES2fopen;
  v0[52] = _rwES2fread;
  v0[53] = _rwES2fwrite;
  v0[54] = _rwES2fgets;
  v0[55] = _rwES2fputs;
  v0[56] = _rwES2feof;
  v0[57] = _rwES2fseek;
  v0[58] = _rwES2fflush;
  v0[59] = _rwES2ftell;
  v0[49] = rwfexist;
  return 1;
}

//----- (001E2804) --------------------------------------------------------
RwBool __fastcall rwfexist(const RwChar *name)
{
  RwBool v1; // r4

  v1 = (*((int (__fastcall **)(const RwChar *, int *))RwEngineInstance + 50))(name, &dword_1E2838);
  if ( v1 )
  {
    v1 = 1;
    (*((void (**)(void))RwEngineInstance + 51))();
  }
  return v1;
}
// 1E2838: using guessed type int dword_1E2838;

//----- (001E2840) --------------------------------------------------------
void *__fastcall rwES2fopen(const RwChar *name, const RwChar *access)
{
  _BOOL4 v3; // r3
  OSFileError v4; // r0
  OSFile v5; // r1
  OSFile intoFile; // [sp+4h] [bp-Ch] BYREF

  v3 = strchr((const char *)access, 119) != 0;
  v4 = OS_FileOpen(OSFDA_Storage_0, &intoFile, name, (OSFileAccessType)v3);
  v5 = intoFile;
  if ( v4 )
    return 0;
  return v5;
}

//----- (001E2874) --------------------------------------------------------
RwReal RwIm2DGetNearScreenZ()
{
  return *((float *)RwEngineInstance + 6);
}

//----- (001E2884) --------------------------------------------------------
RwReal RwIm2DGetFarScreenZ()
{
  return *((float *)RwEngineInstance + 7);
}

//----- (001E2894) --------------------------------------------------------
RwBool __fastcall RwRenderStateSet(RwRenderState_0 state, void *value)
{
  RwError_0 v3; // [sp+0h] [bp-10h] BYREF

  if ( *(_DWORD *)RwEngineInstance )
    return (*((int (__fastcall **)(RwRenderState_0, void *))RwEngineInstance + 8))(state, value);
  v3.pluginID = 0;
  v3.errorCode = _rwerror(16, value);
  RwErrorSet(&v3);
  return 0;
}

//----- (001E28C8) --------------------------------------------------------
RwBool __fastcall RwRenderStateGet(RwRenderState_0 state, void *value)
{
  return (*((int (__fastcall **)(RwRenderState_0, void *))RwEngineInstance + 9))(state, value);
}

//----- (001E28D8) --------------------------------------------------------
RwBool __fastcall RwIm2DRenderLine(RwIm2DVertex *vertices, RwInt32 numVertices, RwInt32 vert1, RwInt32 vert2)
{
  return (*((int (__fastcall **)(RwIm2DVertex *, RwInt32, RwInt32, RwInt32))RwEngineInstance + 10))(
           vertices,
           numVertices,
           vert1,
           vert2);
}

//----- (001E28F0) --------------------------------------------------------
RwBool __fastcall RwIm2DRenderTriangle(
        RwIm2DVertex *vertices,
        RwInt32 numVertices,
        RwInt32 vert1,
        RwInt32 vert2,
        RwInt32 vert3)
{
  return (*((int (__fastcall **)(RwIm2DVertex *, RwInt32, RwInt32, RwInt32))RwEngineInstance + 11))(
           vertices,
           numVertices,
           vert1,
           vert2);
}

//----- (001E2908) --------------------------------------------------------
RwBool __fastcall RwIm2DRenderPrimitive(RwPrimitiveType_0 primType, RwIm2DVertex *vertices, RwInt32 numVertices)
{
  return (*((int (__fastcall **)(RwPrimitiveType_0, RwIm2DVertex *, RwInt32))RwEngineInstance + 12))(
           primType,
           vertices,
           numVertices);
}

//----- (001E2918) --------------------------------------------------------
RwBool __fastcall RwIm2DRenderIndexedPrimitive(
        RwPrimitiveType_0 primType,
        RwIm2DVertex *vertices,
        RwInt32 numVertices,
        RwImVertexIndex *indices,
        RwInt32 numIndices)
{
  return (*((int (__fastcall **)(RwPrimitiveType_0, RwIm2DVertex *, RwInt32, RwImVertexIndex *))RwEngineInstance + 13))(
           primType,
           vertices,
           numVertices,
           indices);
}

//----- (001E2930) --------------------------------------------------------
RwSList_0 *__fastcall _rwSListCreate(RwInt32 size, RwUInt32 hint)
{
  RwSList_0 *v3; // r0
  RwSList_0 *v4; // r4
  int v5; // r0
  RwError_0 v7[3]; // [sp+0h] [bp-18h] BYREF

  v3 = (RwSList_0 *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(16);
  v4 = v3;
  if ( v3 )
  {
    v3->numElementsAlloced = 20;
    v3->numElementsFilled = 0;
    v3->entrySize = size;
    v5 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(20 * size);
    v4->listElements = (RwUInt8 *)v5;
    if ( !v5 )
    {
      v7[0].pluginID = 0;
      v7[0].errorCode = _rwerror(-2147483629, v4->entrySize * v4->numElementsAlloced);
      RwErrorSet(v7);
      (*((void (__fastcall **)(RwSList_0 *))RwEngineInstance + 76))(v4);
      return 0;
    }
  }
  else
  {
    v4 = 0;
    v7[0].pluginID = 0;
    v7[0].errorCode = _rwerror(-2147483629, 16);
    RwErrorSet(v7);
  }
  return v4;
}

//----- (001E29D0) --------------------------------------------------------
void __fastcall _rwSListEmpty(RwSList_0 *sList)
{
  sList->numElementsFilled = 0;
}

//----- (001E29D8) --------------------------------------------------------
void *__fastcall _rwSListGetNewEntry(RwSList_0 *sList, RwUInt32 hint)
{
  RwInt32 numElementsFilled; // r1
  RwInt32 numElementsAlloced; // r2
  RwUInt8 *listElements; // r0
  RwInt32 v6; // r2
  RwUInt8 *v7; // r5
  RwError_0 v9; // [sp+0h] [bp-10h] BYREF

  numElementsAlloced = sList->numElementsAlloced;
  numElementsFilled = sList->numElementsFilled;
  if ( numElementsFilled >= numElementsAlloced )
  {
    listElements = (RwUInt8 *)(*((int (__fastcall **)(RwUInt8 *, int))RwEngineInstance + 77))(
                                sList->listElements,
                                sList->entrySize * (numElementsAlloced + numElementsAlloced / 4));
    if ( !listElements )
    {
      v7 = 0;
      v9.pluginID = 0;
      v9.errorCode = _rwerror(
                       -2147483629,
                       sList->entrySize * (sList->numElementsAlloced + sList->numElementsAlloced / 4));
      RwErrorSet(&v9);
      return v7;
    }
    v6 = sList->numElementsAlloced;
    numElementsFilled = sList->numElementsFilled;
    sList->listElements = listElements;
    sList->numElementsAlloced = v6 + v6 / 4;
  }
  else
  {
    listElements = sList->listElements;
  }
  v7 = &listElements[sList->entrySize * numElementsFilled];
  sList->numElementsFilled = numElementsFilled + 1;
  return v7;
}

//----- (001E2A60) --------------------------------------------------------
void *__fastcall _rwSListGetNewEntries(RwSList_0 *sList, RwInt32 count, RwUInt32 hint)
{
  RwInt32 numElementsFilled; // r1
  RwInt32 numElementsAlloced; // r2
  RwUInt8 *listElements; // r0
  RwInt32 v8; // r2
  RwUInt8 *v9; // r6
  RwError_0 v11; // [sp+0h] [bp-18h] BYREF

  numElementsAlloced = sList->numElementsAlloced;
  numElementsFilled = sList->numElementsFilled;
  if ( numElementsFilled + count >= numElementsAlloced )
  {
    listElements = (RwUInt8 *)(*((int (__fastcall **)(RwUInt8 *, int))RwEngineInstance + 77))(
                                sList->listElements,
                                sList->entrySize * (numElementsAlloced + count + numElementsAlloced / 4));
    if ( !listElements )
    {
      v9 = 0;
      v11.pluginID = 0;
      v11.errorCode = _rwerror(
                        -2147483629,
                        sList->entrySize * (sList->numElementsAlloced + count + sList->numElementsAlloced / 4));
      RwErrorSet(&v11);
      return v9;
    }
    v8 = sList->numElementsAlloced;
    numElementsFilled = sList->numElementsFilled;
    sList->listElements = listElements;
    sList->numElementsAlloced = v8 + count + v8 / 4;
  }
  else
  {
    listElements = sList->listElements;
  }
  v9 = &listElements[sList->entrySize * numElementsFilled];
  sList->numElementsFilled = numElementsFilled + count;
  return v9;
}

//----- (001E2AF8) --------------------------------------------------------
RwBool __fastcall _rwSListDestroyEntry(RwSList_0 *sList, RwInt32 entry)
{
  RwInt32 numElementsFilled; // r0
  size_t entrySize; // r2
  int v5; // r6
  RwUInt8 *v6; // r5

  numElementsFilled = sList->numElementsFilled;
  if ( numElementsFilled - entry >= 2 )
  {
    entrySize = sList->entrySize;
    v5 = numElementsFilled + 1 - entry;
    v6 = &sList->listElements[entrySize * entry];
    do
    {
      qmemcpy(v6, &v6[entrySize], entrySize);
      entrySize = sList->entrySize;
      --v5;
      v6 += entrySize;
    }
    while ( v5 > 2 );
    numElementsFilled = sList->numElementsFilled;
  }
  sList->numElementsFilled = numElementsFilled - 1;
  return 1;
}

//----- (001E2B36) --------------------------------------------------------
void __fastcall _rwSListDestroyEndEntries(RwSList_0 *sList, RwInt32 amount)
{
  sList->numElementsFilled -= amount;
}

//----- (001E2B3E) --------------------------------------------------------
void *__fastcall _rwSListGetArray(RwSList_0 *sList)
{
  if ( sList->numElementsFilled )
    return sList->listElements;
  else
    return 0;
}

//----- (001E2B4A) --------------------------------------------------------
RwBool __fastcall _rwSListReleaseArray(RwSList_0 *sList)
{
  return 1;
}

//----- (001E2B50) --------------------------------------------------------
RwBool __fastcall _rwSListDestroy(RwSList_0 *sList)
{
  RwUInt8 *listElements; // r0
  bool v3; // zf

  listElements = sList->listElements;
  v3 = listElements == 0;
  if ( listElements )
    v3 = sList->numElementsAlloced == 0;
  if ( !v3 )
  {
    (*((void (**)(void))RwEngineInstance + 76))();
    sList->numElementsAlloced = 0;
    sList->listElements = 0;
  }
  (*((void (__fastcall **)(RwSList_0 *))RwEngineInstance + 76))(sList);
  return 1;
}

//----- (001E2B94) --------------------------------------------------------
RwBool __fastcall _rwSListDestroyArray(RwUInt8 *array)
{
  (*((void (__fastcall **)(RwUInt8 *))RwEngineInstance + 76))(array);
  return 1;
}

//----- (001E2BB0) --------------------------------------------------------
RwInt32 __fastcall _rwSListGetNumEntries(const RwSList_0 *sList)
{
  return sList->numElementsFilled;
}

//----- (001E2BB4) --------------------------------------------------------
void *__fastcall _rwSListToArray(RwSList_0 *sList)
{
  __int64 v2; // r0
  void *v3; // r5

  v2 = *(_QWORD *)&sList->listElements;
  if ( HIDWORD(v2) )
  {
    v3 = (void *)v2;
  }
  else
  {
    v3 = 0;
    if ( (_DWORD)v2 )
    {
      (*((void (**)(void))RwEngineInstance + 76))();
      sList->listElements = 0;
    }
  }
  (*((void (__fastcall **)(RwSList_0 *))RwEngineInstance + 76))(sList);
  return v3;
}

//----- (001E2BF4) --------------------------------------------------------
void *__fastcall _rwSListGetEntry(RwSList_0 *sList, RwInt32 entry)
{
  return &sList->listElements[sList->entrySize * entry];
}

//----- (001E2BFE) --------------------------------------------------------
void *__fastcall _rwSListGetBegin(RwSList_0 *sList)
{
  return sList->listElements;
}

//----- (001E2C02) --------------------------------------------------------
void *__fastcall _rwSListGetEnd(RwSList_0 *sList)
{
  return &sList->listElements[sList->numElementsFilled * sList->entrySize];
}

//----- (001E2C10) --------------------------------------------------------
RwBool __fastcall _rwMatrixSetMultFn(rwMatrixMultFn multMat)
{
  void (__fastcall *v1)(RwMatrix *, const RwMatrix *, const RwMatrix *); // r3
  RwBool result; // r0

  v1 = MatrixMultiply;
  if ( multMat )
    v1 = multMat;
  result = 1;
  *(_DWORD *)((char *)RwEngineInstance + matrixModule + 8) = v1;
  return result;
}
// 6BD044: using guessed type int matrixModule;

//----- (001E2C3C) --------------------------------------------------------
void __fastcall MatrixMultiply(RwMatrix *dstMat, const RwMatrix *matA, const RwMatrix *matB)
{
  dstMat->right.x = (float)((float)(matA->right.x * matB->right.x) + (float)(matA->right.y * matB->up.x))
                  + (float)(matA->right.z * matB->at.x);
  dstMat->right.y = (float)((float)(matA->right.x * matB->right.y) + (float)(matA->right.y * matB->up.y))
                  + (float)(matA->right.z * matB->at.y);
  dstMat->right.z = (float)((float)(matA->right.x * matB->right.z) + (float)(matA->right.y * matB->up.z))
                  + (float)(matA->right.z * matB->at.z);
  dstMat->up.x = (float)((float)(matA->up.x * matB->right.x) + (float)(matA->up.y * matB->up.x))
               + (float)(matA->up.z * matB->at.x);
  dstMat->up.y = (float)((float)(matA->up.x * matB->right.y) + (float)(matA->up.y * matB->up.y))
               + (float)(matA->up.z * matB->at.y);
  dstMat->up.z = (float)((float)(matA->up.x * matB->right.z) + (float)(matA->up.y * matB->up.z))
               + (float)(matA->up.z * matB->at.z);
  dstMat->at.x = (float)((float)(matA->at.x * matB->right.x) + (float)(matA->at.y * matB->up.x))
               + (float)(matA->at.z * matB->at.x);
  dstMat->at.y = (float)((float)(matA->at.x * matB->right.y) + (float)(matA->at.y * matB->up.y))
               + (float)(matA->at.z * matB->at.y);
  dstMat->at.z = (float)((float)(matA->at.x * matB->right.z) + (float)(matA->at.y * matB->up.z))
               + (float)(matA->at.z * matB->at.z);
  dstMat->pos.x = matB->pos.x
                + (float)((float)((float)(matA->pos.x * matB->right.x) + (float)(matA->pos.y * matB->up.x))
                        + (float)(matA->pos.z * matB->at.x));
  dstMat->pos.y = matB->pos.y
                + (float)((float)((float)(matA->pos.x * matB->right.y) + (float)(matA->pos.y * matB->up.y))
                        + (float)(matA->pos.z * matB->at.y));
  dstMat->pos.z = matB->pos.z
                + (float)((float)((float)(matA->pos.x * matB->right.z) + (float)(matA->pos.y * matB->up.z))
                        + (float)(matA->pos.z * matB->at.z));
}

//----- (001E2E98) --------------------------------------------------------
RwBool __fastcall _rwMatrixSetOptimizations(RwInt32 optimizeFlags)
{
  *(_DWORD *)((char *)RwEngineInstance + matrixModule + 4) = optimizeFlags;
  return 1;
}
// 6BD044: using guessed type int matrixModule;

//----- (001E2EB8) --------------------------------------------------------
RwReal __fastcall _rwMatrixDeterminant(const RwMatrix *matrix)
{
  return (float)((float)((float)((float)(matrix->up.y * matrix->at.z) - (float)(matrix->up.z * matrix->at.y))
                       * matrix->right.x)
               + (float)((float)((float)(matrix->up.z * matrix->at.x) - (float)(matrix->at.z * matrix->up.x))
                       * matrix->right.y))
       + (float)((float)((float)(matrix->at.y * matrix->up.x) - (float)(matrix->up.y * matrix->at.x)) * matrix->right.z);
}

//----- (001E2F1A) --------------------------------------------------------
RwReal __fastcall _rwMatrixOrthogonalError(const RwMatrix *matrix)
{
  float x; // s12
  float y; // s2
  float v3; // s14
  float v4; // s6
  float v5; // s8
  float z; // s4
  float v7; // s10

  x = matrix->at.x;
  y = matrix->right.y;
  v3 = matrix->at.y;
  v4 = matrix->up.x;
  v5 = matrix->up.y;
  z = matrix->right.z;
  v7 = matrix->up.z;
  return (float)((float)((float)((float)(v4 * matrix->right.x) + (float)(v5 * y)) + (float)(v7 * z))
               * (float)((float)((float)(v4 * matrix->right.x) + (float)(v5 * y)) + (float)(v7 * z)))
       + (float)((float)((float)((float)((float)(v4 * x) + (float)(v5 * v3)) + (float)(v7 * matrix->at.z))
                       * (float)((float)((float)(v4 * x) + (float)(v5 * v3)) + (float)(v7 * matrix->at.z)))
               + (float)((float)((float)((float)(x * matrix->right.x) + (float)(v3 * y)) + (float)(matrix->at.z * z))
                       * (float)((float)((float)(x * matrix->right.x) + (float)(v3 * y)) + (float)(matrix->at.z * z))));
}

//----- (001E2F94) --------------------------------------------------------
RwReal __fastcall _rwMatrixNormalError(const RwMatrix *matrix)
{
  float v1; // s8
  float v2; // s10
  float v3; // s0
  float v4; // s2

  v1 = matrix->at.z * matrix->at.z;
  v2 = (float)(matrix->at.x * matrix->at.x) + (float)(matrix->at.y * matrix->at.y);
  v3 = (float)((float)((float)(matrix->up.x * matrix->up.x) + (float)(matrix->up.y * matrix->up.y))
             + (float)(matrix->up.z * matrix->up.z))
     + -1.0;
  v4 = (float)((float)((float)(matrix->right.x * matrix->right.x) + (float)(matrix->right.y * matrix->right.y))
             + (float)(matrix->right.z * matrix->right.z))
     + -1.0;
  return (float)((float)(v4 * v4) + (float)(v3 * v3))
       + (float)((float)((float)(v2 + v1) + -1.0) * (float)((float)(v2 + v1) + -1.0));
}

//----- (001E301E) --------------------------------------------------------
RwReal __fastcall _rwMatrixIdentityError(const RwMatrix *matrix)
{
  return (float)((float)((float)((float)((float)((float)(matrix->right.x + -1.0) * (float)(matrix->right.x + -1.0))
                                       + (float)(matrix->right.y * matrix->right.y))
                               + (float)(matrix->right.z * matrix->right.z))
                       + (float)((float)((float)(matrix->up.x * matrix->up.x)
                                       + (float)((float)(matrix->up.y + -1.0) * (float)(matrix->up.y + -1.0)))
                               + (float)(matrix->up.z * matrix->up.z)))
               + (float)((float)((float)(matrix->at.z + -1.0) * (float)(matrix->at.z + -1.0))
                       + (float)((float)(matrix->at.x * matrix->at.x) + (float)(matrix->at.y * matrix->at.y))))
       + (float)((float)((float)(matrix->pos.x * matrix->pos.x) + (float)(matrix->pos.y * matrix->pos.y))
               + (float)(matrix->pos.z * matrix->pos.z));
}

//----- (001E30C0) --------------------------------------------------------
void *__fastcall _rwMatrixClose(void *instance, RwInt32 offset, RwInt32 size)
{
  RwFreeList_0 *v4; // r0

  v4 = *(RwFreeList_0 **)((char *)RwEngineInstance + matrixModule);
  if ( v4 )
  {
    RwFreeListDestroy(v4);
    *(_DWORD *)((char *)RwEngineInstance + matrixModule) = 0;
  }
  --matrixModule;
  return instance;
}
// 6BD044: using guessed type int matrixModule;
// 6BD048: using guessed type int matrixModule;

//----- (001E3110) --------------------------------------------------------
void __fastcall RwMatrixSetFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rwMatrixFreeListPreallocBlocks = numBlocksToPrealloc;
  _rwMatrixFreeListBlockSize = blockSize;
}

//----- (001E3128) --------------------------------------------------------
void *__fastcall _rwMatrixOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  RwFreeList_0 *v4; // r0
  int v5; // r1
  char *v6; // r0

  matrixModule = offset;
  v4 = RwFreeListCreateAndPreallocateSpace(
         64,
         _rwMatrixFreeListBlockSize,
         4,
         _rwMatrixFreeListPreallocBlocks,
         &_rwMatrixFreeList);
  v5 = matrixModule;
  *(_DWORD *)((char *)RwEngineInstance + matrixModule) = v4;
  if ( !*(_DWORD *)((char *)RwEngineInstance + v5) )
    return 0;
  *(_DWORD *)((char *)RwEngineInstance + v5 + 4) = 0x20000;
  *(_DWORD *)((char *)RwEngineInstance + v5 + 8) = MatrixMultiply;
  v6 = (char *)RwEngineInstance + v5;
  *((_DWORD *)v6 + 5) = 1008981770;
  *(_QWORD *)(v6 + 12) = *(_QWORD *)&_rwMatrixOpen(void *,int,int)::tolerance.Normal;
  ++matrixModule;
  return instance;
}
// 6BD044: using guessed type int matrixModule;
// 6BD048: using guessed type int matrixModule;

//----- (001E31C8) --------------------------------------------------------
RwBool __fastcall RwEngineSetMatrixTolerances(const RwMatrixTolerance_0 *const tolerance)
{
  __int64 v1; // d16
  char *v2; // r1
  RwBool result; // r0

  v1 = *(_QWORD *)&tolerance->Normal;
  v2 = (char *)RwEngineInstance + matrixModule;
  *((_DWORD *)v2 + 5) = LODWORD(tolerance->Identity);
  result = 1;
  *(_QWORD *)(v2 + 12) = v1;
  return result;
}
// 6BD044: using guessed type int matrixModule;

//----- (001E31F0) --------------------------------------------------------
RwBool __fastcall RwEngineGetMatrixTolerances(RwMatrixTolerance_0 *const tolerance)
{
  __int64 v1; // d16

  v1 = *(_QWORD *)((char *)RwEngineInstance + matrixModule + 12);
  tolerance->Identity = *(RwReal *)((char *)RwEngineInstance + matrixModule + 20);
  *(_QWORD *)&tolerance->Normal = v1;
  return 1;
}
// 6BD044: using guessed type int matrixModule;

//----- (001E3218) --------------------------------------------------------
RwMatrix *__fastcall RwMatrixOptimize(RwMatrix *matrix, const RwMatrixTolerance_0 *tolerance)
{
  float x; // s1
  float y; // s0
  float z; // s3
  float v5; // s8
  float v6; // s4
  float v7; // s5
  float v8; // s2
  float v9; // s10
  float v10; // s12
  float v11; // s7
  float v12; // s9
  float v13; // s16
  float v14; // s6
  float v15; // s14
  float v16; // s24
  float v17; // s22
  float v18; // s12
  float v19; // s11
  _BOOL4 v20; // r2
  float v21; // s18
  float v22; // s1
  float v23; // s13
  float v24; // s5
  float v25; // s1
  float v26; // s3
  float Normal; // s9
  float v28; // s1
  float Orthogonal; // s5
  RwUInt32 flags; // r1
  unsigned int v31; // r3
  unsigned int v32; // r1
  RwUInt32 v33; // r3

  x = matrix->up.x;
  y = matrix->up.y;
  z = matrix->up.z;
  v5 = x * x;
  v6 = matrix->right.x;
  v7 = matrix->right.y;
  v8 = z * z;
  v9 = v7 * v7;
  v10 = matrix->at.y;
  v11 = matrix->at.x;
  v12 = matrix->right.z;
  v13 = v7 * v10;
  v14 = v12 * v12;
  v15 = matrix->at.z;
  v16 = x * v11;
  v17 = y * v10;
  v18 = (float)(v11 * v11) + (float)(v10 * v10);
  v19 = (float)((float)(x * x) + (float)(y * y)) + (float)(z * z);
  if ( !tolerance )
    tolerance = (const RwMatrixTolerance_0 *)((char *)RwEngineInstance + matrixModule + 12);
  v20 = 0;
  v21 = z * v15;
  v22 = (float)(v6 * x) + (float)(v7 * y);
  v23 = (float)((float)((float)((float)(v6 * v6) + (float)(v7 * v7)) + v14) + -1.0)
      * (float)((float)((float)((float)(v6 * v6) + (float)(v7 * v7)) + v14) + -1.0);
  v24 = (float)((float)(matrix->right.x * v11) + v13) + (float)(v12 * v15);
  v25 = v22 + (float)(v12 * z);
  v26 = (float)(v23 + (float)((float)(v19 + -1.0) * (float)(v19 + -1.0)))
      + (float)((float)((float)(v18 + (float)(v15 * v15)) + -1.0) * (float)((float)(v18 + (float)(v15 * v15)) + -1.0));
  Normal = tolerance->Normal;
  v28 = (float)(v25 * v25)
      + (float)((float)((float)((float)(v16 + v17) + v21) * (float)((float)(v16 + v17) + v21)) + (float)(v24 * v24));
  Orthogonal = tolerance->Orthogonal;
  if ( tolerance->Normal >= v26 )
    v20 = tolerance->Identity >= (float)((float)((float)((float)((float)((float)((float)(v6 + -1.0) * (float)(v6 + -1.0))
                                                                       + v9)
                                                               + v14)
                                                       + (float)(v8
                                                               + (float)(v5
                                                                       + (float)((float)(y + -1.0) * (float)(y + -1.0)))))
                                               + (float)(v18 + (float)((float)(v15 + -1.0) * (float)(v15 + -1.0))))
                                       + (float)((float)((float)(matrix->pos.x * matrix->pos.x)
                                                       + (float)(matrix->pos.y * matrix->pos.y))
                                               + (float)(matrix->pos.z * matrix->pos.z)));
  flags = matrix->flags;
  v31 = flags & 0xFFFFFFFE;
  if ( Normal >= v26 )
    v31 = flags | 1;
  v32 = v31 & 0xFFFFFFFD;
  if ( Orthogonal >= v28 )
    v32 = v31 | 2;
  v33 = v32 & 0xFFFDFFFF;
  if ( v20 )
    v33 = v32 | 0x20000;
  matrix->flags = v33;
  return matrix;
}
// 6BD044: using guessed type int matrixModule;

//----- (001E33D4) --------------------------------------------------------
RwMatrix *__fastcall RwMatrixUpdate(RwMatrix *matrix)
{
  matrix->flags &= 0xFFFDFFFC;
  return matrix;
}

//----- (001E33E4) --------------------------------------------------------
RwMatrix *__fastcall RwMatrixMultiply(RwMatrix *dst, const RwMatrix *src1, const RwMatrix *src2)
{
  RwUInt32 flags; // r5
  RwUInt32 v5; // r6

  flags = src2->flags;
  v5 = src1->flags;
  (*(void (__fastcall **)(RwMatrix *))((char *)RwEngineInstance + matrixModule + 8))(dst);
  dst->flags = flags & v5;
  return dst;
}
// 6BD044: using guessed type int matrixModule;

//----- (001E3420) --------------------------------------------------------
RwMatrix *__fastcall RwMatrixOrthoNormalize(RwMatrix *dst, const RwMatrix *src)
{
  unsigned __int64 v2; // d16
  unsigned __int64 v4; // kr00_8
  float v5; // s0
  double v6; // d16
  double v7; // d16
  float v8; // s30
  float v9; // s20
  float v10; // s18
  float v11; // s16
  float v12; // s28
  float v13; // s26
  float v14; // s22
  float v15; // s24
  float v16; // r0
  float v17; // s2
  float v18; // s4
  float v19; // s0
  float *v20; // r6
  float *v21; // r5
  float *v22; // r4
  float v23; // s6
  float v24; // s2
  float v25; // s0
  float v26; // s4
  float v27; // s2
  unsigned __int64 *v28; // r0
  unsigned __int64 *v29; // r0
  float v30; // s2
  float v31; // s10
  float v32; // s4
  float v33; // s8
  float v34; // s12
  float v35; // s4
  float v36; // s0
  RwReal v37; // r0
  float v38; // s0
  float v39; // s2
  float v40; // s4
  float v41; // s8
  float v42; // s10
  float v43; // s12
  float v44; // s4
  float v45; // s0
  RwReal v46; // r0
  float v47; // s2
  float v48; // s4
  unsigned __int64 v49; // d16
  double v50; // d16
  double v51; // d16
  RwUInt32 flags; // r0
  RwV3d_0 pos; // [sp+0h] [bp-90h]
  double v55; // [sp+10h] [bp-80h] BYREF
  float v56; // [sp+18h] [bp-78h]
  double v57; // [sp+20h] [bp-70h] BYREF
  float v58; // [sp+28h] [bp-68h]
  unsigned __int64 v59; // [sp+30h] [bp-60h] BYREF
  float z; // [sp+38h] [bp-58h]

  v2 = *(_QWORD *)&src->right.x;
  z = src->right.z;
  v59 = v2;
  v4 = v2;
  v5 = *((float *)&v2 + 1) * *((float *)&v2 + 1);
  v6 = *(double *)&src->up.x;
  v58 = src->up.z;
  v57 = v6;
  v7 = *(double *)&src->at.x;
  v56 = src->at.z;
  v55 = v7;
  pos = src->pos;
  v8 = _rwInvSqrt((float)((float)(*(float *)&v4 * *(float *)&v4) + v5) + (float)(z * z));
  v9 = *((float *)&v4 + 1) * v8;
  v10 = *(float *)&v4 * v8;
  v11 = z * v8;
  v59 = __PAIR64__(*((float *)&v4 + 1) * v8, *(float *)&v4 * v8);
  z = z * v8;
  v12 = _rwInvSqrt(
          (float)((float)(*(float *)&v57 * *(float *)&v57) + (float)(*((float *)&v57 + 1) * *((float *)&v57 + 1)))
        + (float)(v58 * v58));
  v13 = *((float *)&v57 + 1) * v12;
  v14 = v58 * v12;
  v15 = *(float *)&v57 * v12;
  *((float *)&v57 + 1) = *((float *)&v57 + 1) * v12;
  *(float *)&v57 = *(float *)&v57 * v12;
  v58 = v58 * v12;
  v16 = _rwInvSqrt(
          (float)((float)(*(float *)&v7 * *(float *)&v7) + (float)(*((float *)&v7 + 1) * *((float *)&v7 + 1)))
        + (float)(v56 * v56));
  v17 = *(float *)&v7 * v16;
  v18 = *((float *)&v7 + 1) * v16;
  v19 = v56 * v16;
  *(float *)&v55 = *(float *)&v7 * v16;
  *((float *)&v55 + 1) = *((float *)&v7 + 1) * v16;
  v56 = v56 * v16;
  if ( v8 <= 0.0 )
  {
    v20 = (float *)&v57;
    v21 = (float *)&v55;
    v22 = (float *)&v59;
  }
  else if ( v12 <= 0.0 )
  {
    v20 = (float *)&v55;
    v21 = (float *)&v59;
    v22 = (float *)&v57;
  }
  else
  {
    v20 = (float *)&v59;
    v21 = (float *)&v57;
    v22 = (float *)&v55;
    if ( v16 > 0.0 )
    {
      v23 = (float)(v11 * v19) + (float)((float)(v10 * v17) + (float)(v9 * v18));
      v24 = (float)(v14 * v19) + (float)((float)(v15 * v17) + (float)(v13 * v18));
      v25 = fabsf(v23);
      v26 = fabsf(v24);
      v27 = fabsf((float)(v11 * v14) + (float)((float)(v10 * v15) + (float)(v9 * v13)));
      if ( v26 >= v25 )
      {
        v29 = (unsigned __int64 *)&v57;
        if ( v25 < v27 )
        {
          v29 = &v59;
          v20 = (float *)&v55;
          v22 = (float *)&v57;
        }
        v21 = (float *)v29;
      }
      else
      {
        v28 = &v59;
        if ( v26 < v27 )
        {
          v28 = (unsigned __int64 *)&v57;
          v21 = (float *)&v55;
          v22 = (float *)&v59;
        }
        v20 = (float *)v28;
      }
    }
  }
  v30 = v21[1];
  v31 = v20[2];
  v32 = v21[2];
  v33 = v20[1];
  v34 = (float)(v33 * v32) - (float)(v31 * v30);
  v35 = (float)(v31 * *v21) - (float)(v32 * *v20);
  v36 = (float)(v30 * *v20) - (float)(v33 * *v21);
  *v22 = v34;
  v22[2] = v36;
  v22[1] = v35;
  v37 = _rwInvSqrt((float)(v36 * v36) + (float)((float)(v34 * v34) + (float)(v35 * v35)));
  v38 = v37 * *v22;
  v39 = v37 * v22[1];
  v40 = v37 * v22[2];
  *v22 = v38;
  v22[1] = v39;
  v22[2] = v40;
  v41 = v20[1];
  v42 = v20[2];
  v43 = (float)(v39 * v42) - (float)(v40 * v41);
  v44 = (float)(v40 * *v20) - (float)(v38 * v42);
  v45 = (float)(v38 * v41) - (float)(v39 * *v20);
  *v21 = v43;
  v21[2] = v45;
  v21[1] = v44;
  v46 = _rwInvSqrt((float)(v45 * v45) + (float)((float)(v43 * v43) + (float)(v44 * v44)));
  v47 = v46 * v21[1];
  v48 = v46 * v21[2];
  *v21 = v46 * *v21;
  v21[1] = v47;
  v21[2] = v48;
  v49 = v59;
  dst->right.z = z;
  *(_QWORD *)&dst->right.x = v49;
  v50 = v57;
  dst->up.z = v58;
  *(double *)&dst->up.x = v50;
  v51 = v55;
  dst->at.z = v56;
  *(double *)&dst->at.x = v51;
  dst->pos.z = pos.z;
  flags = dst->flags;
  *(_QWORD *)&dst->pos.x = *(_QWORD *)&pos.x;
  dst->flags = flags & 0xFFFDFFFC | 3;
  return dst;
}

//----- (001E3744) --------------------------------------------------------
RwMatrix *__fastcall RwMatrixRotateOneMinusCosineSine(
        RwMatrix *matrix,
        const RwV3d_0 *unitAxis,
        RwReal oneMinusCosine,
        RwReal sine,
        RwOpCombineType_0 combineOp)
{
  float y; // s2
  float z; // s4
  RwMatrix *v7; // r4
  float v8; // s14
  float v9; // s3
  float v10; // s5
  float v11; // s7
  float v12; // s8
  float v13; // s4
  float v14; // s10
  float v15; // s2
  float v16; // s14
  float v17; // s0
  __int64 v18; // d23
  __int64 v19; // d16
  __int64 v20; // d17
  __int64 v21; // d18
  __int64 v22; // d19
  __int64 v23; // d20
  __int64 v24; // d21
  RwMatrix *v25; // r2
  RwUInt32 flags; // r6
  void (__fastcall **v27)(RwError_0 *, __int64 *, RwMatrix *); // r0
  __int64 *v28; // r1
  __int64 v29; // d17
  __int64 v30; // d18
  __int64 v31; // d19
  RwError_0 v32; // d20
  __int64 v33; // d21
  __int64 v34; // d16
  __int64 v35; // d17
  RwError_0 v37; // [sp+0h] [bp-90h] BYREF
  __int64 v38; // [sp+8h] [bp-88h]
  __int64 v39; // [sp+10h] [bp-80h]
  __int64 v40; // [sp+18h] [bp-78h]
  __int64 v41; // [sp+20h] [bp-70h]
  __int64 v42; // [sp+28h] [bp-68h]
  __int64 v43; // [sp+30h] [bp-60h]
  __int64 v44; // [sp+38h] [bp-58h]
  __int64 v45; // [sp+40h] [bp-50h] BYREF
  __int64 v46; // [sp+48h] [bp-48h]
  __int64 v47; // [sp+50h] [bp-40h]
  __int64 v48; // [sp+58h] [bp-38h]
  __int64 v49; // [sp+60h] [bp-30h]
  __int64 v50; // [sp+68h] [bp-28h]
  __int64 v51; // [sp+70h] [bp-20h]
  __int64 v52; // [sp+78h] [bp-18h]

  y = unitAxis->y;
  z = unitAxis->z;
  v7 = matrix;
  v8 = unitAxis->x * z;
  v9 = y * z;
  v10 = y * y;
  v11 = z * z;
  v12 = 1.0 - (float)(unitAxis->x * unitAxis->x);
  v13 = z * sine;
  v14 = (float)(unitAxis->x * y) * oneMinusCosine;
  v15 = y * sine;
  v16 = v8 * oneMinusCosine;
  v17 = unitAxis->x * sine;
  *((float *)&v45 + 1) = v14 + v13;
  *(float *)&v46 = v16 - v15;
  *(float *)&v47 = v14 - v13;
  *(float *)&v48 = v17 + (float)(v9 * oneMinusCosine);
  *((float *)&v49 + 1) = (float)(v9 * oneMinusCosine) - v17;
  *(float *)&v49 = v15 + v16;
  v51 = 0LL;
  *(float *)&v45 = 1.0 - (float)(v12 * oneMinusCosine);
  LODWORD(v52) = 0;
  *((float *)&v47 + 1) = 1.0 - (float)((float)(1.0 - v10) * oneMinusCosine);
  *(float *)&v50 = 1.0 - (float)((float)(1.0 - v11) * oneMinusCosine);
  HIDWORD(v46) = 3;
  if ( combineOp == rwCOMBINEPOSTCONCAT )
  {
    v25 = (RwMatrix *)&v45;
    flags = matrix->flags;
    v27 = (void (__fastcall **)(RwError_0 *, __int64 *, RwMatrix *))((char *)RwEngineInstance + matrixModule);
    v28 = (__int64 *)v7;
LABEL_7:
    v27[2](&v37, v28, v25);
    v29 = v44;
    v30 = v41;
    v31 = v42;
    HIDWORD(v38) = flags & 3;
    v32 = v37;
    v33 = v38;
    *(_QWORD *)&v7->pos.x = v43;
    *(_QWORD *)&v7->pos.z = v29;
    v34 = v39;
    v35 = v40;
    *(_QWORD *)&v7->at.x = v30;
    *(_QWORD *)&v7->at.z = v31;
    *(RwError_0 *)&v7->right.x = v32;
    *(_QWORD *)&v7->right.z = v33;
    *(_QWORD *)&v7->up.x = v34;
    *(_QWORD *)&v7->up.z = v35;
    return v7;
  }
  if ( combineOp == rwCOMBINEPRECONCAT )
  {
    v25 = matrix;
    flags = matrix->flags;
    v27 = (void (__fastcall **)(RwError_0 *, __int64 *, RwMatrix *))((char *)RwEngineInstance + matrixModule);
    v28 = &v45;
    goto LABEL_7;
  }
  if ( combineOp )
  {
    v7 = 0;
    v37.pluginID = 0;
    v37.errorCode = _rwerror(-2147483645, "Invalid combination type");
    RwErrorSet(&v37);
  }
  else
  {
    v18 = v52;
    v19 = v45;
    v20 = v46;
    v21 = v49;
    v22 = v50;
    v23 = v47;
    v24 = v48;
    *(_QWORD *)&matrix->pos.x = v51;
    *(_QWORD *)&matrix->pos.z = v18;
    *(_QWORD *)&matrix->at.x = v21;
    *(_QWORD *)&matrix->at.z = v22;
    *(_QWORD *)&matrix->right.x = v19;
    *(_QWORD *)&matrix->right.z = v20;
    *(_QWORD *)&matrix->up.x = v23;
    *(_QWORD *)&matrix->up.z = v24;
  }
  return v7;
}
// 6BD044: using guessed type int matrixModule;

//----- (001E38F4) --------------------------------------------------------
RwMatrix *__fastcall RwMatrixRotate(RwMatrix *matrix, const RwV3d_0 *axis, RwReal angle, RwOpCombineType_0 combineOp)
{
  float v7; // r5
  float v8; // s16
  RwReal v9; // s18
  float v10; // r4
  float v11; // r0
  RwV3d_0 unitAxis; // [sp+4h] [bp-34h] BYREF

  v7 = angle * 0.017453;
  v8 = _rwInvSqrt((float)((float)(axis->x * axis->x) + (float)(axis->y * axis->y)) + (float)(axis->z * axis->z));
  v9 = v8 * axis->y;
  unitAxis.x = v8 * axis->x;
  v10 = cosf(v7);
  v11 = sinf(v7);
  unitAxis.y = v9;
  unitAxis.z = v8 * axis->z;
  RwMatrixRotateOneMinusCosineSine(matrix, &unitAxis, 1.0 - v10, v11, combineOp);
  return matrix;
}

//----- (001E39A8) --------------------------------------------------------
RwMatrix *__fastcall RwMatrixInvert(RwMatrix *dst, const RwMatrix *src)
{
  RwMatrix *v2; // r4
  __int64 v3; // d16
  __int64 v4; // d17
  __int64 v5; // d20
  __int64 v6; // d21
  __int64 v7; // d23
  __int64 v8; // d18
  __int64 v9; // d19
  float v10; // s0
  float z; // s4
  float v12; // s2
  float v13; // s10

  v2 = dst;
  if ( (*(_DWORD *)((_BYTE *)RwEngineInstance + matrixModule + 4) & src->flags & 0x20000) != 0 )
  {
    v3 = *(_QWORD *)&src->right.x;
    v4 = *(_QWORD *)&src->right.z;
    v5 = *(_QWORD *)&src->up.x;
    v6 = *(_QWORD *)&src->up.z;
    v7 = *(_QWORD *)&src->pos.z;
    v8 = *(_QWORD *)&src->at.x;
    v9 = *(_QWORD *)&src->at.z;
    *(_QWORD *)&dst->pos.x = *(_QWORD *)&src->pos.x;
    *(_QWORD *)&dst->pos.z = v7;
    *(_QWORD *)&dst->at.x = v8;
    *(_QWORD *)&dst->at.z = v9;
    *(_QWORD *)&dst->right.x = v3;
    *(_QWORD *)&dst->right.z = v4;
    *(_QWORD *)&dst->up.x = v5;
    *(_QWORD *)&dst->up.z = v6;
  }
  else if ( (src->flags & 3) == 3 )
  {
    dst->right.x = src->right.x;
    dst->right.y = src->up.x;
    dst->right.z = src->at.x;
    dst->up.x = src->right.y;
    dst->up.y = src->up.y;
    dst->up.z = src->at.y;
    dst->at.x = src->right.z;
    dst->at.y = src->up.z;
    dst->at.z = src->at.z;
    dst->pos.x = -(float)((float)((float)(src->pos.x * src->right.x) + (float)(src->pos.y * src->right.y))
                        + (float)(src->pos.z * src->right.z));
    dst->pos.y = -(float)((float)((float)(src->pos.x * src->up.x) + (float)(src->pos.y * src->up.y))
                        + (float)(src->pos.z * src->up.z));
    v10 = src->pos.x * src->at.x;
    z = src->at.z;
    v12 = src->pos.y * src->at.y;
    v13 = src->pos.z;
    dst->flags = 3;
    dst->pos.z = -(float)((float)(v10 + v12) + (float)(v13 * z));
  }
  else
  {
    MatrixInvertGeneric(dst, src);
    return v2;
  }
  return dst;
}
// 6BD044: using guessed type int matrixModule;

//----- (001E3AE4) --------------------------------------------------------
RwMatrix *__fastcall MatrixInvertGeneric(RwMatrix *dst, const RwMatrix *src)
{
  float v2; // s2
  float v3; // s0
  float v4; // s4
  float v5; // s6
  float v6; // s0
  RwReal v7; // s8
  RwReal v8; // s4
  float v9; // s2
  float v10; // s6
  RwReal v11; // s10
  float v12; // s12
  RwReal v13; // s14
  float v14; // s1
  RwReal v15; // s3
  float y; // s6
  float v17; // s2
  float z; // s8
  float v19; // [sp+0h] [bp-4h]

  v2 = (float)(src->up.y * src->at.z) - (float)(src->up.z * src->at.y);
  dst->right.x = v2;
  v3 = (float)(src->right.y * src->at.z) - (float)(src->right.z * src->at.y);
  v4 = -v3;
  dst->right.y = -v3;
  v5 = (float)(src->right.y * src->up.z) - (float)(src->right.z * src->up.y);
  dst->right.z = v5;
  v19 = (float)((float)(v2 * src->right.x) - (float)(src->up.x * v3)) + (float)(v5 * src->at.x);
  v6 = 1.0;
  if ( v19 != 0.0 )
    v6 = 1.0 / v19;
  v7 = v6 * v2;
  v8 = v6 * v4;
  v9 = v6 * v5;
  dst->right.x = v7;
  dst->right.y = v8;
  dst->right.z = v6 * v5;
  v10 = (float)(src->up.x * src->at.z) - (float)(src->up.z * src->at.x);
  dst->up.x = -(float)(v6 * v10);
  v11 = v6 * (float)((float)(src->right.x * src->at.z) - (float)(src->right.z * src->at.x));
  dst->up.y = v11;
  v12 = (float)(src->right.x * src->up.z) - (float)(src->right.z * src->up.x);
  dst->up.z = -(float)(v6 * v12);
  v13 = v6 * (float)((float)(src->up.x * src->at.y) - (float)(src->up.y * src->at.x));
  dst->at.x = v13;
  v14 = (float)(src->right.x * src->at.y) - (float)(src->right.y * src->at.x);
  dst->at.y = -(float)(v6 * v14);
  v15 = v6 * (float)((float)(src->right.x * src->up.y) - (float)(src->right.y * src->up.x));
  dst->at.z = v15;
  dst->pos.x = -(float)((float)((float)(src->pos.x * v7) - (float)(src->pos.y * (float)(v6 * v10)))
                      + (float)(src->pos.z * v13));
  dst->pos.y = -(float)((float)((float)(src->pos.x * v8) + (float)(src->pos.y * v11))
                      - (float)(src->pos.z * (float)(v6 * v14)));
  y = src->pos.y;
  v17 = src->pos.x * v9;
  z = src->pos.z;
  dst->flags = 0;
  dst->pos.z = -(float)((float)(v17 - (float)(y * (float)(v6 * v12))) + (float)(z * v15));
  return dst;
}

//----- (001E3CFC) --------------------------------------------------------
RwMatrix *__fastcall RwMatrixScale(RwMatrix *matrix, const RwV3d_0 *scale, RwOpCombineType_0 combineOp)
{
  RwMatrix *v3; // r4
  float y; // s2
  float z; // s4
  float x; // s6
  float v7; // s2
  float v8; // s4
  float v9; // s2
  float v10; // s4
  float v11; // s2
  RwReal v12; // s0
  float v13; // s4
  float v14; // s6
  float v15; // s2
  float v16; // s4
  float v17; // s6
  float v18; // s2
  RwReal v19; // s0
  float v20; // s2
  float v21; // s2
  float v22; // s4
  RwError_0 v24; // [sp+0h] [bp-10h] BYREF

  v3 = matrix;
  if ( combineOp == rwCOMBINEPOSTCONCAT )
  {
    y = matrix->right.y;
    z = matrix->right.z;
    x = matrix->up.x;
    matrix->right.x = matrix->right.x * scale->x;
    matrix->right.y = y * scale->y;
    matrix->right.z = z * scale->z;
    v7 = matrix->up.y;
    v8 = matrix->up.z;
    matrix->up.x = x * scale->x;
    matrix->up.y = v7 * scale->y;
    matrix->up.z = v8 * scale->z;
    v9 = matrix->at.y;
    v10 = matrix->at.z;
    matrix->at.x = matrix->at.x * scale->x;
    matrix->at.y = v9 * scale->y;
    v11 = matrix->pos.x;
    v12 = v10 * scale->z;
    v13 = matrix->pos.y;
    v14 = matrix->pos.z;
    matrix->at.z = v12;
    matrix->pos.x = v11 * scale->x;
    matrix->pos.y = v13 * scale->y;
    matrix->pos.z = v14 * scale->z;
  }
  else if ( combineOp == rwCOMBINEPRECONCAT )
  {
    v15 = matrix->right.y;
    v16 = matrix->right.z;
    v17 = matrix->up.x;
    matrix->right.x = matrix->right.x * scale->x;
    matrix->right.y = v15 * scale->x;
    matrix->right.z = v16 * scale->x;
    v18 = matrix->up.y;
    matrix->up.x = v17 * scale->y;
    v19 = v18 * scale->y;
    v20 = matrix->up.z;
    matrix->up.y = v19;
    matrix->up.z = v20 * scale->y;
    v21 = matrix->at.y;
    v22 = matrix->at.z;
    matrix->at.x = matrix->at.x * scale->z;
    matrix->at.y = v21 * scale->z;
    matrix->at.z = v22 * scale->z;
  }
  else if ( combineOp )
  {
    v3 = 0;
    v24.pluginID = 0;
    v24.errorCode = _rwerror(-2147483645, "Invalid combination type");
    RwErrorSet(&v24);
  }
  else
  {
    matrix->up.y = 1.0;
    matrix->up.x = 0.0;
    matrix->right.z = 0.0;
    matrix->right.x = 1.0;
    matrix->right.y = 0.0;
    matrix->up.z = 0.0;
    matrix->at.x = 0.0;
    matrix->at.y = 0.0;
    matrix->at.z = 1.0;
    matrix->pos.x = 0.0;
    matrix->pos.y = 0.0;
    matrix->pos.z = 0.0;
    matrix->flags |= 0x20003u;
    matrix->right.x = scale->x;
    matrix->up.y = scale->y;
    matrix->at.z = scale->z;
  }
  v3->flags &= 0xFFFDFFFC;
  return v3;
}

//----- (001E3ED4) --------------------------------------------------------
RwMatrix *__fastcall RwMatrixTranslate(RwMatrix *matrix, const RwV3d_0 *translation, RwOpCombineType_0 combineOp)
{
  RwMatrix *v3; // r4
  float y; // s2
  float z; // s4
  float v6; // s2
  float v7; // s6
  RwError_0 v9; // [sp+0h] [bp-10h] BYREF

  v3 = matrix;
  if ( combineOp == rwCOMBINEPOSTCONCAT )
  {
    y = matrix->pos.y;
    z = matrix->pos.z;
    matrix->pos.x = matrix->pos.x + translation->x;
    matrix->pos.y = y + translation->y;
    matrix->pos.z = z + translation->z;
  }
  else if ( combineOp == rwCOMBINEPRECONCAT )
  {
    v6 = matrix->right.y;
    v7 = matrix->up.y;
    matrix->pos.x = matrix->pos.x
                  + (float)((float)((float)(translation->x * matrix->right.x) + (float)(translation->y * matrix->up.x))
                          + (float)(translation->z * matrix->at.x));
    matrix->pos.y = matrix->pos.y
                  + (float)((float)((float)(translation->x * v6) + (float)(translation->y * v7))
                          + (float)(translation->z * matrix->at.y));
    matrix->pos.z = matrix->pos.z
                  + (float)((float)((float)(translation->x * matrix->right.z) + (float)(translation->y * matrix->up.z))
                          + (float)(translation->z * matrix->at.z));
  }
  else if ( combineOp )
  {
    v3 = 0;
    v9.pluginID = 0;
    v9.errorCode = _rwerror(-2147483645, "Invalid combination type");
    RwErrorSet(&v9);
  }
  else
  {
    matrix->up.y = 1.0;
    matrix->up.x = 0.0;
    matrix->right.z = 0.0;
    matrix->right.x = 1.0;
    matrix->right.y = 0.0;
    matrix->up.z = 0.0;
    matrix->at.x = 0.0;
    matrix->at.y = 0.0;
    matrix->at.z = 1.0;
    matrix->pos.x = 0.0;
    matrix->pos.y = 0.0;
    matrix->pos.z = 0.0;
    matrix->flags |= 0x20003u;
    matrix->pos = *translation;
  }
  v3->flags &= ~0x20000u;
  return v3;
}

//----- (001E402C) --------------------------------------------------------
RwMatrix *__fastcall RwMatrixTransform(RwMatrix *matrix, const RwMatrix *transform, RwOpCombineType_0 combineOp)
{
  const RwMatrix *v3; // r3
  RwMatrix *v4; // r4
  __int64 v5; // d16
  __int64 v6; // d17
  __int64 v7; // d20
  __int64 v8; // d21
  __int64 v9; // d23
  __int64 v10; // d18
  __int64 v11; // d19
  const RwMatrix *v12; // r2
  RwUInt32 flags; // r8
  RwUInt32 v14; // r9
  void (__fastcall **v15)(RwError_0 *, const RwMatrix *, const RwMatrix *, const RwMatrix *); // r0
  __int64 v16; // d17
  __int64 v17; // d18
  __int64 v18; // d19
  RwError_0 v19; // d20
  __int64 v20; // d21
  __int64 v21; // d16
  __int64 v22; // d17
  RwError_0 v24; // [sp+0h] [bp-58h] BYREF
  __int64 v25; // [sp+8h] [bp-50h]
  __int64 v26; // [sp+10h] [bp-48h]
  __int64 v27; // [sp+18h] [bp-40h]
  __int64 v28; // [sp+20h] [bp-38h]
  __int64 v29; // [sp+28h] [bp-30h]
  __int64 v30; // [sp+30h] [bp-28h]
  __int64 v31; // [sp+38h] [bp-20h]

  v3 = transform;
  v4 = matrix;
  if ( combineOp == rwCOMBINEPOSTCONCAT )
  {
    v12 = transform;
    flags = transform->flags;
    v14 = matrix->flags;
    v15 = (void (__fastcall **)(RwError_0 *, const RwMatrix *, const RwMatrix *, const RwMatrix *))((char *)RwEngineInstance
                                                                                                  + matrixModule);
    transform = v4;
LABEL_7:
    v15[2](&v24, transform, v12, v3);
    v16 = v31;
    v17 = v28;
    v18 = v29;
    HIDWORD(v25) = flags & v14;
    v19 = v24;
    v20 = v25;
    *(_QWORD *)&v4->pos.x = v30;
    *(_QWORD *)&v4->pos.z = v16;
    v21 = v26;
    v22 = v27;
    *(_QWORD *)&v4->at.x = v17;
    *(_QWORD *)&v4->at.z = v18;
    *(RwError_0 *)&v4->right.x = v19;
    *(_QWORD *)&v4->right.z = v20;
    *(_QWORD *)&v4->up.x = v21;
    *(_QWORD *)&v4->up.z = v22;
    return v4;
  }
  if ( combineOp == rwCOMBINEPRECONCAT )
  {
    v12 = matrix;
    flags = matrix->flags;
    v14 = transform->flags;
    v15 = (void (__fastcall **)(RwError_0 *, const RwMatrix *, const RwMatrix *, const RwMatrix *))((char *)RwEngineInstance
                                                                                                  + matrixModule);
    goto LABEL_7;
  }
  if ( combineOp )
  {
    v4 = 0;
    v24.errorCode = _rwerror(-2147483645, "Invalid combination type", combineOp, transform, 0);
    RwErrorSet(&v24);
  }
  else
  {
    v5 = *(_QWORD *)&transform->right.x;
    v6 = *(_QWORD *)&transform->right.z;
    v7 = *(_QWORD *)&transform->up.x;
    v8 = *(_QWORD *)&transform->up.z;
    v9 = *(_QWORD *)&transform->pos.z;
    v10 = *(_QWORD *)&transform->at.x;
    v11 = *(_QWORD *)&transform->at.z;
    *(_QWORD *)&matrix->pos.x = *(_QWORD *)&transform->pos.x;
    *(_QWORD *)&matrix->pos.z = v9;
    *(_QWORD *)&matrix->at.x = v10;
    *(_QWORD *)&matrix->at.z = v11;
    *(_QWORD *)&matrix->right.x = v5;
    *(_QWORD *)&matrix->right.z = v6;
    *(_QWORD *)&matrix->up.x = v7;
    *(_QWORD *)&matrix->up.z = v8;
  }
  return v4;
}
// 6BD044: using guessed type int matrixModule;

//----- (001E4134) --------------------------------------------------------
const RwMatrix *__fastcall RwMatrixQueryRotate(
        const RwMatrix *matrix,
        RwV3d_0 *unitAxis,
        RwReal *angle,
        RwV3d_0 *center)
{
  RwReal v8; // s4
  float v9; // s0
  RwReal v10; // s2
  float v11; // s16
  float v12; // r0
  float v13; // s4
  float v14; // s0
  float v15; // s2
  float x; // s0
  float y; // s2
  float v18; // s2
  float v19; // s18
  float v20; // s16
  float v21; // s20
  float z; // s0
  float v23; // s0
  RwReal v24; // r0
  float v25; // s4
  float v26; // s6
  float v27; // s4
  float v28; // s6
  float v29; // s4
  RwReal v30; // s2
  float v31; // s6
  __int64 v32; // d16
  const RwMatrix *result; // r0
  float v34; // s4
  RwReal v35; // s0
  RwReal v36; // s2
  RwReal v37; // s4
  RwReal v38; // s0
  RwReal v39; // s2
  RwReal v40; // s4
  RwMatrix v41; // [sp+0h] [bp-B8h] BYREF
  RwMatrix src; // [sp+44h] [bp-74h] BYREF
  RwV3d_0 in; // [sp+84h] [bp-34h] BYREF

  src.flags = 1;
  v41.flags = 1;
  v8 = matrix->at.x - matrix->right.z;
  v9 = (float)(matrix->right.x + matrix->up.y) + matrix->at.z;
  v10 = matrix->right.y - matrix->up.x;
  in.x = matrix->up.z - matrix->at.y;
  in.y = v8;
  in.z = v10;
  v11 = v9 + -1.0;
  v12 = RwV3dLength(&in);
  if ( v12 <= 0.0 )
  {
    v15 = 0.0;
    v13 = 0.0;
    v14 = 0.0;
  }
  else
  {
    v13 = (float)(1.0 / v12) * in.y;
    v14 = (float)(1.0 / v12) * in.z;
    v15 = (float)(1.0 / v12) * in.x;
  }
  unitAxis->x = v15;
  unitAxis->y = v13;
  unitAxis->z = v14;
  *angle = atan2f(v12, v11) * 57.296;
  if ( v11 <= 0.0 )
  {
    x = matrix->right.x;
    y = matrix->up.y;
    if ( matrix->right.x <= y )
    {
      z = matrix->at.z;
      if ( y > z )
      {
        v19 = matrix->up.z + matrix->at.y;
        v21 = matrix->up.x + matrix->right.y;
        v20 = (float)(y + 1.0) + (float)(y + 1.0);
        goto LABEL_13;
      }
      v23 = z + 1.0;
    }
    else
    {
      v18 = matrix->at.z;
      if ( x > v18 )
      {
        v19 = matrix->right.z + matrix->at.x;
        v20 = matrix->right.y + matrix->up.x;
        v21 = (float)(x + 1.0) + (float)(x + 1.0);
LABEL_13:
        v24 = _rwInvSqrt((float)((float)(v21 * v21) + (float)(v20 * v20)) + (float)(v19 * v19));
        unitAxis->x = v21 * v24;
        unitAxis->y = v20 * v24;
        unitAxis->z = v19 * v24;
        goto LABEL_14;
      }
      v23 = v18 + 1.0;
    }
    v19 = v23 + v23;
    v21 = matrix->at.x + matrix->right.z;
    v20 = matrix->at.y + matrix->up.z;
    goto LABEL_13;
  }
LABEL_14:
  memset(&src.pos, 0, sizeof(src.pos));
  v25 = matrix->right.y;
  v26 = matrix->right.z;
  src.right.x = 1.0 - matrix->right.x;
  src.right.y = 0.0 - v25;
  src.right.z = 0.0 - v26;
  v27 = matrix->up.y;
  v28 = matrix->up.z;
  src.up.x = 0.0 - matrix->up.x;
  src.up.y = 1.0 - v27;
  src.up.z = 0.0 - v28;
  v29 = matrix->at.y;
  v30 = 0.0 - matrix->at.x;
  v31 = matrix->at.z;
  v41.flags = 1;
  src.at.x = v30;
  src.at.y = 0.0 - v29;
  src.flags = 1;
  src.at.z = 1.0 - v31;
  MatrixInvertGeneric(&v41, &src);
  v32 = *(_QWORD *)&v41.pos.x;
  center->z = v41.pos.z;
  result = matrix;
  *(_QWORD *)&center->x = v32;
  v34 = center->y;
  v35 = center->x + (float)(v41.right.x * matrix->pos.x);
  center->x = v35;
  v36 = v34 + (float)(v41.right.y * matrix->pos.x);
  center->y = v36;
  v37 = center->z + (float)(v41.right.z * matrix->pos.x);
  center->z = v37;
  v38 = v35 + (float)(v41.up.x * matrix->pos.y);
  center->x = v38;
  v39 = v36 + (float)(v41.up.y * matrix->pos.y);
  center->y = v39;
  v40 = v37 + (float)(v41.up.z * matrix->pos.y);
  center->z = v40;
  center->x = v38 + (float)(v41.at.x * matrix->pos.z);
  center->y = v39 + (float)(v41.at.y * matrix->pos.z);
  center->z = v40 + (float)(v41.at.z * matrix->pos.z);
  return result;
}

//----- (001E446C) --------------------------------------------------------
RwBool __fastcall RwMatrixDestroy(RwMatrix *matrix)
{
  (*((void (__fastcall **)(_DWORD, RwMatrix *))RwEngineInstance + 80))(
    *(_DWORD *)((char *)RwEngineInstance + matrixModule),
    matrix);
  return 1;
}
// 6BD044: using guessed type int matrixModule;

//----- (001E4494) --------------------------------------------------------
RwMatrix *RwMatrixCreate()
{
  RwMatrix *result; // r0
  __int64 v1; // r2

  result = (RwMatrix *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                         + matrixModule));
  if ( result )
  {
    HIDWORD(v1) = (char *)&elf_hash_chain[16294] + 3;
    LODWORD(v1) = 0;
    result->at.x = 0.0;
    result->at.y = 0.0;
    result->at.z = 1.0;
    result->pos.x = 0.0;
    result->pos.y = 0.0;
    result->pos.z = 0.0;
    result->right.x = 1.0;
    result->right.y = 0.0;
    *(_QWORD *)&result->right.z = v1;
    result->up.x = 0.0;
    result->up.y = 1.0;
    result->up.z = 0.0;
  }
  return result;
}
// 10168: using guessed type int elf_hash_chain[22025];
// 6BD044: using guessed type int matrixModule;

//----- (001E44E4) --------------------------------------------------------
void __fastcall _rwFreeListEnable(RwBool enabled)
{
  FreeListsEnabled = enabled;
}

//----- (001E44F0) --------------------------------------------------------
RwFreeList_0 *__fastcall RwFreeListCreate(RwInt32 entrySize, RwInt32 entriesPerBlock, RwInt32 alignment)
{
  return FreeListCreate(entrySize, entriesPerBlock, alignment, 1u, 0);
}

//----- (001E4504) --------------------------------------------------------
RwFreeList_0 *__fastcall FreeListCreate(
        RwUInt32 entrySize,
        RwUInt32 entriesPerBlock,
        RwUInt32 alignment,
        RwUInt32 blocks,
        RwFreeList_0 *a5)
{
  RwFreeList_0 *v7; // r10
  RwUInt32 v8; // r6
  int v10; // r0
  int v11; // r0
  RwUInt32 v12; // r1
  RwLinkList_0 *p_blockList; // r4
  size_t v14; // r9
  RwUInt32 v15; // r8
  RwLLLink *v16; // r0
  RwLLLink *v17; // r1
  RwLinkList_0 *next; // r0
  RwLinkList_0 *v19; // r4
  bool v20; // zf

  v7 = a5;
  v8 = alignment;
  if ( !FreeListsEnabled )
    blocks = FreeListsEnabled;
  if ( !alignment )
    v8 = 4;
  if ( a5 )
  {
    v10 = 3;
  }
  else
  {
    if ( _masterFreeListPtr )
      v11 = (*((int (__fastcall **)(RwFreeList_0 *))RwEngineInstance + 79))(_masterFreeListPtr);
    else
      v11 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(36);
    v7 = (RwFreeList_0 *)v11;
    if ( !v11 )
      return 0;
    v10 = 2;
  }
  v12 = (entrySize + v8 - 1) & -v8;
  p_blockList = &v7->blockList;
  v14 = ((entriesPerBlock + 15) >> 3) & 0x1FFFFFFE;
  v7->entrySize = v12;
  v7->entriesPerBlock = entriesPerBlock;
  v7->heapSize = v14;
  v7->alignment = v8;
  v7->blockList.link.next = &v7->blockList.link;
  v7->blockList.link.prev = &v7->blockList.link;
  v7->flags = v10;
  if ( blocks )
  {
    v15 = v14 + v8 + v12 * entriesPerBlock + 7;
    while ( 1 )
    {
      v16 = (RwLLLink *)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(v15);
      if ( !v16 )
        break;
      v16->next = 0;
      v16->prev = 0;
      v16->next = p_blockList->link.next;
      v16->prev = &p_blockList->link;
      p_blockList->link.next->prev = v16;
      p_blockList->link.next = v16;
      memset(&v16[1], 0, v14);
      if ( !--blocks )
        goto LABEL_16;
    }
    v19 = &v7->blockList;
    next = (RwLinkList_0 *)v7->blockList.link.next;
    if ( next != &v7->blockList )
    {
      do
      {
        next->link.prev->next = next->link.next;
        next->link.next->prev = next->link.prev;
        (*((void (**)(void))RwEngineInstance + 76))();
        next = (RwLinkList_0 *)v19->link.next;
      }
      while ( (RwLinkList_0 *)v19->link.next != v19 );
    }
    if ( !(LOBYTE(v7->flags) << 31) )
    {
      v20 = _masterFreeListPtr == v7;
      if ( _masterFreeListPtr != v7 )
        v20 = _masterFreeListPtr == 0;
      if ( !v20 )
      {
        (*((void (**)(void))RwEngineInstance + 80))();
        return 0;
      }
      (*((void (__fastcall **)(RwFreeList_0 *))RwEngineInstance + 76))(v7);
    }
    return 0;
  }
LABEL_16:
  v17 = _freeListList.link.next;
  v7->link.next = _freeListList.link.next;
  v7->link.prev = (RwLLLink *)&_freeListList;
  v17->prev = &v7->link;
  _freeListList.link.next = &v7->link;
  return v7;
}

//----- (001E4670) --------------------------------------------------------
RwBool __fastcall RwFreeListDestroy(RwFreeList_0 *freeList)
{
  RwLLLink *next; // r0
  RwLinkList_0 *p_blockList; // r5
  bool v4; // zf

  freeList->link.prev->next = freeList->link.next;
  freeList->link.next->prev = freeList->link.prev;
  p_blockList = &freeList->blockList;
  next = freeList->blockList.link.next;
  if ( next != (RwLLLink *)p_blockList )
  {
    do
    {
      next->prev->next = next->next;
      next->next->prev = next->prev;
      (*((void (**)(void))RwEngineInstance + 76))();
      next = p_blockList->link.next;
    }
    while ( (RwLinkList_0 *)p_blockList->link.next != p_blockList );
  }
  if ( !(LOBYTE(freeList->flags) << 31) )
  {
    v4 = _masterFreeListPtr == freeList;
    if ( _masterFreeListPtr != freeList )
      v4 = _masterFreeListPtr == 0;
    if ( v4 )
      (*((void (__fastcall **)(RwFreeList_0 *))RwEngineInstance + 76))(freeList);
    else
      (*((void (**)(void))RwEngineInstance + 80))();
  }
  return 1;
}

//----- (001E46F4) --------------------------------------------------------
void __fastcall RwFreeListSetFlags(RwFreeList_0 *freeList, RwUInt32 flags)
{
  freeList->flags |= flags & 0xFFFFFFFE;
}

//----- (001E4700) --------------------------------------------------------
RwUInt32 __fastcall RwFreeListGetFlags(RwFreeList_0 *freeList)
{
  return freeList->flags;
}

//----- (001E4704) --------------------------------------------------------
void *__fastcall _rwFreeListAllocReal(RwFreeList_0 *freeList)
{
  RwLinkList_0 *p_blockList; // r0
  RwLLLink *v3; // lr
  RwLLLink *next; // t1
  size_t v5; // r11
  RwLLLink *v6; // r8
  RwUInt32 entriesPerBlock; // r3
  int v8; // r6
  size_t j; // r4
  int v10; // r0
  int v11; // r9
  unsigned int v12; // r5
  RwUInt32 v13; // r0
  RwUInt32 v14; // r2
  int v15; // r0
  int v16; // r6
  RwLinkList_0 *i; // [sp+0h] [bp-20h]

  next = freeList->blockList.link.next;
  p_blockList = &freeList->blockList;
  v3 = next;
  v5 = (size_t)p_blockList[-1].link.next;
  for ( i = p_blockList; v3 != (RwLLLink *)i; v3 = v3->next )
  {
    if ( v5 )
    {
      v6 = v3 + 1;
      entriesPerBlock = freeList->entriesPerBlock;
      v8 = 0;
      for ( j = 0; j < v5; ++j )
      {
        v10 = *((unsigned __int8 *)&v6->next + j);
        if ( v10 == 255 )
        {
          entriesPerBlock -= 8;
        }
        else if ( entriesPerBlock )
        {
          v11 = 0;
          while ( ((0x80u >> v11) & v10) != 0 )
          {
            v12 = v11 + 1;
            if ( entriesPerBlock - 1 != v11 )
            {
              ++v11;
              if ( v12 < 8 )
                continue;
            }
            entriesPerBlock -= v12;
            goto LABEL_15;
          }
          *((_BYTE *)&v6->next + j) = v10 | (0x80u >> v11);
          v13 = freeList->entrySize * v8 - v11 * freeList->entrySize;
          v14 = -freeList->alignment & ((unsigned int)&v3->prev + v5 + freeList->alignment + 3);
          if ( v14 != v13 )
            return (void *)(v14 - v13);
          entriesPerBlock -= v11;
        }
        else
        {
          entriesPerBlock = 0;
        }
LABEL_15:
        v8 -= 8;
      }
    }
  }
  v15 = (*((int (__fastcall **)(size_t))RwEngineInstance + 75))(v5
                                                              + freeList->entrySize * freeList->entriesPerBlock
                                                              + freeList->alignment + 7);
  v16 = v15;
  if ( !v15 )
    return 0;
  memset((void *)(v15 + 8), 0, v5);
  *(_DWORD *)v16 = freeList->blockList.link.next;
  *(_DWORD *)(v16 + 4) = i;
  freeList->blockList.link.next->prev = (RwLLLink *)v16;
  freeList->blockList.link.next = (RwLLLink *)v16;
  *(_BYTE *)(v16 + 8) = 0x80;
  return (void *)(-freeList->alignment & (v16 + 8 + v5 + freeList->alignment - 1));
}

//----- (001E480C) --------------------------------------------------------
RwFreeList_0 *__fastcall _rwFreeListFreeReal(RwFreeList_0 *freeList, void *entry)
{
  int32x4_t v2; // q9
  RwFreeList_0 *v3; // r8
  RwLLLink *next; // r5
  RwLinkList_0 *p_blockList; // r9
  RwUInt32 heapSize; // r4
  RwLLLink *v7; // r6
  unsigned int v8; // r0
  __int64 v9; // r2
  unsigned int v11; // r0
  int8x16_t v12; // q8
  unsigned int v13; // r2
  unsigned __int32 v14; // t1
  int32x4_t v15; // q8
  unsigned __int32 v16; // r1
  RwUInt32 v17; // r2
  unsigned __int8 *v18; // r0
  int v19; // t1
  RwLLLink *v20; // r0

  v3 = freeList;
  p_blockList = &freeList->blockList;
  next = freeList->blockList.link.next;
  if ( next == (RwLLLink *)&freeList->blockList )
    return 0;
  heapSize = freeList->heapSize;
  while ( 1 )
  {
    v7 = next + 1;
    v8 = (unsigned int)&next[1] + heapSize;
    if ( v8 <= (unsigned int)entry )
    {
      v9 = *(_QWORD *)&v3->entrySize;
      if ( v8 + (_DWORD)v9 * HIDWORD(v9) >= (unsigned int)entry )
        break;
    }
    next = next->next;
    if ( next == (RwLLLink *)p_blockList )
      return 0;
  }
  *((_BYTE *)&v7->next + ((((unsigned int)entry - v8) / (unsigned int)v9) >> 3)) &= ~(0x80u >> ((((unsigned int)entry
                                                                                                - v8)
                                                                                               / (unsigned int)v9) & 7));
  if ( (v3->flags & 2) != 0 )
  {
    if ( !heapSize )
    {
LABEL_20:
      if ( next != p_blockList->link.next )
      {
        v20 = next->next;
LABEL_23:
        next->prev->next = v20;
        next->next->prev = next->prev;
        (*((void (__fastcall **)(RwLLLink *))RwEngineInstance + 76))(next);
        return v3;
      }
      v20 = next->next;
      if ( (RwLinkList_0 *)next->next != p_blockList )
        goto LABEL_23;
      return v3;
    }
    if ( heapSize >= 4 && (v11 = heapSize & 0xFFFFFFFC, (heapSize & 0xFFFFFFFC) != 0) )
    {
      v12 = 0uLL;
      v13 = heapSize & 0xFFFFFFFC;
      do
      {
        v14 = (unsigned __int32)v7->next;
        v7 = (RwLLLink *)((char *)v7 + 4);
        v13 -= 4;
        v2.n128_u32[0] = v14;
        v2 = vmovl_u16((uint16x4_t)vmovl_u8((uint8x8_t)v2.n128_u64[0]).n128_u64[0]);
        v12 = vaddq_s32(v12, v2);
      }
      while ( v13 );
      v15 = vaddq_s32(v12, vextq_s8(v12, v12, 8u));
      v16 = vaddq_s32(v15, vdupq_lane_s32((int32x2_t)v15.n128_u64[0], 1)).n128_u32[0];
      if ( heapSize == v11 )
      {
LABEL_19:
        if ( v16 )
          return v3;
        goto LABEL_20;
      }
    }
    else
    {
      v16 = 0;
      v11 = 0;
    }
    v17 = heapSize - v11;
    v18 = (unsigned __int8 *)&next[1] + v11;
    do
    {
      v19 = *v18++;
      --v17;
      v16 += v19;
    }
    while ( v17 );
    goto LABEL_19;
  }
  return v3;
}
// 1E4894: variable 'v2' is possibly undefined

//----- (001E4908) --------------------------------------------------------
RwInt32 __fastcall RwFreeListPurge(RwFreeList_0 *freeList)
{
  int32x4_t v1; // q9
  RwLinkList_0 *p_blockList; // r9
  RwLLLink *next; // r10
  RwUInt32 heapSize; // r8
  int v6; // r1
  unsigned int v7; // r11
  RwLLLink *v8; // r1
  RwLLLink *v9; // r0
  unsigned __int32 v10; // r3
  unsigned int v11; // r6
  int8x16_t v12; // q8
  RwLLLink *v13; // r3
  unsigned int v14; // r4
  unsigned __int32 v15; // t1
  int32x4_t v16; // q8
  RwUInt32 v17; // r4
  unsigned __int8 *v18; // r6
  int v19; // t1
  int v21; // [sp+4h] [bp-24h]

  p_blockList = &freeList->blockList;
  next = freeList->blockList.link.next;
  if ( next == (RwLLLink *)&freeList->blockList )
  {
    v6 = 0;
    return freeList->entrySize * v6;
  }
  heapSize = freeList->heapSize;
  v6 = 0;
  v7 = heapSize & 0xFFFFFFFC;
  while ( 2 )
  {
    v21 = v6;
    v8 = next;
    v9 = next;
    while ( 1 )
    {
      v8->prev->next = v8->next;
      v8->next->prev = v8->prev;
      if ( (RwLinkList_0 *)p_blockList->link.next == p_blockList )
      {
        v8->next = &p_blockList->link;
        v8->prev = &p_blockList->link;
        p_blockList->link.next->prev = v8;
        p_blockList->link.next = v8;
LABEL_22:
        v6 = v21;
        return freeList->entrySize * v6;
      }
      next = v8->next;
      if ( !heapSize )
        break;
      v10 = 0;
      if ( heapSize < 4 )
      {
        v11 = 0;
LABEL_13:
        v17 = heapSize - v11;
        v18 = (unsigned __int8 *)&v9[1] + v11;
        do
        {
          v19 = *v18++;
          --v17;
          v10 += v19;
        }
        while ( v17 );
        goto LABEL_15;
      }
      v11 = 0;
      if ( !v7 )
        goto LABEL_13;
      v12 = 0uLL;
      v13 = v9 + 1;
      v14 = heapSize & 0xFFFFFFFC;
      do
      {
        v15 = (unsigned __int32)v13->next;
        v13 = (RwLLLink *)((char *)v13 + 4);
        v14 -= 4;
        v1.n128_u32[0] = v15;
        v1 = vmovl_u16((uint16x4_t)vmovl_u8((uint8x8_t)v1.n128_u64[0]).n128_u64[0]);
        v12 = vaddq_s32(v12, v1);
      }
      while ( v14 );
      v11 = heapSize & 0xFFFFFFFC;
      v16 = vaddq_s32(v12, vextq_s8(v12, v12, 8u));
      v1 = vdupq_lane_s32((int32x2_t)v16.n128_u64[0], 1);
      v10 = vaddq_s32(v16, v1).n128_u32[0];
      if ( heapSize != v7 )
        goto LABEL_13;
LABEL_15:
      if ( !v10 )
        break;
      v8->next = p_blockList->link.next;
      v8->prev = &p_blockList->link;
      p_blockList->link.next->prev = v8;
      v8 = next;
      p_blockList->link.next = v9;
      v9 = next;
      if ( next == (RwLLLink *)p_blockList )
        goto LABEL_22;
    }
    (*((void (**)(void))RwEngineInstance + 76))();
    v6 = v21 + 1;
    if ( next != (RwLLLink *)p_blockList )
      continue;
    return freeList->entrySize * v6;
  }
}
// 1E497E: variable 'v1' is possibly undefined

//----- (001E4A18) --------------------------------------------------------
RwFreeList_0 *__fastcall RwFreeListForAllUsed(RwFreeList_0 *freeList, RwFreeListCallBack fpCallBack, void *pData)
{
  RwFreeList_0 *v3; // r4
  RwFreeList_0 *next; // r6
  size_t heapSize; // r5
  RwUInt32 *v7; // r0
  RwUInt32 *p_heapSize; // r10
  int v9; // r6
  _BYTE *v10; // r9
  char *v11; // r10
  size_t v12; // r5
  int v13; // r11
  RwLinkList_0 *p_blockList; // [sp+4h] [bp-34h]
  size_t v16; // [sp+Ch] [bp-2Ch]
  RwFreeList_0 *entrySize; // [sp+10h] [bp-28h]
  _BYTE *v18; // [sp+14h] [bp-24h]

  v3 = freeList;
  next = (RwFreeList_0 *)freeList->blockList.link.next;
  if ( next != (RwFreeList_0 *)&freeList->blockList )
  {
    heapSize = freeList->heapSize;
    p_blockList = &freeList->blockList;
    v16 = heapSize;
    while ( 1 )
    {
      v7 = (RwUInt32 *)(*((int (__fastcall **)(size_t))RwEngineInstance + 75))(heapSize);
      if ( !v7 )
        return 0;
      p_heapSize = &next->heapSize;
      v18 = v7;
      qmemcpy(v7, &next->heapSize, heapSize);
      entrySize = (RwFreeList_0 *)next->entrySize;
      if ( heapSize )
      {
        v9 = 7;
        v10 = v18;
        v11 = (char *)p_heapSize + v16;
        v12 = v16;
        while ( 2 )
        {
          v13 = (unsigned __int8)*v10;
          if ( !*v10 )
            goto LABEL_24;
          if ( (v13 & 0x80) != 0 )
          {
            fpCallBack(
              (void *)((-v3->alignment & (unsigned int)&v11[v3->alignment - 1]) + v3->entrySize * (v9 - 7)),
              pData);
            if ( (v13 & 0x40) == 0 )
              goto LABEL_17;
          }
          else if ( (v13 & 0x40) == 0 )
          {
LABEL_17:
            if ( (v13 & 0x20) == 0 )
            {
LABEL_18:
              if ( (v13 & 0x10) == 0 )
              {
LABEL_19:
                if ( (v13 & 8) == 0 )
                {
LABEL_20:
                  if ( (v13 & 4) == 0 )
                    goto LABEL_21;
LABEL_11:
                  fpCallBack(
                    (void *)((-v3->alignment & (unsigned int)&v11[v3->alignment - 1]) + v3->entrySize * (v9 - 2)),
                    pData);
                  if ( (v13 & 2) != 0 )
                    goto LABEL_12;
                  goto LABEL_22;
                }
LABEL_10:
                fpCallBack(
                  (void *)((-v3->alignment & (unsigned int)&v11[v3->alignment - 1]) + v3->entrySize * (v9 - 3)),
                  pData);
                if ( (v13 & 4) != 0 )
                  goto LABEL_11;
LABEL_21:
                if ( (v13 & 2) != 0 )
                {
LABEL_12:
                  fpCallBack(
                    (void *)((-v3->alignment & (unsigned int)&v11[v3->alignment - 1]) + v3->entrySize * (v9 - 1)),
                    pData);
                  if ( !(v13 << 31) )
                    goto LABEL_24;
LABEL_23:
                  fpCallBack(
                    (void *)((-v3->alignment & (unsigned int)&v11[v3->alignment - 1]) + v3->entrySize * v9),
                    pData);
                  goto LABEL_24;
                }
LABEL_22:
                if ( v13 << 31 )
                  goto LABEL_23;
LABEL_24:
                --v12;
                ++v10;
                v9 += 8;
                if ( !v12 )
                  goto LABEL_25;
                continue;
              }
LABEL_9:
              fpCallBack(
                (void *)((-v3->alignment & (unsigned int)&v11[v3->alignment - 1]) + v3->entrySize * (v9 - 4)),
                pData);
              if ( (v13 & 8) == 0 )
                goto LABEL_20;
              goto LABEL_10;
            }
LABEL_8:
            fpCallBack(
              (void *)((-v3->alignment & (unsigned int)&v11[v3->alignment - 1]) + v3->entrySize * (v9 - 5)),
              pData);
            if ( (v13 & 0x10) == 0 )
              goto LABEL_19;
            goto LABEL_9;
          }
          break;
        }
        fpCallBack((void *)((-v3->alignment & (unsigned int)&v11[v3->alignment - 1]) + v3->entrySize * (v9 - 6)), pData);
        if ( (v13 & 0x20) == 0 )
          goto LABEL_18;
        goto LABEL_8;
      }
LABEL_25:
      (*((void (__fastcall **)(_BYTE *))RwEngineInstance + 76))(v18);
      next = entrySize;
      heapSize = v16;
      if ( entrySize == (RwFreeList_0 *)p_blockList )
        return v3;
    }
  }
  return v3;
}

//----- (001E4BE4) --------------------------------------------------------
RwInt32 RwFreeListPurgeAllFreeLists()
{
  int32x4_t v0; // q9
  int v1; // r12
  RwLinkList_0 *next; // lr
  RwLinkList_0 *prev; // r10
  RwLinkList_0 *v4; // r11
  unsigned int v5; // r8
  int v6; // r2
  RwLinkList_0 **v7; // r1
  RwLinkList_0 *v8; // r0
  unsigned __int32 v9; // r3
  unsigned int v10; // r5
  int8x16_t v11; // q8
  unsigned int v12; // r4
  unsigned __int32 *v13; // r3
  unsigned __int32 v14; // t1
  int32x4_t v15; // q8
  unsigned int v16; // r4
  unsigned __int8 *v17; // r5
  int v18; // t1
  int v19; // r4
  RwLLLink *v20; // r0
  int v22; // [sp+8h] [bp-28h]
  unsigned int v23; // [sp+Ch] [bp-24h]

  v1 = 0;
  next = (RwLinkList_0 *)_freeListList.link.next;
  if ( (RwLinkList_0 *)_freeListList.link.next == &_freeListList )
    return v1;
  do
  {
    v4 = (RwLinkList_0 *)((char *)next - 12);
    prev = (RwLinkList_0 *)next[-2].link.prev;
    if ( prev == (RwLinkList_0 *)&next[-2].link.prev )
    {
      v6 = 0;
      goto LABEL_23;
    }
    v5 = (unsigned int)next[-3].link.prev;
    v6 = 0;
    v23 = v5 & 0xFFFFFFFC;
    while ( 2 )
    {
      v7 = (RwLinkList_0 **)prev;
      v8 = prev;
      v22 = v6;
      while ( 1 )
      {
        v7[1]->link.next = (RwLLLink *)*v7;
        (*v7)->link.prev = (RwLLLink *)v7[1];
        if ( (RwLinkList_0 *)v4->link.next == v4 )
        {
          *v7 = v4;
          v7[1] = v4;
          v4->link.next->prev = (RwLLLink *)v7;
          v4->link.next = (RwLLLink *)v7;
          goto LABEL_23;
        }
        prev = *v7;
        if ( !v5 )
          break;
        v9 = 0;
        if ( v5 < 4 )
        {
          v10 = 0;
LABEL_14:
          v16 = v5 - v10;
          v17 = (unsigned __int8 *)&v8[1] + v10;
          do
          {
            v18 = *v17++;
            --v16;
            v9 += v18;
          }
          while ( v16 );
          goto LABEL_16;
        }
        v10 = 0;
        if ( !v23 )
          goto LABEL_14;
        v11 = 0uLL;
        v12 = v5 & 0xFFFFFFFC;
        v13 = (unsigned __int32 *)&v8[1];
        do
        {
          v14 = *v13++;
          v12 -= 4;
          v0.n128_u32[0] = v14;
          v0 = vmovl_u16((uint16x4_t)vmovl_u8((uint8x8_t)v0.n128_u64[0]).n128_u64[0]);
          v11 = vaddq_s32(v11, v0);
        }
        while ( v12 );
        v15 = vaddq_s32(v11, vextq_s8(v11, v11, 8u));
        v10 = v5 & 0xFFFFFFFC;
        v0 = vdupq_lane_s32((int32x2_t)v15.n128_u64[0], 1);
        v9 = vaddq_s32(v15, v0).n128_u32[0];
        if ( v5 != v23 )
          goto LABEL_14;
LABEL_16:
        if ( !v9 )
          break;
        *v7 = (RwLinkList_0 *)v4->link.next;
        v7[1] = v4;
        v4->link.next->prev = (RwLLLink *)v7;
        v7 = (RwLinkList_0 **)prev;
        v4->link.next = &v8->link;
        v8 = prev;
        if ( prev == v4 )
          goto LABEL_23;
      }
      v19 = v1;
      (*((void (**)(void))RwEngineInstance + 76))();
      v1 = v19;
      v6 = v22 + 1;
      if ( prev != v4 )
        continue;
      break;
    }
LABEL_23:
    v20 = next[-4].link.prev;
    next = (RwLinkList_0 *)next->link.next;
    if ( (int)v20 * v6 > 0 )
      v1 += (_DWORD)v20 * v6;
  }
  while ( next != &_freeListList );
  return v1;
}
// 1E4C6A: variable 'v0' is possibly undefined

//----- (001E4D2C) --------------------------------------------------------
RwBool __fastcall _rwMemoryOpen(const RwMemoryFunctions_0 *memFuncs)
{
  RwBool v2; // r5
  RwFreeList_0 *v3; // r0
  _DWORD *v4; // r0
  __int64 v5; // d17
  char *v6; // r0

  v2 = 0;
  _freeListList.link.next = (RwLLLink *)&_freeListList;
  _freeListList.link.prev = (RwLLLink *)&_freeListList;
  v3 = FreeListCreate(0x24u, 0x10u, 4u, 0, &_masterFreeList);
  _masterFreeListPtr = v3;
  if ( v3 )
  {
    v3->link.prev->next = v3->link.next;
    v3->link.next->prev = v3->link.prev;
    v4 = RwEngineInstance;
    if ( memFuncs )
    {
      v5 = *(_QWORD *)&memFuncs->rwrealloc;
      v6 = (char *)RwEngineInstance + 300;
      *(_QWORD *)((char *)RwEngineInstance + 300) = *(_QWORD *)&memFuncs->rwmalloc;
      *((_QWORD *)v6 + 1) = v5;
    }
    else
    {
      *((_DWORD *)RwEngineInstance + 75) = &malloc;
      v4[76] = &free;
      v4[77] = &realloc;
      v4[78] = FakeCalloc;
    }
    return 1;
  }
  return v2;
}

//----- (001E4DC8) --------------------------------------------------------
void *__fastcall FakeCalloc(size_t numObj, size_t sizeObj)
{
  size_t v2; // r4
  void *v3; // r0
  void *v4; // r5

  v2 = sizeObj * numObj;
  v3 = malloc(sizeObj * numObj);
  v4 = v3;
  if ( v3 )
    memset(v3, 0, v2);
  return v4;
}

//----- (001E4DE8) --------------------------------------------------------
void _rwMemoryClose()
{
  RwLLLink *i; // r5
  RwLLLink *next; // r0
  RwLLLink *v2; // r5
  RwLLLink *prev; // t1
  RwFreeList_0 *v4; // r4
  bool v5; // zf
  RwFreeList_0 *v6; // r4
  RwLinkList_0 *v7; // r0
  RwLinkList_0 *p_blockList; // r5
  bool v9; // zf

  for ( i = _freeListList.link.next; (RwLinkList_0 *)_freeListList.link.next != &_freeListList; i = _freeListList.link.next )
  {
    i->prev->next = i->next;
    i->next->prev = i->prev;
    prev = i[-2].prev;
    v2 = (RwLLLink *)((char *)i - 12);
    next = prev;
    v4 = (RwFreeList_0 *)&v2[-2];
    if ( prev != v2 )
    {
      do
      {
        next->prev->next = next->next;
        next->next->prev = next->prev;
        (*((void (**)(void))RwEngineInstance + 76))();
        next = v2->next;
      }
      while ( v2->next != v2 );
    }
    if ( !(LOBYTE(v2[1].next) << 31) )
    {
      v5 = _masterFreeListPtr == v4;
      if ( _masterFreeListPtr != v4 )
        v5 = _masterFreeListPtr == 0;
      if ( v5 )
        (*((void (__fastcall **)(RwLLLink *))RwEngineInstance + 76))(v2 - 2);
      else
        (*((void (**)(void))RwEngineInstance + 80))();
    }
  }
  v6 = _masterFreeListPtr;
  _masterFreeListPtr->link.prev->next = _masterFreeListPtr->link.next;
  v6->link.next->prev = v6->link.prev;
  p_blockList = &v6->blockList;
  v7 = (RwLinkList_0 *)v6->blockList.link.next;
  if ( v7 != &v6->blockList )
  {
    do
    {
      v7->link.prev->next = v7->link.next;
      v7->link.next->prev = v7->link.prev;
      (*((void (**)(void))RwEngineInstance + 76))();
      v7 = (RwLinkList_0 *)p_blockList->link.next;
    }
    while ( (RwLinkList_0 *)p_blockList->link.next != p_blockList );
  }
  if ( !(LOBYTE(v6->flags) << 31) )
  {
    v9 = _masterFreeListPtr == v6;
    if ( _masterFreeListPtr != v6 )
      v9 = _masterFreeListPtr == 0;
    if ( v9 )
      (*((void (__fastcall **)(RwFreeList_0 *))RwEngineInstance + 76))(v6);
    else
      (*((void (**)(void))RwEngineInstance + 80))();
  }
  _masterFreeListPtr = 0;
}

//----- (001E4F18) --------------------------------------------------------
RwMemoryFunctions_0 *RwOsGetMemoryInterface()
{
  return (RwMemoryFunctions_0 *)((char *)RwEngineInstance + 300);
}

//----- (001E4F2C) --------------------------------------------------------
void *__fastcall _rwResourcesOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  char *v3; // r2
  char *v4; // r2
  void *v5; // r1

  v3 = (char *)RwEngineInstance;
  resourcesModule.globalsOffset = offset;
  *(_DWORD *)((char *)RwEngineInstance + offset) = *((_DWORD *)RwEngineInstance + 83);
  v4 = &v3[offset];
  *((_DWORD *)v4 + 4) = v4 + 16;
  *((_DWORD *)v4 + 5) = v4 + 16;
  *((_DWORD *)v4 + 6) = v4 + 24;
  *((_DWORD *)v4 + 7) = v4 + 24;
  *((_DWORD *)v4 + 8) = v4 + 24;
  *((_DWORD *)v4 + 9) = v4 + 16;
  v5 = 0;
  *((_DWORD *)v4 + 1) = 0;
  *((_DWORD *)v4 + 2) = 0;
  if ( v4 )
  {
    ++resourcesModule.numInstances;
    return instance;
  }
  return v5;
}

//----- (001E4F80) --------------------------------------------------------
void *__fastcall _rwResourcesClose(void *instance, RwInt32 offset, RwInt32 size)
{
  RwResourcesEmptyArena();
  --resourcesModule.numInstances;
  return instance;
}

//----- (001E4FA0) --------------------------------------------------------
RwBool RwResourcesEmptyArena()
{
  RwInt32 globalsOffset; // r0
  char *v1; // r1
  char *v2; // r11
  char *v3; // r4
  void (__fastcall *v4)(char *); // r1
  char *v5; // r5
  _DWORD *v6; // r0

  **(_DWORD **)((char *)RwEngineInstance + resourcesModule.globalsOffset + 20) = *(_DWORD *)((char *)RwEngineInstance
                                                                                           + resourcesModule.globalsOffset
                                                                                           + 24);
  globalsOffset = resourcesModule.globalsOffset;
  v1 = (char *)RwEngineInstance;
  v2 = (char *)RwEngineInstance + resourcesModule.globalsOffset + 24;
  v3 = *(char **)((char *)RwEngineInstance + resourcesModule.globalsOffset + 16);
  if ( v3 != v2 )
  {
    do
    {
      v4 = (void (__fastcall *)(char *))*((_DWORD *)v3 + 5);
      v5 = *(char **)v3;
      if ( v4 )
        v4(v3);
      v6 = (_DWORD *)*((_DWORD *)v3 + 4);
      if ( v6 )
        *v6 = 0;
      if ( *(_DWORD *)v3 )
      {
        **((_DWORD **)v3 + 1) = *(_DWORD *)v3;
        *(_DWORD *)(*(_DWORD *)v3 + 4) = *((_DWORD *)v3 + 1);
        *(_DWORD *)((char *)RwEngineInstance + resourcesModule.globalsOffset + 4) -= *((_DWORD *)v3 + 2);
      }
      (*((void (__fastcall **)(char *))RwEngineInstance + 76))(v3);
      v3 = v5;
    }
    while ( v5 != v2 );
    globalsOffset = resourcesModule.globalsOffset;
    v1 = (char *)RwEngineInstance;
  }
  *(_DWORD *)&v1[globalsOffset + 16] = &v1[globalsOffset + 16];
  *(_DWORD *)((char *)RwEngineInstance + resourcesModule.globalsOffset + 20) = (char *)RwEngineInstance
                                                                             + resourcesModule.globalsOffset
                                                                             + 16;
  *(_DWORD *)((char *)RwEngineInstance + resourcesModule.globalsOffset + 24) = (char *)RwEngineInstance
                                                                             + resourcesModule.globalsOffset
                                                                             + 24;
  *(_DWORD *)((char *)RwEngineInstance + resourcesModule.globalsOffset + 28) = (char *)RwEngineInstance
                                                                             + resourcesModule.globalsOffset
                                                                             + 24;
  *(_DWORD *)((char *)RwEngineInstance + resourcesModule.globalsOffset + 8) = 0;
  return 1;
}

//----- (001E50B8) --------------------------------------------------------
RwBool __fastcall RwResourcesFreeResEntry(RwResEntry_0 *entry)
{
  RwResEntryDestroyNotify destroyNotify; // r1
  RwResEntry **ownerRef; // r0

  destroyNotify = entry->destroyNotify;
  if ( destroyNotify )
    destroyNotify(entry);
  ownerRef = entry->ownerRef;
  if ( ownerRef )
    *ownerRef = 0;
  if ( entry->link.next )
  {
    entry->link.prev->next = entry->link.next;
    entry->link.next->prev = entry->link.prev;
    *(_DWORD *)((char *)RwEngineInstance + resourcesModule.globalsOffset + 4) -= entry->size;
  }
  (*((void (__fastcall **)(RwResEntry_0 *))RwEngineInstance + 76))(entry);
  return 1;
}

//----- (001E5120) --------------------------------------------------------
void _rwResourcesPurge()
{
  RwInt32 globalsOffset; // r2
  char *v1; // r3
  __int64 v2; // kr00_8
  int v3; // r0
  _DWORD *v4; // r2
  _DWORD *v5; // r0
  _DWORD *v6; // r0

  globalsOffset = resourcesModule.globalsOffset;
  v1 = (char *)RwEngineInstance;
  v2 = *(_QWORD *)((char *)RwEngineInstance + resourcesModule.globalsOffset + 32);
  v3 = *(_DWORD *)v2;
  if ( *(_DWORD *)v2 != (_DWORD)v2 )
  {
    if ( *(_DWORD *)HIDWORD(v2) == HIDWORD(v2) )
    {
      *(_DWORD *)HIDWORD(v2) = v3;
      *(_DWORD *)(v3 + 4) = HIDWORD(v2);
      v6 = *(_DWORD **)(v2 + 4);
      *(_DWORD *)(HIDWORD(v2) + 4) = v6;
      *v6 = HIDWORD(v2);
    }
    else
    {
      v4 = *(_DWORD **)(HIDWORD(v2) + 4);
      *v4 = v3;
      *(_DWORD *)(v3 + 4) = v4;
      v5 = *(_DWORD **)(v2 + 4);
      *v5 = HIDWORD(v2);
      *(_DWORD *)(HIDWORD(v2) + 4) = v5;
    }
    *(_DWORD *)v2 = v2;
    *(_DWORD *)(v2 + 4) = v2;
    v1 = (char *)RwEngineInstance;
    globalsOffset = resourcesModule.globalsOffset;
  }
  *(_DWORD *)&v1[globalsOffset + 36] = v2;
  *(_DWORD *)((char *)RwEngineInstance + resourcesModule.globalsOffset + 32) = HIDWORD(v2);
  *(_DWORD *)((char *)RwEngineInstance + resourcesModule.globalsOffset + 8) = 0;
}

//----- (001E51C4) --------------------------------------------------------
RwResEntry_0 *__fastcall RwResourcesAllocateResEntry(
        void *owner,
        RwResEntry_0 **ownerRef,
        RwInt32 size,
        RwResEntryDestroyNotify destroyNotify)
{
  RwInt32 globalsOffset; // r6
  int (__fastcall **i)(int); // r4
  char *v7; // r0
  int v8; // r1
  int v9; // r6
  void (__fastcall *v10)(int); // r1
  _DWORD *v11; // r0
  void (__fastcall **v12)(_DWORD); // r0
  int v13; // r1
  void (__fastcall *v14)(int); // r1
  _DWORD *v15; // r0
  RwResEntry_0 *v16; // r0
  RwResEntry_0 *v17; // r6
  char *v18; // r2
  RwInt32 v19; // r0
  RwError_0 code; // [sp+1Ch] [bp-24h] BYREF

  globalsOffset = resourcesModule.globalsOffset;
  for ( i = (int (__fastcall **)(int))RwEngineInstance;
        *(_DWORD *)((char *)RwEngineInstance + resourcesModule.globalsOffset + 4) + size > *(_DWORD *)((char *)RwEngineInstance + resourcesModule.globalsOffset);
        i = (int (__fastcall **)(int))RwEngineInstance )
  {
    v7 = (char *)i + globalsOffset;
    v8 = *(int *)((char *)i + globalsOffset + 32);
    v9 = *(_DWORD *)(v8 + 4);
    if ( v9 == v8 )
    {
      v13 = *((_DWORD *)v7 + 9);
      v9 = *(_DWORD *)(v13 + 4);
      if ( v9 == v13 )
      {
        v17 = 0;
        if ( ownerRef )
          *ownerRef = 0;
        code.pluginID = 0;
        v19 = _rwerror(12, size);
LABEL_26:
        code.errorCode = v19;
        RwErrorSet(&code);
        return v17;
      }
      *((_DWORD *)v7 + 2) += *(_DWORD *)(v9 + 8);
      v14 = *(void (__fastcall **)(int))(v9 + 20);
      if ( v14 )
        v14(v9);
      v15 = *(_DWORD **)(v9 + 16);
      if ( v15 )
        *v15 = 0;
      if ( !*(_DWORD *)v9 )
      {
LABEL_16:
        v12 = (void (__fastcall **)(_DWORD))RwEngineInstance;
        goto LABEL_17;
      }
      **(_DWORD **)(v9 + 4) = *(_DWORD *)v9;
      *(_DWORD *)(*(_DWORD *)v9 + 4) = *(_DWORD *)(v9 + 4);
      *(_DWORD *)((char *)RwEngineInstance + resourcesModule.globalsOffset + 4) -= *(_DWORD *)(v9 + 8);
      v12 = (void (__fastcall **)(_DWORD))RwEngineInstance;
    }
    else
    {
      v10 = *(void (__fastcall **)(int))(v9 + 20);
      if ( v10 )
        v10(v9);
      v11 = *(_DWORD **)(v9 + 16);
      if ( v11 )
        *v11 = 0;
      if ( !*(_DWORD *)v9 )
        goto LABEL_16;
      **(_DWORD **)(v9 + 4) = *(_DWORD *)v9;
      *(_DWORD *)(*(_DWORD *)v9 + 4) = *(_DWORD *)(v9 + 4);
      *(_DWORD *)((char *)RwEngineInstance + resourcesModule.globalsOffset + 4) -= *(_DWORD *)(v9 + 8);
      v12 = (void (__fastcall **)(_DWORD))RwEngineInstance;
    }
LABEL_17:
    v12[76](v9);
    globalsOffset = resourcesModule.globalsOffset;
  }
  v16 = (RwResEntry_0 *)i[75](size + 24);
  v17 = v16;
  if ( !v16 )
  {
    v17 = 0;
    code.pluginID = 0;
    v19 = _rwerror(-2147483629, size + 24);
    goto LABEL_26;
  }
  v16->link.next = **(RwLLLink ***)((char *)RwEngineInstance + resourcesModule.globalsOffset + 36);
  v18 = (char *)RwEngineInstance + resourcesModule.globalsOffset;
  v16->link.prev = *(RwLLLink **)((char *)RwEngineInstance + resourcesModule.globalsOffset + 36);
  *(_DWORD *)(**((_DWORD **)v18 + 9) + 4) = v16;
  **((_DWORD **)v18 + 9) = v16;
  v16->size = size;
  v16->owner = owner;
  v16->ownerRef = ownerRef;
  v16->destroyNotify = destroyNotify;
  *(_DWORD *)((char *)RwEngineInstance + resourcesModule.globalsOffset + 4) += size;
  if ( ownerRef )
    *ownerRef = v16;
  return v17;
}

//----- (001E53A4) --------------------------------------------------------
RwBool __fastcall RwResourcesSetArenaSize(RwUInt32 size)
{
  RwUInt32 *v1; // r5
  RwUInt32 v2; // r0
  int v3; // r4
  void (__fastcall *v4)(_DWORD); // r1
  _DWORD *v5; // r0
  void (__fastcall **v6)(_DWORD); // r0
  RwUInt32 v7; // r0
  void (__fastcall *v8)(_DWORD); // r1
  _DWORD *v9; // r0

  if ( !resourcesModule.numInstances )
  {
    *((_DWORD *)RwEngineInstance + 83) = size;
    return 1;
  }
  v1 = (RwUInt32 *)((char *)RwEngineInstance + resourcesModule.globalsOffset);
  *v1 = size;
  if ( (int)v1[1] <= (int)size )
    return 1;
  while ( 1 )
  {
    v2 = v1[8];
    v3 = *(_DWORD *)(v2 + 4);
    if ( v3 == v2 )
      break;
    v4 = *(void (__fastcall **)(_DWORD))(v3 + 20);
    if ( v4 )
      v4(*(_DWORD *)(v2 + 4));
    v5 = *(_DWORD **)(v3 + 16);
    if ( v5 )
      *v5 = 0;
    if ( *(_DWORD *)v3 )
    {
      **(_DWORD **)(v3 + 4) = *(_DWORD *)v3;
      *(_DWORD *)(*(_DWORD *)v3 + 4) = *(_DWORD *)(v3 + 4);
      *(_DWORD *)((char *)RwEngineInstance + resourcesModule.globalsOffset + 4) -= *(_DWORD *)(v3 + 8);
    }
    v6 = (void (__fastcall **)(_DWORD))RwEngineInstance;
LABEL_21:
    v6[76](v3);
    if ( (int)v1[1] <= (int)*v1 )
      return 1;
  }
  v7 = v1[9];
  v3 = *(_DWORD *)(v7 + 4);
  if ( v3 != v7 )
  {
    v8 = *(void (__fastcall **)(_DWORD))(v3 + 20);
    if ( v8 )
      v8(*(_DWORD *)(v7 + 4));
    v9 = *(_DWORD **)(v3 + 16);
    if ( v9 )
      *v9 = 0;
    if ( *(_DWORD *)v3 )
    {
      **(_DWORD **)(v3 + 4) = *(_DWORD *)v3;
      *(_DWORD *)(*(_DWORD *)v3 + 4) = *(_DWORD *)(v3 + 4);
      *(_DWORD *)((char *)RwEngineInstance + resourcesModule.globalsOffset + 4) -= *(_DWORD *)(v3 + 8);
    }
    v6 = (void (__fastcall **)(_DWORD))RwEngineInstance;
    goto LABEL_21;
  }
  return 0;
}

//----- (001E54E4) --------------------------------------------------------
RwInt32 RwResourcesGetArenaSize()
{
  return *(_DWORD *)((char *)RwEngineInstance + resourcesModule.globalsOffset);
}

//----- (001E5500) --------------------------------------------------------
RwInt32 RwResourcesGetArenaUsage()
{
  RwInt32 result; // r0
  _DWORD *v1; // r1
  _DWORD *i; // r2

  result = *(_DWORD *)((char *)RwEngineInstance + resourcesModule.globalsOffset + 8);
  v1 = *(_DWORD **)((char *)RwEngineInstance + resourcesModule.globalsOffset + 36);
  for ( i = (_DWORD *)*v1; i != v1; i = (_DWORD *)*i )
    result += i[2];
  return result;
}

//----- (001E5534) --------------------------------------------------------
void __fastcall RwStreamSetFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rwStreamFreeListPreallocBlocks = numBlocksToPrealloc;
  _rwStreamFreeListBlockSize = blockSize;
}

//----- (001E554C) --------------------------------------------------------
void *__fastcall _rwStreamModuleOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  RwFreeList_0 *v4; // r0
  int v5; // r2

  streamModule = offset;
  v4 = RwFreeListCreateAndPreallocateSpace(
         36,
         _rwStreamFreeListBlockSize,
         4,
         _rwStreamFreeListPreallocBlocks,
         &_rwStreamFreeList);
  v5 = streamModule;
  *(_DWORD *)((char *)RwEngineInstance + streamModule) = v4;
  if ( !*(_DWORD *)((char *)RwEngineInstance + v5) )
    return 0;
  ++streamModule;
  return instance;
}
// 6BD0A8: using guessed type int streamModule;
// 6BD0AC: using guessed type int streamModule;

//----- (001E55B4) --------------------------------------------------------
void *__fastcall _rwStreamModuleClose(void *instance, RwInt32 offset, RwInt32 size)
{
  RwFreeList_0 *v4; // r0

  v4 = *(RwFreeList_0 **)((char *)RwEngineInstance + streamModule);
  if ( v4 )
    RwFreeListDestroy(v4);
  --streamModule;
  return instance;
}
// 6BD0A8: using guessed type int streamModule;
// 6BD0AC: using guessed type int streamModule;

//----- (001E55EC) --------------------------------------------------------
RwStream_0 *__fastcall _rwStreamInitialize(RwStream_0 *stream, RwBool rwOwned, __int64 type, RwUInt32 a4)
{
  RwStream_0 *v4; // r4
  int *v5; // r1
  RwUInt32 v6; // r0
  __int64 v7; // d17
  void *v8; // r0
  RwInt32 v9; // r0
  int v10; // r0
  RwUInt8 *v11; // r0
  RwError_0 v13; // [sp+0h] [bp-10h] BYREF

  v4 = stream;
  if ( stream )
  {
    *(_QWORD *)&stream->type = type;
    stream->rwOwned = rwOwned;
    switch ( (int)type )
    {
      case 1:
        if ( (*((int (__fastcall **)(RwUInt32))RwEngineInstance + 59))(a4) == -1 )
          return 0;
        v4->Type.memory.position = a4;
        return v4;
      case 2:
        switch ( HIDWORD(type) )
        {
          case 3:
            v5 = &dword_1E56BC;
            break;
          case 2:
            v5 = &dword_1E56C4;
            break;
          case 1:
            v5 = &dword_1E56CC;
            break;
          default:
            goto LABEL_17;
        }
        v10 = (*((int (__fastcall **)(RwUInt32, int *))RwEngineInstance + 50))(a4, v5);
        if ( !v10 )
          return 0;
        v4->Type.memory.position = v10;
        return v4;
      case 3:
        switch ( HIDWORD(type) )
        {
          case 3:
            v6 = *(_DWORD *)(a4 + 4);
            break;
          case 2:
            v11 = 0;
            v4->Type.memory.position = 0;
            v4->Type.memory.nSize = 0;
            goto LABEL_27;
          case 1:
            v6 = 0;
            break;
          default:
LABEL_17:
            v4 = 0;
            v9 = 13;
            goto LABEL_18;
        }
        v4->Type.memory.position = v6;
        v4->Type.memory.nSize = *(_DWORD *)(a4 + 4);
        v11 = *(RwUInt8 **)a4;
LABEL_27:
        v4->Type.memory.memBlock = v11;
        return v4;
      case 4:
        v7 = *(_QWORD *)(a4 + 8);
        v8 = *(void **)(a4 + 16);
        *(_QWORD *)&v4->Type.memory.position = *(_QWORD *)a4;
        *(_QWORD *)&v4->Type.custom.sfnwrite = v7;
        v4->Type.custom.data = v8;
        return v4;
      default:
        v4 = 0;
        v9 = 14;
LABEL_18:
        v13.pluginID = 0;
        v13.errorCode = _rwerror(v9);
        RwErrorSet(&v13);
        return v4;
    }
  }
  return 0;
}
// 1E56BC: using guessed type int dword_1E56BC;
// 1E56C4: using guessed type int dword_1E56C4;
// 1E56CC: using guessed type int dword_1E56CC;

//----- (001E56D4) --------------------------------------------------------
RwUInt32 __fastcall RwStreamRead(RwStream_0 *stream, void *buffer, RwUInt32 length)
{
  RwStreamType_0 type; // r0
  size_t v6; // r4
  RwUInt32 position; // r5
  RwUInt32 v9; // r6
  int v10; // r0
  RwInt32 v11; // r0
  __int64 v12; // r0
  size_t v13; // r8
  RwError_0 v14[4]; // [sp+0h] [bp-20h] BYREF

  type = stream->type;
  v6 = length;
  if ( (unsigned int)(type - 1) < 2 )
  {
    position = stream->Type.memory.position;
    v9 = (*((int (__fastcall **)(void *, int, RwUInt32, RwUInt32))RwEngineInstance + 52))(buffer, 1, length, position);
    if ( v9 != v6 )
    {
      v10 = (*((int (__fastcall **)(RwUInt32))RwEngineInstance + 56))(position);
      v14[0].pluginID = 0;
      if ( v10 )
        v11 = _rwerror(5);
      else
        v11 = _rwerror(-2147483622);
      v14[0].errorCode = v11;
      RwErrorSet(v14);
      return v9;
    }
  }
  else if ( type == rwSTREAMMEMORY )
  {
    v12 = *(_QWORD *)&stream->Type.memory.position;
    v13 = HIDWORD(v12) - v12;
    if ( HIDWORD(v12) - (int)v12 < length )
    {
      v14[0].pluginID = 1;
      v14[0].errorCode = _rwerror(5);
      RwErrorSet(v14);
      LODWORD(v12) = stream->Type.memory.position;
      v6 = v13;
    }
    qmemcpy(buffer, &stream->Type.memory.memBlock[v12], v6);
    stream->Type.memory.position += v6;
  }
  else
  {
    if ( type == rwSTREAMCUSTOM )
      return ((int (__fastcall *)(void *, void *, RwUInt32))stream->Type.memory.nSize)(
               stream->Type.custom.data,
               buffer,
               length);
    v6 = 0;
    v14[0].pluginID = 0;
    v14[0].errorCode = _rwerror(14);
    RwErrorSet(v14);
  }
  return v6;
}

//----- (001E57B4) --------------------------------------------------------
RwStream_0 *__fastcall RwStreamWrite(RwStream_0 *stream, const void *buffer, RwUInt32 length)
{
  RwStream_0 *v3; // r4
  RwStreamType_0 type; // r0
  RwInt32 v7; // r0
  int memBlock; // r0
  int nSize; // r9
  RwUInt32 *p_nSize; // r10
  RwInt32 v11; // r0
  RwUInt32 position; // r1
  RwUInt32 v13; // r2
  RwUInt32 v14; // r9
  RwError_0 code; // [sp+4h] [bp-24h] BYREF

  v3 = stream;
  type = stream->type;
  if ( (unsigned int)(type - 1) < 2 )
  {
    if ( (*((int (__fastcall **)(const void *, int, RwUInt32, RwUInt32))RwEngineInstance + 53))(
           buffer,
           1,
           length,
           v3->Type.memory.position) == length )
      return v3;
    v3 = 0;
    v7 = -2147483620;
    goto LABEL_12;
  }
  if ( type == rwSTREAMMEMORY )
  {
    memBlock = (int)v3->Type.memory.memBlock;
    if ( memBlock )
    {
      p_nSize = &v3->Type.memory.nSize;
      nSize = v3->Type.memory.nSize;
    }
    else
    {
      nSize = 512;
      memBlock = (*((int (__fastcall **)(int))RwEngineInstance + 75))(512);
      v3->Type.memory.memBlock = (RwUInt8 *)memBlock;
      if ( !memBlock )
      {
        v3 = 0;
        code.pluginID = 0;
        v11 = _rwerror(-2147483629, 512);
        goto LABEL_13;
      }
      v3->Type.memory.nSize = 512;
      p_nSize = &v3->Type.memory.nSize;
    }
    position = v3->Type.memory.position;
    if ( nSize - position < length )
    {
      v13 = length;
      if ( length <= 0x200 )
        v13 = 512;
      v14 = nSize + v13;
      memBlock = (*((int (**)(void))RwEngineInstance + 77))();
      if ( !memBlock )
      {
        v3 = 0;
        code.pluginID = 0;
        v11 = _rwerror(-2147483629, v14 - *p_nSize);
        goto LABEL_13;
      }
      position = v3->Type.memory.position;
      v3->Type.memory.nSize = v14;
      v3->Type.memory.memBlock = (RwUInt8 *)memBlock;
    }
    qmemcpy((void *)(memBlock + position), buffer, length);
    v3->Type.memory.position += length;
    return v3;
  }
  if ( type != rwSTREAMCUSTOM )
  {
    v3 = 0;
    v7 = 14;
LABEL_12:
    code.pluginID = 0;
    v11 = _rwerror(v7);
LABEL_13:
    code.errorCode = v11;
    RwErrorSet(&code);
    return v3;
  }
  if ( !((int (__fastcall *)(void *, const void *, RwUInt32))v3->Type.memory.memBlock)(
          v3->Type.custom.data,
          buffer,
          length) )
    return 0;
  return v3;
}

//----- (001E58CC) --------------------------------------------------------
RwStream_0 *__fastcall RwStreamSkip(RwStream_0 *stream, RwUInt32 offset)
{
  RwStream_0 *v2; // r4
  RwStreamType_0 type; // r0
  RwUInt32 position; // r5
  __int64 v5; // kr00_8
  RwUInt32 v6; // r1
  RwInt32 v7; // r0
  RwError_0 v9; // [sp+0h] [bp-10h] BYREF

  v2 = stream;
  if ( !offset )
    return v2;
  type = stream->type;
  if ( (unsigned int)(v2->type - 1) < 2 )
  {
    position = v2->Type.memory.position;
    if ( !(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 57))(position) )
      return v2;
    v2 = 0;
    if ( !(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 56))(position) )
      return v2;
    goto LABEL_13;
  }
  if ( type == rwSTREAMMEMORY )
  {
    v5 = *(_QWORD *)&v2->Type.memory.position;
    v6 = offset + v5;
    if ( v6 <= HIDWORD(v5) )
    {
      v2->Type.memory.position = v6;
      return v2;
    }
    v2->Type.memory.position = HIDWORD(v5);
    v2 = 0;
LABEL_13:
    v9.pluginID = 0;
    v7 = _rwerror(5);
LABEL_15:
    v9.errorCode = v7;
    RwErrorSet(&v9);
    return v2;
  }
  if ( type != rwSTREAMCUSTOM )
  {
    v2 = 0;
    v9.pluginID = 0;
    v7 = _rwerror(14);
    goto LABEL_15;
  }
  if ( !((int (__fastcall *)(void *))v2->Type.custom.sfnskip)(v2->Type.custom.data) )
    return 0;
  return v2;
}

//----- (001E5958) --------------------------------------------------------
RwBool __fastcall RwStreamClose(RwStream_0 *stream, void *pData)
{
  _BOOL4 v3; // r5
  void (__fastcall *position)(void *); // r1
  RwError_0 v6; // [sp+0h] [bp-10h] BYREF

  v3 = 1;
  switch ( stream->type )
  {
    case rwSTREAMFILE:
      goto LABEL_11;
    case rwSTREAMFILENAME:
      v3 = (*((int (__fastcall **)(RwUInt32))RwEngineInstance + 51))(stream->Type.memory.position) == 0;
      goto LABEL_11;
    case rwSTREAMMEMORY:
      v3 = 1;
      if ( pData && stream->accessType != rwSTREAMREAD )
      {
        *(_DWORD *)pData = stream->Type.memory.memBlock;
        *((_DWORD *)pData + 1) = stream->Type.memory.position;
        v3 = 1;
      }
      goto LABEL_11;
    case rwSTREAMCUSTOM:
      position = (void (__fastcall *)(void *))stream->Type.memory.position;
      if ( position )
        position(stream->Type.custom.data);
      v3 = 1;
LABEL_11:
      if ( stream->rwOwned )
        (*((void (__fastcall **)(_DWORD, RwStream_0 *))RwEngineInstance + 80))(
          *(_DWORD *)((char *)RwEngineInstance + streamModule),
          stream);
      break;
    default:
      v3 = 0;
      v6.pluginID = 0;
      v6.errorCode = _rwerror(14, pData);
      RwErrorSet(&v6);
      break;
  }
  return v3;
}
// 6BD0A8: using guessed type int streamModule;

//----- (001E59F0) --------------------------------------------------------
RwStream_0 *__fastcall RwStreamOpen(RwStreamType_0 type, RwStreamAccessType_0 accessType, const void *pData)
{
  RwStream_0 *v6; // r4

  v6 = (RwStream_0 *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                       + streamModule));
  if ( !_rwStreamInitialize(v6, 1, __SPAIR64__(accessType, type), (RwUInt32)pData) )
  {
    (*((void (__fastcall **)(_DWORD, RwStream_0 *))RwEngineInstance + 80))(
      *(_DWORD *)((char *)RwEngineInstance + streamModule),
      v6);
    return 0;
  }
  return v6;
}
// 6BD0A8: using guessed type int streamModule;

//----- (001E5A5C) --------------------------------------------------------
RwInt32 __fastcall _rwPluginRegistryAddPluginStream(
        RwPluginRegistry_0 *reg,
        RwUInt32 pluginID,
        RwPluginDataChunkReadCallBack readCB,
        RwPluginDataChunkWriteCallBack writeCB,
        RwInt32 (*a5)(const void *, RwInt32, RwInt32))
{
  RwPluginRegEntry_0 *firstRegEntry; // r12
  RwInt32 result; // r0

  firstRegEntry = reg->firstRegEntry;
  if ( !firstRegEntry )
    return -1;
  while ( firstRegEntry->pluginID != pluginID )
  {
    firstRegEntry = firstRegEntry->nextRegEntry;
    if ( !firstRegEntry )
      return -1;
  }
  result = firstRegEntry->offset;
  firstRegEntry->readCB = readCB;
  firstRegEntry->writeCB = writeCB;
  firstRegEntry->getSizeCB = a5;
  return result;
}

//----- (001E5A9A) --------------------------------------------------------
RwInt32 __fastcall _rwPluginRegistryAddPlgnStrmlwysCB(
        RwPluginRegistry_0 *reg,
        RwUInt32 pluginID,
        RwPluginDataChunkAlwaysCallBack alwaysCB)
{
  RwPluginRegEntry_0 *firstRegEntry; // r3
  RwInt32 result; // r0

  firstRegEntry = reg->firstRegEntry;
  if ( !firstRegEntry )
    return -1;
  while ( firstRegEntry->pluginID != pluginID )
  {
    firstRegEntry = firstRegEntry->nextRegEntry;
    if ( !firstRegEntry )
      return -1;
  }
  result = firstRegEntry->offset;
  firstRegEntry->alwaysCB = alwaysCB;
  return result;
}

//----- (001E5AC0) --------------------------------------------------------
RwInt32 __fastcall _rwPluginRegistryAddPlgnStrmRightsCB(
        RwPluginRegistry_0 *reg,
        RwUInt32 pluginID,
        RwPluginDataChunkRightsCallBack rightsCB)
{
  RwPluginRegEntry_0 *firstRegEntry; // r3
  RwInt32 result; // r0

  firstRegEntry = reg->firstRegEntry;
  if ( !firstRegEntry )
    return -1;
  while ( firstRegEntry->pluginID != pluginID )
  {
    firstRegEntry = firstRegEntry->nextRegEntry;
    if ( !firstRegEntry )
      return -1;
  }
  result = firstRegEntry->offset;
  firstRegEntry->rightsCB = rightsCB;
  return result;
}

//----- (001E5AE8) --------------------------------------------------------
const RwPluginRegistry_0 *__fastcall _rwPluginRegistryReadDataChunks(
        const RwPluginRegistry_0 *reg,
        RwStream_0 *stream,
        void *object)
{
  RwPluginRegEntry_0 **p_firstRegEntry; // r5
  RwPluginRegEntry_0 *v7; // r0
  int (__fastcall *readCB)(RwStream_0 *, RwUInt32, void *, RwInt32, RwInt32); // r4
  RwPluginRegEntry_0 *v9; // r5
  int (__fastcall *alwaysCB)(void *, RwInt32, RwInt32); // r3
  RwError_0 type; // [sp+8h] [bp-30h] BYREF
  RwUInt32 offset; // [sp+10h] [bp-28h] BYREF
  RwUInt32 versionOut; // [sp+14h] [bp-24h] BYREF
  RwUInt32 lengthOut[8]; // [sp+18h] [bp-20h] BYREF

  if ( RwStreamFindChunk(stream, 3u, lengthOut, &versionOut) )
  {
    if ( versionOut - 212992 > 0x2003 )
    {
      reg = 0;
      type.pluginID = 0;
      type.errorCode = _rwerror(-2147483644);
      RwErrorSet(&type);
    }
    else
    {
      p_firstRegEntry = &reg->firstRegEntry;
      if ( lengthOut[0] )
      {
        while ( _rwStreamReadChunkHeader(stream, (RwUInt32 *)&type, &offset, 0, 0) )
        {
          v7 = *p_firstRegEntry;
          if ( !*p_firstRegEntry )
            goto LABEL_12;
          while ( v7->pluginID != type.pluginID )
          {
            v7 = v7->nextRegEntry;
            if ( !v7 )
              goto LABEL_12;
          }
          readCB = (int (__fastcall *)(RwStream_0 *, RwUInt32, void *, RwInt32, RwInt32))v7->readCB;
          if ( readCB )
          {
            if ( !readCB(stream, offset, object, v7->offset, v7->size) )
              return 0;
          }
          else
          {
LABEL_12:
            if ( !RwStreamSkip(stream, offset) )
              return 0;
          }
          lengthOut[0] += -12 - offset;
          if ( !lengthOut[0] )
            goto LABEL_14;
        }
        return 0;
      }
LABEL_14:
      v9 = *p_firstRegEntry;
      if ( v9 )
      {
        while ( 1 )
        {
          alwaysCB = v9->alwaysCB;
          if ( alwaysCB )
          {
            if ( !alwaysCB(object, v9->offset, v9->size) )
              break;
          }
          v9 = v9->nextRegEntry;
          if ( !v9 )
            return reg;
        }
        return 0;
      }
    }
  }
  else
  {
    reg = 0;
    ChunkError = 1;
  }
  return reg;
}
// 1E5AE8: using guessed type RwUInt32 lengthOut[8];

//----- (001E5BD8) --------------------------------------------------------
const RwPluginRegistry_0 *__fastcall _rwPluginRegistryInvokeRights(
        const RwPluginRegistry_0 *reg,
        RwUInt32 id,
        void *obj,
        RwUInt32 extraData)
{
  const RwPluginRegistry_0 *v4; // r5
  RwPluginRegEntry_0 *firstRegEntry; // r0
  int (__fastcall *rightsCB)(void *, RwInt32, RwInt32, RwUInt32); // lr

  v4 = reg;
  firstRegEntry = reg->firstRegEntry;
  if ( !firstRegEntry )
    return 0;
  while ( firstRegEntry->pluginID != id )
  {
    firstRegEntry = firstRegEntry->nextRegEntry;
    if ( !firstRegEntry )
      return 0;
  }
  rightsCB = firstRegEntry->rightsCB;
  if ( !rightsCB )
    return 0;
  if ( !rightsCB(obj, firstRegEntry->offset, firstRegEntry->size, extraData) )
    return 0;
  return v4;
}

//----- (001E5C12) --------------------------------------------------------
RwInt32 __fastcall _rwPluginRegistryGetSize(const RwPluginRegistry_0 *reg, const void *object)
{
  RwPluginRegEntry_0 *firstRegEntry; // r6
  RwInt32 i; // r5
  int (__fastcall *getSizeCB)(const void *, RwInt32, RwInt32); // r3
  int v6; // r0

  firstRegEntry = reg->firstRegEntry;
  for ( i = 0; firstRegEntry; firstRegEntry = firstRegEntry->nextRegEntry )
  {
    getSizeCB = firstRegEntry->getSizeCB;
    if ( getSizeCB )
    {
      v6 = getSizeCB(object, firstRegEntry->offset, firstRegEntry->size);
      if ( v6 >= 1 )
        i += v6 + 12;
    }
  }
  return i;
}

//----- (001E5C4A) --------------------------------------------------------
const RwPluginRegistry_0 *__fastcall _rwPluginRegistryWriteDataChunks(
        const RwPluginRegistry_0 *reg,
        RwStream_0 *stream,
        const void *object)
{
  const RwPluginRegistry_0 *v3; // r9
  RwPluginRegEntry_0 *firstRegEntry; // r6
  RwInt32 i; // r4
  int (__fastcall *getSizeCB)(const void *, RwInt32, RwInt32); // r3
  int v9; // r0
  RwPluginRegEntry_0 *v10; // r6
  int (__fastcall *v11)(const void *, RwInt32, RwInt32); // r3
  bool v12; // zf
  RwInt32 v13; // r4

  v3 = reg;
  firstRegEntry = reg->firstRegEntry;
  for ( i = 0; firstRegEntry; firstRegEntry = firstRegEntry->nextRegEntry )
  {
    getSizeCB = firstRegEntry->getSizeCB;
    if ( getSizeCB )
    {
      v9 = getSizeCB(object, firstRegEntry->offset, firstRegEntry->size);
      if ( v9 >= 1 )
        i += v9 + 12;
    }
  }
  if ( _rwStreamWriteVersionedChunkHeader(stream, 3, i, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
  {
    v10 = v3->firstRegEntry;
    if ( !v10 )
      return v3;
    while ( 1 )
    {
      v11 = v10->getSizeCB;
      v12 = v11 == 0;
      if ( v11 )
        v12 = v10->writeCB == 0;
      if ( !v12 )
      {
        v13 = v11(object, v10->offset, v10->size);
        if ( v13 >= 1
          && (!_rwStreamWriteVersionedChunkHeader(
                 stream,
                 v10->pluginID,
                 v13,
                 (RwUInt32)&stru_35FFC.st_value + 3,
                 0xFFFFu)
           || !v10->writeCB(stream, v13, object, v10->offset, v10->size)) )
        {
          break;
        }
      }
      v10 = v10->nextRegEntry;
      if ( !v10 )
        return v3;
    }
  }
  return 0;
}
// 35FFC: using guessed type Elf32_Sym stru_35FFC;

//----- (001E5CFA) --------------------------------------------------------
const RwPluginRegistry_0 *__fastcall _rwPluginRegistrySkipDataChunks(const RwPluginRegistry_0 *reg, RwStream_0 *stream)
{
  const RwPluginRegistry_0 *v4; // r6
  RwUInt32 offset; // [sp+8h] [bp-20h] BYREF
  RwUInt32 lengthOut[7]; // [sp+Ch] [bp-1Ch] BYREF

  v4 = 0;
  if ( RwStreamFindChunk(stream, 3u, lengthOut, 0) )
  {
    if ( lengthOut[0] )
    {
      while ( _rwStreamReadChunkHeader(stream, 0, &offset, 0, 0) && RwStreamSkip(stream, offset) )
      {
        lengthOut[0] += -12 - offset;
        if ( !lengthOut[0] )
          return reg;
      }
      return 0;
    }
    else
    {
      return reg;
    }
  }
  return v4;
}
// 1E5CFA: using guessed type RwUInt32 lengthOut[7];

//----- (001E5D5C) --------------------------------------------------------
void __fastcall RwPluginRegistrySetFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rwPluginRegListPreallocBlocks = numBlocksToPrealloc;
  _rwPluginRegFreeListBlockSize = blockSize;
}

//----- (001E5D74) --------------------------------------------------------
RwBool _rwPluginRegistryOpen()
{
  RwBool result; // r0

  toolkitRegEntries = RwFreeListCreateAndPreallocateSpace(
                        60,
                        _rwPluginRegFreeListBlockSize,
                        4,
                        _rwPluginRegListPreallocBlocks,
                        &toolkitRegEntriesSpace);
  result = 0;
  if ( toolkitRegEntries )
  {
    numRegToolkits = 0;
    return 1;
  }
  return result;
}

//----- (001E5DC4) --------------------------------------------------------
RwBool _rwPluginRegistryClose()
{
  RwPluginRegistry_0 **v0; // r0
  RwUInt32 v1; // r5
  RwPluginRegEntry_0 *firstRegEntry; // r1
  RwPluginRegistry_0 *parentRegistry; // r11
  RwPluginRegEntry_0 *nextRegEntry; // r6
  RwInt32 origSizeOfStruct; // r0

  if ( toolkitRegEntries )
  {
    RwFreeListForAllUsed(toolkitRegEntries, rwDestroyEntry, toolkitRegEntries);
    if ( *((void *(__fastcall **)(RwFreeList_0 *))RwEngineInstance + 79) != _rwFreeListAllocReal )
    {
      v0 = toolkitNonFLRegList;
      if ( numRegToolkits )
      {
        v1 = 0;
        do
        {
          firstRegEntry = v0[v1]->firstRegEntry;
          if ( firstRegEntry )
          {
            parentRegistry = firstRegEntry->parentRegistry;
            do
            {
              nextRegEntry = firstRegEntry->nextRegEntry;
              (*((void (__fastcall **)(_DWORD))RwEngineInstance + 80))(0);
              firstRegEntry = nextRegEntry;
            }
            while ( nextRegEntry );
            if ( parentRegistry && parentRegistry->firstRegEntry )
            {
              origSizeOfStruct = parentRegistry->origSizeOfStruct;
              parentRegistry->firstRegEntry = 0;
              parentRegistry->lastRegEntry = 0;
              parentRegistry->sizeOfStruct = origSizeOfStruct;
            }
          }
          v0 = toolkitNonFLRegList;
          ++v1;
        }
        while ( v1 < numRegToolkits );
      }
      if ( v0 )
      {
        (*((void (**)(void))RwEngineInstance + 76))();
        toolkitNonFLRegList = 0;
      }
    }
    RwFreeListDestroy(toolkitRegEntries);
    toolkitRegEntries = 0;
  }
  return 1;
}

//----- (001E5EC8) --------------------------------------------------------
void __fastcall rwDestroyEntry(void *object, void *freelist)
{
  _DWORD *v3; // r0

  v3 = (_DWORD *)*((_DWORD *)object + 14);
  if ( v3[4] )
  {
    *v3 = v3[1];
    *(_DWORD *)(*((_DWORD *)object + 14) + 16) = 0;
    *(_DWORD *)(*((_DWORD *)object + 14) + 20) = 0;
  }
  (*((void (__fastcall **)(void *, void *))RwEngineInstance + 80))(freelist, object);
}

//----- (001E5EF4) --------------------------------------------------------
RwBool __fastcall _rwPluginRegistrySetStaticPluginsSize(RwPluginRegistry_0 *reg, RwInt32 size)
{
  __int64 v2; // r2
  RwInt32 maxSizeOfStruct; // r3

  v2 = *(_QWORD *)&reg->sizeOfStruct;
  if ( (_DWORD)v2 != HIDWORD(v2) )
    return 0;
  maxSizeOfStruct = reg->maxSizeOfStruct;
  if ( maxSizeOfStruct < 1 || maxSizeOfStruct > size )
    reg->maxSizeOfStruct = size + v2;
  reg->staticAlloc = 1;
  return 1;
}

//----- (001E5F18) --------------------------------------------------------
RwBool __fastcall _rwPluginRegistryGetPluginOffset(const RwPluginRegistry_0 *reg, RwUInt32 pluginID)
{
  RwPluginRegEntry_0 *i; // r0

  for ( i = reg->firstRegEntry; ; i = i->nextRegEntry )
  {
    if ( !i )
      return -1;
    if ( i->pluginID == pluginID )
      break;
  }
  return i->offset;
}

//----- (001E5F34) --------------------------------------------------------
RwInt32 __fastcall _rwPluginRegistryAddPlugin(
        RwPluginRegistry_0 *reg,
        RwInt32 size,
        RwUInt32 pluginID,
        RwPluginObjectConstructor constructCB,
        void *(__fastcall *a5)(void *object, RwInt32 offsetInObject, RwInt32 sizeInObject),
        void *(__fastcall *a6)(void *dstObject, const void *srcObject, RwInt32 offsetInObject, RwInt32 sizeInObject))
{
  RwUInt32 v11; // r2
  RwPluginRegistry_0 **v12; // r9
  RwPluginRegistry_0 **v13; // r0
  RwUInt32 v14; // r1
  RwUInt32 v15; // r11
  RwUInt32 v16; // r2
  RwPluginRegistry_0 **v17; // r3
  RwPluginRegistry_0 **v18; // r6
  __int64 v19; // d16
  __int64 v20; // d17
  RwPluginRegEntry_0 *firstRegEntry; // r6
  RwInt32 maxSizeOfStruct; // r0
  RwInt32 v23; // r6
  int v24; // r0
  void *(__fastcall *v25)(void *, RwInt32, RwInt32); // r2
  void *(__fastcall *v26)(void *, const void *, RwInt32, RwInt32); // r9
  void *(__fastcall *v27)(void *, RwInt32, RwInt32); // r1
  RwPluginRegEntry_0 **p_lastRegEntry; // r4
  RwPluginRegEntry_0 *lastRegEntry; // t1
  RwError_0 code; // [sp+4h] [bp-24h] BYREF

  if ( !toolkitRegEntries )
    return -1;
  if ( _rwGetNumEngineInstances() )
  {
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483625);
    RwErrorSet(&code);
    return -1;
  }
  if ( *((void *(__fastcall **)(RwFreeList_0 *))RwEngineInstance + 79) != _rwFreeListAllocReal )
  {
    if ( numRegToolkits )
    {
      v11 = 0;
      do
      {
        if ( toolkitNonFLRegList[v11] == reg )
          break;
        ++v11;
      }
      while ( v11 < numRegToolkits );
    }
    else
    {
      v11 = 0;
    }
    if ( numRegToolkits == v11 )
    {
      v12 = (RwPluginRegistry_0 **)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(4 * numRegToolkits + 4);
      v13 = toolkitNonFLRegList;
      if ( !toolkitNonFLRegList )
      {
        v15 = 0;
LABEL_29:
        v12[v15] = reg;
        toolkitNonFLRegList = v12;
        ++numRegToolkits;
        goto LABEL_30;
      }
      v14 = numRegToolkits;
      if ( numRegToolkits )
      {
        if ( numRegToolkits >= 4 )
        {
          v15 = numRegToolkits & 0xFFFFFFFC;
          if ( (numRegToolkits & 0xFFFFFFFC) != 0 )
          {
            if ( v12 >= &toolkitNonFLRegList[numRegToolkits] || &v12[numRegToolkits] <= toolkitNonFLRegList )
            {
              v16 = numRegToolkits & 0xFFFFFFFC;
              v17 = v12;
              v18 = toolkitNonFLRegList;
              do
              {
                v19 = *(_QWORD *)v18;
                v20 = *((_QWORD *)v18 + 1);
                v18 += 4;
                v16 -= 4;
                *(_QWORD *)v17 = v19;
                *((_QWORD *)v17 + 1) = v20;
                v17 += 4;
              }
              while ( v16 );
              if ( v14 == v15 )
                goto LABEL_28;
            }
            else
            {
              v15 = 0;
            }
          }
          else
          {
            v15 = 0;
          }
        }
        else
        {
          v15 = 0;
        }
        do
        {
          v12[v15] = v13[v15];
          ++v15;
        }
        while ( v15 < v14 );
      }
      else
      {
        v15 = 0;
      }
LABEL_28:
      (*((void (**)(void))RwEngineInstance + 76))();
      toolkitNonFLRegList = 0;
      goto LABEL_29;
    }
  }
LABEL_30:
  firstRegEntry = reg->firstRegEntry;
  if ( firstRegEntry )
  {
    while ( firstRegEntry->pluginID != pluginID )
    {
      firstRegEntry = firstRegEntry->nextRegEntry;
      if ( !firstRegEntry )
        goto LABEL_33;
    }
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483625);
    RwErrorSet(&code);
    return firstRegEntry->offset;
  }
  else
  {
LABEL_33:
    maxSizeOfStruct = reg->maxSizeOfStruct;
    v23 = reg->sizeOfStruct + ((size + 3) & 0xFFFFFFFC);
    if ( maxSizeOfStruct && v23 > maxSizeOfStruct )
      return -1;
    v24 = (*((int (__fastcall **)(RwFreeList_0 *))RwEngineInstance + 79))(toolkitRegEntries);
    if ( !v24 )
      return -1;
    v25 = PluginDefaultDestructor;
    *(_DWORD *)v24 = reg->sizeOfStruct;
    v26 = PluginDefaultCopy;
    reg->sizeOfStruct = v23;
    *(_QWORD *)(v24 + 12) = 0LL;
    *(_QWORD *)(v24 + 20) = 0LL;
    v27 = PluginDefaultConstructor;
    *(_DWORD *)(v24 + 4) = size;
    *(_DWORD *)(v24 + 8) = pluginID;
    if ( a5 )
      v25 = a5;
    if ( a6 )
      v26 = a6;
    if ( constructCB )
      v27 = constructCB;
    *(_DWORD *)(v24 + 28) = 0;
    *(_DWORD *)(v24 + 32) = v27;
    *(_DWORD *)(v24 + 36) = v25;
    *(_DWORD *)(v24 + 40) = v26;
    *(_DWORD *)(v24 + 44) = 0;
    *(_DWORD *)(v24 + 48) = 0;
    *(_DWORD *)(v24 + 52) = 0;
    *(_DWORD *)(v24 + 56) = reg;
    if ( reg->firstRegEntry )
    {
      lastRegEntry = reg->lastRegEntry;
      p_lastRegEntry = &reg->lastRegEntry;
      lastRegEntry->nextRegEntry = (RwPluginRegEntry *)v24;
      *(_DWORD *)(v24 + 52) = *p_lastRegEntry;
    }
    else
    {
      reg->firstRegEntry = (RwPluginRegEntry_0 *)v24;
      p_lastRegEntry = &reg->lastRegEntry;
    }
    *p_lastRegEntry = (RwPluginRegEntry_0 *)v24;
    return *(_DWORD *)v24;
  }
}

//----- (001E617A) --------------------------------------------------------
const RwPluginRegistry_0 *__fastcall _rwPluginRegistryInitObject(const RwPluginRegistry_0 *reg, void *object)
{
  const RwPluginRegistry_0 *v2; // r5
  RwPluginRegEntry_0 *firstRegEntry; // r6
  RwPluginRegEntry *i; // r5

  v2 = reg;
  firstRegEntry = reg->firstRegEntry;
  if ( firstRegEntry )
  {
    while ( firstRegEntry->constructCB(object, firstRegEntry->offset, firstRegEntry->size) )
    {
      firstRegEntry = firstRegEntry->nextRegEntry;
      if ( !firstRegEntry )
        return v2;
    }
    for ( i = firstRegEntry->prevRegEntry; i; i = i->prevRegEntry )
      i->destructCB(object, i->offset, i->size);
    return 0;
  }
  return v2;
}

//----- (001E61BC) --------------------------------------------------------
const RwPluginRegistry_0 *__fastcall _rwPluginRegistryDeInitObject(const RwPluginRegistry_0 *reg, void *object)
{
  RwPluginRegEntry_0 *i; // r6

  for ( i = reg->lastRegEntry; i; i = i->prevRegEntry )
    i->destructCB(object, i->offset, i->size);
  return reg;
}

//----- (001E61E4) --------------------------------------------------------
const RwPluginRegistry_0 *__fastcall _rwPluginRegistryCopyObject(
        const RwPluginRegistry_0 *reg,
        void *dstObject,
        const void *srcObject)
{
  RwPluginRegEntry_0 *i; // r5

  for ( i = reg->firstRegEntry; i; i = i->nextRegEntry )
    i->copyCB(dstObject, srcObject, i->offset, i->size);
  return reg;
}

//----- (001E6214) --------------------------------------------------------
RwBool __fastcall _rwVectorSetMultFn(
        rwVectorMultFn multPoint,
        rwVectorsMultFn multPoints,
        rwVectorMultFn multVector,
        rwVectorsMultFn multVectors)
{
  RwV3d_0 *(__fastcall *v4)(RwV3d_0 *, const RwV3d_0 *, const RwMatrix *); // r5
  int v5; // lr
  RwV3d_0 *(__fastcall *v6)(RwV3d_0 *, const RwV3d_0 *, RwInt32, const RwMatrix *); // r4
  RwV3d_0 *(__fastcall *v7)(RwV3d_0 *, const RwV3d_0 *, const RwMatrix *); // r1
  RwV3d_0 *(__fastcall *v8)(RwV3d_0 *, const RwV3d_0 *, RwInt32, const RwMatrix *); // r1

  v4 = VectorMultPoint;
  v5 = vectorModule;
  if ( multPoint )
    v4 = multPoint;
  *(_DWORD *)((char *)RwEngineInstance + vectorModule + 8) = v4;
  v6 = VectorMultPoints;
  if ( multPoints )
    v6 = multPoints;
  *(_DWORD *)((char *)RwEngineInstance + v5 + 12) = v6;
  v7 = VectorMultVector;
  if ( multVector )
    v7 = multVector;
  *(_DWORD *)((char *)RwEngineInstance + v5 + 16) = v7;
  v8 = VectorMultVectors;
  if ( multVectors )
    v8 = multVectors;
  *(_DWORD *)((char *)RwEngineInstance + v5 + 20) = v8;
  return 1;
}
// 6BD0E4: using guessed type int vectorModule;

//----- (001E6290) --------------------------------------------------------
RwV3d_0 *__fastcall VectorMultPoint(RwV3d_0 *pointOut, const RwV3d_0 *pointIn, const RwMatrix *matrix)
{
  float y; // s10
  float z; // s12
  float v5; // s14
  float v6; // s2
  float v7; // s6
  float v8; // s4

  y = pointIn->y;
  z = pointIn->z;
  v5 = z * matrix->at.y;
  v6 = (float)(pointIn->x * matrix->right.y) + (float)(y * matrix->up.y);
  v7 = z * matrix->at.z;
  v8 = (float)(pointIn->x * matrix->right.z) + (float)(y * matrix->up.z);
  pointOut->x = (float)((float)((float)(pointIn->x * matrix->right.x) + (float)(y * matrix->up.x))
                      + (float)(z * matrix->at.x))
              + matrix->pos.x;
  pointOut->y = (float)(v6 + v5) + matrix->pos.y;
  pointOut->z = (float)(v8 + v7) + matrix->pos.z;
  return pointOut;
}

//----- (001E6322) --------------------------------------------------------
RwV3d_0 *__fastcall VectorMultPoints(
        RwV3d_0 *pointsOut,
        const RwV3d_0 *pointsIn,
        RwInt32 numPoints,
        const RwMatrix *matrix)
{
  int v4; // r12
  RwV3d_0 *v5; // r2
  float x; // s8
  float y; // s10
  float v8; // s0
  float z; // s12
  float v10; // s14
  float v11; // s2
  float v12; // s6
  float v13; // s4

  if ( numPoints >= 1 )
  {
    v4 = numPoints + 1;
    v5 = pointsOut;
    do
    {
      --v4;
      x = pointsIn->x;
      y = pointsIn->y;
      v8 = pointsIn->x * matrix->right.x;
      z = pointsIn->z;
      ++pointsIn;
      v10 = z * matrix->at.y;
      v11 = (float)(x * matrix->right.y) + (float)(y * matrix->up.y);
      v12 = z * matrix->at.z;
      v13 = (float)(x * matrix->right.z) + (float)(y * matrix->up.z);
      v5->x = (float)((float)(v8 + (float)(y * matrix->up.x)) + (float)(z * matrix->at.x)) + matrix->pos.x;
      v5->y = (float)(v11 + v10) + matrix->pos.y;
      v5->z = (float)(v13 + v12) + matrix->pos.z;
      ++v5;
    }
    while ( v4 > 1 );
  }
  return pointsOut;
}

//----- (001E63D2) --------------------------------------------------------
RwV3d_0 *__fastcall VectorMultVector(RwV3d_0 *pointOut, const RwV3d_0 *pointIn, const RwMatrix *matrix)
{
  float y; // s10
  float z; // s12
  float v5; // s4
  float v6; // s14
  float v7; // s2

  y = pointIn->y;
  z = pointIn->z;
  v5 = pointIn->x * matrix->right.z;
  v6 = matrix->up.z;
  v7 = (float)(pointIn->x * matrix->right.y) + (float)(y * matrix->up.y);
  pointOut->x = (float)((float)(pointIn->x * matrix->right.x) + (float)(y * matrix->up.x)) + (float)(z * matrix->at.x);
  pointOut->y = v7 + (float)(z * matrix->at.y);
  pointOut->z = (float)(v5 + (float)(y * v6)) + (float)(z * matrix->at.z);
  return pointOut;
}

//----- (001E644C) --------------------------------------------------------
RwV3d_0 *__fastcall VectorMultVectors(
        RwV3d_0 *pointsOut,
        const RwV3d_0 *pointsIn,
        RwInt32 numPoints,
        const RwMatrix *matrix)
{
  int v4; // r12
  RwV3d_0 *v5; // r2
  float x; // s8
  float y; // s10
  float v8; // s0
  float z; // s12
  float v10; // s4
  float v11; // s14
  float v12; // s2

  if ( numPoints >= 1 )
  {
    v4 = numPoints + 1;
    v5 = pointsOut;
    do
    {
      --v4;
      x = pointsIn->x;
      y = pointsIn->y;
      v8 = pointsIn->x * matrix->right.x;
      z = pointsIn->z;
      ++pointsIn;
      v10 = x * matrix->right.z;
      v11 = matrix->up.z;
      v12 = (float)(x * matrix->right.y) + (float)(y * matrix->up.y);
      v5->x = (float)(v8 + (float)(y * matrix->up.x)) + (float)(z * matrix->at.x);
      v5->y = v12 + (float)(z * matrix->at.y);
      v5->z = (float)(v10 + (float)(y * v11)) + (float)(z * matrix->at.z);
      ++v5;
    }
    while ( v4 > 1 );
  }
  return pointsOut;
}

//----- (001E64E4) --------------------------------------------------------
RwReal __fastcall _rwV3dNormalize(RwV3d_0 *out, const RwV3d_0 *in)
{
  float x; // s0
  float v3; // s2
  float v5; // [sp+0h] [bp-4h]

  x = in->x;
  v5 = (float)((float)(x * x) + (float)(in->y * in->y)) + (float)(in->z * in->z);
  if ( v5 == 0.0 )
    v3 = 0.0;
  else
    LODWORD(v3) = (~((unsigned int)(LODWORD(v5) + 2048) >> 1) & 0x3FC00000)
                + *(_DWORD *)(*(_DWORD *)((char *)RwEngineInstance + vectorModule + 4)
                            + 4 * (((unsigned int)(LODWORD(v5) + 2048) >> 12) & 0xFFF));
  out->x = v3 * x;
  out->y = v3 * in->y;
  out->z = v3 * in->z;
  return v3;
}
// 6BD0E4: using guessed type int vectorModule;

//----- (001E6580) --------------------------------------------------------
RwReal __fastcall _rwInvSqrt(const RwReal num)
{
  float v1; // s0

  if ( num == 0.0 )
    return 0.0;
  LODWORD(v1) = *(_DWORD *)(*(_DWORD *)((char *)RwEngineInstance + vectorModule + 4)
                          + 4 * (((unsigned int)(LODWORD(num) + 2048) >> 12) & 0xFFF))
              + (~((unsigned int)(LODWORD(num) + 2048) >> 1) & 0x3FC00000);
  return v1;
}
// 6BD0E4: using guessed type int vectorModule;

//----- (001E65D8) --------------------------------------------------------
RwReal __fastcall RwV3dNormalize(RwV3d_0 *out, const RwV3d_0 *in)
{
  float x; // s0
  float v3; // s4
  float v4; // s2
  float v5; // s16
  RwError_0 v7; // [sp+0h] [bp-18h] BYREF

  x = in->x;
  v3 = (float)((float)(x * x) + (float)(in->y * in->y)) + (float)(in->z * in->z);
  v4 = 0.0;
  v5 = 0.0;
  *(float *)&v7.pluginID = v3;
  if ( v3 != 0.0 )
    LODWORD(v5) = (((unsigned int)(v7.pluginID + 2048) >> 1) & 0x3FC00000)
                + *(_DWORD *)(*(_DWORD *)((char *)RwEngineInstance + vectorModule)
                            + 4 * (((unsigned int)(v7.pluginID + 2048) >> 12) & 0xFFF));
  *(float *)&v7.pluginID = v3;
  if ( v3 != 0.0 )
  {
    v7.pluginID = (~((unsigned int)(v7.pluginID + 2048) >> 1) & 0x3FC00000)
                + *(_DWORD *)(*(_DWORD *)((char *)RwEngineInstance + vectorModule + 4)
                            + 4 * (((unsigned int)(v7.pluginID + 2048) >> 12) & 0xFFF));
    v4 = *(float *)&v7.pluginID;
  }
  out->x = v4 * x;
  out->y = v4 * in->y;
  out->z = v4 * in->z;
  if ( v5 <= 0.0 )
  {
    v7.pluginID = 0;
    v7.errorCode = _rwerror(25);
    RwErrorSet(&v7);
  }
  return v5;
}
// 6BD0E4: using guessed type int vectorModule;

//----- (001E66E0) --------------------------------------------------------
RwReal __fastcall _rwSqrt(const RwReal num)
{
  float v1; // s0

  if ( num == 0.0 )
    return 0.0;
  LODWORD(v1) = *(_DWORD *)(*(_DWORD *)((char *)RwEngineInstance + vectorModule)
                          + 4 * (((unsigned int)(LODWORD(num) + 2048) >> 12) & 0xFFF))
              + (((unsigned int)(LODWORD(num) + 2048) >> 1) & 0x3FC00000);
  return v1;
}
// 6BD0E4: using guessed type int vectorModule;

//----- (001E6738) --------------------------------------------------------
RwReal __fastcall RwV3dLength(const RwV3d_0 *in)
{
  float v1; // s0
  float v3; // [sp+0h] [bp-4h]

  v3 = (float)((float)(in->x * in->x) + (float)(in->y * in->y)) + (float)(in->z * in->z);
  if ( v3 == 0.0 )
    return 0.0;
  LODWORD(v1) = *(_DWORD *)(*(_DWORD *)((char *)RwEngineInstance + vectorModule)
                          + 4 * (((unsigned int)(LODWORD(v3) + 2048) >> 12) & 0xFFF))
              + (((unsigned int)(LODWORD(v3) + 2048) >> 1) & 0x3FC00000);
  return v1;
}
// 6BD0E4: using guessed type int vectorModule;

//----- (001E67B0) --------------------------------------------------------
RwReal __fastcall RwV2dLength(const RwV2d_0 *in)
{
  float v1; // s0
  float v3; // [sp+0h] [bp-4h]

  v3 = (float)(in->x * in->x) + (float)(in->y * in->y);
  if ( v3 == 0.0 )
    return 0.0;
  LODWORD(v1) = *(_DWORD *)(*(_DWORD *)((char *)RwEngineInstance + vectorModule)
                          + 4 * (((unsigned int)(LODWORD(v3) + 2048) >> 12) & 0xFFF))
              + (((unsigned int)(LODWORD(v3) + 2048) >> 1) & 0x3FC00000);
  return v1;
}
// 6BD0E4: using guessed type int vectorModule;

//----- (001E681C) --------------------------------------------------------
RwReal __fastcall RwV2dNormalize(RwV2d_0 *out, const RwV2d_0 *in)
{
  float x; // s0
  float v3; // s4
  float v4; // s2
  float v5; // s16
  RwError_0 v7; // [sp+0h] [bp-18h] BYREF

  x = in->x;
  v3 = (float)(x * x) + (float)(in->y * in->y);
  v4 = 0.0;
  v5 = 0.0;
  *(float *)&v7.pluginID = v3;
  if ( v3 != 0.0 )
    LODWORD(v5) = (((unsigned int)(v7.pluginID + 2048) >> 1) & 0x3FC00000)
                + *(_DWORD *)(*(_DWORD *)((char *)RwEngineInstance + vectorModule)
                            + 4 * (((unsigned int)(v7.pluginID + 2048) >> 12) & 0xFFF));
  *(float *)&v7.pluginID = v3;
  if ( v3 != 0.0 )
  {
    v7.pluginID = (~((unsigned int)(v7.pluginID + 2048) >> 1) & 0x3FC00000)
                + *(_DWORD *)(*(_DWORD *)((char *)RwEngineInstance + vectorModule + 4)
                            + 4 * (((unsigned int)(v7.pluginID + 2048) >> 12) & 0xFFF));
    v4 = *(float *)&v7.pluginID;
  }
  out->x = v4 * x;
  out->y = v4 * in->y;
  if ( v5 <= 0.0 )
  {
    v7.pluginID = 0;
    v7.errorCode = _rwerror(25);
    RwErrorSet(&v7);
  }
  return v5;
}
// 6BD0E4: using guessed type int vectorModule;

//----- (001E690C) --------------------------------------------------------
RwV3d_0 *__fastcall RwV3dTransformPoint(RwV3d_0 *pointOut, const RwV3d_0 *pointIn, const RwMatrix *matrix)
{
  (*(void (__fastcall **)(RwV3d_0 *, const RwV3d_0 *, const RwMatrix *))((char *)RwEngineInstance + vectorModule + 8))(
    pointOut,
    pointIn,
    matrix);
  return pointOut;
}
// 6BD0E4: using guessed type int vectorModule;

//----- (001E6934) --------------------------------------------------------
RwV3d_0 *__fastcall RwV3dTransformPoints(
        RwV3d_0 *pointsOut,
        const RwV3d_0 *pointsIn,
        RwInt32 numPoints,
        const RwMatrix *matrix)
{
  (*(void (__fastcall **)(RwV3d_0 *, const RwV3d_0 *, RwInt32, const RwMatrix *))((char *)RwEngineInstance
                                                                                + vectorModule
                                                                                + 12))(
    pointsOut,
    pointsIn,
    numPoints,
    matrix);
  return pointsOut;
}
// 6BD0E4: using guessed type int vectorModule;

//----- (001E6964) --------------------------------------------------------
RwV3d_0 *__fastcall RwV3dTransformVector(RwV3d_0 *vectorOut, const RwV3d_0 *vectorIn, const RwMatrix *matrix)
{
  (*(void (__fastcall **)(RwV3d_0 *, const RwV3d_0 *, const RwMatrix *))((char *)RwEngineInstance + vectorModule + 16))(
    vectorOut,
    vectorIn,
    matrix);
  return vectorOut;
}
// 6BD0E4: using guessed type int vectorModule;

//----- (001E698C) --------------------------------------------------------
RwV3d_0 *__fastcall RwV3dTransformVectors(
        RwV3d_0 *vectorsOut,
        const RwV3d_0 *vectorsIn,
        RwInt32 numPoints,
        const RwMatrix *matrix)
{
  (*(void (__fastcall **)(RwV3d_0 *, const RwV3d_0 *, RwInt32, const RwMatrix *))((char *)RwEngineInstance
                                                                                + vectorModule
                                                                                + 20))(
    vectorsOut,
    vectorsIn,
    numPoints,
    matrix);
  return vectorsOut;
}
// 6BD0E4: using guessed type int vectorModule;

//----- (001E69BC) --------------------------------------------------------
void *__fastcall _rwVectorClose(void *instance, RwInt32 offset, RwInt32 size)
{
  int v4; // r2
  void (**v5)(void); // r1

  v4 = vectorModule;
  v5 = (void (**)(void))RwEngineInstance;
  if ( *(_DWORD *)((char *)RwEngineInstance + vectorModule + 4) )
  {
    (*((void (**)(void))RwEngineInstance + 76))();
    v4 = vectorModule;
    *(_DWORD *)((char *)RwEngineInstance + vectorModule + 4) = 0;
    v5 = (void (**)(void))RwEngineInstance;
  }
  if ( *(void (**)(void))((char *)v5 + v4) )
  {
    v5[76]();
    *(_DWORD *)((char *)RwEngineInstance + vectorModule) = 0;
  }
  --vectorModule;
  return instance;
}
// 6BD0E4: using guessed type int vectorModule;
// 6BD0E8: using guessed type int vectorModule;

//----- (001E6A38) --------------------------------------------------------
void *__fastcall _rwVectorOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  int v4; // r0
  float v5; // s0
  int v6; // r1
  int v7; // r1
  int v8; // r0
  int v9; // r1
  float v10; // s2
  int i; // r1
  RwError_0 v13; // [sp+0h] [bp-18h] BYREF
  int v14; // [sp+8h] [bp-10h]
  int v15; // [sp+Ch] [bp-Ch]

  vectorModule = offset;
  *(_DWORD *)((char *)RwEngineInstance + offset + 8) = VectorMultPoint;
  *(_DWORD *)((char *)RwEngineInstance + offset + 12) = VectorMultPoints;
  *(_DWORD *)((char *)RwEngineInstance + offset + 16) = VectorMultVector;
  *(_DWORD *)((char *)RwEngineInstance + offset + 20) = VectorMultVectors;
  v4 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(0x4000);
  if ( !v4 )
    goto LABEL_12;
  v5 = 1.0;
  v15 = 1065353216;
  v6 = 2048;
  do
  {
    *(_DWORD *)(v4 + 4 * v6++) = COERCE_INT(sqrtf(v5)) - 532676608;
    v15 += 4096;
    v5 = *(float *)&v15;
  }
  while ( v6 != 4096 );
  v7 = 0;
  do
  {
    v14 = COERCE_INT(sqrtf(v5)) - 0x20000000;
    *(_DWORD *)(v4 + 4 * v7++) = v14;
    v15 += 4096;
    v5 = *(float *)&v15;
  }
  while ( v7 != 2048 );
  *(_DWORD *)((char *)RwEngineInstance + vectorModule) = v4;
  v8 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(0x4000);
  if ( v8 )
  {
    v15 = 1065353216;
    v9 = 2048;
    v10 = 1.0;
    do
    {
      *(_DWORD *)(v8 + 4 * v9++) = COERCE_INT(1.0 / sqrtf(v10)) - 0x20000000;
      v15 += 4096;
      v10 = *(float *)&v15;
    }
    while ( v9 != 4096 );
    for ( i = 0; i != 2048; ++i )
    {
      *(_DWORD *)(v8 + 4 * i) = COERCE_INT(1.0 / sqrtf(v10)) - 532676608;
      v15 += 4096;
      v10 = *(float *)&v15;
    }
    *(_DWORD *)((char *)RwEngineInstance + vectorModule + 4) = v8;
    ++vectorModule;
  }
  else
  {
LABEL_12:
    instance = 0;
    v13.pluginID = 0;
    v13.errorCode = _rwerror(-2147483629, 0x4000);
    RwErrorSet(&v13);
  }
  return instance;
}
// 6BD0E4: using guessed type int vectorModule;
// 6BD0E8: using guessed type int vectorModule;

//----- (001E6BEC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
RwBool __fastcall _rwResHeapInit(void *resHeap, RwUInt32 size)
{
  _QWORD *v2; // r2
  int v3; // r1
  signed int v4; // r3
  int v5; // r1
  int v6; // r1
  RwBool v7; // r1

  v2 = (_QWORD *)(((unsigned int)resHeap + 39) & 0xFFFFFFE0);
  v4 = (((unsigned int)resHeap + v3) & 0xFFFFFFE0) - (_DWORD)v2 - 32;
  v5 = 0;
  if ( v4 >= 32 )
  {
    *v2 = *(_QWORD *)&resHeap;
    *(_DWORD *)&byte_8[((unsigned int)resHeap + 39) & 0xFFFFFFE0] = 0;
    *(_DWORD *)&byte_9[(((unsigned int)resHeap + 39) & 0xFFFFFFE0) + 3] = v4;
    *(_DWORD *)((char *)&word_10 + (((unsigned int)resHeap + 39) & 0xFFFFFFE0)) = 0;
    v6 = 1;
    *(_DWORD *)resHeap = v2;
    *((_DWORD *)resHeap + 1) = v2;
  }
  return v7;
}
// 1E6BEC: variables would overlap: r0.4 and r0.8
// 10: using guessed type __int16 word_10;

//----- (001E6C1A) --------------------------------------------------------
RwBool __fastcall _rwResHeapClose(void *resHeap)
{
  return 1;
}

//----- (001E6C1E) --------------------------------------------------------
void __fastcall _rwResHeapFree(void *memory)
{
  char *v1; // r2
  int v2; // lr
  __int64 v3; // kr00_8
  unsigned int v4; // r1
  int v5; // r0

  v1 = (char *)memory - 32;
  v2 = *((_DWORD *)memory - 8);
  v3 = *(_QWORD *)((char *)memory - 28);
  *((_DWORD *)memory - 4) = 0;
  v4 = *(_DWORD *)(v2 + 4);
  if ( !v4 )
  {
    *(_DWORD *)(v2 + 4) = v1;
    if ( !HIDWORD(v3) )
      goto LABEL_11;
    goto LABEL_7;
  }
  if ( v4 > (unsigned int)v1 )
    *(_DWORD *)(v2 + 4) = v1;
  if ( HIDWORD(v3) )
  {
LABEL_7:
    if ( !(*(unsigned __int8 *)(HIDWORD(v3) + 16) << 31) )
    {
      *(_DWORD *)(HIDWORD(v3) + 4) = v3;
      if ( (_DWORD)v3 )
        *(_DWORD *)(v3 + 8) = HIDWORD(v3);
      v1 = (char *)HIDWORD(v3);
      *(_DWORD *)(HIDWORD(v3) + 12) += *((_DWORD *)memory - 5) + 32;
    }
  }
LABEL_11:
  if ( (_DWORD)v3 && !(*(unsigned __int8 *)(v3 + 16) << 31) )
  {
    *((_DWORD *)v1 + 1) = *(_DWORD *)(v3 + 4);
    v5 = *(_DWORD *)(v3 + 4);
    if ( v5 )
      *(_DWORD *)(v5 + 8) = v1;
    *((_DWORD *)v1 + 3) += *(_DWORD *)(v3 + 12) + 32;
  }
}

//----- (001E6C9A) --------------------------------------------------------
void *__fastcall _rwResHeapAlloc(void *resHeap, RwUInt32 size)
{
  _DWORD *v2; // r12
  _DWORD *v3; // r3
  RwUInt32 v4; // r5
  int v5; // r1
  RwUInt32 v6; // r2
  int v7; // lr
  _DWORD *v8; // r1
  int v9; // r12
  int v10; // r4
  int v11; // r2
  _DWORD *v13; // r1
  bool v14; // zf

  v2 = (_DWORD *)*((_DWORD *)resHeap + 1);
  if ( !v2 )
    return 0;
  v3 = 0;
  v4 = (size + 31) & 0xFFFFFFE0;
  v5 = *((_DWORD *)resHeap + 1);
  do
  {
    if ( !(*(unsigned __int8 *)(v5 + 16) << 31) )
    {
      v6 = *(_DWORD *)(v5 + 12);
      if ( v6 >= v4 )
      {
        if ( v3 )
        {
          if ( v6 < v3[3] )
            v3 = (_DWORD *)v5;
        }
        else
        {
          v3 = (_DWORD *)v5;
        }
      }
    }
    v5 = *(_DWORD *)(v5 + 4);
  }
  while ( v5 );
  if ( !v3 )
    return 0;
  if ( v3[3] > v4 + 64 )
  {
    v7 = v3[1];
    v8 = (_DWORD *)((char *)v3 + v4 + 32);
    if ( !v7 || *(unsigned __int8 *)(v7 + 16) << 31 )
    {
      v10 = -32;
      *(_DWORD *)((char *)v3 + v4 + 36) = v7;
      v9 = (int)v3 + v4 + 36;
      v11 = v3[3];
    }
    else
    {
      *(_DWORD *)((char *)v3 + v4 + 36) = *(_DWORD *)(v7 + 4);
      v9 = (int)v3 + v4 + 36;
      v10 = v3[3];
      v11 = *(_DWORD *)(v3[1] + 12);
    }
    *(_DWORD *)((char *)v3 + v4 + 44) = v10 - v4 + v11;
    v3[1] = v8;
    *(_DWORD *)((char *)v3 + v4 + 40) = v3;
    *(_DWORD *)((char *)v3 + v4 + 48) = 0;
    if ( *(_DWORD *)v9 )
      *(_DWORD *)(*(_DWORD *)v9 + 8) = v8;
    v3[3] = v4;
    *v8 = *v3;
    v2 = (_DWORD *)*((_DWORD *)resHeap + 1);
  }
  if ( v3 == v2 )
  {
    v13 = v3;
    do
    {
      v13 = (_DWORD *)v13[1];
      *((_DWORD *)resHeap + 1) = v13;
      v14 = v13 == 0;
      if ( v13 )
        v14 = *((unsigned __int8 *)v13 + 16) << 31 == 0;
    }
    while ( !v14 );
  }
  v3[4] = 1;
  return v3 + 8;
}

//----- (001E6D5C) --------------------------------------------------------
void *__fastcall _rwResHeapCalloc(void *resHeap, RwUInt32 num, RwUInt32 size)
{
  size_t v3; // r4
  void *v4; // r0
  void *v5; // r5

  v3 = size * num;
  v4 = _rwResHeapAlloc(resHeap, size * num);
  v5 = v4;
  if ( v4 )
    memset(v4, 0, v3);
  return v5;
}

//----- (001E6D7C) --------------------------------------------------------
void *__fastcall _rwResHeapRealloc(void *memory, RwUInt32 size)
{
  char *v2; // r9
  unsigned int v3; // r0
  RwUInt32 v4; // r1
  char *v5; // r8
  int v6; // r2
  unsigned int v7; // r5
  unsigned int v8; // r0
  char *v9; // r0
  unsigned int v10; // r1
  unsigned int v11; // r12
  int v12; // lr
  unsigned int v13; // r1
  char *v14; // r1
  char *v15; // r2
  unsigned int v16; // r3
  int v17; // t1
  __int64 v18; // kr00_8
  char *v19; // r2
  unsigned int v20; // r6
  __int64 v21; // kr08_8
  char *v22; // r2
  char *v23; // r3
  int v24; // r5
  int v25; // r6
  _DWORD *v26; // r3
  char *v27; // r6
  int v28; // r0
  int v29; // r3
  int v30; // r2
  unsigned int v31; // r1
  unsigned int v32; // r2
  bool v33; // zf
  int v34; // r1
  int v35; // r2
  int v37; // r5
  char *v38; // r6
  char *v39; // r4
  __int64 v40; // d16
  __int64 v41; // d17

  v2 = (char *)memory;
  v3 = *((_DWORD *)memory - 5);
  v4 = (size + 31) & 0xFFFFFFE0;
  v5 = v2 - 32;
  if ( v4 <= v3 )
  {
    if ( v3 > v4 + 64 )
    {
      v21 = *((_QWORD *)v2 - 4);
      v22 = &v2[v4];
      if ( !HIDWORD(v21) || *(unsigned __int8 *)(HIDWORD(v21) + 16) << 31 )
      {
        v24 = -32;
        *(_DWORD *)&v5[v4 + 36] = HIDWORD(v21);
        v23 = &v5[v4 + 36];
        v25 = *((_DWORD *)v2 - 5);
      }
      else
      {
        *(_DWORD *)&v5[v4 + 36] = *(_DWORD *)(HIDWORD(v21) + 4);
        v23 = &v5[v4 + 36];
        v24 = *((_DWORD *)v2 - 5);
        v25 = *(_DWORD *)(*((_DWORD *)v2 - 7) + 12);
      }
      *(_DWORD *)&v5[v4 + 44] = v25 + v24 - v4;
      *((_DWORD *)v2 - 7) = v22;
      *(_DWORD *)&v5[v4 + 40] = v5;
      *(_DWORD *)&v5[v4 + 48] = 0;
      v29 = *(_DWORD *)v23;
      if ( v29 )
        *(_DWORD *)(v29 + 8) = v22;
      v30 = *((_DWORD *)v2 - 8);
      *((_DWORD *)v2 - 5) = v4;
      *(_DWORD *)&v2[v4] = v30;
      v31 = *(_DWORD *)(v21 + 4);
      if ( v31 )
      {
        v32 = *((_DWORD *)v2 - 7);
        if ( v32 < v31 )
          *(_DWORD *)(v21 + 4) = v32;
      }
      else
      {
        *(_DWORD *)(v21 + 4) = *((_DWORD *)v2 - 7);
      }
    }
  }
  else
  {
    v6 = *((_DWORD *)v2 - 7);
    v7 = v4 - v3;
    if ( v6 )
    {
      if ( *(unsigned __int8 *)(v6 + 16) << 31 )
        v8 = 0;
      else
        v8 = *(_DWORD *)(v6 + 12) + 32;
      if ( v8 < v7 )
      {
LABEL_7:
        v9 = (char *)_rwResHeapAlloc(*(void **)v5, v4);
        if ( !v9 )
          return 0;
        v10 = *((_DWORD *)v2 - 5);
        if ( v10 >> 2 )
        {
          v11 = v10 >> 2;
          if ( v10 < 0x10
            || (v12 = v11 & 0x3FFFFFFC, (v11 & 0x3FFFFFFC) == 0)
            || (v13 = v10 & 0xFFFFFFFC, v9 < &v2[v13]) && &v9[v13] > v2 )
          {
            v14 = v9;
            v15 = v2;
            v16 = v11;
            do
            {
LABEL_14:
              v17 = *(_DWORD *)v15;
              v15 += 4;
              --v16;
              *(_DWORD *)v14 = v17;
              v14 += 4;
            }
            while ( v16 );
            goto LABEL_15;
          }
          v16 = v11 - v12;
          v15 = &v2[4 * v12];
          v14 = &v9[4 * v12];
          v37 = v11 & 0x3FFFFFFC;
          v38 = v9;
          v39 = v2;
          do
          {
            v40 = *(_QWORD *)v39;
            v41 = *((_QWORD *)v39 + 1);
            v39 += 16;
            v37 -= 4;
            *(_QWORD *)v38 = v40;
            *((_QWORD *)v38 + 1) = v41;
            v38 += 16;
          }
          while ( v37 );
          if ( v11 != v12 )
            goto LABEL_14;
        }
LABEL_15:
        v18 = *((_QWORD *)v2 - 4);
        v19 = (char *)*((_DWORD *)v2 - 6);
        *((_DWORD *)v2 - 4) = 0;
        v20 = *(_DWORD *)(v18 + 4);
        if ( v20 )
        {
          if ( v20 > (unsigned int)v5 )
            *(_DWORD *)(v18 + 4) = v5;
          if ( !v19 )
            goto LABEL_54;
        }
        else
        {
          *(_DWORD *)(v18 + 4) = v5;
          if ( !v19 )
          {
LABEL_54:
            if ( HIDWORD(v18) && !(*(unsigned __int8 *)(HIDWORD(v18) + 16) << 31) )
            {
              *((_DWORD *)v5 + 1) = *(_DWORD *)(HIDWORD(v18) + 4);
              v35 = *(_DWORD *)(HIDWORD(v18) + 4);
              if ( v35 )
                *(_DWORD *)(v35 + 8) = v5;
              *((_DWORD *)v5 + 3) += *(_DWORD *)(HIDWORD(v18) + 12) + 32;
            }
            return v9;
          }
        }
        if ( !((unsigned __int8)v19[16] << 31) )
        {
          *((_DWORD *)v19 + 1) = HIDWORD(v18);
          if ( HIDWORD(v18) )
            *(_DWORD *)(HIDWORD(v18) + 8) = v19;
          v5 = v19;
          *((_DWORD *)v19 + 3) += *((_DWORD *)v2 - 5) + 32;
        }
        goto LABEL_54;
      }
    }
    else
    {
      v8 = 0;
      if ( v7 )
        goto LABEL_7;
    }
    v26 = *(_DWORD **)v5;
    if ( v7 + 64 >= v8 )
    {
      if ( v6 == v26[1] )
      {
        do
        {
          v6 = *(_DWORD *)(v6 + 4);
          v26[1] = v6;
          v33 = v6 == 0;
          if ( v6 )
            v33 = *(unsigned __int8 *)(v6 + 16) << 31 == 0;
        }
        while ( !v33 );
        v6 = *((_DWORD *)v2 - 7);
      }
      v34 = *(_DWORD *)(v6 + 4);
      *((_DWORD *)v2 - 7) = v34;
      if ( v34 )
        *(_DWORD *)(v34 + 8) = v5;
      *((_DWORD *)v2 - 5) += v8;
    }
    else
    {
      v27 = &v2[v4];
      *((_DWORD *)v27 + 1) = *(_DWORD *)(v6 + 4);
      *((_DWORD *)v27 + 2) = v5;
      *((_DWORD *)v27 + 3) = v8 + -32 - v7;
      *(_DWORD *)&v2[v4] = *((_DWORD *)v2 - 8);
      *((_DWORD *)v27 + 4) = 0;
      if ( *((_DWORD *)v2 - 7) == v26[1] )
        v26[1] = v27;
      *((_DWORD *)v2 - 7) = v27;
      v28 = *((_DWORD *)v27 + 1);
      if ( v28 )
        *(_DWORD *)(v28 + 8) = v27;
      *((_DWORD *)v2 - 5) = v4;
    }
  }
  return v2;
}

//----- (001E6FAE) --------------------------------------------------------
RwBool __fastcall _rwResHeapGetStats(
        void *resHeap,
        RwUInt32 *totalAllocated,
        RwUInt32 *totalFree,
        RwUInt32 *largestAllocated,
        unsigned int *a5,
        RwUInt32 *a6,
        unsigned int *a7)
{
  int v7; // r0
  int v8; // r5
  unsigned int v9; // r5
  RwUInt32 v10; // r5

  *totalAllocated = 0;
  *totalFree = 0;
  *largestAllocated = 0;
  *a5 = 0;
  *a6 = -1;
  *a7 = -1;
  v7 = *(_DWORD *)resHeap;
  if ( v7 )
  {
    while ( 1 )
    {
      v8 = *(_DWORD *)(v7 + 12);
      if ( *(unsigned __int8 *)(v7 + 16) << 31 )
      {
        *totalAllocated += v8;
        v10 = *(_DWORD *)(v7 + 12);
        if ( v10 < *a6 )
        {
          *a6 = v10;
          v10 = *(_DWORD *)(v7 + 12);
        }
        if ( v10 <= *largestAllocated )
          goto LABEL_3;
        *largestAllocated = v10;
        v7 = *(_DWORD *)(v7 + 4);
        if ( !v7 )
          return 1;
      }
      else
      {
        *totalFree += v8;
        v9 = *(_DWORD *)(v7 + 12);
        if ( v9 < *a7 )
        {
          *a7 = v9;
          v9 = *(_DWORD *)(v7 + 12);
        }
        if ( v9 > *a5 )
          *a5 = v9;
LABEL_3:
        v7 = *(_DWORD *)(v7 + 4);
        if ( !v7 )
          return 1;
      }
    }
  }
  return 1;
}

//----- (001E7034) --------------------------------------------------------
RwBool _rwStringOpen()
{
  _DWORD *v0; // r0

  v0 = RwEngineInstance;
  *((_DWORD *)RwEngineInstance + 62) = &strcpy;
  v0[61] = vsprintf;
  v0[63] = &strncpy;
  v0[64] = &strcat;
  v0[65] = &strncat;
  v0[66] = StrRChr;
  v0[67] = StrChr;
  v0[68] = &strcmp;
  v0[69] = StrICmp;
  v0[70] = &strlen;
  v0[71] = StrUpr;
  v0[72] = StrLwr;
  v0[73] = &strtok;
  v0[74] = &sscanf;
  v0[60] = sprintf;
  return 1;
}

//----- (001E7114) --------------------------------------------------------
RwChar *__fastcall StrRChr(const RwChar *s, int c)
{
  RwChar *result; // r0
  int v4; // r12
  const RwChar *v5; // r3
  int v6; // r1
  int v7; // t1

  result = 0;
  v4 = (unsigned __int8)c;
  v5 = s;
  do
  {
    v7 = *v5++;
    v6 = v7;
    if ( v7 == v4 )
      result = (RwChar *)s;
    s = v5;
  }
  while ( v6 );
  return result;
}

//----- (001E7130) --------------------------------------------------------
RwChar *__fastcall StrChr(RwChar *s, int c)
{
  int v2; // r2

  while ( 1 )
  {
    v2 = *s;
    if ( v2 == (unsigned __int8)c )
      break;
    ++s;
    if ( !v2 )
      return 0;
  }
  return s;
}

//----- (001E7144) --------------------------------------------------------
int __fastcall StrICmp(const RwChar *s1, const RwChar *s2)
{
  bool v2; // zf
  int v3; // r2
  RwChar v4; // r12
  int v5; // r2

  v2 = s1 == 0;
  v3 = 0;
  if ( s1 )
    v2 = s2 == 0;
  if ( !v2 )
  {
    while ( 1 )
    {
      v4 = *s2;
      v5 = *s1;
      if ( (unsigned __int8)(*s2 - 65) < 0x1Au )
        v4 += 32;
      if ( (unsigned __int8)(v5 - 65) < 0x1Au )
        v5 += 32;
      if ( (unsigned __int8)v5 != v4 )
        break;
      ++s2;
      ++s1;
      if ( !(v5 << 24) )
        return 0;
    }
    return (unsigned __int8)v5 - v4;
  }
  return v3;
}

//----- (001E7190) --------------------------------------------------------
RwChar *__fastcall StrUpr(RwChar *s)
{
  int v1; // r1
  bool v2; // zf
  RwChar *v3; // r2
  int v4; // t1

  v2 = s == 0;
  if ( s )
  {
    v1 = *s;
    v2 = v1 == 0;
  }
  if ( !v2 )
  {
    v3 = s + 1;
    do
    {
      if ( (unsigned __int8)(v1 - 97) <= 0x19u )
        *(v3 - 1) = v1 - 32;
      v4 = *v3++;
      LOBYTE(v1) = v4;
    }
    while ( v4 );
  }
  return s;
}
// 1E719C: variable 'v1' is possibly undefined

//----- (001E71BA) --------------------------------------------------------
RwChar *__fastcall StrLwr(RwChar *s)
{
  int v1; // r1
  bool v2; // zf
  RwChar *v3; // r2
  int v4; // t1

  v2 = s == 0;
  if ( s )
  {
    v1 = *s;
    v2 = v1 == 0;
  }
  if ( !v2 )
  {
    v3 = s + 1;
    do
    {
      if ( (unsigned __int8)(v1 - 65) <= 0x19u )
        *(v3 - 1) = v1 + 32;
      v4 = *v3++;
      LOBYTE(v1) = v4;
    }
    while ( v4 );
  }
  return s;
}
// 1E71C6: variable 'v1' is possibly undefined

//----- (001E71E8) --------------------------------------------------------
unsigned int __fastcall HashMem(const unsigned __int8 *mem, unsigned int size)
{
  unsigned int i; // r2
  int v3; // t1

  for ( i = 0; size; i = 33 * i + v3 )
  {
    v3 = *mem++;
    --size;
  }
  return i + (i >> 5);
}

//----- (001E7200) --------------------------------------------------------
unsigned int __fastcall HashString(const unsigned __int8 *name)
{
  const unsigned __int8 *v1; // r4
  size_t v2; // r0
  unsigned int i; // r1
  int v4; // t1

  v1 = name;
  v2 = strlen((const char *)name);
  for ( i = 0; v2; i = 33 * i + v4 )
  {
    v4 = *v1++;
    --v2;
  }
  return i + (i >> 5);
}

//----- (001E7222) --------------------------------------------------------
void __fastcall MakeUpper(unsigned __int8 *str)
{
  unsigned __int8 v1; // r1
  unsigned __int8 *v2; // r0
  int v3; // t1

  v1 = *str;
  if ( *str )
  {
    v2 = str + 1;
    do
    {
      if ( (unsigned __int8)(v1 - 97) <= 0x19u )
        *(v2 - 1) = v1 - 32;
      v3 = *v2++;
      v1 = v3;
    }
    while ( v3 );
  }
}

//----- (001E7248) --------------------------------------------------------
unsigned int __fastcall HashStringNoCase(const unsigned __int8 *str)
{
  unsigned __int8 v1; // r0
  unsigned __int8 *v2; // r1
  int v3; // t1
  size_t v4; // r0
  unsigned int v5; // r1
  unsigned __int8 *v6; // r2
  int v7; // t1

  strcpy((char *)HashStringNoCase(char const*)::buffer, (const char *)str);
  v1 = HashStringNoCase(char const*)::buffer[0];
  if ( HashStringNoCase(char const*)::buffer[0] )
  {
    v2 = &HashStringNoCase(char const*)::buffer[1];
    do
    {
      if ( (unsigned __int8)(v1 - 97) <= 0x19u )
        *(v2 - 1) = v1 - 32;
      v3 = *v2++;
      v1 = v3;
    }
    while ( v3 );
  }
  v4 = strlen((const char *)HashStringNoCase(char const*)::buffer);
  if ( !v4 )
    return 0;
  v5 = 0;
  v6 = HashStringNoCase(char const*)::buffer;
  do
  {
    v7 = *v6++;
    --v4;
    v5 = 33 * v5 + v7;
  }
  while ( v4 );
  return v5 + (v5 >> 5);
}

//----- (001E72B8) --------------------------------------------------------
unsigned int __fastcall HashFile(const unsigned __int8 *filename)
{
  unsigned int v1; // r6
  int v2; // r5
  unsigned __int8 *v3; // r4
  unsigned __int8 *v4; // r0
  int v5; // t1
  OSFile intoFile; // [sp+4h] [bp-14h] BYREF

  v1 = 0;
  OS_FileOpen(OSFDA_Storage_0, &intoFile, filename, OSFAT_Read_0);
  v2 = OS_FileSize(intoFile);
  v3 = (unsigned __int8 *)malloc(v2);
  OS_FileRead(intoFile, v3, v2);
  OS_FileClose(intoFile);
  if ( v2 )
  {
    v1 = 0;
    v4 = v3;
    do
    {
      v5 = *v4++;
      --v2;
      v1 = 33 * v1 + v5;
    }
    while ( v2 );
  }
  free(v3);
  return v1 + (v1 >> 5);
}

//----- (001E7316) --------------------------------------------------------
void __fastcall RLEDecompress(
        unsigned __int8 *dest,
        unsigned int destSize,
        const unsigned __int8 *source,
        unsigned int segSize,
        int a5)
{
  unsigned __int8 *v7; // r8
  int v8; // r5
  unsigned __int8 *v9; // r6
  int v10; // r10
  unsigned int v11; // r11
  unsigned __int8 *v12; // r5
  unsigned int v13; // r0
  unsigned __int8 *v14; // [sp+4h] [bp-24h]
  unsigned int v15; // [sp+8h] [bp-20h]

  v7 = dest;
  if ( (int)destSize >= 1 )
  {
    v8 = a5;
    v9 = &dest[destSize];
    v14 = &dest[destSize];
    v15 = segSize + 2;
    do
    {
      if ( *source == v8 )
      {
        v10 = source[1];
        if ( source[1] )
        {
          v11 = v10 * segSize;
          v12 = v7;
          do
          {
            qmemcpy(v12, source + 2, segSize);
            v12 += segSize;
            --v10;
          }
          while ( v10 );
          v13 = v15;
          v7 += v11;
          v8 = a5;
          v9 = v14;
        }
        else
        {
          v13 = v15;
        }
      }
      else
      {
        qmemcpy(v7, source, segSize);
        v7 += segSize;
        v13 = segSize;
      }
      source += v13;
    }
    while ( v7 < v9 );
  }
}

//----- (001E738E) --------------------------------------------------------
void __fastcall FileWriteEndian(OSFile file, unsigned __int8 *data, unsigned int size, unsigned int swapSize)
{
  unsigned int v4; // r4

  v4 = size;
  if ( swapSize == 2 )
  {
    if ( size )
    {
      do
      {
        OS_FileWrite(file, data + 1, 1);
        OS_FileWrite(file, data, 1);
        data += 2;
        v4 -= 2;
      }
      while ( v4 );
    }
  }
  else if ( swapSize == 4 && size )
  {
    do
    {
      OS_FileWrite(file, data + 3, 1);
      OS_FileWrite(file, data + 2, 1);
      OS_FileWrite(file, data + 1, 1);
      OS_FileWrite(file, data, 1);
      data += 4;
      v4 -= 4;
    }
    while ( v4 );
  }
}

//----- (001E73F8) --------------------------------------------------------
bool __fastcall TextureDatabaseEntry::operator==(const TextureDatabaseEntry *this, const TextureDatabaseEntry *other)
{
  int flags; // r0
  bool result; // r0

  result = 0;
  if ( !strcmp((const char *)this->name, (const char *)other->name)
    && !((*((unsigned __int16 *)this + 4) ^ *((unsigned __int16 *)other + 4)) << 20) )
  {
    flags = this->flags;
    if ( flags == other->flags
      && this->width == other->width
      && this->height == other->height
      && ((flags & 4) == 0 || !strcmp((const char *)this->_anon_0.instance, (const char *)other->_anon_0.instance)) )
    {
      return 1;
    }
  }
  return result;
}

//----- (001E7450) --------------------------------------------------------
unsigned int __fastcall TextureListing::GetTotalSize(const TextureListing *this)
{
  int v1; // r6
  int v2; // r1
  unsigned int width; // r5
  unsigned int v4; // r4
  int v5; // r1
  int v6; // r3
  int v7; // r2
  int format; // r12
  unsigned int v9; // lr
  int v10; // r2
  unsigned int result; // r0
  unsigned int v12; // r4
  int v13; // r6
  int v14; // r11
  int v15; // r5
  int v16; // r8
  unsigned int v17; // r10
  unsigned int v18; // r3
  unsigned int v19; // lr
  int v20; // r4

  v1 = *((__int16 *)this + 3);
  v2 = 1;
  if ( v1 > -1 )
    goto LABEL_11;
  width = this->width;
  v4 = v1 & 0x7FFF;
  v2 = 1;
  if ( width + v4 < 3 )
    goto LABEL_11;
  v5 = -1;
  do
  {
    v6 = 1;
    if ( v4 >> 1 > 1 )
      v6 = v4 >> 1;
    v7 = 1;
    --v5;
    if ( width >> 1 > 1 )
      v7 = width >> 1;
    v4 = v6;
    width = v7;
  }
  while ( (unsigned int)(v7 + v6) > 2 );
  if ( v5 )
  {
    v2 = -v5;
    LOWORD(v1) = *((_WORD *)this + 3);
LABEL_11:
    format = this->format;
    v9 = this->width;
    v10 = 0;
    result = 0;
    v12 = v1 & 0x7FFF;
    while ( 1 )
    {
      v13 = v12 >> v10;
      v14 = 1;
      v15 = v9 >> v10;
      if ( (int)(v12 >> v10) > 1 )
        v14 = v12 >> v10;
      v16 = 1;
      v17 = 0;
      if ( v15 > 1 )
        v16 = v9 >> v10;
      if ( format > 33777 )
      {
        v18 = v9;
        v19 = v12;
        switch ( format )
        {
          case 35840:
          case 35842:
            v20 = 32;
            if ( v16 > 8 )
              v20 = 4 * v15;
            goto LABEL_38;
          case 35841:
          case 35843:
            v20 = 32;
            if ( v16 > 16 )
              v20 = 2 * v15;
LABEL_38:
            if ( v14 <= 8 )
              v13 = 8;
            v17 = (unsigned int)(v20 * v13 + 7) >> 3;
            goto LABEL_41;
          default:
            if ( (unsigned int)(format - 33778) < 2 )
            {
              if ( v16 <= 4 )
                v15 = 4;
              if ( v14 <= 4 )
                v13 = 4;
              v17 = v13 * v15;
LABEL_41:
              v12 = v19;
              v9 = v18;
              goto LABEL_50;
            }
            v9 = v18;
            if ( format != 36196 )
              goto LABEL_50;
            break;
        }
LABEL_45:
        if ( v16 <= 4 )
          v15 = 4;
        if ( v14 <= 4 )
          v13 = 4;
        v17 = (unsigned int)(v13 * v15) >> 1;
        goto LABEL_50;
      }
      if ( format <= 32818 )
        break;
      if ( (unsigned int)(format - 32819) < 2 )
        goto LABEL_35;
      if ( (unsigned int)(format - 33776) < 2 )
        goto LABEL_45;
      if ( format == 33635 )
        goto LABEL_35;
LABEL_50:
      ++v10;
      result += v17;
      if ( v2 == v10 )
        return result;
    }
    if ( format == 5121 )
    {
      v17 = 4 * v16 * v14;
      goto LABEL_50;
    }
    if ( format == 6409 )
    {
      v17 = v14 * v16;
      goto LABEL_50;
    }
    if ( format != 6410 )
      goto LABEL_50;
LABEL_35:
    v17 = 2 * v16 * v14;
    goto LABEL_50;
  }
  return 0;
}

//----- (001E7612) --------------------------------------------------------
unsigned int __fastcall TextureListing::GetMipCount(const TextureListing *this)
{
  int v1; // r1
  unsigned int result; // r0
  unsigned int width; // r2
  unsigned int v4; // r1
  int v5; // r3
  int v6; // r2
  bool v7; // cc

  v1 = *((__int16 *)this + 3);
  if ( v1 > -1 )
    return 1;
  width = this->width;
  v4 = v1 & 0x7FFF;
  result = 1;
  if ( v4 + width >= 3 )
  {
    do
    {
      v5 = 1;
      ++result;
      if ( width >> 1 > 1 )
        v5 = width >> 1;
      v6 = 1;
      if ( v4 >> 1 > 1 )
        v6 = v4 >> 1;
      v7 = (unsigned int)(v6 + v5) > 2;
      v4 = v6;
      width = v5;
    }
    while ( v7 );
  }
  return result;
}

//----- (001E7658) --------------------------------------------------------
unsigned int __fastcall TextureListing::GetMipSize(const TextureListing *this, unsigned int mip)
{
  __int16 v2; // r4
  int v3; // lr
  unsigned int width; // r2
  int v5; // r12
  int format; // r3
  unsigned int result; // r0
  int v8; // r2
  int v9; // r1
  int v10; // r0

  v2 = *((_WORD *)this + 3);
  v3 = 1;
  width = this->width;
  v5 = 1;
  format = this->format;
  result = 0;
  v8 = width >> mip;
  v9 = (unsigned __int16)(v2 & 0x7FFF) >> mip;
  if ( v8 > 1 )
    v3 = v8;
  if ( v9 > 1 )
    v5 = v9;
  if ( format > 33777 )
  {
    switch ( format )
    {
      case 35840:
      case 35842:
        v10 = 32;
        if ( v5 <= 8 )
          v9 = 8;
        if ( v3 > 8 )
          v10 = 4 * v8;
        return (unsigned int)(v10 * v9 + 7) >> 3;
      case 35841:
      case 35843:
        v10 = 32;
        if ( v5 <= 8 )
          v9 = 8;
        if ( v3 > 16 )
          v10 = 2 * v8;
        return (unsigned int)(v10 * v9 + 7) >> 3;
      default:
        if ( (unsigned int)(format - 33778) < 2 )
        {
          if ( v3 <= 4 )
            v8 = 4;
          if ( v5 <= 4 )
            v9 = 4;
          return v9 * v8;
        }
        if ( format != 36196 )
          return result;
        break;
    }
    goto LABEL_36;
  }
  if ( format > 32818 )
  {
    if ( (unsigned int)(format - 32819) < 2 )
      return 2 * v3 * v5;
    if ( (unsigned int)(format - 33776) >= 2 )
    {
      if ( format != 33635 )
        return result;
      return 2 * v3 * v5;
    }
LABEL_36:
    if ( v3 <= 4 )
      v8 = 4;
    if ( v5 <= 4 )
      v9 = 4;
    return (unsigned int)(v9 * v8) >> 1;
  }
  switch ( format )
  {
    case 5121:
      return 4 * v3 * v5;
    case 6409:
      return v5 * v3;
    case 6410:
      return 2 * v3 * v5;
  }
  return result;
}

//----- (001E7768) --------------------------------------------------------
unsigned int __fastcall TextureListing::GetRLESegSize(const TextureListing *this)
{
  int format; // r1
  unsigned int result; // r0

  format = this->format;
  result = 8;
  if ( format < 35840 )
  {
    if ( (unsigned int)(format - 33776) >= 2 )
    {
      if ( (unsigned int)(format - 33778) >= 2 )
        return 4;
      else
        return 16;
    }
  }
  else
  {
    switch ( format )
    {
      case 35840:
      case 35842:
        return 16;
      case 35841:
      case 35843:
        result = 32;
        break;
      default:
        if ( format != 36196 )
          return 4;
        break;
    }
  }
  return result;
}

//----- (001E77B0) --------------------------------------------------------
RQTextureFormat __fastcall TextureListing::GetRQFormat(const TextureListing *this)
{
  int format; // r0
  RQTextureFormat result; // r0

  format = this->format;
  if ( format <= 33775 )
  {
    if ( format > 32818 )
    {
      switch ( format )
      {
        case 32819:
          return 4;
        case 32820:
          return 3;
        case 33635:
          return 2;
        default:
          return 0;
      }
    }
    else
    {
      if ( format == 5121 )
        return 0;
      if ( format == 6409 )
        return 5;
      if ( format != 6410 )
        return 0;
      else
        return 6;
    }
  }
  else
  {
    switch ( format )
    {
      case 33776:
        result = TF_DXT1;
        break;
      case 33777:
        result = TF_DXT1A;
        break;
      case 33778:
        result = TF_DXT3;
        break;
      case 33779:
        result = TF_DXT5;
        break;
      default:
        switch ( format )
        {
          case 35840:
            result = TF_PVR_4BPP_RGB;
            break;
          case 35841:
            result = TF_PVR_2BPP_RGB;
            break;
          case 35842:
            result = TF_PVR_4BPP_RGBA;
            break;
          case 35843:
            result = TF_PVR_2BPP_RGBA;
            break;
          default:
            if ( format == 36196 )
              result = TF_ETC1;
            else
              result = TF_RGBA_8888;
            break;
        }
        break;
    }
  }
  return result;
}

//----- (001E7860) --------------------------------------------------------
void __fastcall TextureListingContainer::~TextureListingContainer(TextureListingContainer *this)
{
  if ( this->ownsData )
    free(this->data);
  this->dataSize = 0;
  this->data = 0;
}

//----- (001E787C) --------------------------------------------------------
void __fastcall TextureDatabase::~TextureDatabase(TextureDatabase *this)
{
  unsigned int numEntries; // r1
  int v3; // r4
  unsigned int v4; // r5
  TextureDatabaseEntry *v5; // r0
  int v6; // r4
  unsigned int v7; // r5
  unsigned int v8; // r4
  void **dataPtr; // r0
  TDBArray<void *> *p_toFree; // r6
  TextureDatabase *v11; // r10
  int v12; // r4
  unsigned int v13; // r5
  void **v14; // r8
  void **v15; // r0
  TextureDatabaseEntry *v16; // r0
  TextureCategory *v17; // r0

  numEntries = this->entries.numEntries;
  this->_vptr$TextureDatabase = (int (**)(void))&off_660924;
  if ( numEntries )
  {
    v3 = 0;
    v4 = 0;
    do
    {
      free((void *)this->entries.dataPtr[v3].name);
      v5 = &this->entries.dataPtr[v3];
      if ( (v5->flags & 4) != 0 )
        free(v5->_anon_0.instance);
      ++v4;
      ++v3;
    }
    while ( v4 < this->entries.numEntries );
  }
  if ( this->categories.numEntries )
  {
    v6 = 0;
    v7 = 0;
    do
    {
      free((void *)this->categories.dataPtr[v6].name);
      ++v7;
      ++v6;
    }
    while ( v7 < this->categories.numEntries );
  }
  if ( this->toFree.numEntries )
  {
    v8 = 0;
    do
      free(this->toFree.dataPtr[v8++]);
    while ( v8 < this->toFree.numEntries );
  }
  free((void *)this->name);
  dataPtr = this->toFree.dataPtr;
  this->toFree.numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->toFree.dataPtr = 0;
  }
  this->toFree.numAlloced = 0;
  p_toFree = &this->toFree;
  do
  {
    v11 = (TextureDatabase *)&p_toFree[-1];
    if ( p_toFree[-1].numEntries )
    {
      v12 = 0;
      v13 = 0;
      do
      {
        v14 = (void **)((char *)p_toFree[-1].dataPtr + v12);
        if ( *((_BYTE *)v14 + 16) )
          free(v14[2]);
        v14[2] = 0;
        v12 += 17;
        v14[3] = 0;
        ++v13;
      }
      while ( v13 < p_toFree[-1].numEntries );
    }
    v15 = p_toFree[-1].dataPtr;
    p_toFree[-1].numEntries = 0;
    if ( v15 )
    {
      free(v15);
      p_toFree[-1].dataPtr = 0;
    }
    v11->_vptr$TextureDatabase = 0;
    --p_toFree;
  }
  while ( v11 != (TextureDatabase *)this->thumbs );
  v16 = this->entries.dataPtr;
  this->entries.numEntries = 0;
  if ( v16 )
  {
    free(v16);
    this->entries.dataPtr = 0;
  }
  v17 = this->categories.dataPtr;
  this->categories.numEntries = 0;
  this->entries.numAlloced = 0;
  if ( v17 )
  {
    free(v17);
    this->categories.dataPtr = 0;
  }
  this->categories.numAlloced = 0;
}
// 660924: using guessed type void *;

//----- (001E79D0) --------------------------------------------------------
void __fastcall TextureDatabase::~TextureDatabase(TextureDatabase *this)
{
  void *v1; // r0

  TextureDatabase::~TextureDatabase(this);
  sub_191374(v1);
}
// 1E79DC: variable 'v1' is possibly undefined

//----- (001E79E0) --------------------------------------------------------
void __fastcall TextureDatabase::LoadEntry(TextureDatabase *this, unsigned __int8 *line, bool hashName)
{
  int v4; // r6
  unsigned __int8 *v5; // r4
  int v6; // r5
  int v7; // r0
  __int16 v8; // r1
  int v9; // r0
  int v10; // r1
  unsigned int v11; // r1
  char *v12; // r8
  char *v13; // r9
  size_t v14; // r0
  unsigned int i; // r1
  int v16; // t1
  int v17; // r0
  int v18; // r0
  unsigned __int8 *v19; // r8
  int v20; // r4
  __int16 v21; // r6
  int v22; // r0
  __int16 v23; // r1
  unsigned int *p_numEntries; // r4
  unsigned int numEntries; // r8
  unsigned int numAlloced; // r0
  unsigned int v27; // r10
  TextureCategory *v28; // r0
  TextureCategory *dataPtr; // r9
  TextureCategory *v30; // r5
  TextureCategory *v31; // r0
  TextureCategory *v32; // r0
  int v33; // r0
  TextureDatabase *v34; // r3
  unsigned __int8 *v35; // r11
  __int16 v36; // lr
  __int16 v37; // r12
  char v38; // r8
  unsigned int v39; // r5
  __int16 v40; // r6
  unsigned int v41; // r0
  unsigned int v42; // r10
  TextureDatabaseEntry *v43; // r1
  TextureDatabaseEntry *v44; // r9
  size_t v45; // r2
  TextureDatabaseEntry *v46; // r5
  int v47; // r0
  unsigned __int8 *v48; // [sp+0h] [bp-60h]
  __int16 v49; // [sp+4h] [bp-5Ch]
  int v50; // [sp+8h] [bp-58h]
  int v51; // [sp+Ch] [bp-54h]
  char v52; // [sp+10h] [bp-50h]
  __int16 v53; // [sp+14h] [bp-4Ch]
  unsigned __int16 v54; // [sp+18h] [bp-48h]
  __int16 v56; // [sp+20h] [bp-40h]
  int v57; // [sp+24h] [bp-3Ch]
  int v58; // [sp+28h] [bp-38h]
  int v59; // [sp+2Ch] [bp-34h]
  int v60; // [sp+30h] [bp-30h]
  unsigned int v61; // [sp+34h] [bp-2Ch]
  unsigned __int8 *v62; // [sp+38h] [bp-28h]
  unsigned int v63; // [sp+3Ch] [bp-24h]
  __int16 v64; // [sp+40h] [bp-20h]

  v51 = 80;
  v64 = 1;
  v56 = 2;
  v54 = 0;
  v57 = 0;
  v58 = 0;
  v60 = 0;
  v62 = 0;
  v61 = 2;
  v52 = 0;
  v53 = 0;
  v49 = 0;
  v48 = 0;
  v63 = 0;
  v59 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v50 = 0;
  do
  {
    if ( *line == 34 )
    {
      v12 = strchr((const char *)++line, 34);
      v13 = strchr(v12, 32);
      *v12 = 0;
    }
    else
    {
      v13 = strchr((const char *)line, 32);
    }
    if ( v13 )
      *v13 = 0;
    if ( v6 << 31 )
    {
      if ( !strncmp((const char *)line, "name=", 5u) )
      {
        v62 = j_strdup(line + 5);
        v6 = 1;
      }
      else if ( !strncmp((const char *)line, "onfoot=", 7u) )
      {
        v60 = atoi((const char *)line + 7);
        v6 = 1;
      }
      else if ( !strncmp((const char *)line, "slow=", 5u) )
      {
        v58 = atoi((const char *)line + 5);
        v6 = 1;
      }
      else if ( !strncmp((const char *)line, "fast=", 5u) )
      {
        v57 = atoi((const char *)line + 5);
        v6 = 1;
      }
      else if ( !strncmp((const char *)line, "defaultformat=", 0xEu) )
      {
        v56 = atoi((const char *)line + 14);
        v6 = 1;
      }
      else
      {
        if ( !strncmp((const char *)line, "defaultstream=", 0xEu) )
          v54 = atoi((const char *)line + 14);
        v6 = 1;
      }
    }
    else
    {
      if ( !strchr((const char *)line, 61) )
      {
        v5 = j_strdup(line);
        v14 = strlen((const char *)line);
        for ( i = 0; v14; i = 33 * i + v16 )
        {
          v16 = *line++;
          --v14;
        }
        v63 = i + (i >> 5);
        goto LABEL_61;
      }
      if ( !strncmp((const char *)line, "cat=", 4u) )
      {
        v17 = atoi((const char *)line + 4);
        v6 = 0;
        if ( v5 )
          v4 = v17;
        else
          v6 = 1;
        goto LABEL_74;
      }
      if ( !strncmp((const char *)line, "format=", 7u) )
      {
        v18 = atoi((const char *)line + 7) & 0xF;
        v59 = 1;
        v11 = v61 & 0xFFFFFFF0 | v18;
        if ( v18 == 7 )
          v11 = v61 & 0xFFFFF0F0 | 0x107;
LABEL_60:
        v61 = v11;
        goto LABEL_61;
      }
      if ( !strncmp((const char *)line, "mipmode=", 8u) )
      {
        v19 = v5;
        v20 = v4;
        v21 = v64 & 0xFFFE;
        v22 = atoi((const char *)line + 8);
        v23 = v64 | 1;
      }
      else if ( !strncmp((const char *)line, "hassibling=", 0xBu) )
      {
        v19 = v5;
        v20 = v4;
        v21 = v64 & 0xFFFD;
        v22 = atoi((const char *)line + 11);
        v23 = v64 | 2;
      }
      else if ( !strncmp((const char *)line, "hasbias=", 8u) )
      {
        v19 = v5;
        v20 = v4;
        v21 = v64 & 0xFFF7;
        v22 = atoi((const char *)line + 8);
        v23 = v64 | 8;
      }
      else if ( !strncmp((const char *)line, "camnorm=", 8u) )
      {
        v19 = v5;
        v20 = v4;
        v21 = v64 & 0xFFBF;
        v22 = atoi((const char *)line + 8);
        v23 = v64 | 0x40;
      }
      else if ( !strncmp((const char *)line, "forcez=", 7u) )
      {
        v19 = v5;
        v20 = v4;
        v21 = v64 & 0xFF7F;
        v22 = atoi((const char *)line + 7);
        v23 = v64 | 0x80;
      }
      else if ( !strncmp((const char *)line, "decalz=", 7u) )
      {
        v19 = v5;
        v20 = v4;
        v21 = v64 & 0xFEFF;
        v22 = atoi((const char *)line + 7);
        v23 = v64 | 0x100;
      }
      else
      {
        if ( strncmp((const char *)line, "noalphatest=", 0xCu) )
        {
          if ( !strncmp((const char *)line, "hasdetail=", 0xAu) )
          {
            v7 = atoi((const char *)line + 10);
            if ( !v7 )
            {
              v64 &= ~0x20u;
              goto LABEL_61;
            }
            v8 = v64 | 0x20;
          }
          else
          {
            if ( strncmp((const char *)line, "isdetail=", 9u) )
            {
              if ( !strncmp((const char *)line, "detailtile=", 0xBu) )
              {
                v9 = atoi((const char *)line + 11);
                v10 = v51;
                if ( v9 )
                  v10 = v9;
                v51 = v10;
              }
              else
              {
                if ( !strncmp((const char *)line, "alphamode=", 0xAu) )
                {
                  v11 = v61 & 0xFFFFFF0F | (16 * (atoi((const char *)line + 10) & 0xF));
                  goto LABEL_60;
                }
                if ( !strncmp((const char *)line, "streammode=", 0xBu) )
                {
                  v6 = 0;
                  v61 = v61 & 0xFFFFF0FF | ((atoi((const char *)line + 11) & 0xF) << 8);
                  v50 = 1;
                  goto LABEL_74;
                }
                if ( !strncmp((const char *)line, "width=", 6u) )
                {
                  v53 = atoi((const char *)line + 6);
                }
                else if ( !strncmp((const char *)line, "height=", 7u) )
                {
                  v49 = atoi((const char *)line + 7);
                }
                else if ( !strncmp((const char *)line, "affiliate=", 0xAu) )
                {
                  v64 |= 4u;
                  v48 = j_strdup(line + 10);
                }
              }
LABEL_61:
              v6 = 0;
              goto LABEL_74;
            }
            v7 = atoi((const char *)line + 9);
            if ( !v7 )
            {
              v64 &= ~0x10u;
              goto LABEL_61;
            }
            v8 = v64 | 0x10;
          }
          v64 = v8;
          v6 = 0;
          v52 = v7;
          goto LABEL_74;
        }
        v19 = v5;
        v20 = v4;
        v21 = v64 & 0xFDFF;
        v22 = atoi((const char *)line + 12);
        v23 = v64 | 0x200;
      }
      v6 = 0;
      if ( v22 )
        v21 = v23;
      v64 = v21;
      v4 = v20;
      v5 = v19;
    }
LABEL_74:
    line = (unsigned __int8 *)(v13 + 1);
  }
  while ( v13 );
  if ( v6 == 1 )
  {
    p_numEntries = &this->categories.numEntries;
    numEntries = this->categories.numEntries;
    numAlloced = this->categories.numAlloced;
    if ( numAlloced < numEntries + 1 )
    {
      v27 = ((3 * (numEntries + 1)) >> 1) + 3;
      if ( v27 != numAlloced )
      {
        v28 = (TextureCategory *)malloc(20 * v27);
        dataPtr = this->categories.dataPtr;
        v30 = v28;
        if ( dataPtr )
        {
          memmove(v28, this->categories.dataPtr, 20 * numEntries);
          free(dataPtr);
          numEntries = *p_numEntries;
        }
        this->categories.dataPtr = v30;
        this->categories.numAlloced = v27;
      }
    }
    v31 = this->categories.dataPtr;
    v31[numEntries].name = v62;
    v32 = &v31[numEntries];
    v32->onFootPriority = v60;
    v32->slowCarPriority = v58;
    v32->fastCarPriority = v57;
    v32->defaultFormat = v56;
    v32->defaultStreamMode = v54;
  }
  else
  {
    if ( v59 << 31 )
    {
      LOWORD(v33) = v61;
      v34 = this;
    }
    else
    {
      v34 = this;
      v33 = this->categories.dataPtr[(unsigned __int8)v4].defaultFormat & 0xF | (16 * (v61 >> 4));
    }
    v35 = v5;
    v36 = v53;
    v37 = v64;
    v38 = v4;
    if ( !(v50 << 31) )
      LOWORD(v33) = v33 & 0xF0FF | ((v34->categories.dataPtr[(unsigned __int8)v4].defaultStreamMode & 0xF) << 8);
    p_numEntries = &v34->entries.numEntries;
    v39 = v34->entries.numEntries;
    v40 = v33 & 0xF0FF | 0x100;
    if ( (v64 & 0x10) == 0 )
      v40 = v33;
    v41 = v34->entries.numAlloced;
    if ( v41 < v39 + 1 )
    {
      v42 = ((3 * (v39 + 1)) >> 1) + 3;
      if ( v42 == v41 )
      {
        v34 = this;
      }
      else
      {
        v43 = (TextureDatabaseEntry *)malloc(23 * v42);
        v44 = this->entries.dataPtr;
        if ( v44 )
        {
          v45 = 23 * v39;
          v46 = v43;
          memmove(v43, this->entries.dataPtr, v45);
          free(v44);
          v43 = v46;
          v39 = *p_numEntries;
        }
        v36 = v53;
        v34 = this;
        this->entries.dataPtr = v43;
        this->entries.numAlloced = v42;
      }
      v37 = v64;
    }
    v47 = (int)&v34->entries.dataPtr[v39];
    *(_DWORD *)v47 = v35;
    *(_DWORD *)(v47 + 4) = v63;
    *(_WORD *)(v47 + 8) = v40;
    *(_WORD *)(v47 + 10) = v37;
    *(_BYTE *)(v47 + 12) = v38;
    *(_BYTE *)(v47 + 13) = v52;
    *(_BYTE *)(v47 + 14) = v51;
    *(_WORD *)(v47 + 15) = v36;
    *(_WORD *)(v47 + 17) = v49;
    *(_DWORD *)(v47 + 19) = v48;
  }
  ++*p_numEntries;
}

//----- (001E80E4) --------------------------------------------------------
bool __fastcall TextureDatabase::LoadEntries(TextureDatabase *this, bool hashNames, bool fromBackup)
{
  _BOOL4 v4; // r4
  bool v5; // r5
  int v6; // r5
  char *v7; // r8
  char *v8; // r10
  unsigned int v9; // r6
  int v10; // r4
  int v11; // r0
  unsigned __int8 *v12; // r10
  unsigned int numAlloced; // r0
  unsigned int numEntries; // r5
  unsigned int v15; // r6
  TextureCategory *v16; // r0
  TextureCategory *dataPtr; // r8
  TextureCategory *v18; // r9
  TextureCategory *v19; // r0
  TextureCategory *v20; // r0
  unsigned int v21; // r8
  unsigned int i; // r6
  TextureDatabaseEntry *v23; // r4
  const unsigned __int8 *name; // r5
  TextureDatabaseEntry *v25; // r8
  unsigned int v26; // r4
  unsigned __int8 *v27; // r5
  size_t v28; // r0
  unsigned __int8 *v29; // r1
  int v30; // t1
  unsigned __int8 *v31; // r10
  unsigned int v32; // r0
  unsigned int v33; // r9
  unsigned int v34; // r8
  unsigned int v35; // r4
  TextureDatabaseEntry *v36; // r0
  TextureDatabaseEntry *v37; // r1
  size_t v38; // r2
  TextureDatabaseEntry *v39; // r9
  TextureDatabaseEntry *v40; // r2
  _BOOL4 v42; // [sp+8h] [bp-330h]
  TextureDatabaseEntry *v43; // [sp+8h] [bp-330h]
  OSFile intoFile; // [sp+14h] [bp-324h] BYREF
  unsigned __int8 line[512]; // [sp+18h] [bp-320h] BYREF
  unsigned __int8 s[256]; // [sp+218h] [bp-120h] BYREF

  v4 = hashNames;
  if ( fromBackup )
    snprintf(s, 0x100u, "texdb/%s/%s.txt.bak");
  else
    snprintf(s, 0x100u, "texdb/%s/%s.txt");
  v5 = 0;
  if ( OS_FileOpen(OSFDA_Storage_0, &intoFile, s, OSFAT_Read_0) )
    return v5;
  v6 = OS_FileSize(intoFile);
  v7 = (char *)malloc(v6);
  if ( OS_FileRead(intoFile, v7, v6) )
  {
    free(v7);
    return 0;
  }
  OS_FileClose(intoFile);
  if ( !v6 )
    goto LABEL_20;
  v8 = v7;
  v9 = 0;
  v42 = v4;
  do
  {
    ++v8;
    v10 = 1 - v6;
    while ( 1 )
    {
      v11 = (unsigned __int8)*(v8 - 1);
      if ( v11 == 10 )
        break;
      if ( v11 != 13 )
      {
        line[v9++] = v11;
        goto LABEL_17;
      }
LABEL_14:
      ++v10;
      ++v8;
      if ( v10 == 1 )
        goto LABEL_18;
    }
    line[v9] = 0;
    if ( v9 < 2 )
      goto LABEL_14;
    v9 = 0;
    TextureDatabase::LoadEntry(this, line, 0);
LABEL_17:
    v6 = -v10;
  }
  while ( v10 );
LABEL_18:
  v4 = v42;
  if ( v9 >= 2 )
  {
    line[v9] = 0;
    TextureDatabase::LoadEntry(this, line, 0);
  }
LABEL_20:
  free(v7);
  if ( !this->categories.numEntries )
  {
    v12 = j_strdup("Default");
    numEntries = this->categories.numEntries;
    numAlloced = this->categories.numAlloced;
    if ( numAlloced < numEntries + 1 )
    {
      v15 = ((3 * (numEntries + 1)) >> 1) + 3;
      if ( v15 != numAlloced )
      {
        v16 = (TextureCategory *)malloc(20 * v15);
        dataPtr = this->categories.dataPtr;
        v18 = v16;
        if ( dataPtr )
        {
          memmove(v16, this->categories.dataPtr, 20 * numEntries);
          free(dataPtr);
          numEntries = this->categories.numEntries;
        }
        this->categories.dataPtr = v18;
        this->categories.numAlloced = v15;
      }
    }
    v19 = this->categories.dataPtr;
    v19[numEntries].name = v12;
    v20 = &v19[numEntries];
    v20->onFootPriority = 5;
    v20->slowCarPriority = 5;
    v20->fastCarPriority = 5;
    ++this->categories.numEntries;
  }
  if ( v4 )
  {
    v21 = this->entries.numEntries;
    if ( v21 )
    {
      for ( i = 0; i < v21; ++i )
      {
        v23 = this->entries.dataPtr;
        name = v23[i].name;
        if ( strlen((const char *)name) >= 0x20 )
        {
          v25 = &v23[i];
          v26 = 0;
          v27 = j_strdup(name);
          v27[31] = 0;
          v28 = strlen((const char *)v27);
          if ( v28 )
          {
            v26 = 0;
            v29 = v27;
            do
            {
              v30 = *v29++;
              --v28;
              v26 = 33 * v26 + v30;
            }
            while ( v28 );
          }
          if ( (v25->flags & 4) != 0 )
            v25 = (TextureDatabaseEntry *)((char *)v25 + 19);
          v31 = j_strdup(v25->name);
          v33 = this->entries.numEntries;
          v32 = this->entries.numAlloced;
          v34 = v26 + (v26 >> 5);
          if ( v32 < v33 + 1 )
          {
            v35 = ((3 * (v33 + 1)) >> 1) + 3;
            if ( v35 != v32 )
            {
              v36 = (TextureDatabaseEntry *)malloc(23 * v35);
              v37 = this->entries.dataPtr;
              if ( v37 )
              {
                v43 = v36;
                v38 = 23 * v33;
                v39 = this->entries.dataPtr;
                memmove(v36, v37, v38);
                free(v39);
                v36 = v43;
                v33 = this->entries.numEntries;
              }
              this->entries.dataPtr = v36;
              this->entries.numAlloced = v35;
            }
          }
          v40 = &this->entries.dataPtr[v33];
          v40->name = v27;
          v40->nameHash = v34;
          *((_DWORD *)v40 + 2) = 0x40000;
          HIBYTE(v40->height) = 0;
          *(unsigned __int16 *)((char *)&v40->width + 1) = 0;
          v40->_anon_0.instance = (RwTexture *)v31;
          *(_DWORD *)&v40->category = 0;
          v21 = this->entries.numEntries + 1;
          this->entries.numEntries = v21;
        }
      }
    }
  }
  return 1;
}
// 1E80E4: using guessed type unsigned __int8 line[512];

//----- (001E83A4) --------------------------------------------------------
bool __fastcall TextureDatabase::LoadDataFile(
        TextureDatabase *this,
        const unsigned __int8 *filename,
        TDBArray<TextureListingContainer> *intoArray)
{
  bool v5; // r4
  unsigned int v6; // r8
  unsigned __int8 *v7; // r10
  unsigned int v8; // r5
  size_t v9; // r6
  unsigned int v10; // r5
  unsigned int v11; // r4
  TextureListingContainer *v12; // r0
  TextureListingContainer *v13; // r6
  TextureListingContainer *v14; // r9
  TextureListingContainer *v15; // r0
  TextureListingContainer *v16; // r0
  unsigned int v17; // r1
  unsigned int v18; // r5
  TextureListingContainer *v19; // r6
  int v20; // r0
  unsigned int TotalSize; // r0
  int *p_dataSize; // r5
  _DWORD *v23; // r3
  int v24; // r10
  int v25; // r1
  unsigned int format; // r2
  unsigned __int16 *p_format; // r8
  char *v28; // r11
  unsigned int v29; // r1
  int v30; // r0
  unsigned __int8 *v31; // r5
  char *v32; // r4
  __int16 v33; // r9
  int v34; // r10
  char *v35; // r8
  int v36; // r0
  unsigned int numEntries; // r6
  __int64 v38; // kr10_8
  unsigned int v39; // r4
  void **v40; // r0
  void **v41; // r8
  void **dataPtr; // r9
  int v43; // r5
  unsigned int v44; // r6
  TextureListingContainer *v45; // r4
  int v46; // r5
  unsigned int v47; // r6
  TextureListingContainer *v48; // r4
  void *p; // [sp+4h] [bp-5Ch]
  TDBArray<TextureListingContainer> *v51; // [sp+8h] [bp-58h]
  TextureDatabase *v52; // [sp+Ch] [bp-54h]
  unsigned int v53; // [sp+10h] [bp-50h]
  unsigned int v54; // [sp+14h] [bp-4Ch]
  unsigned __int8 *v55; // [sp+18h] [bp-48h]
  char *v56; // [sp+1Ch] [bp-44h]
  int v57; // [sp+20h] [bp-40h]
  unsigned int v58; // [sp+24h] [bp-3Ch]
  OSFile intoFile; // [sp+2Ch] [bp-34h] BYREF

  v5 = 0;
  if ( OS_FileOpen(OSFDA_Storage_0, &intoFile, filename, OSFAT_Read_0) )
    return v5;
  v6 = OS_FileSize(intoFile);
  p = malloc(v6);
  OS_FileRead(intoFile, p, v6);
  OS_FileClose(intoFile);
  v52 = this;
  if ( !this->entries.numEntries )
  {
LABEL_49:
    v38 = *(_QWORD *)&this->toFree.numAlloced;
    numEntries = this->toFree.numEntries;
    if ( (unsigned int)v38 < numEntries + 1 )
    {
      v39 = ((3 * (numEntries + 1)) >> 1) + 3;
      if ( v39 != (_DWORD)v38 )
      {
        v40 = (void **)malloc(4 * v39);
        v41 = v40;
        dataPtr = v52->toFree.dataPtr;
        if ( dataPtr )
        {
          memmove(v40, v52->toFree.dataPtr, 4 * numEntries);
          free(dataPtr);
          numEntries = v52->toFree.numEntries;
        }
        v52->toFree.dataPtr = v41;
        v52->toFree.numAlloced = v39;
      }
    }
    v5 = 1;
    v52->toFree.dataPtr[numEntries] = p;
    ++v52->toFree.numEntries;
    return v5;
  }
  v7 = (unsigned __int8 *)p;
  v8 = 0;
  v51 = intoArray;
  while ( 1 )
  {
    v58 = v8;
    v10 = intoArray->numEntries;
    if ( intoArray->numAlloced < v10 + 1 )
    {
      v11 = ((3 * (v10 + 1)) >> 1) + 3;
      if ( v11 != intoArray->numAlloced )
      {
        v12 = (TextureListingContainer *)malloc(17 * v11);
        v13 = intoArray->dataPtr;
        v14 = v12;
        if ( v13 )
        {
          memmove(v12, intoArray->dataPtr, 17 * v10);
          free(v13);
          v10 = intoArray->numEntries;
        }
        this = v52;
        intoArray->dataPtr = v14;
        intoArray->numAlloced = v11;
      }
    }
    v15 = &intoArray->dataPtr[v10];
    v15->listing = 0LL;
    *(_QWORD *)&v15->data = 0LL;
    v15->ownsData = 0;
    v16 = intoArray->dataPtr;
    v17 = intoArray->numEntries;
    intoArray->numEntries = v17 + 1;
    v18 = v58;
    if ( (this->entries.dataPtr[v58].flags & 4) != 0 )
      goto LABEL_48;
    if ( v6 <= 7 )
      break;
    v19 = &v16[v17];
    v20 = *(_DWORD *)v7;
    *(_DWORD *)&v19->listing.width = *((_DWORD *)v7 + 1);
    *(_DWORD *)&v19->listing.nameHash = v20;
    TotalSize = TextureListing::GetTotalSize(&v19->listing);
    v19->dataSize = TotalSize;
    p_dataSize = (int *)&v19->dataSize;
    v53 = *((_DWORD *)v7 + 2) - 4;
    v54 = v6 - 16;
    if ( v6 - 16 < v53 )
    {
      if ( intoArray->numEntries )
      {
        v46 = 0;
        v47 = 0;
        do
        {
          v48 = &intoArray->dataPtr[v46];
          if ( v48->ownsData )
            free(v48->data);
          v48->data = 0;
          ++v46;
          v48->dataSize = 0;
          ++v47;
        }
        while ( v47 < intoArray->numEntries );
      }
      v16 = intoArray->dataPtr;
      goto LABEL_67;
    }
    v23 = v7 + 16;
    v55 = v7 + 16;
    v24 = *((_DWORD *)v7 + 3);
    if ( !v24 )
    {
      v19->data = v23;
      goto LABEL_47;
    }
    v25 = 8;
    p_format = &v19->listing.format;
    format = v19->listing.format;
    if ( format < 0x8C00 )
    {
      if ( format - 33776 >= 2 )
      {
        if ( format - 33778 >= 2 )
          v25 = 4;
        else
LABEL_25:
          v25 = 16;
      }
    }
    else
    {
      switch ( v19->listing.format )
      {
        case 0x8C00u:
        case 0x8C02u:
          goto LABEL_25;
        case 0x8C01u:
        case 0x8C03u:
          v25 = 32;
          break;
        default:
          if ( format != 36196 )
            v25 = 4;
          break;
      }
    }
    v28 = (char *)malloc(((TotalSize + v25 - 1) & -v25) + 64);
    v19->data = v28;
    v19->ownsData = 1;
    v9 = 8;
    v29 = *p_format;
    v30 = *p_dataSize;
    if ( v29 >= 0x8C00 )
    {
      switch ( *p_format )
      {
        case 0x8C00u:
        case 0x8C02u:
          goto LABEL_36;
        case 0x8C01u:
        case 0x8C03u:
          v9 = 32;
          if ( v30 >= 1 )
            goto LABEL_38;
          break;
        default:
          if ( v29 != 36196 )
            v9 = 4;
          if ( v30 >= 1 )
            goto LABEL_38;
          break;
      }
      goto LABEL_47;
    }
    if ( v29 - 33776 >= 2 )
    {
      if ( v29 - 33778 >= 2 )
      {
        v9 = 4;
        if ( v30 >= 1 )
          goto LABEL_38;
        goto LABEL_47;
      }
LABEL_36:
      v9 = 16;
    }
    if ( v30 >= 1 )
    {
LABEL_38:
      v31 = v55;
      v32 = &v28[v30];
      v56 = &v28[v30];
      v57 = v24;
      do
      {
        if ( v24 == *v31 )
        {
          v33 = v31[1];
          if ( v31[1] )
          {
            v34 = v31[1];
            v35 = v28;
            do
            {
              qmemcpy(v35, v31 + 2, v9);
              v35 += v9;
              --v34;
            }
            while ( v34 );
            v28 += (__int16)v9 * v33;
            v36 = v9 | 2;
            v32 = v56;
            v24 = v57;
          }
          else
          {
            v36 = v9 | 2;
          }
        }
        else
        {
          qmemcpy(v28, v31, v9);
          v28 += v9;
          v36 = v9;
        }
        v31 += v36;
      }
      while ( v28 < v32 );
    }
LABEL_47:
    v6 = v54 - v53;
    intoArray = v51;
    this = v52;
    v18 = v58;
    v7 = &v55[v53];
LABEL_48:
    v8 = v18 + 1;
    if ( v8 >= this->entries.numEntries )
      goto LABEL_49;
  }
  if ( v17 != -1 )
  {
    v43 = 0;
    v44 = 0;
    do
    {
      v45 = &v16[v43];
      if ( v16[v43].ownsData )
        free(v45->data);
      v45->data = 0;
      ++v43;
      v45->dataSize = 0;
      ++v44;
      v16 = intoArray->dataPtr;
    }
    while ( v44 < intoArray->numEntries );
  }
LABEL_67:
  v5 = 0;
  intoArray->numEntries = 0;
  if ( v16 )
  {
    free(v16);
    intoArray->dataPtr = 0;
  }
  intoArray->numAlloced = 0;
  free(p);
  return v5;
}

//----- (001E86F8) --------------------------------------------------------
bool __fastcall TextureDatabase::LoadThumbs(TextureDatabase *this, TextureDatabaseFormat forFormat, bool setEntries)
{
  unsigned __int8 s[256]; // [sp+4h] [bp-10Ch] BYREF

  switch ( forFormat )
  {
    case DF_UNC:
      snprintf(s, 0x100u, "texdb/%s/%s.unc.tmb");
      break;
    case DF_DXT:
      snprintf(s, 0x100u, "texdb/%s/%s.dxt.tmb");
      break;
    case DF_360:
      snprintf(s, 0x100u, "texdb/%s/%s.360.tmb");
      break;
    case DF_PS3:
      snprintf(s, 0x100u, "texdb/%s/%s.ps3.tmb");
      break;
    case DF_PVR:
      snprintf(s, 0x100u, "texdb/%s/%s.pvr.tmb");
      break;
    case DF_ETC:
      snprintf(s, 0x100u, "texdb/%s/%s.etc.tmb");
      break;
    default:
      return TextureDatabase::LoadDataFile(this, s, &this->thumbs[forFormat]);
  }
  return TextureDatabase::LoadDataFile(this, s, &this->thumbs[forFormat]);
}

//----- (001E8808) --------------------------------------------------------
void __fastcall TextureDatabase::GetPNGFilename(
        TextureDatabase *this,
        unsigned __int8 *pngBuffer,
        const unsigned __int8 *entryName)
{
  snprintf(pngBuffer, 0x100u, "texdb/%s/src/%s.png", (const char *)this->name, (const char *)entryName);
}

//----- (001E8838) --------------------------------------------------------
int __fastcall TextureDatabase::LoadDataOffsets(
        TextureDatabase *this,
        TextureDatabaseFormat forFormat,
        TDBArray<unsigned int> *offsets,
        OSFile *filePointer,
        int a5)
{
  int v9; // r5
  unsigned int numEntries; // r6
  unsigned int v11; // r5
  unsigned int v12; // r4
  unsigned int *v13; // r0
  unsigned int *dataPtr; // r9
  unsigned int *v15; // r8
  __int64 v16; // r0
  OSFile v17; // r0
  unsigned int v18; // r8
  int v19; // r11
  int v20; // r5
  unsigned int numAlloced; // r0
  unsigned int v22; // r9
  unsigned int v23; // r1
  unsigned int v24; // r4
  void *v25; // r0
  unsigned int *v26; // r6
  size_t v27; // r2
  void *v28; // r9
  OSFileError v29; // r0
  unsigned int v30; // r4
  void *v31; // r0
  unsigned int *v32; // r6
  size_t v33; // r2
  void *v34; // r9
  OSFile v35; // r5
  unsigned int v36; // r0
  OSFile v37; // r5
  unsigned int *v38; // r6
  int v39; // r4
  unsigned int *v40; // r0
  unsigned int v41; // r4
  unsigned int *v42; // r0
  unsigned int *v43; // r5
  unsigned int *v44; // r8
  TextureDatabaseFormat v46; // [sp+4h] [bp-344h]
  TextureDatabase *v47; // [sp+Ch] [bp-33Ch]
  OSFile *intoFile; // [sp+10h] [bp-338h]
  OSFile v49; // [sp+14h] [bp-334h] BYREF
  OSFile file[2]; // [sp+18h] [bp-330h] BYREF
  unsigned int buffer; // [sp+20h] [bp-328h] BYREF
  int v52; // [sp+24h] [bp-324h] BYREF
  unsigned __int8 filename[256]; // [sp+28h] [bp-320h] BYREF
  unsigned __int8 v54[256]; // [sp+128h] [bp-220h] BYREF
  unsigned __int8 s[256]; // [sp+228h] [bp-120h] BYREF

  v9 = 1;
  switch ( forFormat )
  {
    case DF_UNC:
      return v9;
    case DF_DXT:
      snprintf(s, 0x100u, "texdb/%s/%s.dxt");
      goto LABEL_7;
    case DF_360:
      snprintf(s, 0x100u, "texdb/%s/%s.360");
      goto LABEL_7;
    case DF_PS3:
      snprintf(s, 0x100u, "texdb/%s/%s.ps3");
      goto LABEL_7;
    case DF_PVR:
      snprintf(s, 0x100u, "texdb/%s/%s.pvr");
      goto LABEL_7;
    case DF_ETC:
      snprintf(s, 0x100u, "texdb/%s/%s.etc");
      goto LABEL_7;
    default:
LABEL_7:
      intoFile = filePointer;
      snprintf(v54, 0x100u, "%s.dat", (const char *)s);
      snprintf(filename, 0x100u, "%s.toc", (const char *)s);
      v9 = 0;
      if ( OS_FileOpen(OSFDA_Storage_0, filePointer, v54, OSFAT_Read_0) )
        return v9;
      v52 = OS_FileSize(*filePointer);
      offsets->numEntries = 0;
      v47 = this;
      if ( a5 || OS_FileOpen(OSFDA_Storage_0, file, filename, OSFAT_Read_0) )
        goto LABEL_19;
      OS_FileRead(file[0], &buffer, 4);
      if ( buffer == v52 )
      {
        numEntries = offsets->numEntries;
        v11 = this->entries.numEntries;
        if ( offsets->numAlloced < numEntries + v11 )
        {
          v12 = ((3 * (numEntries + v11)) >> 1) + 3;
          if ( v12 != offsets->numAlloced )
          {
            v13 = (unsigned int *)malloc(4 * v12);
            dataPtr = offsets->dataPtr;
            v15 = v13;
            if ( dataPtr )
            {
              memmove(v13, offsets->dataPtr, 4 * numEntries);
              free(dataPtr);
              numEntries = offsets->numEntries;
            }
            offsets->dataPtr = v15;
            offsets->numAlloced = v12;
          }
          this = v47;
        }
        memset(&offsets->dataPtr[numEntries], 0, 4 * v11);
        v16 = *(_QWORD *)&offsets->numEntries;
        offsets->numEntries = v16 + v11;
        OS_FileRead(file[0], (void *)HIDWORD(v16), 4 * this->entries.numEntries);
        v17 = file[0];
        goto LABEL_52;
      }
      OS_FileClose(file[0]);
LABEL_19:
      v46 = forFormat;
      buffer = 0;
      if ( !this->entries.numEntries )
      {
LABEL_41:
        if ( a5 != 1 )
        {
LABEL_53:
          v41 = offsets->numEntries;
          if ( v41 != offsets->numAlloced )
          {
            v42 = (unsigned int *)malloc(4 * v41);
            v43 = offsets->dataPtr;
            v44 = v42;
            if ( v43 )
            {
              memmove(v42, offsets->dataPtr, 4 * v41);
              free(v43);
            }
            offsets->dataPtr = v44;
            offsets->numAlloced = v41;
          }
          return 1;
        }
        OS_FileOpen(OSFDA_Storage_0, &v49, filename, OSFAT_Write_0);
        v35 = v49;
        if ( (v46 | 1) == 3 )
        {
          OS_FileWrite(v49, (char *)&v52 + 3, 1);
          OS_FileWrite(v35, (char *)&v52 + 2, 1);
          OS_FileWrite(v35, (char *)&v52 + 1, 1);
          OS_FileWrite(v35, &v52, 1);
          v36 = this->entries.numEntries;
          if ( 4 * v36 )
          {
            v37 = v49;
            v38 = offsets->dataPtr;
            v39 = -4 * v36;
            do
            {
              OS_FileWrite(v37, (char *)v38 + 3, 1);
              OS_FileWrite(v37, (char *)v38 + 2, 1);
              OS_FileWrite(v37, (char *)v38 + 1, 1);
              OS_FileWrite(v37, v38, 1);
              v39 += 4;
              ++v38;
            }
            while ( v39 );
          }
        }
        else
        {
          OS_FileWrite(v49, &v52, 4);
          OS_FileWrite(v49, offsets->dataPtr, 4 * this->entries.numEntries);
        }
        v17 = v49;
LABEL_52:
        OS_FileClose(v17);
        goto LABEL_53;
      }
      v18 = 0;
      v19 = 10;
      v20 = 0;
      break;
  }
  while ( 1 )
  {
    v22 = offsets->numEntries;
    numAlloced = offsets->numAlloced;
    v23 = v22 + 1;
    if ( (*((_BYTE *)&this->entries.dataPtr->name + v19) & 4) != 0 )
    {
      if ( numAlloced < v23 )
      {
        v30 = ((3 * v23) >> 1) + 3;
        if ( v30 != numAlloced )
        {
          v31 = malloc(4 * v30);
          v32 = offsets->dataPtr;
          if ( v32 )
          {
            v33 = 4 * v22;
            v34 = v31;
            memmove(v31, offsets->dataPtr, v33);
            free(v32);
            v31 = v34;
            v22 = offsets->numEntries;
          }
          filePointer = intoFile;
          offsets->dataPtr = (unsigned int *)v31;
          offsets->numAlloced = v30;
        }
        this = v47;
      }
      offsets->dataPtr[v22] = -1;
      ++offsets->numEntries;
      goto LABEL_40;
    }
    if ( numAlloced < v23 )
    {
      v24 = ((3 * v23) >> 1) + 3;
      if ( v24 != numAlloced )
      {
        v25 = malloc(4 * v24);
        v26 = offsets->dataPtr;
        if ( v26 )
        {
          v27 = 4 * v22;
          v28 = v25;
          memmove(v25, offsets->dataPtr, v27);
          free(v26);
          v25 = v28;
          v22 = offsets->numEntries;
        }
        filePointer = intoFile;
        offsets->dataPtr = (unsigned int *)v25;
        offsets->numAlloced = v24;
      }
      this = v47;
    }
    offsets->dataPtr[v22] = v20;
    ++offsets->numEntries;
    OS_FileSetPosition(*filePointer, v20);
    if ( OS_FileRead(*filePointer, file, 8) )
      break;
    v29 = OS_FileRead(*filePointer, &buffer, 4);
    if ( (v46 | 1) == 3 )
      buffer = bswap32(buffer);
    if ( v29 )
      break;
    v20 += buffer + 12;
LABEL_40:
    ++v18;
    v19 += 23;
    if ( v18 >= this->entries.numEntries )
      goto LABEL_41;
  }
  v40 = offsets->dataPtr;
  v9 = 0;
  offsets->numEntries = 0;
  if ( v40 )
  {
    free(v40);
    offsets->dataPtr = 0;
  }
  offsets->numAlloced = 0;
  OS_FileClose(*filePointer);
  return v9;
}

//----- (001E8C5C) --------------------------------------------------------
int IsLowSpecDevice()
{
  return 0;
}

//----- (001E8C60) --------------------------------------------------------
int GetMaxStorage()
{
  return 47185920;
}

//----- (001E8C68) --------------------------------------------------------
void CheckForPump()
{
  char v0; // r0
  unsigned int v1; // r4

  v0 = `guard variable for'CheckForPump(void)::lastPump;
  __dmb(0xBu);
  if ( (v0 & 1) == 0 && _cxa_guard_acquire((__guard *)&`guard variable for'CheckForPump(void)::lastPump) )
  {
    CheckForPump(void)::lastPump = OS_TimeMS();
    _cxa_guard_release((__guard *)&`guard variable for'CheckForPump(void)::lastPump);
  }
  v1 = OS_TimeMS();
  if ( v1 - CheckForPump(void)::lastPump >= 0x22 )
  {
    if ( CLoadingScreen::m_bActive )
    {
      CLoadingScreen::DisplayPCScreen();
    }
    else if ( bLoadingScene )
    {
      Pump_SwapBuffers();
    }
    CheckForPump(void)::lastPump = v1;
  }
}
// 6BD170: using guessed type char `guard variable for'CheckForPump(void)::lastPump;

//----- (001E8CF8) --------------------------------------------------------
RwRaster *__fastcall TextureListingContainer::CreateRaster(
        const TextureListingContainer *this,
        const TextureDatabaseEntry *forEntry)
{
  int v3; // r3
  __int16 v4; // r2
  unsigned __int16 flags; // r4
  RwInt32 height; // r1
  RwRaster_0 *v8; // r5
  bool v9; // r4
  _BYTE *v10; // r10
  char v11; // r1
  __int16 v12; // r0
  RQTextureFormat RQFormat; // r8
  unsigned int MipCount; // r11
  RQTexture *v15; // r0
  char *data; // r4
  unsigned int width; // r8
  int v18; // r6
  unsigned __int8 *v19; // r0
  RwUInt16 privateFlags; // r1
  unsigned int v21; // r6
  unsigned int MipSize; // r8
  unsigned int v23; // r5
  RQTextureFormat v25; // [sp+4h] [bp-24h]
  RwRaster *v26; // [sp+4h] [bp-24h]
  RwInt32 v27; // [sp+8h] [bp-20h]
  const TextureDatabaseEntry *v28; // [sp+8h] [bp-20h]

  v3 = 1540;
  v4 = *((_WORD *)forEntry + 4);
  flags = forEntry->flags;
  height = forEntry->height;
  if ( (v4 & 0xF) == 7 )
    v3 = 1284;
  if ( (v4 & 0xF0) != 0 )
    v3 = 1284;
  v8 = RwRasterCreate(forEntry->width, height, 32, v3 | (unsigned __int16)(flags << 15));
  v9 = 0;
  v27 = RasterExtOffset;
  v10 = (char *)v8 + RasterExtOffset;
  v11 = 1;
  if ( (*((_WORD *)forEntry + 4) & 0xF0) != 0 )
    v11 = 5;
  v10[20] = v11;
  v12 = *((_WORD *)forEntry + 4);
  v10[21] = 0;
  v10[22] = (v12 & 0xF0) != 0;
  RQFormat = TextureListing::GetRQFormat(&this->listing);
  MipCount = TextureListing::GetMipCount(&this->listing);
  if ( MipCount > 1 )
    v9 = 1;
  v25 = RQFormat;
  v15 = RQTexture::Create(RQFormat, this->listing.width, *((_WORD *)&this->listing + 3) & 0x7FFF, v9);
  *(RwRaster **)((char *)&v8->parent + v27) = (RwRaster *)v15;
  if ( ((this->listing.width + 0xFFFF) & this->listing.width) != 0
    || (((*((_WORD *)&this->listing + 3) & 0x7FFF) + 0x7FFF) & *((_WORD *)&this->listing + 3) & 0x7FFF) != 0 )
  {
    (*((void (__fastcall **)(RQTexture *, int, int))v15->_vptr$RQTexture + 3))(v15, 1, 1);
  }
  else
  {
    (*((void (__fastcall **)(RQTexture *, _DWORD, _DWORD))v15->_vptr$RQTexture + 3))(v15, 0, 0);
  }
  data = (char *)this->data;
  v28 = forEntry;
  if ( (*((_WORD *)forEntry + 4) & 0xF) == 7 )
  {
    width = this->listing.width;
    v18 = *((_WORD *)&this->listing + 3) & 0x7FFF;
    v19 = (unsigned __int8 *)malloc(4 * width * v18);
    privateFlags = v8->privateFlags;
    v8->cpPixels = v19;
    v8->privateFlags = privateFlags | 0x100;
    RQTexture::ConvertToRaw32(v19, (unsigned __int8 *)this->data, width, v18, v25);
  }
  v21 = 0;
  v26 = v8;
  do
  {
    MipSize = TextureListing::GetMipSize(&this->listing, v21);
    (*(void (__fastcall **)(_DWORD, unsigned int, char *))(**(_DWORD **)v10 + 20))(*(_DWORD *)v10, v21, data);
    v23 = v21 + 1;
    if ( MipSize > TextureListing::GetMipSize(&this->listing, v21 + 1) )
      data += TextureListing::GetMipSize(&this->listing, v21);
    ++v21;
  }
  while ( v23 < MipCount );
  (*(void (**)(void))(**(_DWORD **)v10 + 16))();
  v26->dbEntry = (TextureDatabaseEntry *)v28;
  return v26;
}

//----- (001E8E78) --------------------------------------------------------
RwTexture *__fastcall TextureDatabaseEntry::LoadInstance(
        TextureDatabaseEntry *this,
        const TextureListingContainer *container)
{
  RwRaster *Raster; // r5
  RwTexture *instance; // r0
  RwTexture_0 *v5; // r0
  const unsigned __int8 *name; // r1
  unsigned __int16 flags; // r0

  Raster = TextureListingContainer::CreateRaster(container, this);
  instance = this->_anon_0.instance;
  if ( instance )
  {
    RwRasterDestroy(instance->raster);
    this->_anon_0.instance->raster = 0;
    RwTextureSetRaster(this->_anon_0.instance, Raster);
  }
  else
  {
    v5 = RwTextureCreate(Raster);
    name = this->name;
    this->_anon_0.instance = v5;
    RwTextureSetName(v5, name);
  }
  flags = this->flags;
  if ( (flags & 8) != 0 )
  {
    Raster->privateFlags |= 0x80u;
    (*(void (__fastcall **)(_DWORD, int))(**(_DWORD **)((char *)&Raster->parent + RasterExtOffset) + 8))(
      *(RwRaster **)((char *)&Raster->parent + RasterExtOffset),
      1);
    flags = this->flags;
  }
  if ( (flags & 0x20) != 0 && this->detailTexture )
  {
    Raster->privateFlags |= 0x40u;
    flags = this->flags;
  }
  if ( (flags & 0x40) != 0 )
  {
    Raster->privateFlags |= 0x20u;
    flags = this->flags;
  }
  if ( (flags & 0x80) != 0 )
  {
    Raster->privateFlags |= 0x10u;
    flags = this->flags;
  }
  if ( (flags & 0x100) != 0 )
  {
    Raster->privateFlags |= 0x200u;
    flags = this->flags;
  }
  if ( (flags & 0x200) != 0 )
    Raster->privateFlags |= 0x400u;
  return this->_anon_0.instance;
}

//----- (001E8F30) --------------------------------------------------------
RwTexture *__fastcall TextureDatabaseEntry::LoadPNG(TextureDatabaseEntry *this, const unsigned __int8 *filename)
{
  RwImage_0 *v3; // r5
  RwRaster_0 *v4; // r6
  RwTexture *instance; // r0
  RwTexture_0 *v6; // r0
  const unsigned __int8 *name; // r1
  RwInt32 v9; // [sp+8h] [bp-20h] BYREF
  RwInt32 npDepth; // [sp+Ch] [bp-1Ch] BYREF
  RwInt32 npHeight; // [sp+10h] [bp-18h] BYREF
  RwInt32 npWidth[5]; // [sp+14h] [bp-14h] BYREF

  v3 = RtPNGImageRead(filename);
  RwImageFindRasterFormat(v3, 4, npWidth, &npHeight, &npDepth, &v9);
  v4 = RwRasterCreate(npWidth[0], npHeight, npDepth, v9);
  RwRasterSetFromImage(v4, v3);
  v4->dbEntry = this;
  instance = this->_anon_0.instance;
  if ( instance )
  {
    RwRasterDestroy(instance->raster);
    this->_anon_0.instance->raster = 0;
    RwTextureSetRaster(this->_anon_0.instance, v4);
  }
  else
  {
    v6 = RwTextureCreate(v4);
    name = this->name;
    this->_anon_0.instance = v6;
    RwTextureSetName(v6, name);
  }
  RwImageDestroy(v3);
  return this->_anon_0.instance;
}
// 1E8F30: using guessed type RwInt32 npWidth[5];

//----- (001E8FB0) --------------------------------------------------------
unsigned int __fastcall TextureDatabaseEntry::Delete(TextureDatabaseEntry *this)
{
  unsigned int v2; // r5
  RwTexture *instance; // r0
  __int64 v4; // kr00_8

  v2 = 0;
  instance = this->_anon_0.instance;
  if ( instance->refCount == 1 )
  {
    v4 = *(_QWORD *)&(*(RwRaster **)((char *)&instance->raster->parent + RasterExtOffset))->cpPixels;
    instance->refCount = 0;
    TextureAnnihilate(this->_anon_0.instance);
    this->_anon_0.instance = 0;
    return HIDWORD(v4) * v4;
  }
  return v2;
}

//----- (001E8FF8) --------------------------------------------------------
int __fastcall TextureDatabaseRuntime::GetEntry(
        TextureDatabaseRuntime *this,
        const unsigned __int8 *name,
        bool *hasSibling)
{
  unsigned int v5; // r0
  unsigned int *dataPtr; // r4
  unsigned int v7; // r6
  unsigned int v8; // r1
  unsigned int v9; // r2
  unsigned int v10; // r1
  unsigned int v11; // r0
  TextureDatabaseEntry *v12; // r3
  TextureDatabaseEntry *v13; // r1
  int result; // r0
  unsigned int v15; // r0
  unsigned int *v16; // r4
  unsigned int v17; // r1

  v5 = HashString(name);
  dataPtr = this->hashOffsets.dataPtr;
  v7 = v5;
  v8 = v5 % this->numHashes;
  v9 = dataPtr[v8];
  v10 = dataPtr[v8 + 1];
  if ( v9 >= v10 )
    return -1;
  do
  {
    v11 = v9;
    v12 = this->entries.dataPtr;
    while ( v12[v11].nameHash != v7 )
    {
      ++v9;
      ++v11;
      if ( v9 >= v10 )
        return -1;
    }
    *hasSibling |= (v12[v11].flags & 2) != 0;
    v13 = &this->entries.dataPtr[v11];
    result = v9;
    if ( (v13->flags & 4) == 0 )
      break;
    v15 = HashString(v13->_anon_0.matchingName);
    v16 = this->hashOffsets.dataPtr;
    v7 = v15;
    v17 = v15 % this->numHashes;
    v9 = v16[v17];
    v10 = v16[v17 + 1];
    result = -1;
  }
  while ( v9 < v10 );
  return result;
}

//----- (001E9090) --------------------------------------------------------
RwTexture *__fastcall TextureDatabaseRuntime::GetRWTexture(TextureDatabaseRuntime *this, int entryNum)
{
  TextureDatabaseEntry *v4; // r0
  unsigned int v5; // r1
  RwTexture **p_instance; // r6
  unsigned int numEntries; // r0
  unsigned int *dataPtr; // r1
  int v10; // r2

  if ( entryNum == -1 )
    return 0;
  v4 = &this->entries.dataPtr[entryNum];
  v5 = *((unsigned __int16 *)v4 + 4);
  p_instance = &v4->_anon_0.instance;
  if ( !v4->_anon_0.instance )
  {
    if ( (v5 & 0xF00) == 256 )
    {
      TextureDatabaseRuntime::storedTexels += TextureDatabaseRuntime::LoadFullTexture(this, entryNum);
      return *p_instance;
    }
    TextureDatabaseEntry::LoadInstance(v4, &this->thumbs[this->loadedFormat].dataPtr[entryNum]);
LABEL_15:
    TextureDatabaseRuntime::StreamFullTexture(this, entryNum);
    return *p_instance;
  }
  if ( v5 >> 12 == 5 )
  {
    numEntries = this->deletionQueue.numEntries;
    if ( numEntries )
    {
      dataPtr = this->deletionQueue.dataPtr;
      v10 = 0;
      while ( dataPtr[v10] != entryNum )
      {
        if ( ++v10 >= numEntries )
          return *p_instance;
      }
      dataPtr[v10] = dataPtr[numEntries - 1];
      --this->deletionQueue.numEntries;
    }
    return *p_instance;
  }
  if ( v5 >> 12 == 4 )
    goto LABEL_15;
  return *p_instance;
}

//----- (001E9148) --------------------------------------------------------
unsigned int __fastcall TextureDatabaseRuntime::LoadFullTexture(TextureDatabaseRuntime *this, unsigned int entryIndex)
{
  int v4; // r4
  void *v5; // r11
  unsigned int RLESegSize; // r0
  unsigned int dataSize; // r4
  unsigned int v8; // r6
  void *v9; // r8
  unsigned int v10; // r0
  TextureDatabaseEntry **p_dataPtr; // r9
  int v12; // r5
  unsigned int v13; // r6
  void *v14; // r4
  TextureDatabaseEntry *v15; // r0
  TextureDatabaseEntry *dataPtr; // t1
  __int64 v17; // r0
  TextureListingContainer v19; // [sp+8h] [bp-140h] BYREF
  int v20; // [sp+20h] [bp-128h] BYREF
  int v21; // [sp+24h] [bp-124h] BYREF
  TextureListingContainer buffer[15]; // [sp+28h] [bp-120h] BYREF

  if ( this->loadedFormat )
  {
    OS_FileSetPosition(this->streamFile, this->fullDataOffsets.dataPtr[entryIndex]);
    OS_FileRead(this->streamFile, buffer, 8);
    buffer[0].dataSize = TextureListing::GetTotalSize(&buffer[0].listing);
    buffer[0].ownsData = 1;
    v20 = 0;
    v21 = 0;
    OS_FileRead(this->streamFile, &v21, 4);
    OS_FileRead(this->streamFile, &v20, 4);
    if ( v20 )
    {
      v4 = v21 - 4;
      v5 = malloc(v21 - 4);
      OS_FileRead(this->streamFile, v5, v4);
      RLESegSize = TextureListing::GetRLESegSize(&buffer[0].listing);
      dataSize = buffer[0].dataSize;
      v8 = ((-RLESegSize & (RLESegSize + buffer[0].dataSize - 1)) + 3) & 0xFFFFFFFC;
      v9 = malloc(v8);
      buffer[0].data = v9;
      memset(v9, 0, v8);
      v10 = TextureListing::GetRLESegSize(&buffer[0].listing);
      RLEDecompress((unsigned __int8 *)v9, dataSize, (const unsigned __int8 *)v5, v10, v20);
      free(v5);
    }
    else
    {
      v12 = buffer[0].dataSize;
      v13 = (buffer[0].dataSize + 3) & 0xFFFFFFFC;
      v14 = malloc(v13);
      buffer[0].data = v14;
      memset(v14, 0, v13);
      OS_FileRead(this->streamFile, v14, v12);
    }
    if ( *((__int16 *)&buffer[0].listing + 3) > -1
      || !RQCaps[8]
      || buffer[0].listing.width < 5u
      || (v15 = &this->entries.dataPtr[entryIndex], this->categories.dataPtr[v15->category].onFootPriority == 10)
      || (*((_WORD *)v15 + 4) & 0xF) == 7 )
    {
      dataPtr = this->entries.dataPtr;
      p_dataPtr = &this->entries.dataPtr;
      TextureDatabaseEntry::LoadInstance(&dataPtr[entryIndex], buffer);
    }
    else
    {
      *(_DWORD *)&v19.listing.nameHash = *(_DWORD *)&buffer[0].listing.nameHash;
      *(_QWORD *)&v19.data = *(_QWORD *)&buffer[0].data;
      v19.ownsData = 0;
      v19.listing.width = buffer[0].listing.width >> 1;
      *((_WORD *)&v19.listing + 3) = *((_WORD *)&buffer[0].listing + 3) & 0x8000 | (*((_WORD *)&buffer[0].listing + 3) >> 1) & 0x3FFF;
      v19.dataSize = TextureListing::GetTotalSize(&v19.listing);
      v19.data = (char *)v19.data + buffer[0].dataSize - v19.dataSize;
      TextureDatabaseEntry::LoadInstance(&this->entries.dataPtr[entryIndex], &v19);
      TextureListingContainer::~TextureListingContainer(&v19);
      p_dataPtr = &this->entries.dataPtr;
    }
    TextureListingContainer::~TextureListingContainer(buffer);
  }
  else
  {
    TextureDatabase::GetPNGFilename(this, (unsigned __int8 *)buffer, this->entries.dataPtr[entryIndex].name);
    TextureDatabaseEntry::LoadPNG(&this->entries.dataPtr[entryIndex], (const unsigned __int8 *)buffer);
    p_dataPtr = &this->entries.dataPtr;
  }
  *((_WORD *)&(*p_dataPtr)[entryIndex] + 4) = *((_WORD *)&(*p_dataPtr)[entryIndex] + 4) & 0xFFF | 0x3000;
  v17 = *(_QWORD *)&(*(RwRaster **)((char *)&(*p_dataPtr)[entryIndex]._anon_0.instance->raster->parent + RasterExtOffset))->cpPixels;
  return v17 * HIDWORD(v17);
}

//----- (001E9374) --------------------------------------------------------
void __fastcall TextureDatabaseRuntime::StreamFullTexture(TextureDatabaseRuntime *this, unsigned int entryIndex)
{
  unsigned int numAlloced; // r0
  unsigned int numEntries; // r6
  unsigned int v6; // r10
  unsigned int *v7; // r0
  unsigned int *dataPtr; // r9
  unsigned int *v9; // r8
  __int64 v10; // r0
  __int16 v11; // r0
  unsigned int v12; // r0
  unsigned int v13; // r6
  unsigned int v14; // r10
  unsigned int *v15; // r0
  unsigned int *v16; // r9
  unsigned int *v17; // r8

  if ( (*((_WORD *)&this->entries.dataPtr[entryIndex] + 4) & 0xF00) == 512 )
  {
    numEntries = this->priorityStreamingQueue.numEntries;
    numAlloced = this->priorityStreamingQueue.numAlloced;
    if ( numAlloced < numEntries + 1 )
    {
      v6 = ((3 * (numEntries + 1)) >> 1) + 3;
      if ( v6 != numAlloced )
      {
        v7 = (unsigned int *)malloc(4 * v6);
        dataPtr = this->priorityStreamingQueue.dataPtr;
        v9 = v7;
        if ( dataPtr )
        {
          memmove(v7, this->priorityStreamingQueue.dataPtr, 4 * numEntries);
          free(dataPtr);
          numEntries = this->priorityStreamingQueue.numEntries;
        }
        this->priorityStreamingQueue.dataPtr = v9;
        this->priorityStreamingQueue.numAlloced = v6;
      }
    }
    memmove(this->priorityStreamingQueue.dataPtr + 1, this->priorityStreamingQueue.dataPtr, 4 * numEntries);
    v10 = *(_QWORD *)&this->priorityStreamingQueue.numEntries;
    this->priorityStreamingQueue.numEntries = v10 + 1;
    *(_DWORD *)HIDWORD(v10) = 0;
    *this->priorityStreamingQueue.dataPtr = entryIndex;
    v11 = 0x2000;
  }
  else
  {
    v13 = this->unrenderedStreamingQueue.numEntries;
    v12 = this->unrenderedStreamingQueue.numAlloced;
    if ( v12 < v13 + 1 )
    {
      v14 = ((3 * (v13 + 1)) >> 1) + 3;
      if ( v14 != v12 )
      {
        v15 = (unsigned int *)malloc(4 * v14);
        v16 = this->unrenderedStreamingQueue.dataPtr;
        v17 = v15;
        if ( v16 )
        {
          memmove(v15, this->unrenderedStreamingQueue.dataPtr, 4 * v13);
          free(v16);
          v13 = this->unrenderedStreamingQueue.numEntries;
        }
        this->unrenderedStreamingQueue.dataPtr = v17;
        this->unrenderedStreamingQueue.numAlloced = v14;
      }
    }
    this->unrenderedStreamingQueue.dataPtr[v13] = entryIndex;
    ++this->unrenderedStreamingQueue.numEntries;
    v11 = 4096;
  }
  *((_WORD *)&this->entries.dataPtr[entryIndex] + 4) = v11 | *((_WORD *)&this->entries.dataPtr[entryIndex] + 4) & 0xFFF;
}

//----- (001E9474) --------------------------------------------------------
void __fastcall TextureDatabaseRuntime::CancelDeletion(TextureDatabaseRuntime *this, unsigned int index)
{
  unsigned int numEntries; // r12
  unsigned int *dataPtr; // lr
  int v4; // r2

  numEntries = this->deletionQueue.numEntries;
  if ( numEntries )
  {
    dataPtr = this->deletionQueue.dataPtr;
    v4 = 0;
    while ( dataPtr[v4] != index )
    {
      if ( ++v4 >= numEntries )
        return;
    }
    dataPtr[v4] = dataPtr[numEntries - 1];
    --this->deletionQueue.numEntries;
  }
}

//----- (001E94B4) --------------------------------------------------------
void __fastcall TextureDatabaseRuntime::FullyLoad(TextureDatabaseRuntime *this)
{
  unsigned int numEntries; // r0
  int v3; // r6
  unsigned int i; // r5
  TextureDatabaseEntry *dataPtr; // r1

  numEntries = this->entries.numEntries;
  if ( numEntries )
  {
    v3 = 0;
    for ( i = 0; i < numEntries; ++i )
    {
      dataPtr = this->entries.dataPtr;
      if ( (dataPtr[v3].flags & 4) == 0 )
      {
        if ( (*((_WORD *)&dataPtr[v3] + 4) & 0xF000) != 12288 )
        {
          TextureDatabaseRuntime::storedTexels += TextureDatabaseRuntime::LoadFullTexture(this, i);
          dataPtr = this->entries.dataPtr;
        }
        ++dataPtr[v3]._anon_0.instance->refCount;
        numEntries = this->entries.numEntries;
      }
      ++v3;
    }
  }
}

//----- (001E9518) --------------------------------------------------------
void __fastcall TextureDatabaseRuntime::UpdateStreaming(float deltaTime, bool flush)
{
  _BOOL4 v2; // r5
  float v4; // s2
  int *v5; // r1
  unsigned int v6; // r0
  int v7; // r6
  int v8; // r10
  _BOOL4 v9; // r0
  signed int v10; // r4
  unsigned int v11; // r1
  unsigned int v12; // r0
  unsigned int v13; // r1
  int v14; // r0
  unsigned int numEntries; // r0
  int v16; // r4
  int v17; // r1
  int v18; // r8
  unsigned int v19; // r9
  TextureDatabaseRuntime *v20; // r5
  TDBArray<unsigned int> *p_unrenderedStreamingQueue; // r10
  unsigned int v22; // r2
  unsigned int i; // r11
  unsigned int *dataPtr; // r0
  unsigned int v25; // r6
  bool v26; // cc
  unsigned int v27; // r4
  _BOOL4 v28; // [sp+Ch] [bp-24h]
  int v29; // [sp+10h] [bp-20h]

  v2 = flush;
  if ( RQCaps[14] )
  {
    v4 = 225280.0;
  }
  else
  {
    v5 = dword_1E9744;
    if ( RQCaps[13] )
      v5 = &dword_1E9744[1];
    v4 = *(float *)v5;
  }
  v6 = TextureDatabaseRuntime::storedTexels;
  v7 = TextureDatabaseRuntime::UpdateStreaming(float,bool)::texelOverrun + (int)(float)(v4 * deltaTime);
  if ( (int)TextureDatabaseRuntime::storedTexels > 47185920 || v2 )
  {
    if ( v7 > 0 )
      v6 = TextureDatabaseRuntime::storedTexels + 2 * v7;
    v8 = v6 - 47185920;
    v9 = (int)(v6 - 47185920) > 0;
    v10 = TextureDatabaseRuntime::loaded.numEntries - 1;
    if ( (signed int)(TextureDatabaseRuntime::loaded.numEntries - 1) >= 0 && (v9 || v2) )
    {
      do
      {
        v11 = v8;
        if ( v2 )
          v11 = 47185920;
        v12 = TextureDatabaseRuntime::DeleteTextures(TextureDatabaseRuntime::loaded.dataPtr[v10], v11);
        v8 -= v12;
        --v10;
        v13 = TextureDatabaseRuntime::storedTexels - v12;
        v14 = 0;
        TextureDatabaseRuntime::storedTexels = v13;
        if ( v8 > 0 )
          v14 = 1;
      }
      while ( v10 >= 0 && v14 | v2 );
    }
  }
  numEntries = TextureDatabaseRuntime::loaded.numEntries;
  if ( TextureDatabaseRuntime::loaded.numEntries )
  {
    v16 = 0;
    v28 = v2;
    do
    {
      v17 = 0;
      v18 = numEntries - 1;
      if ( v7 > 0 )
        v17 = 1;
      if ( v18 >= 0 && (v17 | v2) == 1 )
      {
        while ( 1 )
        {
          v19 = v7;
          if ( v2 )
            v19 = 47185920;
          v20 = TextureDatabaseRuntime::loaded.dataPtr[v18];
          v29 = v7;
          if ( v16 == 2 )
          {
            p_unrenderedStreamingQueue = &v20->unrenderedStreamingQueue;
          }
          else if ( v16 == 1 )
          {
            p_unrenderedStreamingQueue = &v20->renderedStreamingQueue;
          }
          else if ( v16 )
          {
            p_unrenderedStreamingQueue = 0;
          }
          else
          {
            p_unrenderedStreamingQueue = &v20->priorityStreamingQueue;
          }
          OS_TimeMS();
          v22 = p_unrenderedStreamingQueue->numEntries;
          for ( i = 0; v22; v22 = p_unrenderedStreamingQueue->numEntries )
          {
            dataPtr = p_unrenderedStreamingQueue->dataPtr;
            if ( v16 == 2 )
            {
              v25 = dataPtr[v22 - 1];
            }
            else
            {
              v25 = *dataPtr;
              memmove(dataPtr, dataPtr + 1, 4 * v22 - 4);
              v22 = p_unrenderedStreamingQueue->numEntries;
            }
            p_unrenderedStreamingQueue->numEntries = v22 - 1;
            i += TextureDatabaseRuntime::LoadFullTexture(v20, v25);
            v26 = v19 > 0x2D00000;
            if ( v19 != 47185920 )
              v26 = i > v19;
            if ( v26 )
              break;
            CheckForPump();
          }
          --v18;
          v7 = v29 - i;
          TextureDatabaseRuntime::storedTexels += i;
          if ( v18 < 0 )
            break;
          v2 = v28;
          if ( (int)(v29 - i) <= 0 && !v28 )
            goto LABEL_47;
        }
        v2 = v28;
      }
LABEL_47:
      ++v16;
      numEntries = TextureDatabaseRuntime::loaded.numEntries;
    }
    while ( v16 != 3 );
    if ( TextureDatabaseRuntime::loaded.numEntries )
    {
      v27 = 0;
      do
        TextureDatabaseRuntime::MarkTexturesAsUnrendered(TextureDatabaseRuntime::loaded.dataPtr[v27++]);
      while ( v27 < TextureDatabaseRuntime::loaded.numEntries );
    }
    if ( v7 <= -1 && !v2 )
      TextureDatabaseRuntime::UpdateStreaming(float,bool)::texelOverrun = v7;
  }
}
// 1E9744: using guessed type int dword_1E9744[2];

//----- (001E9778) --------------------------------------------------------
unsigned int __fastcall TextureDatabaseRuntime::DeleteTextures(TextureDatabaseRuntime *this, unsigned int toDelete)
{
  unsigned int numEntries; // r3
  bool v4; // zf
  unsigned int result; // r0
  TextureDatabaseEntry *dataPtr; // r1
  unsigned int v7; // r8
  TextureDatabaseEntry *v8; // r9
  RwTexture *v9; // r0
  RwTexture_0 **p_instance; // r9
  RwTexture *instance; // t1
  __int64 v12; // r10
  int v13; // r3
  unsigned int v15; // [sp+4h] [bp-24h]

  v4 = toDelete == 0;
  if ( toDelete )
  {
    numEntries = this->deletionQueue.numEntries;
    v4 = numEntries == 0;
  }
  result = 0;
  if ( !v4 )
  {
    result = 0;
    while ( 1 )
    {
      v15 = result;
      while ( 1 )
      {
        dataPtr = this->entries.dataPtr;
        v7 = this->deletionQueue.dataPtr[numEntries - 1];
        this->deletionQueue.numEntries = numEntries - 1;
        v8 = &dataPtr[v7];
        instance = v8->_anon_0.instance;
        p_instance = &v8->_anon_0.instance;
        v9 = instance;
        if ( instance->refCount == 1 )
          break;
LABEL_9:
        *((_WORD *)&dataPtr[v7] + 4) = *((_WORD *)&dataPtr[v7] + 4) & 0xFFF | 0x3000;
        numEntries = this->deletionQueue.numEntries;
        if ( !numEntries )
          return v15;
      }
      v12 = *(_QWORD *)&(*(RwRaster **)((char *)&v9->raster->parent + RasterExtOffset))->cpPixels;
      v9->refCount = 0;
      TextureAnnihilate(*p_instance);
      v13 = HIDWORD(v12) * v12;
      *p_instance = 0;
      if ( !(HIDWORD(v12) * (_DWORD)v12) )
        break;
      *((_WORD *)&this->entries.dataPtr[v7] + 4) &= 0xFFFu;
      result = v15 + v13;
      if ( v15 + v13 < toDelete )
      {
        numEntries = this->deletionQueue.numEntries;
        if ( numEntries )
          continue;
      }
      return result;
    }
    dataPtr = this->entries.dataPtr;
    goto LABEL_9;
  }
  return result;
}
// 1E97AA: variable 'numEntries' is possibly undefined

//----- (001E9834) --------------------------------------------------------
unsigned int __fastcall TextureDatabaseRuntime::UpdateTextureStreaming(
        TextureDatabaseRuntime *this,
        unsigned int toStream,
        unsigned int priorityClass)
{
  TDBArray<unsigned int> *p_unrenderedStreamingQueue; // r5
  unsigned int numEntries; // r2
  unsigned int i; // r6
  unsigned int *dataPtr; // r0
  unsigned int v10; // r4
  bool v11; // cc

  if ( priorityClass == 2 )
  {
    p_unrenderedStreamingQueue = &this->unrenderedStreamingQueue;
  }
  else if ( priorityClass == 1 )
  {
    p_unrenderedStreamingQueue = &this->renderedStreamingQueue;
  }
  else if ( priorityClass )
  {
    p_unrenderedStreamingQueue = 0;
  }
  else
  {
    p_unrenderedStreamingQueue = &this->priorityStreamingQueue;
  }
  OS_TimeMS();
  numEntries = p_unrenderedStreamingQueue->numEntries;
  for ( i = 0; numEntries; numEntries = p_unrenderedStreamingQueue->numEntries )
  {
    dataPtr = p_unrenderedStreamingQueue->dataPtr;
    if ( priorityClass == 2 )
    {
      v10 = dataPtr[numEntries - 1];
    }
    else
    {
      v10 = *dataPtr;
      memmove(dataPtr, dataPtr + 1, 4 * numEntries - 4);
      numEntries = p_unrenderedStreamingQueue->numEntries;
    }
    p_unrenderedStreamingQueue->numEntries = numEntries - 1;
    i += TextureDatabaseRuntime::LoadFullTexture(this, v10);
    v11 = toStream > 0x2D00000;
    if ( toStream != 47185920 )
      v11 = i > toStream;
    if ( v11 )
      break;
    CheckForPump();
  }
  return i;
}

//----- (001E98C6) --------------------------------------------------------
void __fastcall TextureDatabaseRuntime::MarkTexturesAsUnrendered(TextureDatabaseRuntime *this)
{
  unsigned int v2; // r0
  unsigned int v3; // r6
  unsigned int numEntries; // r6
  __int64 v5; // kr00_8
  unsigned int v6; // r5
  unsigned int v7; // r11
  unsigned int *v8; // r0
  unsigned int *dataPtr; // r9
  unsigned int *v10; // r8

  if ( this->renderedStreamingQueue.numEntries )
  {
    v2 = 0;
    do
    {
      v3 = this->renderedStreamingQueue.dataPtr[v2++];
      *((_WORD *)&this->entries.dataPtr[v3] + 4) = *((_WORD *)&this->entries.dataPtr[v3] + 4) & 0xFFF | 0x1000;
      numEntries = this->renderedStreamingQueue.numEntries;
    }
    while ( v2 < numEntries );
    if ( numEntries )
    {
      v5 = *(_QWORD *)&this->renderedStreamingQueue.dataPtr;
      v6 = this->unrenderedStreamingQueue.numEntries;
      if ( HIDWORD(v5) < v6 + numEntries )
      {
        v7 = ((3 * (v6 + numEntries)) >> 1) + 3;
        if ( v7 != HIDWORD(v5) )
        {
          v8 = (unsigned int *)malloc(4 * v7);
          dataPtr = this->unrenderedStreamingQueue.dataPtr;
          v10 = v8;
          if ( dataPtr )
          {
            memmove(v8, this->unrenderedStreamingQueue.dataPtr, 4 * v6);
            free(dataPtr);
            v6 = this->unrenderedStreamingQueue.numEntries;
          }
          this->unrenderedStreamingQueue.dataPtr = v10;
          this->unrenderedStreamingQueue.numAlloced = v7;
        }
      }
      memmove(&this->unrenderedStreamingQueue.dataPtr[v6], (const void *)v5, 4 * numEntries);
      this->unrenderedStreamingQueue.numEntries += numEntries;
    }
    this->renderedStreamingQueue.numEntries = 0;
  }
}

//----- (001E9978) --------------------------------------------------------
int __fastcall textureCompare(const void *a, const void *b)
{
  unsigned int v2; // r2
  int result; // r0

  v2 = *(_DWORD *)(4 * *(_DWORD *)a);
  result = 1;
  if ( v2 < *(_DWORD *)(4 * *(_DWORD *)b) )
    return -1;
  return result;
}

//----- (001E9994) --------------------------------------------------------
void __fastcall TextureDatabaseRuntime::SetAsRendered(TextureDatabaseRuntime *this, unsigned int index)
{
  unsigned int numEntries; // r0
  unsigned int *dataPtr; // r1
  int v6; // r2
  unsigned int numAlloced; // r0
  unsigned int v8; // r6
  unsigned int v9; // r10
  unsigned int *v10; // r0
  unsigned int *v11; // r9
  unsigned int *v12; // r8

  numEntries = this->unrenderedStreamingQueue.numEntries;
  if ( numEntries )
  {
    dataPtr = this->unrenderedStreamingQueue.dataPtr;
    v6 = 0;
    while ( dataPtr[v6] != index )
    {
      if ( ++v6 >= numEntries )
        goto LABEL_8;
    }
    if ( v6 >= 0 )
    {
      dataPtr[v6] = dataPtr[numEntries - 1];
      --this->unrenderedStreamingQueue.numEntries;
    }
  }
LABEL_8:
  v8 = this->renderedStreamingQueue.numEntries;
  numAlloced = this->renderedStreamingQueue.numAlloced;
  if ( numAlloced < v8 + 1 )
  {
    v9 = ((3 * (v8 + 1)) >> 1) + 3;
    if ( v9 != numAlloced )
    {
      v10 = (unsigned int *)malloc(4 * v9);
      v11 = this->renderedStreamingQueue.dataPtr;
      v12 = v10;
      if ( v11 )
      {
        memmove(v10, this->renderedStreamingQueue.dataPtr, 4 * v8);
        free(v11);
        v8 = this->renderedStreamingQueue.numEntries;
      }
      this->renderedStreamingQueue.dataPtr = v12;
      this->renderedStreamingQueue.numAlloced = v9;
    }
  }
  this->renderedStreamingQueue.dataPtr[v8] = index;
  ++this->renderedStreamingQueue.numEntries;
}

//----- (001E9A36) --------------------------------------------------------
void __fastcall TextureDatabaseRuntime::StopStreaming(TextureDatabaseRuntime *this, unsigned int index)
{
  unsigned int numEntries; // r12
  unsigned int *dataPtr; // lr
  int v4; // r2
  unsigned int v5; // r12
  unsigned int *v6; // lr
  int v7; // r2
  unsigned int v8; // r12
  unsigned int *v9; // lr
  int v10; // r2

  numEntries = this->unrenderedStreamingQueue.numEntries;
  if ( numEntries )
  {
    dataPtr = this->unrenderedStreamingQueue.dataPtr;
    v4 = 0;
    while ( dataPtr[v4] != index )
    {
      if ( ++v4 >= numEntries )
        goto LABEL_7;
    }
    dataPtr[v4] = dataPtr[numEntries - 1];
    --this->unrenderedStreamingQueue.numEntries;
  }
LABEL_7:
  v5 = this->renderedStreamingQueue.numEntries;
  if ( v5 )
  {
    v6 = this->renderedStreamingQueue.dataPtr;
    v7 = 0;
    while ( v6[v7] != index )
    {
      if ( ++v7 >= v5 )
        goto LABEL_13;
    }
    v6[v7] = v6[v5 - 1];
    --this->renderedStreamingQueue.numEntries;
  }
LABEL_13:
  v8 = this->priorityStreamingQueue.numEntries;
  if ( v8 )
  {
    v9 = this->priorityStreamingQueue.dataPtr;
    v10 = 0;
    while ( v9[v10] != index )
    {
      if ( ++v10 >= v8 )
        return;
    }
    v9[v10] = v9[v8 - 1];
    --this->priorityStreamingQueue.numEntries;
  }
}

//----- (001E9ADC) --------------------------------------------------------
void __fastcall TextureDatabaseRuntime::QueueForDeletion(TextureDatabaseRuntime *this, unsigned int index)
{
  unsigned int numAlloced; // r0
  unsigned int numEntries; // r6
  unsigned int v6; // r10
  unsigned int *v7; // r0
  unsigned int *dataPtr; // r9
  unsigned int *v9; // r8

  numEntries = this->deletionQueue.numEntries;
  numAlloced = this->deletionQueue.numAlloced;
  if ( numAlloced < numEntries + 1 )
  {
    v6 = ((3 * (numEntries + 1)) >> 1) + 3;
    if ( v6 != numAlloced )
    {
      v7 = (unsigned int *)malloc(4 * v6);
      dataPtr = this->deletionQueue.dataPtr;
      v9 = v7;
      if ( dataPtr )
      {
        memmove(v7, this->deletionQueue.dataPtr, 4 * numEntries);
        free(dataPtr);
        numEntries = this->deletionQueue.numEntries;
      }
      this->deletionQueue.dataPtr = v9;
      this->deletionQueue.numAlloced = v6;
    }
  }
  this->deletionQueue.dataPtr[numEntries] = index;
  ++this->deletionQueue.numEntries;
}

//----- (001E9B48) --------------------------------------------------------
void __fastcall TextureDatabaseRuntime::Register(TextureDatabaseRuntime *toRegister)
{
  unsigned int numEntries; // r5
  int v3; // r1
  unsigned int v4; // r6
  void *v5; // r8
  TextureDatabaseRuntime **dataPtr; // r9

  numEntries = TextureDatabaseRuntime::registered.numEntries;
  if ( TextureDatabaseRuntime::registered.numEntries )
  {
    v3 = 0;
    while ( TextureDatabaseRuntime::registered.dataPtr[v3] != toRegister )
    {
      if ( ++v3 >= TextureDatabaseRuntime::registered.numEntries )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    if ( TextureDatabaseRuntime::registered.numAlloced < TextureDatabaseRuntime::registered.numEntries + 1 )
    {
      v4 = ((3 * (TextureDatabaseRuntime::registered.numEntries + 1)) >> 1) + 3;
      if ( v4 != TextureDatabaseRuntime::registered.numAlloced )
      {
        v5 = malloc(4 * v4);
        dataPtr = TextureDatabaseRuntime::registered.dataPtr;
        if ( TextureDatabaseRuntime::registered.dataPtr )
        {
          memmove(v5, TextureDatabaseRuntime::registered.dataPtr, 4 * numEntries);
          free(dataPtr);
          numEntries = TextureDatabaseRuntime::registered.numEntries;
        }
        TextureDatabaseRuntime::registered.dataPtr = (TextureDatabaseRuntime **)v5;
        TextureDatabaseRuntime::registered.numAlloced = v4;
      }
    }
    TextureDatabaseRuntime::registered.dataPtr[numEntries] = toRegister;
    ++TextureDatabaseRuntime::registered.numEntries;
  }
}

//----- (001E9C00) --------------------------------------------------------
void __fastcall TextureDatabaseRuntime::Unregister(TextureDatabaseRuntime *toUnregister)
{
  size_t v1; // r2
  TextureDatabaseRuntime **dataPtr; // lr
  unsigned int v3; // r1

  if ( TextureDatabaseRuntime::registered.numEntries )
  {
    v1 = 4 * TextureDatabaseRuntime::registered.numEntries - 4;
    dataPtr = TextureDatabaseRuntime::registered.dataPtr;
    v3 = 0;
    while ( *dataPtr != toUnregister )
    {
      ++v3;
      ++dataPtr;
      v1 -= 4;
      if ( v3 >= TextureDatabaseRuntime::registered.numEntries )
        return;
    }
    memmove(dataPtr, dataPtr + 1, v1);
    --TextureDatabaseRuntime::registered.numEntries;
  }
}

//----- (001E9C64) --------------------------------------------------------
RwTexture *__fastcall TextureDatabaseRuntime::GetTexture(const unsigned __int8 *name)
{
  unsigned int v2; // r6
  int v3; // r4
  int v4; // r5
  int Entry; // r0
  unsigned int v6; // r6
  int v7; // r0
  bool hasSibling; // [sp+Bh] [bp-9Dh] BYREF
  unsigned __int8 s[128]; // [sp+Ch] [bp-9Ch] BYREF

  v2 = 0;
  if ( TextureDatabaseRuntime::registered.numEntries )
  {
    v3 = -1;
    v4 = -1;
    hasSibling = 0;
    do
    {
      Entry = TextureDatabaseRuntime::GetEntry(TextureDatabaseRuntime::registered.dataPtr[v2], name, &hasSibling);
      if ( Entry != -1 )
      {
        v3 = Entry;
        v4 = v2;
      }
      ++v2;
    }
    while ( v2 < TextureDatabaseRuntime::registered.numEntries );
    if ( hasSibling )
    {
      if ( TextureDatabaseRuntime::curParentName[0] )
      {
        snprintf(s, 0x80u, "%s_%s", (const char *)name, (const char *)TextureDatabaseRuntime::curParentName);
        if ( TextureDatabaseRuntime::registered.numEntries )
        {
          v6 = 0;
          do
          {
            v7 = TextureDatabaseRuntime::GetEntry(TextureDatabaseRuntime::registered.dataPtr[v6], s, &hasSibling);
            if ( v7 != -1 )
            {
              v3 = v7;
              v4 = v6;
            }
            ++v6;
          }
          while ( v6 < TextureDatabaseRuntime::registered.numEntries );
        }
      }
    }
    if ( v4 == -1 )
      return 0;
    else
      return TextureDatabaseRuntime::GetRWTexture(TextureDatabaseRuntime::registered.dataPtr[v4], v3);
  }
  return (RwTexture *)v2;
}

//----- (001E9D88) --------------------------------------------------------
TextureDatabaseRuntime *__fastcall TextureDatabaseRuntime::GetDatabaseFor(
        TextureDatabaseEntry *entry,
        unsigned int *intoIndex)
{
  int v2; // r3
  TextureDatabaseRuntime *v3; // r2
  unsigned int dataPtr; // r5
  char *v5; // r5

  if ( !TextureDatabaseRuntime::loaded.numEntries )
    return 0;
  v2 = 0;
  while ( 1 )
  {
    v3 = TextureDatabaseRuntime::loaded.dataPtr[v2];
    dataPtr = (unsigned int)v3->entries.dataPtr;
    if ( dataPtr <= (unsigned int)entry && dataPtr + 23 * v3->entries.numEntries > (unsigned int)entry )
    {
      v5 = (char *)entry - dataPtr;
      if ( v5 != (char *)-23 )
        break;
    }
    if ( ++v2 >= TextureDatabaseRuntime::loaded.numEntries )
      return 0;
  }
  if ( intoIndex )
  {
    *intoIndex = -373475417 * (_DWORD)v5;
    return TextureDatabaseRuntime::loaded.dataPtr[v2];
  }
  return v3;
}

//----- (001E9E04) --------------------------------------------------------
void __fastcall TextureDatabaseRuntime::RenderingTextureEntry(TextureDatabaseEntry *entry)
{
  unsigned int v1; // r1
  TextureDatabaseRuntime *v2; // r2
  unsigned int dataPtr; // r4
  char *v4; // r4
  __int16 v5; // r3

  if ( !pumpHack )
  {
    v1 = (unsigned int)&TextureDatabaseRuntime::loaded;
    if ( TextureDatabaseRuntime::loaded.numEntries )
    {
      v1 = 0;
      while ( 1 )
      {
        v2 = TextureDatabaseRuntime::loaded.dataPtr[v1];
        dataPtr = (unsigned int)v2->entries.dataPtr;
        if ( dataPtr <= (unsigned int)entry && dataPtr + 23 * v2->entries.numEntries > (unsigned int)entry )
        {
          v4 = (char *)entry - dataPtr;
          if ( v4 != (char *)-23 )
            break;
        }
        if ( ++v1 >= TextureDatabaseRuntime::loaded.numEntries )
          goto LABEL_8;
      }
      v1 = -373475417 * (_DWORD)v4;
    }
    else
    {
LABEL_8:
      v2 = 0;
    }
    v5 = *((_WORD *)entry + 4);
    if ( (v5 & 0xF000) == 4096 )
    {
      *((_WORD *)entry + 4) = v5 & 0xFFF | 0x2000;
      TextureDatabaseRuntime::SetAsRendered(v2, v1);
    }
  }
}

//----- (001E9E90) --------------------------------------------------------
void __fastcall TextureDatabaseRuntime::CanUnloadTextureEntry(TextureDatabaseEntry *entry)
{
  unsigned int dataPtr; // r4
  int v2; // r3
  TextureDatabaseRuntime *v3; // r6
  unsigned int v4; // r1
  unsigned int v5; // r0
  unsigned int *v6; // r1
  int v7; // r2
  unsigned int numAlloced; // r0
  unsigned int numEntries; // r5
  unsigned int v10; // r10
  unsigned int *v11; // r0
  unsigned int *v12; // r9
  unsigned int *v13; // r8
  unsigned int v14; // r0
  unsigned int *v15; // r1
  int v16; // r2
  unsigned int v17; // r0
  unsigned int *v18; // r1
  int v19; // r2

  if ( TextureDatabaseRuntime::loaded.numEntries )
  {
    v2 = 0;
    while ( 1 )
    {
      v3 = TextureDatabaseRuntime::loaded.dataPtr[v2];
      dataPtr = (unsigned int)v3->entries.dataPtr;
      if ( dataPtr <= (unsigned int)entry && dataPtr + 23 * v3->entries.numEntries > (unsigned int)entry )
      {
        dataPtr = (unsigned int)entry - dataPtr;
        if ( dataPtr != -23 )
          break;
      }
      if ( ++v2 >= TextureDatabaseRuntime::loaded.numEntries )
        goto LABEL_7;
    }
    dataPtr *= -373475417;
  }
  else
  {
LABEL_7:
    v3 = 0;
  }
  v4 = *((unsigned __int16 *)entry + 4);
  if ( (v4 >> 12) - 1 >= 2 )
  {
    if ( v4 >> 12 == 3 )
    {
      *((_WORD *)entry + 4) = v4 & 0xFFF | 0x5000;
      numEntries = v3->deletionQueue.numEntries;
      numAlloced = v3->deletionQueue.numAlloced;
      if ( numAlloced < numEntries + 1 )
      {
        v10 = ((3 * (numEntries + 1)) >> 1) + 3;
        if ( v10 != numAlloced )
        {
          v11 = (unsigned int *)malloc(4 * v10);
          v12 = v3->deletionQueue.dataPtr;
          v13 = v11;
          if ( v12 )
          {
            memmove(v11, v3->deletionQueue.dataPtr, 4 * numEntries);
            free(v12);
            numEntries = v3->deletionQueue.numEntries;
          }
          v3->deletionQueue.dataPtr = v13;
          v3->deletionQueue.numAlloced = v10;
        }
      }
      v3->deletionQueue.dataPtr[numEntries] = dataPtr;
      ++v3->deletionQueue.numEntries;
    }
  }
  else
  {
    *((_WORD *)entry + 4) = v4 & 0xFFF | 0x4000;
    v5 = v3->unrenderedStreamingQueue.numEntries;
    if ( v5 )
    {
      v6 = v3->unrenderedStreamingQueue.dataPtr;
      v7 = 0;
      while ( v6[v7] != dataPtr )
      {
        if ( ++v7 >= v5 )
          goto LABEL_22;
      }
      v6[v7] = v6[v5 - 1];
      --v3->unrenderedStreamingQueue.numEntries;
    }
LABEL_22:
    v14 = v3->renderedStreamingQueue.numEntries;
    if ( v14 )
    {
      v15 = v3->renderedStreamingQueue.dataPtr;
      v16 = 0;
      while ( v15[v16] != dataPtr )
      {
        if ( ++v16 >= v14 )
          goto LABEL_28;
      }
      v15[v16] = v15[v14 - 1];
      --v3->renderedStreamingQueue.numEntries;
    }
LABEL_28:
    v17 = v3->priorityStreamingQueue.numEntries;
    if ( v17 )
    {
      v18 = v3->priorityStreamingQueue.dataPtr;
      v19 = 0;
      while ( v18[v19] != dataPtr )
      {
        if ( ++v19 >= v17 )
          return;
      }
      v18[v19] = v18[v17 - 1];
      --v3->priorityStreamingQueue.numEntries;
    }
  }
}
// 1E9F00: variable 'dataPtr' is possibly undefined

//----- (001EA00C) --------------------------------------------------------
void __fastcall TextureDatabaseRuntime::SetWriteMode(bool withValue)
{
  TextureDatabaseRuntime::isWriteMode = withValue;
}

//----- (001EA01C) --------------------------------------------------------
void __fastcall TextureDatabaseRuntime::SortEntries(TextureDatabaseRuntime *this, bool justEntries)
{
  unsigned int numEntries; // r10
  _BOOL4 v3; // r8
  unsigned int v4; // r2
  unsigned int v5; // r6
  bool v6; // zf
  void *v7; // r9
  TextureDatabaseRuntime *v8; // r2
  unsigned int v9; // r4
  int v10; // r5
  int v11; // r1
  TextureDatabaseRuntime *v12; // r4
  unsigned int v13; // r5
  void *v14; // r6
  TextureListingContainer *v15; // r11
  void *v16; // r8
  unsigned int v17; // r4
  unsigned int v18; // r5
  unsigned int v19; // r0
  unsigned int v20; // r5
  unsigned int v21; // r0
  void *v22; // r0
  TextureDatabaseRuntime *v23; // r2
  _DWORD *v24; // r3
  _QWORD *v25; // r5
  _DWORD *v26; // r1
  TextureListingContainer *v27; // r4
  unsigned int v28; // lr
  TextureDatabaseEntry *v29; // r0
  __int64 v30; // d17
  int v31; // r0
  TextureListing v32; // d16
  __int64 v33; // d17
  TextureDatabaseRuntime *v34; // r4
  unsigned int numAlloced; // r0
  unsigned int v36; // r5
  TextureDatabaseRuntime *v37; // r2
  unsigned int *v38; // r0
  unsigned int *v39; // r4
  void *v40; // r6
  unsigned int *dataPtr; // r0
  unsigned int v42; // r11
  void *v43; // r4
  unsigned int i; // r10
  unsigned int v45; // r8
  unsigned int v46; // r9
  void *v47; // r4
  void *v48; // r5
  unsigned int numHashes; // r1
  unsigned int v50; // r8
  unsigned int v51; // r10
  unsigned int v52; // r5
  TextureListingContainer *v53; // r11
  int v54; // r4
  void *v55; // r9
  unsigned int *v56; // r6
  int v57; // r1
  void *v58; // r6
  TextureDatabaseEntry *v59; // r0
  TextureDatabaseEntry *v60; // r4
  TextureDatabaseEntry *v61; // r5
  __int64 v62; // kr00_8
  void *v63; // r1
  void *v64; // r4
  void *v65; // r6
  void *v66; // r9
  unsigned int v67; // r11
  void *v68; // r6
  int (***v69)(void); // r4
  int (***v70)(void); // r5
  int (**v71)(void); // r10
  void *v72; // r0
  _DWORD *v73; // r4
  int (**v74)(void); // r9
  int (**v75)(void); // t1
  __int64 v76; // kr08_8
  unsigned int *v77; // r0
  TextureDatabaseRuntime *v78; // r1
  unsigned int *v79; // r11
  unsigned int *v80; // r4
  void **p_data; // r0
  unsigned int v82; // r4
  TextureListingContainer *v83; // r0
  TextureListingContainer *v84; // r0
  unsigned int v85; // [sp+4h] [bp-3Ch]
  unsigned int v86; // [sp+8h] [bp-38h]
  _BOOL4 v87; // [sp+Ch] [bp-34h]
  _DWORD *p; // [sp+10h] [bp-30h]
  TextureListingContainer *v89; // [sp+14h] [bp-2Ch]
  TextureListingContainer *v90; // [sp+14h] [bp-2Ch]
  void *v91; // [sp+18h] [bp-28h]
  const void **p_dataPtr; // [sp+1Ch] [bp-24h]
  void *v93; // [sp+1Ch] [bp-24h]

  numEntries = this->entries.numEntries;
  v3 = justEntries;
  this->numHashes = 1;
  if ( numEntries >> 4 )
  {
    v4 = numEntries >> 4;
    v5 = 1;
    do
    {
      v6 = v4 >> 1 == 0;
      v5 *= 2;
      v4 >>= 1;
    }
    while ( !v6 );
    if ( v5 <= 7 )
      v5 = 8;
  }
  else
  {
    v5 = 8;
  }
  this->numHashes = v5;
  if ( numEntries )
    v7 = malloc(8 * numEntries);
  else
    v7 = 0;
  memset(v7, 0, 8 * numEntries);
  v8 = this;
  if ( this->entries.numEntries )
  {
    v9 = 0;
    v10 = 4;
    do
    {
      *((_DWORD *)v7 + 2 * v9) = v9;
      v11 = *(unsigned int *)((char *)&v8->entries.dataPtr->name + v10) % v8->numHashes;
      v8 = this;
      v10 += 23;
      *((_DWORD *)v7 + 2 * v9++ + 1) = v11;
    }
    while ( v9 < this->entries.numEntries );
  }
  v12 = v8;
  v87 = v3;
  qsort(v7, numEntries, 8u, EntryIndex::sort);
  v13 = v12->entries.numEntries;
  if ( v13 )
  {
    v14 = malloc(23 * v13);
    v15 = (TextureListingContainer *)malloc(17 * v13);
    v16 = malloc(4 * v13);
    v17 = v13;
  }
  else
  {
    v17 = 0;
    v16 = 0;
    v15 = 0;
    v14 = 0;
  }
  memset(v14, 0, 23 * v13);
  v18 = this->entries.numEntries;
  if ( v17 < v18 )
  {
    v19 = ((3 * v18) >> 1) + 3;
    if ( v19 != v17 )
    {
      v89 = (TextureListingContainer *)malloc(17 * v19);
      if ( v15 )
        free(v15);
      v15 = v89;
    }
  }
  v85 = v18;
  memset(v15, 0, 17 * v18);
  v20 = this->entries.numEntries;
  v91 = v14;
  if ( v17 >= v20 || (v21 = ((3 * v20) >> 1) + 3, v21 == v17) )
  {
    v22 = v16;
  }
  else
  {
    v22 = malloc(4 * v21);
    if ( v16 )
    {
      v43 = v22;
      free(v16);
      v22 = v43;
    }
  }
  p = v22;
  memset(v22, 0, 4 * v20);
  v23 = this;
  if ( numEntries )
  {
    v24 = p;
    v25 = v14;
    v26 = v7;
    v27 = v15;
    v28 = numEntries;
    do
    {
      v29 = &v23->entries.dataPtr[*v26];
      v30 = *((_QWORD *)v29 + 1);
      *v25 = *(_QWORD *)&v29->name;
      v25[1] = v30;
      *(_QWORD *)((char *)v25 + 15) = *(_QWORD *)&v29->width;
      if ( !v87 )
      {
        v31 = (int)&v23->thumbs[v23->loadedFormat].dataPtr[*v26];
        v32 = *(TextureListing *)v31;
        v33 = *(_QWORD *)(v31 + 8);
        LOBYTE(v31) = *(_BYTE *)(v31 + 16);
        v27->listing = v32;
        *(_QWORD *)&v27->data = v33;
        v27->ownsData = v31;
        v23 = this;
        *v24 = this->fullDataOffsets.dataPtr[*v26];
      }
      v26 += 2;
      ++v27;
      ++v24;
      v25 = (_QWORD *)((char *)v25 + 23);
      --v28;
    }
    while ( v28 );
  }
  v34 = v23;
  qmemcpy(v23->entries.dataPtr, v14, 23 * v23->entries.numEntries);
  if ( !v87 )
  {
    qmemcpy(v34->thumbs[v34->loadedFormat].dataPtr, v15, 17 * v34->entries.numEntries);
    qmemcpy(v34->fullDataOffsets.dataPtr, p, 4 * v34->entries.numEntries);
  }
  numAlloced = v34->hashOffsets.numAlloced;
  v36 = v34->numHashes + 1;
  v34->hashOffsets.numEntries = 0;
  v37 = v34;
  v90 = v15;
  v86 = numEntries;
  if ( numAlloced >= v36 )
  {
    v40 = v7;
    p_dataPtr = (const void **)&v34->hashOffsets.dataPtr;
    v42 = 0;
    v36 = numAlloced;
  }
  else
  {
    v38 = (unsigned int *)malloc(4 * v36);
    v37 = this;
    v39 = v38;
    v40 = v7;
    dataPtr = this->hashOffsets.dataPtr;
    p_dataPtr = (const void **)&this->hashOffsets.dataPtr;
    if ( dataPtr )
    {
      free(dataPtr);
      v37 = this;
      v42 = this->hashOffsets.numEntries;
    }
    else
    {
      v42 = 0;
    }
    v37->hashOffsets.dataPtr = v39;
    v37->hashOffsets.numAlloced = v36;
  }
  for ( i = 1; ; ++i )
  {
    v45 = v37->entries.numEntries;
    if ( v36 < v42 + 1 )
    {
      v46 = ((3 * (v42 + 1)) >> 1) + 3;
      if ( v46 != v36 )
      {
        v47 = malloc(4 * v46);
        v48 = (void *)*p_dataPtr;
        if ( *p_dataPtr )
        {
          memmove(v47, *p_dataPtr, 4 * v42);
          free(v48);
          v37 = this;
          v42 = this->hashOffsets.numEntries;
        }
        else
        {
          v37 = this;
        }
        v37->hashOffsets.dataPtr = (unsigned int *)v47;
        v37->hashOffsets.numAlloced = v46;
      }
    }
    v37->hashOffsets.dataPtr[v42] = v45;
    numHashes = v37->numHashes;
    v42 = v37->hashOffsets.numEntries + 1;
    v37->hashOffsets.numEntries = v42;
    if ( i > numHashes )
      break;
    v36 = v37->hashOffsets.numAlloced;
  }
  v50 = v37->entries.numEntries;
  if ( v50 )
  {
    v51 = v86;
    v52 = 0;
    v53 = v90;
    v54 = 4;
    v55 = v40;
    while ( 1 )
    {
      v56 = v37->hashOffsets.dataPtr;
      v57 = *(unsigned int *)((char *)&v37->entries.dataPtr->name + v54) % numHashes;
      v37 = this;
      if ( v56[v57] > v52 )
      {
        v56[v57] = v52;
        v50 = this->entries.numEntries;
      }
      if ( ++v52 >= v50 )
        break;
      numHashes = this->numHashes;
      v54 += 23;
    }
    v58 = v91;
  }
  else
  {
    v55 = v40;
    v51 = v86;
    v53 = v90;
    v58 = v91;
    v50 = 0;
  }
  if ( v50 != v37->entries.numAlloced )
  {
    v59 = (TextureDatabaseEntry *)malloc(23 * v50);
    v37 = this;
    v60 = v59;
    v61 = this->entries.dataPtr;
    if ( v61 )
    {
      memmove(v59, this->entries.dataPtr, 23 * v50);
      free(v61);
      v37 = this;
    }
    v37->entries.dataPtr = v60;
    v37->entries.numAlloced = v50;
    v53 = v90;
  }
  v62 = *(_QWORD *)&v37->hashOffsets.numAlloced;
  if ( HIDWORD(v62) != (_DWORD)v62 )
  {
    v63 = malloc(4 * HIDWORD(v62));
    v64 = (void *)*p_dataPtr;
    if ( *p_dataPtr )
    {
      v65 = v55;
      v66 = v63;
      memmove(v63, *p_dataPtr, 4 * HIDWORD(v62));
      free(v64);
      v63 = v66;
      v55 = v65;
      v58 = v91;
    }
    v37 = this;
    this->hashOffsets.dataPtr = (unsigned int *)v63;
    this->hashOffsets.numAlloced = HIDWORD(v62);
  }
  if ( !v87 )
  {
    v67 = v51;
    v68 = v55;
    v69 = &v37->_vptr$TextureDatabase + 3 * v37->loadedFormat;
    v70 = v69 + 8;
    v71 = v69[9];
    if ( v71 != v69[8] )
    {
      v72 = malloc(17 * (_DWORD)v71);
      v75 = v69[10];
      v73 = v69 + 10;
      v74 = v75;
      if ( v75 )
      {
        v93 = v72;
        memmove(v72, v74, 17 * (_DWORD)v71);
        free(v74);
        v72 = v93;
      }
      *v70 = v71;
      *v73 = v72;
      v37 = this;
    }
    v76 = *(_QWORD *)&v37->fullDataOffsets.numAlloced;
    v55 = v68;
    v51 = v67;
    v53 = v90;
    v58 = v91;
    if ( HIDWORD(v76) != (_DWORD)v76 )
    {
      v77 = (unsigned int *)malloc(4 * HIDWORD(v76));
      v78 = this;
      v79 = v77;
      v80 = this->fullDataOffsets.dataPtr;
      if ( v80 )
      {
        memmove((void *)v76, this->fullDataOffsets.dataPtr, 4 * HIDWORD(v76));
        free(v80);
        v78 = this;
      }
      v78->fullDataOffsets.dataPtr = v79;
      v78->fullDataOffsets.numAlloced = HIDWORD(v76);
      v53 = v90;
    }
  }
  if ( v51 )
  {
    p_data = &v53->data;
    do
    {
      *((_BYTE *)p_data + 8) = 0;
      --v51;
      *p_data = 0;
      p_data = (void **)((char *)p_data + 17);
    }
    while ( v51 );
  }
  v82 = v85;
  if ( p )
    free(p);
  if ( v85 )
  {
    v83 = v53;
    do
    {
      TextureListingContainer::~TextureListingContainer(v83);
      v83 = v84 + 1;
      --v82;
    }
    while ( v82 );
  }
  if ( v53 )
    free(v53);
  if ( v58 )
    free(v58);
  if ( v55 )
    j_free(v55);
}
// 1EA49A: variable 'v84' is possibly undefined

//----- (001EA4D8) --------------------------------------------------------
void __fastcall TextureDatabaseRuntime::ReloadEntries(TextureDatabaseRuntime *this)
{
  unsigned int numEntries; // r6
  TextureDatabaseEntry *v3; // r9
  unsigned int v4; // r12
  unsigned int *p_nameHash; // r1
  unsigned int v6; // r3
  unsigned int *v7; // r2
  int v8; // r0
  TextureDatabaseEntry *dataPtr; // r1
  int *v10; // r1
  int v11; // r12
  __int16 v12; // r2
  TextureDatabaseEntry *v13; // r5
  __int16 v14; // r3

  numEntries = this->entries.numEntries;
  this->categories.numEntries = 0;
  if ( numEntries )
    v3 = (TextureDatabaseEntry *)malloc(23 * numEntries);
  else
    v3 = 0;
  memset(v3, 0, 23 * numEntries);
  qmemcpy(v3, this->entries.dataPtr, 23 * this->entries.numEntries);
  this->entries.numEntries = 0;
  if ( !TextureDatabase::LoadEntries(this, 1, 0) )
    goto LABEL_28;
  TextureDatabaseRuntime::SortEntries(this, 1);
  v4 = this->entries.numEntries;
  if ( v4 )
  {
    p_nameHash = &v3->nameHash;
    v6 = 0;
    v7 = &this->entries.dataPtr->nameHash;
    while ( *v7 == *p_nameHash )
    {
      ++v6;
      p_nameHash = (unsigned int *)((char *)p_nameHash + 23);
      v7 = (unsigned int *)((char *)v7 + 23);
      if ( v6 >= v4 )
        goto LABEL_9;
    }
    goto LABEL_29;
  }
LABEL_9:
  if ( !numEntries )
  {
LABEL_28:
    if ( !v3 )
      return;
    goto LABEL_29;
  }
  v8 = 10;
  do
  {
    *(_DWORD *)((char *)this->entries.dataPtr + v8 + 9) = *(_DWORD *)((char *)v3 + v8 + 9);
    *(_WORD *)((char *)this->entries.dataPtr + v8 - 2) = *(_WORD *)((char *)v3 + v8 - 2) & 0xF000 | *(_WORD *)((char *)this->entries.dataPtr + v8 - 2) & 0xFFF;
    dataPtr = this->entries.dataPtr;
    if ( (*((_BYTE *)&dataPtr->name + v8) & 4) == 0 )
    {
      v10 = *(int **)((char *)dataPtr + v8 + 9);
      if ( v10 )
      {
        v11 = *v10;
        v12 = *(_WORD *)(*v10 + 48) & 0xF90F;
        *(_WORD *)(*v10 + 48) = v12;
        v13 = this->entries.dataPtr;
        v14 = *(_WORD *)((char *)&v13->name + v8);
        if ( (v14 & 8) != 0 )
        {
          v12 |= 0x80u;
          *(_WORD *)(v11 + 48) = v12;
          v13 = this->entries.dataPtr;
          v14 = *(_WORD *)((char *)&v13->name + v8);
        }
        if ( (v14 & 0x20) != 0 && *((_BYTE *)&v13->name + v8 + 3) )
        {
          v12 |= 0x40u;
          *(_WORD *)(v11 + 48) = v12;
          v14 = *(_WORD *)((char *)&this->entries.dataPtr->name + v8);
        }
        if ( (v14 & 0x40) != 0 )
        {
          v12 |= 0x20u;
          *(_WORD *)(v11 + 48) = v12;
          v14 = *(_WORD *)((char *)&this->entries.dataPtr->name + v8);
        }
        if ( (v14 & 0x80) != 0 )
        {
          v12 |= 0x10u;
          *(_WORD *)(v11 + 48) = v12;
          v14 = *(_WORD *)((char *)&this->entries.dataPtr->name + v8);
        }
        if ( (v14 & 0x100) != 0 )
        {
          v12 |= 0x200u;
          *(_WORD *)(v11 + 48) = v12;
          v14 = *(_WORD *)((char *)&this->entries.dataPtr->name + v8);
        }
        if ( (v14 & 0x200) != 0 )
          *(_WORD *)(v11 + 48) = v12 | 0x400;
      }
    }
    --numEntries;
    v8 += 23;
  }
  while ( numEntries );
LABEL_29:
  j_free(v3);
}

//----- (001EA638) --------------------------------------------------------
void __fastcall TextureDatabaseRuntime::~TextureDatabaseRuntime(TextureDatabaseRuntime *this)
{
  OSFile streamFile; // r0
  unsigned int numEntries; // r0
  int v4; // r6
  unsigned int i; // r5
  TextureDatabaseEntry *v6; // r1
  int detailTexture; // r1
  TextureDatabaseEntry *v8; // r0
  int v9; // r0
  unsigned int v10; // r0
  unsigned int v11; // r0
  TextureDatabaseEntry *dataPtr; // r1
  unsigned int v13; // r5
  TextureDatabaseEntry *v14; // r10
  RwTexture *v15; // r0
  RwTexture_0 **p_instance; // r10
  RwTexture *instance; // t1
  __int64 v18; // r8
  size_t v19; // r2
  unsigned int v20; // r3
  TextureDatabaseRuntime **v21; // r0
  unsigned int *v22; // r0
  unsigned int *v23; // r0
  unsigned int *v24; // r0
  unsigned int *v25; // r0
  unsigned int *v26; // r0
  unsigned int *v27; // r0
  unsigned int v28; // [sp+4h] [bp-24h]

  streamFile = this->streamFile;
  this->_vptr$TextureDatabase = (int (**)(void))&off_660934;
  if ( streamFile )
  {
    OS_FileClose(streamFile);
    this->streamFile = 0;
  }
  numEntries = this->entries.numEntries;
  if ( numEntries )
  {
    v4 = 0;
    for ( i = 0; i < numEntries; ++i )
    {
      v6 = &this->entries.dataPtr[v4];
      if ( (v6->flags & 0x10) != 0 )
      {
        detailTexture = v6->detailTexture;
        if ( detailTexture )
        {
          RwTextureDestroy(TextureDatabaseRuntime::detailTextures.dataPtr[detailTexture - 1]);
          v8 = &this->entries.dataPtr[v4];
          if ( (v8->flags & 0x10) != 0 )
            v9 = v8->detailTexture;
          else
            v9 = 0;
          TextureDatabaseRuntime::detailTextures.dataPtr[v9 - 1] = 0;
          numEntries = this->entries.numEntries;
        }
      }
      ++v4;
    }
  }
  v10 = this->deletionQueue.numEntries;
  if ( v10 )
  {
    v28 = 0;
    while ( 1 )
    {
      v11 = v10 - 1;
      dataPtr = this->entries.dataPtr;
      v13 = this->deletionQueue.dataPtr[v11];
      this->deletionQueue.numEntries = v11;
      v14 = &dataPtr[v13];
      instance = v14->_anon_0.instance;
      p_instance = &v14->_anon_0.instance;
      v15 = instance;
      if ( instance->refCount != 1 )
        goto LABEL_17;
      v18 = *(_QWORD *)&(*(RwRaster **)((char *)&v15->raster->parent + RasterExtOffset))->cpPixels;
      v15->refCount = 0;
      TextureAnnihilate(*p_instance);
      *p_instance = 0;
      if ( !(HIDWORD(v18) * (_DWORD)v18) )
        break;
      *((_WORD *)&this->entries.dataPtr[v13] + 4) &= 0xFFFu;
      v28 += HIDWORD(v18) * v18;
      if ( v28 >> 20 > 0x2C )
        goto LABEL_21;
LABEL_18:
      v10 = this->deletionQueue.numEntries;
      if ( !v10 )
        goto LABEL_21;
    }
    dataPtr = this->entries.dataPtr;
LABEL_17:
    *((_WORD *)&dataPtr[v13] + 4) = *((_WORD *)&dataPtr[v13] + 4) & 0xFFF | 0x3000;
    goto LABEL_18;
  }
LABEL_21:
  if ( TextureDatabaseRuntime::loaded.numEntries )
  {
    v19 = 4 * TextureDatabaseRuntime::loaded.numEntries - 4;
    v20 = 0;
    v21 = TextureDatabaseRuntime::loaded.dataPtr;
    while ( *v21 != this )
    {
      ++v20;
      ++v21;
      v19 -= 4;
      if ( v20 >= TextureDatabaseRuntime::loaded.numEntries )
        goto LABEL_27;
    }
    memmove(v21, v21 + 1, v19);
    --TextureDatabaseRuntime::loaded.numEntries;
  }
LABEL_27:
  v22 = this->hashOffsets.dataPtr;
  this->hashOffsets.numEntries = 0;
  if ( v22 )
  {
    free(v22);
    this->hashOffsets.dataPtr = 0;
  }
  v23 = this->fullDataOffsets.dataPtr;
  this->fullDataOffsets.numEntries = 0;
  this->hashOffsets.numAlloced = 0;
  if ( v23 )
  {
    free(v23);
    this->fullDataOffsets.dataPtr = 0;
  }
  v24 = this->deletionQueue.dataPtr;
  this->deletionQueue.numEntries = 0;
  this->fullDataOffsets.numAlloced = 0;
  if ( v24 )
  {
    free(v24);
    this->deletionQueue.dataPtr = 0;
  }
  v25 = this->unrenderedStreamingQueue.dataPtr;
  this->unrenderedStreamingQueue.numEntries = 0;
  this->deletionQueue.numAlloced = 0;
  if ( v25 )
  {
    free(v25);
    this->unrenderedStreamingQueue.dataPtr = 0;
  }
  v26 = this->renderedStreamingQueue.dataPtr;
  this->renderedStreamingQueue.numEntries = 0;
  this->unrenderedStreamingQueue.numAlloced = 0;
  if ( v26 )
  {
    free(v26);
    this->renderedStreamingQueue.dataPtr = 0;
  }
  v27 = this->priorityStreamingQueue.dataPtr;
  this->priorityStreamingQueue.numEntries = 0;
  this->renderedStreamingQueue.numAlloced = 0;
  if ( v27 )
  {
    free(v27);
    this->priorityStreamingQueue.dataPtr = 0;
  }
  this->priorityStreamingQueue.numAlloced = 0;
  sub_19EEBC(this);
}
// 660934: using guessed type void *off_660934;

//----- (001EA854) --------------------------------------------------------
void __fastcall TextureDatabaseRuntime::~TextureDatabaseRuntime(TextureDatabaseRuntime *this)
{
  void *v1; // r0

  TextureDatabaseRuntime::~TextureDatabaseRuntime(this);
  sub_191374(v1);
}
// 1EA860: variable 'v1' is possibly undefined

//----- (001EA864) --------------------------------------------------------
TextureDatabaseRuntime *__fastcall TextureDatabaseRuntime::Load(
        const unsigned __int8 *withName,
        bool fullyLoad,
        TextureDatabaseFormat forcedFormat)
{
  unsigned int numEntries; // r10
  int v6; // r4
  TextureDatabaseRuntime **dataPtr; // r5
  TextureDatabaseRuntime *v8; // r6
  int v9; // r4
  unsigned __int8 *v10; // r0
  unsigned int v11; // r0
  int v12; // r5
  unsigned int i; // r6
  int v14; // r1
  unsigned int v15; // r1
  unsigned int v16; // r9
  unsigned int v17; // r11
  unsigned int v18; // r10
  unsigned int v19; // r8
  void *v20; // r3
  size_t v21; // r2
  RwTexture **v22; // r9
  unsigned int v23; // r5
  unsigned int v24; // r6
  _BOOL4 v25; // r2
  void *v26; // r8
  TextureDatabaseRuntime **v27; // r9
  unsigned int v28; // r0
  int v29; // r6
  unsigned int j; // r5
  int v31; // r1
  unsigned int FullTexture; // r0
  void *v34; // [sp+4h] [bp-54h]
  _BOOL4 v35; // [sp+24h] [bp-34h]

  v35 = fullyLoad;
  numEntries = TextureDatabaseRuntime::loaded.numEntries;
  if ( TextureDatabaseRuntime::loaded.numEntries )
  {
    v6 = 0;
    dataPtr = TextureDatabaseRuntime::loaded.dataPtr;
    while ( 1 )
    {
      v8 = dataPtr[v6];
      if ( !strcmp((const char *)v8->name, (const char *)withName) )
        break;
      if ( ++v6 >= numEntries )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    v9 = operator new(0xC8u);
    *(_QWORD *)(v9 + 88) = 0LL;
    *(_QWORD *)(v9 + 96) = 0LL;
    *(_QWORD *)(v9 + 72) = 0LL;
    *(_QWORD *)(v9 + 80) = 0LL;
    *(_QWORD *)(v9 + 56) = 0LL;
    *(_QWORD *)(v9 + 64) = 0LL;
    *(_QWORD *)(v9 + 40) = 0LL;
    *(_QWORD *)(v9 + 48) = 0LL;
    *(_QWORD *)(v9 + 24) = 0LL;
    *(_QWORD *)(v9 + 32) = 0LL;
    *(_QWORD *)(v9 + 100) = 0LL;
    *(_QWORD *)(v9 + 108) = 0LL;
    *(_QWORD *)(v9 + 8) = 0LL;
    *(_QWORD *)(v9 + 16) = 0LL;
    *(_DWORD *)v9 = &off_660924;
    v10 = j_strdup(withName);
    *(_QWORD *)(v9 + 152) = 0LL;
    *(_QWORD *)(v9 + 160) = 0LL;
    *(_QWORD *)(v9 + 136) = 0LL;
    *(_QWORD *)(v9 + 144) = 0LL;
    *(_QWORD *)(v9 + 172) = 0LL;
    *(_QWORD *)(v9 + 180) = 0LL;
    *(_QWORD *)(v9 + 120) = 0LL;
    *(_QWORD *)(v9 + 128) = 0LL;
    *(_DWORD *)v9 = &off_660934;
    *(_DWORD *)(v9 + 4) = v10;
    *(_DWORD *)(v9 + 188) = 0;
    *(_DWORD *)(v9 + 192) = 0;
    if ( forcedFormat == DF_Default )
    {
      if ( RQCaps[5] )
      {
        forcedFormat = DF_PVR;
      }
      else
      {
        forcedFormat = DF_ETC;
        if ( (RQCaps[4] || RQCaps[3]) << 24 )
          forcedFormat = DF_DXT;
      }
    }
    *(_DWORD *)(v9 + 116) = forcedFormat;
    v8 = 0;
    if ( TextureDatabase::LoadEntries((TextureDatabase *)v9, 1, 0) )
    {
      if ( TextureDatabase::LoadThumbs((TextureDatabase *)v9, *(TextureDatabaseFormat *)(v9 + 116), 1) )
        TextureDatabase::LoadDataOffsets(
          (TextureDatabase *)v9,
          *(TextureDatabaseFormat *)(v9 + 116),
          (TDBArray<unsigned int> *)(v9 + 172),
          (OSFile *)(v9 + 168),
          0);
      TextureDatabaseRuntime::SortEntries((TextureDatabaseRuntime *)v9, 0);
      v11 = *(_DWORD *)(v9 + 24);
      if ( v11 )
      {
        v12 = 0;
        for ( i = 0; i < v11; ++i )
        {
          v14 = *(_DWORD *)(v9 + 28) + v12;
          if ( (*(_BYTE *)(v14 + 10) & 0x10) != 0 )
          {
            v15 = *(unsigned __int8 *)(v14 + 13);
            if ( v15 )
            {
              v16 = TextureDatabaseRuntime::detailTextures.numEntries;
              v17 = v15 - 1;
              if ( v15 - 1 >= TextureDatabaseRuntime::detailTextures.numEntries )
              {
                v18 = v15 - TextureDatabaseRuntime::detailTextures.numEntries;
                if ( TextureDatabaseRuntime::detailTextures.numAlloced < v15 )
                {
                  v19 = ((3 * v15) >> 1) + 3;
                  if ( v19 != TextureDatabaseRuntime::detailTextures.numAlloced )
                  {
                    v20 = malloc(4 * v19);
                    if ( TextureDatabaseRuntime::detailTextures.dataPtr )
                    {
                      v21 = 4 * v16;
                      v34 = v20;
                      v22 = TextureDatabaseRuntime::detailTextures.dataPtr;
                      memmove(v20, TextureDatabaseRuntime::detailTextures.dataPtr, v21);
                      free(v22);
                      v20 = v34;
                      v16 = TextureDatabaseRuntime::detailTextures.numEntries;
                    }
                    TextureDatabaseRuntime::detailTextures.dataPtr = (RwTexture **)v20;
                    TextureDatabaseRuntime::detailTextures.numAlloced = v19;
                  }
                }
                memset(&TextureDatabaseRuntime::detailTextures.dataPtr[v16], 0, 4 * v18);
                TextureDatabaseRuntime::detailTextures.numEntries += v18;
              }
              TextureDatabaseRuntime::detailTextures.dataPtr[v17] = TextureDatabaseRuntime::GetRWTexture(
                                                                      (TextureDatabaseRuntime *)v9,
                                                                      i);
              ++TextureDatabaseRuntime::detailTextures.dataPtr[v17]->refCount;
              v11 = *(_DWORD *)(v9 + 24);
            }
          }
          v12 += 23;
        }
      }
      v23 = TextureDatabaseRuntime::loaded.numEntries;
      if ( TextureDatabaseRuntime::loaded.numAlloced >= TextureDatabaseRuntime::loaded.numEntries + 1
        || (v24 = ((3 * (TextureDatabaseRuntime::loaded.numEntries + 1)) >> 1) + 3,
            v24 == TextureDatabaseRuntime::loaded.numAlloced) )
      {
        v25 = v35;
      }
      else
      {
        v26 = malloc(4 * v24);
        v27 = TextureDatabaseRuntime::loaded.dataPtr;
        if ( TextureDatabaseRuntime::loaded.dataPtr )
        {
          memmove(v26, TextureDatabaseRuntime::loaded.dataPtr, 4 * v23);
          free(v27);
          v23 = TextureDatabaseRuntime::loaded.numEntries;
        }
        v25 = v35;
        TextureDatabaseRuntime::loaded.dataPtr = (TextureDatabaseRuntime **)v26;
        TextureDatabaseRuntime::loaded.numAlloced = v24;
      }
      v8 = (TextureDatabaseRuntime *)v9;
      TextureDatabaseRuntime::loaded.dataPtr[v23] = (TextureDatabaseRuntime *)v9;
      ++TextureDatabaseRuntime::loaded.numEntries;
      if ( v25 )
      {
        v28 = *(_DWORD *)(v9 + 24);
        if ( v28 )
        {
          v29 = 0;
          for ( j = 0; j < v28; ++j )
          {
            v31 = *(_DWORD *)(v9 + 28);
            if ( (*(_BYTE *)(v31 + v29 + 10) & 4) == 0 )
            {
              if ( (*(_WORD *)(v31 + v29 + 8) & 0xF000) != 12288 )
              {
                FullTexture = TextureDatabaseRuntime::LoadFullTexture((TextureDatabaseRuntime *)v9, j);
                v31 = *(_DWORD *)(v9 + 28);
                TextureDatabaseRuntime::storedTexels += FullTexture;
              }
              ++*(_DWORD *)(*(_DWORD *)(v31 + v29 + 19) + 84);
              v28 = *(_DWORD *)(v9 + 24);
            }
            v29 += 23;
          }
        }
        return (TextureDatabaseRuntime *)v9;
      }
    }
  }
  return v8;
}
// 660924: using guessed type void *off_660924;
// 660934: using guessed type void *;

//----- (001EABD4) --------------------------------------------------------
void __fastcall TextureDatabaseRuntime::Unload(TextureDatabaseRuntime *this)
{
  unsigned int numEntries; // r1
  int v3; // r5
  unsigned int i; // r6
  TextureDatabaseEntry *v5; // r0
  RwTexture_0 *instance; // r0

  numEntries = this->entries.numEntries;
  if ( numEntries )
  {
    v3 = 0;
    for ( i = 0; i < numEntries; ++i )
    {
      v5 = &this->entries.dataPtr[v3];
      if ( (v5->flags & 4) == 0 )
      {
        instance = v5->_anon_0.instance;
        if ( instance )
        {
          RwTextureDestroy(instance);
          numEntries = this->entries.numEntries;
        }
      }
      ++v3;
    }
  }
}

//----- (001EAC0C) --------------------------------------------------------
TextureDatabaseRuntime *__fastcall TextureDatabaseRuntime::GetDatabase(const char *a1)
{
  const char *v2; // r4
  unsigned int numEntries; // r8
  int v4; // r6
  TextureDatabaseRuntime **dataPtr; // r9
  TextureDatabaseRuntime *v6; // r5

  do
  {
    v2 = a1;
    if ( strcmp(a1, "player") )
      break;
    a1 = "playerhi";
  }
  while ( UseHiDetailPlayer() );
  numEntries = TextureDatabaseRuntime::loaded.numEntries;
  if ( !TextureDatabaseRuntime::loaded.numEntries )
    return 0;
  v4 = 0;
  dataPtr = TextureDatabaseRuntime::loaded.dataPtr;
  while ( 1 )
  {
    v6 = dataPtr[v4];
    if ( !strcmp((const char *)v6->name, v2) )
      break;
    if ( ++v4 >= numEntries )
      return 0;
  }
  return v6;
}

//----- (001EAC84) --------------------------------------------------------
void TextureDatabaseRuntime::ListOverrun()
{
  unsigned int numEntries; // r0
  unsigned int v1; // r6
  TextureDatabaseRuntime **dataPtr; // r12
  TextureDatabaseRuntime *v3; // r2
  unsigned int v4; // r1
  unsigned int v5; // r9
  TextureDatabaseEntry *v6; // r6
  unsigned int v7; // r11
  unsigned int v8; // r8
  unsigned int v9; // [sp+8h] [bp-28h]
  unsigned int v10; // [sp+Ch] [bp-24h]
  bool hasSibling[29]; // [sp+13h] [bp-1Dh] BYREF

  numEntries = TextureDatabaseRuntime::registered.numEntries;
  if ( TextureDatabaseRuntime::registered.numEntries )
  {
    v1 = 0;
    dataPtr = TextureDatabaseRuntime::registered.dataPtr;
    do
    {
      v3 = dataPtr[v1];
      v4 = v1 + 1;
      if ( v3->entries.numEntries )
      {
        v5 = 0;
        v10 = v1 + 2;
        v9 = v1;
        do
        {
          if ( v4 < numEntries )
          {
            v6 = v3->entries.dataPtr;
            v7 = v4;
            TextureDatabaseRuntime::GetEntry(dataPtr[v4], v6[v5].name, hasSibling);
            numEntries = TextureDatabaseRuntime::registered.numEntries;
            if ( v10 < TextureDatabaseRuntime::registered.numEntries )
            {
              v8 = v10;
              do
              {
                TextureDatabaseRuntime::GetEntry(
                  TextureDatabaseRuntime::registered.dataPtr[v8],
                  v6[v5].name,
                  hasSibling);
                numEntries = TextureDatabaseRuntime::registered.numEntries;
                ++v8;
              }
              while ( v8 < TextureDatabaseRuntime::registered.numEntries );
            }
            v1 = v9;
            dataPtr = TextureDatabaseRuntime::registered.dataPtr;
            v4 = v7;
          }
          v3 = dataPtr[v1];
          ++v5;
        }
        while ( v5 < v3->entries.numEntries );
      }
      v1 = v4;
    }
    while ( v4 < numEntries );
  }
}

//----- (001EAD58) --------------------------------------------------------
void __fastcall TDBArray<TextureDatabaseRuntime *>::~TDBArray(TDBArray<TextureDatabaseRuntime *> *this)
{
  TextureDatabaseRuntime **dataPtr; // r0

  dataPtr = this->dataPtr;
  this->numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->dataPtr = 0;
  }
  this->numAlloced = 0;
}

//----- (001EAD72) --------------------------------------------------------
void __fastcall TDBArray<RwTexture *>::~TDBArray(TDBArray<RwTexture *> *this)
{
  RwTexture **dataPtr; // r0

  dataPtr = this->dataPtr;
  this->numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->dataPtr = 0;
  }
  this->numAlloced = 0;
}

//----- (001EAD8C) --------------------------------------------------------
int __fastcall EntryIndex::sort(const void *a, const void *b)
{
  return *((_DWORD *)a + 1) - *((_DWORD *)b + 1);
}

//----- (001EAD94) --------------------------------------------------------
void __fastcall Set360UVAnimHack(bool val)
{
  RunUVAnim = val;
}

//----- (001EADA4) --------------------------------------------------------
void __fastcall RtAnimAnimationFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rtAnimAnimationFreeListPreallocBlocks = numBlocksToPrealloc;
  _rtAnimAnimationFreeListBlockSize = blockSize;
}

//----- (001EADBC) --------------------------------------------------------
bool RtAnimInitialize()
{
  return RwEngineRegisterPlugin(0, 0x1B7u, AnimOpen, AnimClose) > 0;
}

//----- (001EADE8) --------------------------------------------------------
void *__fastcall AnimOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  RtAnimAnimationFreeList = RwFreeListCreateAndPreallocateSpace(
                              24,
                              _rtAnimAnimationFreeListBlockSize,
                              4,
                              _rtAnimAnimationFreeListPreallocBlocks,
                              &RtAnimAnimationFreeListSpace);
  if ( !RtAnimAnimationFreeList )
    return 0;
  return instance;
}

//----- (001EAE30) --------------------------------------------------------
void *__fastcall AnimClose(void *instance, RwInt32 offset, RwInt32 size)
{
  RtAnimInterpolatorInfoBlockNumEntries = 0;
  if ( RtAnimAnimationFreeList )
  {
    RwFreeListDestroy(RtAnimAnimationFreeList);
    RtAnimAnimationFreeList = 0;
  }
  return instance;
}

//----- (001EAE68) --------------------------------------------------------
RwBool __fastcall RtAnimRegisterInterpolationScheme(RtAnimInterpolatorInfo_0 *interpInfo)
{
  RwInt32 v1; // r12
  RtAnimInterpolatorInfo_0 *v3; // r3
  RwInt32 v4; // r1
  RtAnimKeyFrameStreamReadCallBack *p_keyFrameStreamReadCB; // r1
  RtAnimKeyFrameBlendCallBack *p_keyFrameBlendCB; // r0
  __int64 v7; // d16
  __int64 v8; // d17
  __int64 v9; // d19
  __int64 v10; // d20
  __int64 v11; // d21
  RtAnimInterpolatorInfo_0 *v12; // r0

  v1 = RtAnimInterpolatorInfoBlockNumEntries;
  if ( RtAnimInterpolatorInfoBlockNumEntries > 15 )
    return 0;
  if ( RtAnimInterpolatorInfoBlockNumEntries < 1 )
  {
LABEL_7:
    p_keyFrameStreamReadCB = &interpInfo->keyFrameStreamReadCB;
    v7 = *(_QWORD *)&interpInfo->typeID;
    v8 = *(_QWORD *)&interpInfo->animKeyFrameSize;
    p_keyFrameBlendCB = &interpInfo->keyFrameBlendCB;
    v9 = *((_QWORD *)p_keyFrameStreamReadCB + 1);
    v10 = *(_QWORD *)p_keyFrameBlendCB;
    v11 = *((_QWORD *)p_keyFrameBlendCB + 1);
    v12 = &RtAnimInterpolatorInfoBlock[RtAnimInterpolatorInfoBlockNumEntries];
    *(_QWORD *)&v12->keyFrameStreamReadCB = *(_QWORD *)p_keyFrameStreamReadCB;
    *(_QWORD *)&v12->keyFrameStreamGetSizeCB = v9;
    *(_QWORD *)&v12->typeID = v7;
    *(_QWORD *)&v12->animKeyFrameSize = v8;
    v12 = (RtAnimInterpolatorInfo_0 *)((char *)v12 + 16);
    *(_QWORD *)&v12->typeID = v10;
    *(_QWORD *)&v12->animKeyFrameSize = v11;
    RtAnimInterpolatorInfoBlockNumEntries = v1 + 1;
    return 1;
  }
  else
  {
    v3 = RtAnimInterpolatorInfoBlock;
    v4 = 0;
    while ( v3->typeID != interpInfo->typeID )
    {
      ++v4;
      ++v3;
      if ( v4 >= RtAnimInterpolatorInfoBlockNumEntries )
        goto LABEL_7;
    }
    return 0;
  }
}

//----- (001EAEF4) --------------------------------------------------------
RtAnimInterpolatorInfo_0 *__fastcall RtAnimGetInterpolatorInfo(RwInt32 typeID)
{
  RtAnimInterpolatorInfo_0 *result; // r0
  int v3; // r3

  if ( RtAnimInterpolatorInfoBlockNumEntries < 1 )
    return 0;
  v3 = 0;
  for ( result = RtAnimInterpolatorInfoBlock; result->typeID != typeID; ++result )
  {
    if ( ++v3 >= RtAnimInterpolatorInfoBlockNumEntries )
      return 0;
  }
  return result;
}

//----- (001EAF2C) --------------------------------------------------------
RtAnimAnimation_0 *__fastcall RtAnimAnimationCreate(RwInt32 typeID, RwInt32 numFrames, RwInt32 flags, RwReal duration)
{
  RtAnimInterpolatorInfo_0 *v7; // r6
  RwInt32 v8; // r2
  RtAnimAnimation_0 *result; // r0
  char *v10; // r1

  if ( RtAnimInterpolatorInfoBlockNumEntries < 1 )
    return 0;
  v7 = RtAnimInterpolatorInfoBlock;
  v8 = 0;
  while ( v7->typeID != typeID )
  {
    ++v8;
    ++v7;
    if ( v8 >= RtAnimInterpolatorInfoBlockNumEntries )
      return 0;
  }
  if ( !v7 )
    return 0;
  result = (RtAnimAnimation_0 *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(v7->customDataSize
                                                                                   + v7->animKeyFrameSize * numFrames + 24);
  result->duration = duration;
  result->interpInfo = v7;
  result->numFrames = numFrames;
  result->flags = flags;
  result->pFrames = &result[1];
  if ( v7->customDataSize < 1 )
    v10 = 0;
  else
    v10 = (char *)&result[1] + v7->animKeyFrameSize * numFrames;
  result->customData = v10;
  return result;
}

//----- (001EAFBC) --------------------------------------------------------
RwBool __fastcall RtAnimAnimationDestroy(RtAnimAnimation_0 *animation)
{
  (*((void (__fastcall **)(RtAnimAnimation_0 *))RwEngineInstance + 76))(animation);
  return 1;
}

//----- (001EAFD8) --------------------------------------------------------
RtAnimAnimation_0 *__fastcall RtAnimAnimationRead(const RwChar *filename)
{
  RwStream_0 *v1; // r0
  RwStream_0 *v2; // r4
  RtAnimAnimation_0 *v3; // r5

  v1 = RwStreamOpen(rwSTREAMFILENAME, rwSTREAMREAD, filename);
  v2 = v1;
  if ( !v1 || !RwStreamFindChunk(v1, 0x1Bu, 0, 0) )
    return 0;
  v3 = RtAnimAnimationStreamRead(v2);
  RwStreamClose(v2, 0);
  return v3;
}

//----- (001EB010) --------------------------------------------------------
RtAnimAnimation_0 *__fastcall RtAnimAnimationStreamRead(RwStream_0 *stream)
{
  int v2; // r5
  RtAnimKeyFrameStreamReadCallBack *p_keyFrameStreamReadCB; // r6
  RwInt32 v4; // r2
  RwReal v5; // r10
  RwInt32 v6; // r11
  RwInt32 v7; // r8
  RtAnimInterpolatorInfo_0 *v8; // r4
  RwInt32 v9; // r2
  int v10; // r0
  RwReal v12; // [sp+0h] [bp-30h] BYREF
  RwInt32 v13; // [sp+4h] [bp-2Ch] BYREF
  RwInt32 v14; // [sp+8h] [bp-28h] BYREF
  RwInt32 v15; // [sp+Ch] [bp-24h] BYREF
  RwInt32 ints[8]; // [sp+10h] [bp-20h] BYREF

  v2 = 0;
  if ( RwStreamReadInt32(stream, ints, 4u) && ints[0] == 256 )
  {
    if ( !RwStreamReadInt32(stream, &v15, 4u) || RtAnimInterpolatorInfoBlockNumEntries < 1 )
      return 0;
    p_keyFrameStreamReadCB = &RtAnimInterpolatorInfoBlock[0].keyFrameStreamReadCB;
    v4 = 0;
    while ( *(p_keyFrameStreamReadCB - 8) != (RtAnimKeyFrameStreamReadCallBack)v15 )
    {
      ++v4;
      p_keyFrameStreamReadCB += 12;
      if ( v4 >= RtAnimInterpolatorInfoBlockNumEntries )
        return 0;
    }
    if ( p_keyFrameStreamReadCB == (RtAnimKeyFrameStreamReadCallBack *)&dword_20
      || !RwStreamReadInt32(stream, &v14, 4u)
      || !RwStreamReadInt32(stream, &v13, 4u)
      || !RwStreamReadReal(stream, &v12, 4u)
      || RtAnimInterpolatorInfoBlockNumEntries < 1 )
    {
      return 0;
    }
    v2 = 0;
    v5 = v12;
    v6 = v13;
    v7 = v14;
    v8 = RtAnimInterpolatorInfoBlock;
    v9 = 0;
    while ( v8->typeID != v15 )
    {
      ++v9;
      ++v8;
      if ( v9 >= RtAnimInterpolatorInfoBlockNumEntries )
        return (RtAnimAnimation_0 *)v2;
    }
    if ( !v8 )
      return 0;
    v2 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(v8->customDataSize + v8->animKeyFrameSize * v14 + 24);
    *(_DWORD *)v2 = v8;
    *(_DWORD *)(v2 + 4) = v7;
    *(_DWORD *)(v2 + 8) = v6;
    *(RwReal *)(v2 + 12) = v5;
    *(_DWORD *)(v2 + 16) = v2 + 24;
    v10 = v8->customDataSize < 1 ? 0 : v2 + 24 + v8->animKeyFrameSize * v7;
    *(_DWORD *)(v2 + 20) = v10;
    if ( v2 )
      (*p_keyFrameStreamReadCB)(stream, (RtAnimAnimation_0 *)v2);
    else
      return 0;
  }
  return (RtAnimAnimation_0 *)v2;
}
// 20: using guessed type int dword_20;
// 1EB010: using guessed type RwInt32 ints[8];
// 1EB010: using guessed type RwReal var_30;

//----- (001EB130) --------------------------------------------------------
RwBool __fastcall RtAnimAnimationWrite(const RtAnimAnimation_0 *animation, const RwChar *filename)
{
  RwStream_0 *v3; // r5

  v3 = RwStreamOpen(rwSTREAMFILENAME, rwSTREAMWRITE, filename);
  if ( !v3 )
    return 0;
  RtAnimAnimationStreamWrite(animation, v3);
  RwStreamClose(v3, 0);
  return 1;
}

//----- (001EB15C) --------------------------------------------------------
RwBool __fastcall RtAnimAnimationStreamWrite(const RtAnimAnimation_0 *animation, RwStream_0 *stream)
{
  RwInt32 v4; // r0
  RwInt32 ints[3]; // [sp+4h] [bp-Ch] BYREF

  ints[0] = 256;
  v4 = animation->interpInfo->keyFrameStreamGetSizeCB(animation);
  _rwStreamWriteVersionedChunkHeader(stream, 27, v4 + 20, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu);
  if ( !RwStreamWriteInt32(stream, ints, 4u)
    || !RwStreamWriteInt32(stream, &animation->interpInfo->typeID, 4u)
    || !RwStreamWriteInt32(stream, &animation->numFrames, 4u)
    || !RwStreamWriteInt32(stream, &animation->flags, 4u)
    || !RwStreamWriteReal(stream, &animation->duration, 4u) )
  {
    return 0;
  }
  animation->interpInfo->keyFrameStreamWriteCB(animation, stream);
  return 1;
}
// 35FFC: using guessed type Elf32_Sym stru_35FFC;
// 1EB15C: using guessed type RwInt32 ints[3];

//----- (001EB1E4) --------------------------------------------------------
RwInt32 __fastcall RtAnimAnimationStreamGetSize(const RtAnimAnimation_0 *animation)
{
  return animation->interpInfo->keyFrameStreamGetSizeCB(animation) + 20;
}

//----- (001EB1F2) --------------------------------------------------------
RwUInt32 __fastcall RtAnimAnimationGetNumNodes(const RtAnimAnimation_0 *animation)
{
  _DWORD *pFrames; // r12
  RwUInt32 result; // r0
  RwInt32 animKeyFrameSize; // r2
  _DWORD *v4; // r3
  _DWORD *v5; // r1

  pFrames = animation->pFrames;
  if ( (_DWORD *)*pFrames == pFrames )
    return 0;
  animKeyFrameSize = animation->interpInfo->animKeyFrameSize;
  result = 0;
  v4 = (_DWORD *)((char *)pFrames + animKeyFrameSize);
  do
  {
    v5 = (_DWORD *)*v4;
    v4 = (_DWORD *)((char *)v4 + animKeyFrameSize);
    ++result;
  }
  while ( v5 != pFrames );
  return result;
}

//----- (001EB218) --------------------------------------------------------
RtAnimInterpolator_0 *__fastcall RtAnimInterpolatorCreate(RwInt32 numNodes, RwInt32 maxInterpKeyFrameSize)
{
  RtAnimInterpolator_0 *result; // r0

  result = (RtAnimInterpolator_0 *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(maxInterpKeyFrameSize * numNodes + 76);
  result->animCallBackTime = -1.0;
  result->pAnimLoopCallBack = 0;
  result->pAnimLoopCallBackData = 0;
  result->maxInterpKeyFrameSize = maxInterpKeyFrameSize;
  result->currentInterpKeyFrameSize = maxInterpKeyFrameSize;
  result->currentAnimKeyFrameSize = -1;
  result->numNodes = numNodes;
  result->isSubInterpolator = 0;
  *(_QWORD *)&result->keyFrameApplyCB = 0LL;
  *(_QWORD *)&result->keyFrameInterpolateCB = 0LL;
  *(_QWORD *)&result->pCurrentAnim = 0LL;
  *(_QWORD *)&result->pNextFrame = 0LL;
  result->pAnimCallBackData = 0;
  result->offsetInParent = 0;
  result->parentAnimation = result;
  return result;
}

//----- (001EB270) --------------------------------------------------------
void __fastcall RtAnimInterpolatorDestroy(RtAnimInterpolator_0 *anim)
{
  (*((void (__fastcall **)(RtAnimInterpolator_0 *))RwEngineInstance + 76))(anim);
}

//----- (001EB284) --------------------------------------------------------
RwBool __fastcall RtAnimInterpolatorSetCurrentAnim(RtAnimInterpolator_0 *animI, RtAnimAnimation_0 *anim)
{
  RtAnimInterpolatorInfo_0 *interpInfo; // r1
  RwInt32 animKeyFrameSize; // r0
  RwInt32 numNodes; // r2
  void (*keyFrameInterpolateCB)(void *, void *, void *, RwReal, void *); // r5
  int i; // r5
  RwInt32 currentAnimKeyFrameSize; // r0
  RtAnimAnimation_0 *v10; // r1
  void **p_pFrames; // r8
  RtAnimAnimation_0 *pFrames; // t1
  RwReal v13; // r3
  RtAnimInterpolator_0 *v14; // r6
  RwInt32 v15; // r5

  animI->pCurrentAnim = anim;
  animI->currentTime = 0.0;
  interpInfo = anim->interpInfo;
  animI->currentInterpKeyFrameSize = interpInfo->interpKeyFrameSize;
  animKeyFrameSize = interpInfo->animKeyFrameSize;
  animI->currentAnimKeyFrameSize = animKeyFrameSize;
  animI->keyFrameApplyCB = interpInfo->keyFrameApplyCB;
  animI->keyFrameBlendCB = interpInfo->keyFrameBlendCB;
  numNodes = animI->numNodes;
  keyFrameInterpolateCB = interpInfo->keyFrameInterpolateCB;
  animI->keyFrameInterpolateCB = keyFrameInterpolateCB;
  animI->keyFrameAddCB = interpInfo->keyFrameAddCB;
  if ( numNodes >= 1 )
  {
    ((void (__fastcall *)(RtAnimInterpolator_0 *, void *, char *, _DWORD, void *))keyFrameInterpolateCB)(
      &animI[1],
      anim->pFrames,
      (char *)anim->pFrames + animKeyFrameSize * numNodes,
      0,
      anim->customData);
    numNodes = animI->numNodes;
    if ( numNodes >= 2 )
    {
      for ( i = 1; i < numNodes; ++i )
      {
        ((void (__fastcall *)(char *, char *, char *, _DWORD, void *))animI->keyFrameInterpolateCB)(
          (char *)&animI[1] + animI->currentInterpKeyFrameSize * i,
          (char *)anim->pFrames + animI->currentAnimKeyFrameSize * i,
          (char *)anim->pFrames + animI->currentAnimKeyFrameSize * (numNodes + i),
          0,
          anim->customData);
        numNodes = animI->numNodes;
      }
    }
  }
  if ( RunUVAnim )
  {
    currentAnimKeyFrameSize = animI->currentAnimKeyFrameSize;
    pFrames = (RtAnimAnimation_0 *)anim->pFrames;
    p_pFrames = &anim->pFrames;
    v10 = pFrames;
    if ( numNodes >= 1 )
    {
      LODWORD(v13) = (char *)v10 + currentAnimKeyFrameSize * numNodes;
      v14 = animI + 1;
      v15 = 0;
      do
      {
        v14->pCurrentAnim = v10;
        v14->currentTime = v13;
        ++v15;
        currentAnimKeyFrameSize = animI->currentAnimKeyFrameSize;
        LODWORD(v13) += currentAnimKeyFrameSize;
        numNodes = animI->numNodes;
        v10 = (RtAnimAnimation_0 *)((char *)v10 + currentAnimKeyFrameSize);
        v14 = (RtAnimInterpolator_0 *)((char *)v14 + animI->currentInterpKeyFrameSize);
      }
      while ( v15 < numNodes );
    }
  }
  else
  {
    currentAnimKeyFrameSize = animI->currentAnimKeyFrameSize;
    p_pFrames = &anim->pFrames;
  }
  animI->pNextFrame = (char *)*p_pFrames + 2 * currentAnimKeyFrameSize * numNodes;
  return 1;
}

//----- (001EB370) --------------------------------------------------------
RwBool __fastcall RtAnimInterpolatorSetKeyFrameCallBacks(RtAnimInterpolator_0 *anim, RwInt32 keyFrameTypeID)
{
  int v3; // r3
  RtAnimKeyFrameApplyCallBack *i; // lr

  if ( RtAnimInterpolatorInfoBlockNumEntries < 1 )
    return 0;
  v3 = 0;
  for ( i = &RtAnimInterpolatorInfoBlock[0].keyFrameApplyCB;
        *(i - 3) != (RtAnimKeyFrameApplyCallBack)keyFrameTypeID;
        i += 12 )
  {
    if ( ++v3 >= RtAnimInterpolatorInfoBlockNumEntries )
      return 0;
  }
  if ( i == (RtAnimKeyFrameApplyCallBack *)&byte_9[3] )
    return 0;
  anim->keyFrameApplyCB = *i;
  anim->keyFrameBlendCB = (RtAnimKeyFrameBlendCallBack)i[1];
  anim->keyFrameInterpolateCB = (RtAnimKeyFrameInterpolateCallBack)i[2];
  anim->keyFrameAddCB = (RtAnimKeyFrameAddCallBack)i[3];
  return 1;
}

//----- (001EB3D8) --------------------------------------------------------
void __fastcall RtAnimInterpolatorSetAnimLoopCallBack(RtAnimInterpolator_0 *anim, RtAnimCallBack callBack, void *data)
{
  anim->pAnimLoopCallBack = callBack;
  anim->pAnimLoopCallBackData = data;
}

//----- (001EB3DE) --------------------------------------------------------
void __fastcall RtAnimInterpolatorSetAnimCallBack(
        RtAnimInterpolator_0 *anim,
        RtAnimCallBack callBack,
        RwReal time,
        void *data)
{
  anim->pAnimCallBack = callBack;
  anim->pAnimCallBackData = data;
  anim->animCallBackTime = time;
}

//----- (001EB3E6) --------------------------------------------------------
RwBool __fastcall RtAnimInterpolatorCopy(RtAnimInterpolator_0 *outAnim, RtAnimInterpolator_0 *inAnim)
{
  qmemcpy(&outAnim[1], &inAnim[1], outAnim->currentInterpKeyFrameSize * outAnim->numNodes);
  return 1;
}

//----- (001EB3FC) --------------------------------------------------------
RwBool __fastcall RtAnimInterpolatorSubAnimTime(RtAnimInterpolator_0 *interp, RwReal time)
{
  float currentTime; // s2
  int v5; // r2
  RtAnimAnimation_0 *pCurrentAnim; // r1
  int v7; // r0
  float v8; // s16
  float animCallBackTime; // s0
  int v10; // r8
  int v11; // r5
  RwInt32 numNodes; // r9
  RtAnimInterpolator_0 *i; // r5
  RtAnimAnimation_0 *v14; // r1
  RtAnimCallBack pAnimCallBack; // r2
  RtAnimCallBack pAnimLoopCallBack; // r2

  currentTime = interp->currentTime;
  v5 = 0;
  pCurrentAnim = interp->pCurrentAnim;
  v7 = 0;
  v8 = currentTime - time;
  animCallBackTime = interp->animCallBackTime;
  interp->currentTime = v8;
  if ( currentTime > animCallBackTime )
    v5 = 1;
  if ( v8 <= animCallBackTime )
    v7 = 1;
  v10 = v5 & v7;
  if ( v8 >= 0.0 )
  {
    numNodes = interp->numNodes;
    if ( numNodes )
    {
      for ( i = interp + 1; ; i = (RtAnimInterpolator_0 *)((char *)i + interp->currentInterpKeyFrameSize) )
      {
        v14 = i->pCurrentAnim;
        --numNodes;
        if ( v8 < *(float *)&i->pCurrentAnim->numFrames )
        {
          do
          {
            LODWORD(i->currentTime) = v14;
            v14 = (RtAnimAnimation_0 *)v14->interpInfo;
            i->pCurrentAnim = v14;
          }
          while ( interp->currentTime < *(float *)&v14->numFrames );
        }
        ((void (__fastcall *)(RtAnimInterpolator_0 *))interp->keyFrameInterpolateCB)(i);
        if ( !numNodes )
          break;
        v8 = interp->currentTime;
      }
    }
    v11 = 0;
    interp->pNextFrame = 0;
    if ( v10 != 1 )
      return 1;
  }
  else
  {
    do
      v8 = pCurrentAnim->duration + v8;
    while ( v8 < 0.0 );
    interp->currentTime = v8;
    RtAnimInterpolatorSetCurrentAnim(interp, pCurrentAnim);
    RtAnimInterpolatorAddAnimTime(interp, v8);
    if ( !((interp->currentTime < interp->animCallBackTime) | v10) )
    {
LABEL_20:
      pAnimLoopCallBack = interp->pAnimLoopCallBack;
      if ( pAnimLoopCallBack && !(int)pAnimLoopCallBack(interp, interp->pAnimLoopCallBackData) )
        interp->pAnimLoopCallBack = 0;
      return 1;
    }
    v11 = 1;
  }
  pAnimCallBack = interp->pAnimCallBack;
  if ( pAnimCallBack && !(int)pAnimCallBack(interp, interp->pAnimCallBackData) )
    interp->pAnimCallBack = 0;
  if ( v11 )
    goto LABEL_20;
  return 1;
}

//----- (001EB530) --------------------------------------------------------
RwBool __fastcall RtAnimInterpolatorAddAnimTime(RtAnimInterpolator_0 *interp, RwReal time)
{
  RtAnimCallBack currentAnimKeyFrameSize; // r2
  float currentTime; // s4
  int v6; // r0
  float animCallBackTime; // s2
  int v8; // r1
  float v9; // s16
  RtAnimAnimation_0 *pCurrentAnim; // r5
  RwInt32 numNodes; // r6
  int v12; // r8
  float duration; // s0
  int v14; // r11
  unsigned int v15; // r12
  int *pNextFrame; // r0
  int v17; // r3
  RwInt32 *p_currentInterpKeyFrameSize; // r10
  _DWORD *v19; // r5
  char *v20; // r0
  RtAnimInterpolator_0 *v21; // r5
  bool v22; // zf
  bool v23; // zf

  if ( time > 0.0 )
  {
    currentTime = interp->currentTime;
    v6 = 0;
    animCallBackTime = interp->animCallBackTime;
    v8 = 0;
    v9 = currentTime + time;
    pCurrentAnim = interp->pCurrentAnim;
    numNodes = interp->numNodes;
    v12 = 0;
    duration = interp->pCurrentAnim->duration;
    interp->currentTime = v9;
    if ( currentTime < animCallBackTime )
      v6 = 1;
    if ( v9 >= animCallBackTime )
      v8 = 1;
    v14 = v6 & v8;
    if ( v9 > duration )
    {
      do
      {
        v9 = v9 - duration;
        if ( v9 >= animCallBackTime )
          v14 |= 1u;
      }
      while ( v9 > duration );
      interp->currentTime = v9;
      RtAnimInterpolatorSetCurrentAnim(interp, pCurrentAnim);
      v12 = 1;
      interp->currentTime = v9;
    }
    if ( !interp->pNextFrame )
    {
      RtAnimInterpolatorSetCurrentAnim(interp, pCurrentAnim);
      interp->currentTime = v9;
    }
    if ( RunUVAnim )
    {
      currentAnimKeyFrameSize = (RtAnimCallBack)interp->currentAnimKeyFrameSize;
      v15 = (unsigned int)pCurrentAnim->pFrames + (_DWORD)currentAnimKeyFrameSize * pCurrentAnim->numFrames;
      pNextFrame = (int *)interp->pNextFrame;
      if ( (unsigned int)pNextFrame >= v15 )
      {
        p_currentInterpKeyFrameSize = &interp->currentInterpKeyFrameSize;
      }
      else
      {
        v17 = *pNextFrame;
        p_currentInterpKeyFrameSize = &interp->currentInterpKeyFrameSize;
        if ( *(float *)(*pNextFrame + 4) <= v9 )
        {
          currentAnimKeyFrameSize = 0;
          while ( 1 )
          {
            v19 = (RtAnimAnimation_0 **)((char *)&interp[1].pCurrentAnim
                                       + *p_currentInterpKeyFrameSize * (_DWORD)currentAnimKeyFrameSize);
            currentAnimKeyFrameSize = (RtAnimCallBack)((char *)currentAnimKeyFrameSize + 1);
            if ( (int)currentAnimKeyFrameSize >= numNodes )
              currentAnimKeyFrameSize = 0;
            if ( v19[1] == v17 )
            {
              *v19 = v17;
              v19[1] = interp->pNextFrame;
              v20 = (char *)interp->pNextFrame + interp->currentAnimKeyFrameSize;
              interp->pNextFrame = v20;
              if ( (unsigned int)v20 >= v15 )
                break;
              v17 = *(_DWORD *)v20;
              if ( *(float *)(*(_DWORD *)v20 + 4) > interp->currentTime )
                break;
            }
          }
        }
      }
      if ( numNodes >= 1 )
      {
        v21 = interp + 1;
        do
        {
          ((void (__fastcall *)(RtAnimInterpolator_0 *, RtAnimAnimation_0 *, _DWORD, _DWORD, void *))interp->keyFrameInterpolateCB)(
            v21,
            v21->pCurrentAnim,
            LODWORD(v21->currentTime),
            LODWORD(interp->currentTime),
            interp->pCurrentAnim->customData);
          --numNodes;
          v21 = (RtAnimInterpolator_0 *)((char *)v21 + *p_currentInterpKeyFrameSize);
        }
        while ( numNodes );
      }
    }
    v22 = v14 == 0;
    if ( v14 )
    {
      currentAnimKeyFrameSize = interp->pAnimCallBack;
      v22 = currentAnimKeyFrameSize == 0;
    }
    if ( !v22 && !(int)currentAnimKeyFrameSize(interp, interp->pAnimCallBackData) )
      interp->pAnimCallBack = 0;
    v23 = v12 == 0;
    if ( v12 )
    {
      currentAnimKeyFrameSize = interp->pAnimLoopCallBack;
      v23 = currentAnimKeyFrameSize == 0;
    }
    if ( !v23 && !(int)currentAnimKeyFrameSize(interp, interp->pAnimLoopCallBackData) )
      interp->pAnimLoopCallBack = 0;
  }
  return 1;
}
// 1EB69C: variable 'currentAnimKeyFrameSize' is possibly undefined

//----- (001EB6DC) --------------------------------------------------------
RwBool __fastcall RtAnimInterpolatorSetCurrentTime(RtAnimInterpolator_0 *anim, RwReal time)
{
  float v2; // r1

  v2 = time - anim->currentTime;
  if ( v2 >= 0.0 )
  {
    RtAnimInterpolatorAddAnimTime(anim, v2);
    return 1;
  }
  else
  {
    RtAnimInterpolatorSubAnimTime(anim, COERCE_RWREAL(LODWORD(v2) ^ 0x80000000));
    return (RwBool)&dword_0 + 1;
  }
}
// 0: using guessed type int dword_0;

//----- (001EB710) --------------------------------------------------------
RwBool __fastcall RtAnimAnimationMakeDelta(RtAnimAnimation_0 *animation, RwInt32 numNodes, RwReal time)
{
  RwInt32 interpKeyFrameSize; // r6
  int v7; // r9
  RwBool result; // r0
  float *pFrames; // r10
  char *v10; // r4
  int v11; // r11
  float *v12; // r8
  float *v13; // r6
  int v14; // r0
  float *v15; // r1
  __int64 v16; // r0
  RwInt32 v17; // [sp+4h] [bp-2Ch]

  interpKeyFrameSize = animation->interpInfo->interpKeyFrameSize;
  v7 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(interpKeyFrameSize * numNodes + 76);
  result = 0;
  *(_DWORD *)(v7 + 20) = -1082130432;
  *(_DWORD *)(v7 + 24) = 0;
  *(_DWORD *)(v7 + 28) = 0;
  *(_DWORD *)(v7 + 32) = interpKeyFrameSize;
  *(_DWORD *)(v7 + 36) = interpKeyFrameSize;
  *(_DWORD *)(v7 + 40) = -1;
  v17 = numNodes;
  *(_DWORD *)(v7 + 44) = numNodes;
  *(_DWORD *)(v7 + 48) = 0;
  *(_QWORD *)(v7 + 60) = 0LL;
  *(_QWORD *)(v7 + 68) = 0LL;
  *(_QWORD *)v7 = 0LL;
  *(_QWORD *)(v7 + 8) = 0LL;
  *(_DWORD *)(v7 + 16) = 0;
  *(_DWORD *)(v7 + 52) = 0;
  *(_DWORD *)(v7 + 56) = v7;
  if ( v7 )
  {
    RtAnimInterpolatorSetCurrentAnim((RtAnimInterpolator_0 *)v7, animation);
    if ( (float)(time - *(float *)(v7 + 4)) >= 0.0 )
      RtAnimInterpolatorAddAnimTime((RtAnimInterpolator_0 *)v7, time - *(float *)(v7 + 4));
    else
      RtAnimInterpolatorSubAnimTime((RtAnimInterpolator_0 *)v7, -(float)(time - *(float *)(v7 + 4)));
    if ( numNodes >= 1 )
    {
      pFrames = (float *)animation->pFrames;
      v10 = (char *)(v7 + 76);
      v11 = 0;
      v12 = pFrames;
      do
      {
        animation->interpInfo->keyFrameMulRecipCB(v12, v10);
        v13 = pFrames;
        while ( v13[1] != animation->duration )
        {
          if ( *(float **)v13 != v12 )
          {
            v14 = *(_DWORD *)(v7 + 40);
            do
            {
              v15 = *(float **)((char *)v13 + v14);
              v13 = (float *)((char *)v13 + v14);
            }
            while ( v15 != v12 );
            v12 = v13;
          }
          animation->interpInfo->keyFrameMulRecipCB(v12, v10);
        }
        v16 = *(_QWORD *)(v7 + 36);
        pFrames = (float *)((char *)pFrames + HIDWORD(v16));
        ++v11;
        v10 += v16;
        v12 = pFrames;
      }
      while ( v11 != v17 );
    }
    (*((void (__fastcall **)(int))RwEngineInstance + 76))(v7);
    return 1;
  }
  return result;
}

//----- (001EB854) --------------------------------------------------------
RwBool __fastcall RtAnimInterpolatorBlend(
        RtAnimInterpolator_0 *outAnim,
        RtAnimInterpolator_0 *inAnim1,
        RtAnimInterpolator_0 *inAnim2,
        RwReal alpha)
{
  RwInt32 v6; // r8

  if ( outAnim->numNodes >= 1 )
  {
    v6 = 0;
    do
    {
      ((void (__fastcall *)(char *, char *, char *, _DWORD))outAnim->keyFrameBlendCB)(
        (char *)&outAnim[1] + outAnim->currentInterpKeyFrameSize * v6,
        (char *)&inAnim1[1] + inAnim1->currentInterpKeyFrameSize * v6,
        (char *)&inAnim2[1] + inAnim2->currentInterpKeyFrameSize * v6,
        LODWORD(alpha));
      ++v6;
    }
    while ( v6 < outAnim->numNodes );
  }
  return 1;
}

//----- (001EB8B0) --------------------------------------------------------
RwBool __fastcall RtAnimInterpolatorAddTogether(
        RtAnimInterpolator_0 *outAnim,
        RtAnimInterpolator_0 *inAnim1,
        RtAnimInterpolator_0 *inAnim2)
{
  RwInt32 v6; // r5

  if ( outAnim->numNodes >= 1 )
  {
    v6 = 0;
    do
    {
      outAnim->keyFrameAddCB(
        (char *)&outAnim[1] + outAnim->currentInterpKeyFrameSize * v6,
        (char *)&inAnim1[1] + inAnim1->currentInterpKeyFrameSize * v6,
        (char *)&inAnim2[1] + inAnim2->currentInterpKeyFrameSize * v6);
      ++v6;
    }
    while ( v6 < outAnim->numNodes );
  }
  return 1;
}

//----- (001EB900) --------------------------------------------------------
RtAnimInterpolator_0 *__fastcall RtAnimInterpolatorCreateSubInterpolator(
        RtAnimInterpolator_0 *parentAnim,
        RwInt32 startNode,
        RwInt32 numNodes,
        RwInt32 maxInterpKeyFrameSize)
{
  RwInt32 v4; // r5
  RtAnimInterpolator_0 *result; // r0

  v4 = maxInterpKeyFrameSize;
  if ( maxInterpKeyFrameSize == -1 )
    v4 = parentAnim->maxInterpKeyFrameSize;
  result = (RtAnimInterpolator_0 *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(v4 * numNodes + 76);
  result->offsetInParent = startNode;
  result->parentAnimation = parentAnim;
  result->animCallBackTime = -1.0;
  result->pAnimLoopCallBack = 0;
  result->pAnimLoopCallBackData = 0;
  result->maxInterpKeyFrameSize = v4;
  result->currentInterpKeyFrameSize = v4;
  result->currentAnimKeyFrameSize = -1;
  result->numNodes = numNodes;
  result->isSubInterpolator = 1;
  *(_QWORD *)&result->keyFrameApplyCB = 0LL;
  *(_QWORD *)&result->keyFrameInterpolateCB = 0LL;
  *(_QWORD *)&result->pCurrentAnim = 0LL;
  *(_QWORD *)&result->pNextFrame = 0LL;
  result->pAnimCallBackData = 0;
  return result;
}

//----- (001EB96C) --------------------------------------------------------
RwBool __fastcall RtAnimInterpolatorBlendSubInterpolator(
        RtAnimInterpolator_0 *outAnim,
        RtAnimInterpolator_0 *inAnim1,
        RtAnimInterpolator_0 *inAnim2,
        RwReal alpha)
{
  RtAnimInterpolator_0 *v7; // r11
  RwInt32 offsetInParent; // r5
  int v9; // r10
  RtAnimInterpolator_0 *v10; // r10
  RwInt32 currentInterpKeyFrameSize; // r5
  RtAnimInterpolator_0 *v12; // r4
  int numNodes; // r0
  RwInt32 v14; // r1
  RwReal v15; // r4
  RwInt32 v16; // r6
  RwInt32 v17; // r2
  RtAnimInterpolator_0 *v18; // r9
  RwInt32 v19; // r0
  RwInt32 v20; // r2
  RwReal v21; // r4
  RwInt32 v22; // r6
  RwInt32 v23; // r3
  char *v24; // r0
  char *v25; // r1
  int v26; // r2
  int v28; // [sp+8h] [bp-30h]
  int v29; // [sp+Ch] [bp-2Ch]
  RtAnimInterpolator_0 *v31; // [sp+18h] [bp-20h]

  v31 = inAnim1;
  if ( outAnim->isSubInterpolator )
  {
    if ( outAnim->numNodes >= 1 )
    {
      v7 = inAnim1 + 1;
      offsetInParent = outAnim->offsetInParent;
      v9 = 0;
      v29 = offsetInParent - inAnim2->offsetInParent;
      v28 = offsetInParent - inAnim1->offsetInParent;
      do
      {
        ((void (__fastcall *)(char *, char *, char *, _DWORD))outAnim->keyFrameBlendCB)(
          (char *)&outAnim[1] + outAnim->currentInterpKeyFrameSize * v9,
          (char *)v7 + inAnim1->currentInterpKeyFrameSize * (v28 + v9),
          (char *)&inAnim2[1] + inAnim2->currentInterpKeyFrameSize * (v29 + v9),
          LODWORD(alpha));
        ++v9;
        inAnim1 = v31;
      }
      while ( offsetInParent + v9 < outAnim->numNodes + outAnim->offsetInParent );
    }
  }
  else
  {
    v10 = outAnim + 1;
    currentInterpKeyFrameSize = outAnim->currentInterpKeyFrameSize;
    if ( inAnim1->isSubInterpolator )
    {
      v12 = inAnim2 + 1;
      qmemcpy(&outAnim[1], &inAnim2[1], inAnim1->offsetInParent * currentInterpKeyFrameSize);
      numNodes = v31->numNodes;
      v14 = v31->offsetInParent;
      if ( numNodes < 1 )
      {
        v17 = numNodes + v14;
      }
      else
      {
        v15 = alpha;
        v16 = v31->offsetInParent;
        do
        {
          ((void (__fastcall *)(char *, char *, char *, _DWORD))outAnim->keyFrameBlendCB)(
            (char *)v10 + currentInterpKeyFrameSize * v16,
            (char *)&v31[1] + v31->currentInterpKeyFrameSize * (v16 - v14),
            (char *)&inAnim2[1] + inAnim2->currentInterpKeyFrameSize * v16,
            LODWORD(v15));
          ++v16;
          currentInterpKeyFrameSize = outAnim->currentInterpKeyFrameSize;
          v14 = v31->offsetInParent;
          v17 = v31->numNodes + v14;
        }
        while ( v16 < v17 );
        v12 = inAnim2 + 1;
      }
      v24 = (char *)v10 + currentInterpKeyFrameSize * v17;
      v25 = (char *)v12 + inAnim2->currentInterpKeyFrameSize * v17;
      v26 = outAnim->numNodes - v17;
    }
    else
    {
      v18 = inAnim1 + 1;
      qmemcpy(&outAnim[1], &inAnim1[1], inAnim2->offsetInParent * currentInterpKeyFrameSize);
      v19 = inAnim2->numNodes;
      v20 = inAnim2->offsetInParent;
      if ( v19 < 1 )
      {
        v23 = v19 + v20;
      }
      else
      {
        v21 = alpha;
        v22 = inAnim2->offsetInParent;
        do
        {
          ((void (__fastcall *)(char *, char *, char *, _DWORD))outAnim->keyFrameBlendCB)(
            (char *)&outAnim[1] + currentInterpKeyFrameSize * v22,
            (char *)v18 + v31->currentInterpKeyFrameSize * v22,
            (char *)&inAnim2[1] + inAnim2->currentInterpKeyFrameSize * (v22 - v20),
            LODWORD(v21));
          ++v22;
          v20 = inAnim2->offsetInParent;
          currentInterpKeyFrameSize = outAnim->currentInterpKeyFrameSize;
          v23 = inAnim2->numNodes + v20;
        }
        while ( v22 < v23 );
        v10 = outAnim + 1;
      }
      v24 = (char *)v10 + currentInterpKeyFrameSize * v23;
      v26 = outAnim->numNodes - v23;
      v25 = (char *)v18 + v31->currentInterpKeyFrameSize * v23;
    }
    qmemcpy(v24, v25, v26 * currentInterpKeyFrameSize);
  }
  return 1;
}

//----- (001EBB0E) --------------------------------------------------------
RwBool __fastcall RtAnimInterpolatorAddSubInterpolator(
        RtAnimInterpolator_0 *outAnim,
        RtAnimInterpolator_0 *mainAnim,
        RtAnimInterpolator_0 *subAnim)
{
  RwInt32 offsetInParent; // r10
  int v7; // r8
  RtAnimInterpolator_0 *v9; // [sp+4h] [bp-24h]
  RtAnimInterpolator_0 *v10; // [sp+8h] [bp-20h]

  if ( outAnim->isSubInterpolator )
    offsetInParent = 0;
  else
    offsetInParent = subAnim->offsetInParent;
  if ( outAnim->numNodes >= 1 )
  {
    v10 = subAnim + 1;
    v7 = 0;
    v9 = mainAnim + 1;
    do
    {
      outAnim->keyFrameAddCB(
        (char *)&outAnim[1] + outAnim->currentInterpKeyFrameSize * (offsetInParent + v7),
        (char *)v9 + (v7 + subAnim->offsetInParent) * mainAnim->currentInterpKeyFrameSize,
        (char *)v10 + subAnim->currentInterpKeyFrameSize * v7);
      ++v7;
    }
    while ( v7 < outAnim->numNodes );
  }
  return 1;
}

//----- (001EBB8C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
RwImage_0 *__fastcall RtBMPImageRead(const RwChar *imageName)
{
  RwStream_0 *v1; // r0
  RwStream_0 *v2; // r4
  int v3; // r6
  int v4; // r11
  int v5; // r5
  RwInt32 v6; // r0
  RwInt32 v7; // r9
  int v8; // r5
  int v9; // r8
  bool v10; // zf
  int v11; // r6
  RwInt32 v12; // r2
  RwImage_0 *v13; // r0
  RwImage_0 *v14; // r5
  int v15; // r12
  RwRGBA_0 *palette; // r10
  int v17; // r6
  int v18; // r12
  unsigned int v19; // r0
  bool v20; // cf
  __int64 v21; // d22
  __int64 v22; // d23
  RwInt32 *p_width; // r1
  unsigned int v24; // r2
  char *v25; // r3
  const char *v26; // r1
  __int128 v27; // q8
  __int128 v28; // q9
  __int128 v29; // q10
  char *v30; // r3
  int v31; // r0
  int v32; // r0
  RwRGBA_0 *v33; // r1
  bool v34; // cf
  __int64 v35; // d22
  __int64 v36; // d23
  RwInt32 *v37; // r1
  int v38; // r2
  char *v39; // r3
  const char *v40; // r1
  __int128 v41; // q8
  __int128 v42; // q9
  __int128 v43; // q10
  char *v44; // r3
  RwRGBA_0 *v45; // r9
  unsigned int v46; // r12
  RwUInt8 *p_alpha; // r3
  char *v48; // r1
  RwUInt8 *v49; // r0
  char *v50; // r10
  int v51; // r1
  RwRGBA_0 *v52; // r6
  int v53; // r2
  int v54; // r1
  RwInt32 *v55; // r2
  int v56; // r0
  RwRGBA_0 *v57; // r6
  RwUInt8 v58; // r3
  int v59; // r6
  bool v60; // zf
  RwInt32 v61; // r8
  bool v62; // cc
  char *v63; // r9
  RwInt32 v64; // r11
  RwInt32 v65; // r6
  unsigned int v66; // r10
  RwInt32 v67; // r0
  int v68; // r11
  int v69; // r8
  int v70; // r6
  RwInt32 v72; // [sp+Ch] [bp-444h]
  RwInt32 v73; // [sp+Ch] [bp-444h]
  RwInt32 depth; // [sp+10h] [bp-440h]
  int v75; // [sp+14h] [bp-43Ch]
  int v76; // [sp+18h] [bp-438h]
  RwInt32 v77; // [sp+1Ch] [bp-434h]
  int v78; // [sp+20h] [bp-430h]
  int v79; // [sp+20h] [bp-430h]
  RwError_0 code; // [sp+24h] [bp-42Ch] BYREF
  __int16 buffer; // [sp+2Ch] [bp-424h] BYREF
  RwInt32 width; // [sp+30h] [bp-420h] BYREF
  RwInt32 v83; // [sp+34h] [bp-41Ch]
  int v84; // [sp+38h] [bp-418h]
  int v85; // [sp+3Ch] [bp-414h]
  int v86; // [sp+4Ch] [bp-404h]
  int8x8x3_t v87; // 0:d24.8,8:d26.8,16:d28.8 OVERLAPPED
  int8x8x3_t v88; // 0:d25.8,8:d27.8,16:d29.8
  int8x8x4_t v89; // 0:d24.8,8:d26.8,16:d28.8,24:d30.8 OVERLAPPED
  int8x8x4_t v90; // 0:d25.8,8:d27.8,16:d29.8,24:d31.8

  v1 = RwStreamOpen(rwSTREAMFILENAME, rwSTREAMREAD, imageName);
  v2 = v1;
  if ( !v1 )
    return 0;
  if ( RwStreamRead(v1, &buffer, 4u) != 4 )
    goto LABEL_93;
  RwMemNative32(&buffer, 4u);
  if ( buffer != 19778 )
    goto LABEL_93;
  if ( RwStreamRead(v2, (char *)&width + 2, 0xEu) != 14 )
    goto LABEL_93;
  v3 = v84;
  v4 = v85;
  v5 = v85 - 4;
  if ( RwStreamRead(v2, &width, v85 - 4) != v5 )
    goto LABEL_93;
  if ( v4 == 12 )
  {
    v78 = v3;
    v6 = (__int16)width;
    v7 = SHIWORD(width);
    v8 = HIWORD(v83);
    v76 = 0;
  }
  else
  {
    if ( v85 == 2 )
      goto LABEL_33;
    v76 = v85;
    v6 = width;
    v7 = v83;
    v9 = v86;
    v78 = v3;
    v8 = HIWORD(v84);
    if ( v86 >= 1 && v86 <= 1 << SBYTE2(v84) )
      goto LABEL_9;
  }
  v9 = 1 << v8;
LABEL_9:
  v10 = v8 == 1;
  v11 = (__int16)v8;
  v12 = 4;
  if ( v8 != 1 )
    v10 = (__int16)v8 == 4;
  if ( !v10 )
  {
    if ( (__int16)v8 == 8 )
      v12 = 8;
    else
      v12 = 32;
  }
  v75 = v8;
  v77 = v6;
  v13 = RwImageCreate(v6, v7, v12);
  v14 = v13;
  if ( !v13 )
    goto LABEL_93;
  if ( !RwImageAllocatePixels(v13) )
    goto LABEL_92;
  v15 = v4 + 14;
  depth = v11;
  if ( v11 <= 8 )
  {
    v72 = v7;
    palette = v14->palette;
    if ( v4 == 12 )
    {
      v17 = 3 * v9;
      if ( RwStreamRead(v2, &width, 3 * v9) == 3 * v9 )
      {
        v18 = 26;
        if ( v9 >= 1 )
        {
          if ( (unsigned int)v9 <= 0xF )
            goto LABEL_52;
          v19 = v9 & 0xFFFFFFF0;
          if ( (v9 & 0xFFFFFFF0) == 0 )
            goto LABEL_52;
          v20 = palette >= (RwRGBA_0 *)((char *)&width + v17);
          if ( palette < (RwRGBA_0 *)((char *)&width + v17) )
            v20 = &width >= (RwInt32 *)&palette[v9];
          if ( v20 )
          {
            v21 = -1LL;
            v22 = -1LL;
            p_width = &width;
            v24 = v9 & 0xFFFFFFF0;
            v25 = (char *)palette;
            do
            {
              v87 = vld3_s8((const char *)p_width);
              v26 = (const char *)(p_width + 6);
              v24 -= 16;
              v88 = vld3_s8(v26);
              p_width = (RwInt32 *)(v26 + 24);
              v27 = *(_OWORD *)v87.val[2].n64_u64;
              v28 = *(_OWORD *)v87.val[1].n64_u64;
              v29 = *(_OWORD *)v87.val[0].n64_u64;
              vst4_s8(v25, *(int8x8x4_t *)(&v21 - 3));
              v30 = v25 + 32;
              vst4_s8(v30, *(int8x8x4_t *)(&v22 - 3));
              v25 = v30 + 32;
            }
            while ( v24 );
            if ( v9 == v19 )
              goto LABEL_60;
          }
          else
          {
LABEL_52:
            v19 = 0;
          }
          v45 = &palette[v19];
          v46 = v9 - v19;
          p_alpha = &v45->_anon_0._anon_0.alpha;
          v48 = (char *)&width + 3 * v19;
          v49 = (RwUInt8 *)(v48 + 2);
          v50 = v48 + 1;
          v51 = 0;
          do
          {
            v52 = &v45[v51];
            *(p_alpha - 3) = *v49;
            v53 = 3 * v51++;
            v52->_anon_0._anon_0.green = v50[v53];
            LOBYTE(v53) = *(v49 - 2);
            v49 += 3;
            v52->_anon_0._anon_0.blue = v53;
            *p_alpha = -1;
            p_alpha += 4;
          }
          while ( v46 != v51 );
          v18 = 26;
          v17 = 3 * v9;
        }
LABEL_60:
        v7 = v72;
        v15 = v18 + v17;
        goto LABEL_61;
      }
LABEL_93:
      v14 = 0;
      goto LABEL_94;
    }
    if ( v4 == 40 )
    {
      if ( RwStreamRead(v2, &width, 4 * v9) == 4 * v9 )
      {
        if ( v9 >= 1 )
        {
          if ( (unsigned int)v9 <= 0xF )
            goto LABEL_56;
          v31 = v9 & 0xF;
          if ( (v9 & 0xF) == 0 )
            v31 = 16;
          v32 = v9 - v31;
          if ( !v32 )
            goto LABEL_56;
          v33 = (RwRGBA_0 *)((char *)&width + 4 * v9 - 1);
          v34 = palette >= v33;
          if ( palette < v33 )
            v34 = &width >= (RwInt32 *)&palette[v9];
          if ( v34 )
          {
            v35 = -1LL;
            v36 = -1LL;
            v37 = &width;
            v38 = v32;
            v39 = (char *)palette;
            do
            {
              v89 = vld4_s8((const char *)v37);
              v40 = (const char *)(v37 + 8);
              v38 -= 16;
              v90 = vld4_s8(v40);
              v37 = (RwInt32 *)(v40 + 32);
              v41 = *(_OWORD *)v89.val[2].n64_u64;
              v42 = *(_OWORD *)v89.val[1].n64_u64;
              v43 = *(_OWORD *)v89.val[0].n64_u64;
              vst4_s8(v39, *(int8x8x4_t *)(&v35 - 3));
              v44 = v39 + 32;
              vst4_s8(v44, *(int8x8x4_t *)(&v36 - 3));
              v39 = v44 + 32;
            }
            while ( v38 );
          }
          else
          {
LABEL_56:
            v32 = 0;
          }
          v54 = v9 - v32;
          v55 = &width;
          v56 = v32;
          do
          {
            --v54;
            palette[v56]._anon_0._anon_0.red = BYTE2(v55[v56]);
            v57 = &palette[v56];
            ++palette;
            v57->_anon_0._anon_0.green = BYTE1(v55[v56]);
            v58 = v55[v56];
            ++v55;
            v57->_anon_0._anon_0.alpha = -1;
            v57->_anon_0._anon_0.blue = v58;
          }
          while ( v54 );
        }
        v18 = 54;
        v17 = 4 * v9;
        goto LABEL_60;
      }
      goto LABEL_93;
    }
LABEL_33:
    v14 = 0;
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483639);
    RwErrorSet(&code);
LABEL_94:
    RwStreamClose(v2, 0);
    return v14;
  }
LABEL_61:
  if ( !RwStreamSkip(v2, v78 - v15) )
  {
LABEL_92:
    RwImageDestroy(v14);
    goto LABEL_93;
  }
  v59 = (*((int (__fastcall **)(unsigned int))RwEngineInstance + 75))(3 * ((v77 + 7) & 0xFFFFFFF8));
  if ( !v59 )
  {
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483629, 3 * ((v77 + 7) & 0xFFFFFFF8));
    RwErrorSet(&code);
    goto LABEL_97;
  }
  v60 = v75 == 24;
  if ( v75 != 24 )
    v60 = v76 == 0;
  if ( v60 )
  {
    v61 = v7;
    v62 = v7 < 1;
    v63 = (char *)v59;
    if ( v62 )
      goto LABEL_89;
    v64 = v61 - 1;
    v65 = 0;
    while ( 1 )
    {
      v66 = ((depth * v77 + 7) / 8 + 3) & 0xFFFFFFFC;
      if ( RwStreamRead(v2, v63, v66) != v66 )
        break;
      BMPImageSetSpan(v14, v64, (RwUInt8 *)v63, depth, 0);
      ++v65;
      --v64;
      if ( v65 >= v61 )
      {
LABEL_89:
        (*((void (__fastcall **)(char *))RwEngineInstance + 76))(v63);
        goto LABEL_94;
      }
    }
    (*((void (__fastcall **)(char *))RwEngineInstance + 76))(v63);
    goto LABEL_92;
  }
  if ( v76 != 1 )
  {
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483639);
    RwErrorSet(&code);
    (*((void (__fastcall **)(int))RwEngineInstance + 76))(v59);
    goto LABEL_97;
  }
  v67 = v7;
  v62 = v7 < 1;
  v63 = (char *)v59;
  v73 = v67;
  if ( v62 )
    goto LABEL_89;
  v68 = 0;
  v79 = v67 - 1;
LABEL_76:
  if ( RwStreamRead(v2, &code, 2u) == 2 )
  {
    v69 = 0;
    do
    {
      if ( LOBYTE(code.pluginID) )
      {
        memset(&v63[v69], BYTE1(code.pluginID), LOBYTE(code.pluginID));
        v69 += LOBYTE(code.pluginID);
      }
      else
      {
        v70 = BYTE1(code.pluginID);
        if ( BYTE1(code.pluginID) < 3u )
        {
          if ( BYTE1(code.pluginID) )
          {
            v68 = v79;
            if ( BYTE1(code.pluginID) != 1 )
              break;
          }
          BMPImageSetSpan(v14, v79 - v68++, (RwUInt8 *)v63, depth, 1);
          if ( v68 >= v73 )
            goto LABEL_89;
          goto LABEL_76;
        }
        if ( RwStreamRead(v2, &v63[v69], BYTE1(code.pluginID)) != v70 )
          break;
        v69 += BYTE1(code.pluginID);
        if ( (code.pluginID & 0x100) != 0 && RwStreamRead(v2, &code, 1u) != 1 )
          break;
      }
    }
    while ( RwStreamRead(v2, &code, 2u) == 2 );
  }
  (*((void (__fastcall **)(char *))RwEngineInstance + 76))(v63);
LABEL_97:
  RwImageDestroy(v14);
  RwStreamClose(v2, 0);
  return 0;
}
// 1EBB8C: fragmented variable at d22.8 may be wrong
// 1EBB8C: fragmented variable at d23.8 may be wrong
// 1EBCD5: failed to expand linear variable 0:d24.8,8:d26.8,16:d28.8
// 1EBD99: failed to expand linear variable 0:d24.8,8:d26.8,16:d28.8,24:d30.8

//----- (001EC09C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
RwError_0 *__fastcall BMPImageSetSpan(RwImage_0 *image, RwInt32 y, RwUInt8 *cpSpan, RwInt32 depth, RwBool bRGB)
{
  unsigned int width; // r12
  __int64 v6; // kr00_8
  __int64 v7; // kr08_8
  RwError_0 *result; // r0
  int v9; // r3
  bool v10; // zf
  RwUInt8 *v11; // r2
  unsigned int v12; // r8
  unsigned int v13; // t1
  unsigned int v14; // r11
  unsigned int v15; // r1
  RwInt32 *v16; // r9
  bool v17; // zf
  bool v18; // zf
  bool v19; // zf
  unsigned int v20; // t1
  int v21; // r1
  int v22; // r3
  unsigned int v23; // r6
  RwError_0 *v24; // r1
  RwUInt8 *v25; // r4
  unsigned int v26; // t1
  bool v27; // zf
  RwUInt8 *v28; // r2
  unsigned int v29; // r3
  unsigned int v30; // t1
  unsigned int v31; // t1
  int v32; // r3
  unsigned int v33; // r5
  __int128 v34; // q8
  RwError_0 *v35; // r6
  RwUInt8 *v36; // r1
  RwUInt8 *v37; // r2
  char *v38; // r0
  RwUInt8 v39; // r3
  RwUInt8 v40; // r6
  unsigned int v41; // r10
  unsigned int v42; // r8
  RwUInt8 *v43; // r2
  unsigned int v44; // r4
  RwError_0 *v45; // r1
  bool v46; // zf
  bool v47; // zf
  bool v48; // zf
  RwUInt8 v49; // t1
  RwUInt8 v50; // r1
  int v51; // t1
  int v52; // r3
  unsigned int v53; // r6
  RwError_0 *v54; // r1
  RwUInt8 *v55; // r4
  unsigned int v56; // t1
  int v57; // r3
  unsigned int v58; // r5
  RwError_0 *v59; // r1
  RwUInt8 *v60; // r6
  RwUInt8 v61; // r2
  int v62; // r3
  unsigned int v63; // r5
  RwError_0 *v64; // r6
  RwUInt8 *v65; // r1
  RwUInt8 v66; // r6
  __int64 v67; // d21
  int16x8_t v68; // q11
  int16x8_t v69; // q12
  int32x4_t v70; // q13
  int16x8_t v71; // q14
  unsigned __int64 v72; // d20
  unsigned __int64 v73; // d19
  unsigned __int64 v74; // d18
  __int64 v75; // d21
  int16x8_t v76; // q11
  int16x8_t v77; // q12
  int32x4_t v78; // q13
  int16x8_t v79; // q14
  unsigned __int64 v80; // d20
  unsigned __int64 v81; // d19
  unsigned __int64 v82; // d18
  __int128 v83; // q8
  RwUInt8 *v84; // r2
  __int128 v85; // q12 OVERLAPPED
  char *v86; // r0
  __int64 v87; // d22
  __int64 v88; // d23
  RwUInt8 *v89; // r2
  __int128 v90; // q8
  __int128 v91; // q9
  __int128 v92; // q10
  char *v93; // r0
  unsigned int v94; // [sp+4h] [bp-2Ch]
  unsigned int v95; // [sp+8h] [bp-28h]
  RwError_0 code; // [sp+Ch] [bp-24h] BYREF
  int8x8x3_t v97; // 0:d18.8,8:d20.8,16:d22.8 OVERLAPPED
  int8x8x3_t v98; // 0:d19.8,8:d21.8,16:d23.8 OVERLAPPED
  int8x8x3_t v99; // 0:d24.8,8:d26.8,16:d28.8 OVERLAPPED
  int8x8x3_t v100; // 0:d25.8,8:d27.8,16:d29.8
  int8x8x4_t v101; // 0:d18.8,8:d20.8,16:d22.8,24:d24.8 OVERLAPPED
  int8x8x4_t v102; // 0:d19.8,8:d21.8,16:d23.8,24:d25.8

  width = image->width;
  v6 = *(_QWORD *)&image->depth;
  v7 = *(_QWORD *)&image->cpPixels;
  result = (RwError_0 *)(v7 + HIDWORD(v6) * y);
  v9 = v6 | (depth << 8);
  if ( v9 > 2055 )
  {
    v21 = y * HIDWORD(v6);
    if ( v9 >= 4128 )
    {
      if ( v9 == 4128 )
      {
        if ( !width )
          return result;
        if ( width <= 7
          || (v52 = width & 7, v53 = width - v52, width == v52)
          || result < (RwError_0 *)&cpSpan[2 * width] && v21 + 4 * width + (unsigned int)v7 > (unsigned int)cpSpan )
        {
          v54 = result;
          v52 = width;
          v55 = cpSpan;
        }
        else
        {
          v54 = (RwError_0 *)((char *)result + 4 * v53);
          v55 = &cpSpan[2 * v53];
          v75 = -1LL;
          do
          {
            v76 = *(int16x8_t *)cpSpan;
            cpSpan += 16;
            v53 -= 8;
            v77 = vmovl_u16(*(uint16x4_t *)&v76.n128_i8[8]);
            v78 = vmovl_u16((uint16x4_t)v76.n128_u64[0]);
            *(int16x4_t *)&v79.n128_i8[8] = vshrn_n_s32(v77, 3u);
            *(int16x4_t *)&v77.n128_i8[8] = vshrn_n_s32(v77, 8u);
            v79.n128_u64[0] = vshrn_n_s32(v78, 3u).n64_u64[0];
            v77.n128_u64[0] = vshrn_n_s32(v78, 8u).n64_u64[0];
            v80 = vshl_n_s8(vmovn_s16(v76), 3u).n64_u64[0];
            v81 = vmovn_s16(v79).n64_u64[0] & 0xFCFCFCFCFCFCFCFCLL;
            v82 = vmovn_s16(v77).n64_u64[0] & 0xF8F8F8F8F8F8F8F8LL;
            vst4_s8((char *)result, *(int8x8x4_t *)(&v75 - 3));
            result += 4;
          }
          while ( v53 );
          if ( (width & 7) == 0 )
            return result;
        }
        do
        {
          v56 = *(unsigned __int16 *)v55;
          v55 += 2;
          --v52;
          HIBYTE(v54->pluginID) = -1;
          BYTE1(v54->pluginID) = (v56 >> 3) & 0xFC;
          LOBYTE(v54->pluginID) = BYTE1(v56) & 0xF8;
          result = (RwError_0 *)(8 * v56);
          BYTE2(v54->pluginID) = 8 * v56;
          v54 = (RwError_0 *)((char *)v54 + 4);
        }
        while ( v52 );
        return result;
      }
      if ( v9 == 6176 )
      {
        if ( bRGB )
        {
          if ( !width )
            return result;
          if ( width <= 0xF
            || (v57 = width & 0xF, v58 = width - v57, width == v57)
            || result < (RwError_0 *)&cpSpan[3 * width] && v21 + 4 * width + (unsigned int)v7 > (unsigned int)cpSpan )
          {
            v59 = result;
            v57 = width;
            v60 = cpSpan;
          }
          else
          {
            *(_QWORD *)&v83 = -1LL;
            *((_QWORD *)&v83 + 1) = -1LL;
            v59 = (RwError_0 *)((char *)result + 4 * v58);
            v60 = &cpSpan[3 * v58];
            do
            {
              v97 = vld3_s8((const char *)cpSpan);
              v84 = cpSpan + 24;
              v58 -= 16;
              v98 = vld3_s8((const char *)v84);
              cpSpan = v84 + 24;
              v85 = v83;
              vst4_s8((char *)result, *(int8x8x4_t *)v97.val[0].n64_u64);
              v86 = (char *)&result[4];
              vst4_s8(v86, *(int8x8x4_t *)v98.val[0].n64_u64);
              result = (RwError_0 *)(v86 + 32);
            }
            while ( v58 );
            if ( (width & 0xF) == 0 )
              return result;
          }
          result = (RwError_0 *)(elf_hash_bucket + 3);
          do
          {
            --v57;
            LOBYTE(v59->pluginID) = *v60;
            BYTE1(v59->pluginID) = v60[1];
            v61 = v60[2];
            v60 += 3;
            HIBYTE(v59->pluginID) = -1;
            BYTE2(v59->pluginID) = v61;
            v59 = (RwError_0 *)((char *)v59 + 4);
          }
          while ( v57 );
          return result;
        }
        if ( !width )
          return result;
        if ( width <= 0xF
          || (v62 = width & 0xF, v63 = width - v62, width == v62)
          || result < (RwError_0 *)&cpSpan[3 * width] && v21 + 4 * width + (unsigned int)v7 > (unsigned int)cpSpan )
        {
          v64 = result;
          v62 = width;
          v65 = cpSpan;
        }
        else
        {
          v87 = -1LL;
          v88 = -1LL;
          v64 = (RwError_0 *)((char *)result + 4 * v63);
          v65 = &cpSpan[3 * v63];
          do
          {
            v99 = vld3_s8((const char *)cpSpan);
            v89 = cpSpan + 24;
            v63 -= 16;
            v100 = vld3_s8((const char *)v89);
            cpSpan = v89 + 24;
            v90 = *(_OWORD *)v99.val[2].n64_u64;
            v91 = *(_OWORD *)v99.val[1].n64_u64;
            v92 = *(_OWORD *)v99.val[0].n64_u64;
            vst4_s8((char *)result, *(int8x8x4_t *)(&v87 - 3));
            v93 = (char *)&result[4];
            vst4_s8(v93, *(int8x8x4_t *)(&v88 - 3));
            result = (RwError_0 *)(v93 + 32);
          }
          while ( v63 );
          if ( (width & 0xF) == 0 )
            return result;
        }
        result = (RwError_0 *)((char *)&v64->pluginID + 1);
        do
        {
          --v62;
          BYTE1(result->pluginID) = *v65;
          LOBYTE(result->pluginID) = v65[1];
          v66 = v65[2];
          v65 += 3;
          BYTE2(result->pluginID) = -1;
          HIBYTE(result[-1].errorCode) = v66;
          result = (RwError_0 *)((char *)result + 4);
        }
        while ( v62 );
        return result;
      }
      if ( v9 != 8224 )
        goto LABEL_76;
      if ( width )
      {
        if ( width > 0xF )
        {
          v32 = width & 0xF;
          if ( (width & 0xF) == 0 )
            v32 = 16;
          v33 = width - v32;
          if ( width != v32
            && (result >= (RwError_0 *)&cpSpan[4 * width - 1]
             || v21 + 4 * width + (unsigned int)v7 <= (unsigned int)cpSpan) )
          {
            *(_QWORD *)&v34 = -1LL;
            *((_QWORD *)&v34 + 1) = -1LL;
            v35 = (RwError_0 *)((char *)result + 4 * v33);
            v36 = &cpSpan[4 * v33];
            do
            {
              v101 = vld4_s8((const char *)cpSpan);
              v37 = cpSpan + 32;
              width -= 16;
              v102 = vld4_s8((const char *)v37);
              cpSpan = v37 + 32;
              *(_OWORD *)v101.val[3].n64_u64 = v34;
              vst4_s8((char *)result, v101);
              v38 = (char *)&result[4];
              vst4_s8(v38, v102);
              result = (RwError_0 *)(v38 + 32);
            }
            while ( v32 != width );
            result = v35;
            width = v32;
            cpSpan = v36;
          }
        }
        do
        {
          --width;
          LOBYTE(result->pluginID) = *cpSpan;
          BYTE1(result->pluginID) = cpSpan[1];
          v39 = cpSpan[2];
          cpSpan += 4;
          HIBYTE(result->pluginID) = -1;
          BYTE2(result->pluginID) = v39;
          result = (RwError_0 *)((char *)result + 4);
        }
        while ( width );
      }
    }
    else
    {
      if ( v9 == 2056 )
        return (RwError_0 *)sub_19EA98(result, cpSpan, width);
      if ( v9 != 2080 )
      {
        if ( v9 == 3872 )
        {
          if ( !width )
            return result;
          if ( width <= 7
            || (v22 = width & 7, v23 = width - v22, width == v22)
            || result < (RwError_0 *)&cpSpan[2 * width] && v21 + 4 * width + (unsigned int)v7 > (unsigned int)cpSpan )
          {
            v24 = result;
            v22 = width;
            v25 = cpSpan;
          }
          else
          {
            v24 = (RwError_0 *)((char *)result + 4 * v23);
            v67 = -1LL;
            v25 = &cpSpan[2 * v23];
            do
            {
              v68 = *(int16x8_t *)cpSpan;
              cpSpan += 16;
              v23 -= 8;
              v69 = vmovl_u16(*(uint16x4_t *)&v68.n128_i8[8]);
              v70 = vmovl_u16((uint16x4_t)v68.n128_u64[0]);
              *(int16x4_t *)&v71.n128_i8[8] = vshrn_n_s32(v69, 2u);
              *(int16x4_t *)&v69.n128_i8[8] = vshrn_n_s32(v69, 7u);
              v71.n128_u64[0] = vshrn_n_s32(v70, 2u).n64_u64[0];
              v69.n128_u64[0] = vshrn_n_s32(v70, 7u).n64_u64[0];
              v72 = vshl_n_s8(vmovn_s16(v68), 3u).n64_u64[0];
              v73 = vmovn_s16(v71).n64_u64[0] & 0xF8F8F8F8F8F8F8F8LL;
              v74 = vmovn_s16(v69).n64_u64[0] & 0xF8F8F8F8F8F8F8F8LL;
              vst4_s8((char *)result, *(int8x8x4_t *)(&v67 - 3));
              result += 4;
            }
            while ( v23 );
            if ( (width & 7) == 0 )
              return result;
          }
          result = (RwError_0 *)(elf_hash_bucket + 3);
          do
          {
            v26 = *(unsigned __int16 *)v25;
            v25 += 2;
            --v22;
            HIBYTE(v24->pluginID) = -1;
            BYTE1(v24->pluginID) = (v26 >> 2) & 0xF8;
            LOBYTE(v24->pluginID) = (v26 >> 7) & 0xF8;
            BYTE2(v24->pluginID) = 8 * v26;
            v24 = (RwError_0 *)((char *)v24 + 4);
          }
          while ( v22 );
          return result;
        }
        goto LABEL_76;
      }
      for ( ; width; result = (RwError_0 *)((char *)result + 4) )
      {
        v51 = *cpSpan++;
        --width;
        result->pluginID = *(_DWORD *)(HIDWORD(v7) + 4 * v51);
      }
    }
  }
  else if ( v9 > 1027 )
  {
    v27 = v9 == 1028;
    if ( v9 != 1028 )
      v27 = v9 == 1032;
    if ( v27 )
    {
      for ( ; width; ++cpSpan )
      {
        v50 = *cpSpan;
        LOBYTE(result->pluginID) = *cpSpan >> 4;
        if ( width == 1 )
          break;
        BYTE1(result->pluginID) = v50 & 0xF;
        result = (RwError_0 *)((char *)result + 2);
        width -= 2;
      }
    }
    else
    {
      if ( v9 != 1056 )
        goto LABEL_76;
      if ( width )
      {
        v30 = *cpSpan;
        v28 = cpSpan + 1;
        v29 = v30;
        do
        {
          result->pluginID = *(_DWORD *)(HIDWORD(v7) + ((v29 >> 2) & 0x3FFFFFFC));
          if ( width == 1 )
            break;
          width -= 2;
          result->errorCode = *(_DWORD *)(HIDWORD(v7) + 4 * (v29 & 0xF));
          v31 = *v28++;
          v29 = v31;
          ++result;
        }
        while ( width );
      }
    }
  }
  else
  {
    v10 = v9 == 260;
    if ( v9 != 260 )
      v10 = v9 == 264;
    if ( !v10 )
    {
      if ( v9 == 288 )
      {
        if ( width )
        {
          v94 = width - 6;
          v13 = *cpSpan;
          v11 = cpSpan + 1;
          v12 = v13;
          v14 = width - 4;
          v15 = width - 2;
          do
          {
            *(&result->pluginID + v7) = *(_DWORD *)(HIDWORD(v7) + 4 * (v12 >> 7));
            if ( width - 1 == (_DWORD)v7 )
              break;
            v16 = &result->pluginID + v7;
            v17 = v15 == (_DWORD)v7;
            v16[1] = *(_DWORD *)(HIDWORD(v7) + 4 * ((v12 >> 6) & 1));
            if ( v15 != (_DWORD)v7 )
            {
              v16[2] = *(_DWORD *)(HIDWORD(v7) + 4 * ((v12 >> 5) & 1));
              v17 = width - 3 == (_DWORD)v7;
            }
            if ( v17 )
              break;
            v18 = v14 == (_DWORD)v7;
            v16[3] = *(_DWORD *)(HIDWORD(v7) + ((v12 >> 2) & 4));
            if ( v14 != (_DWORD)v7 )
            {
              v16[4] = *(_DWORD *)(HIDWORD(v7) + ((v12 >> 1) & 4));
              v18 = width - 5 == (_DWORD)v7;
            }
            if ( v18 )
              break;
            v16[5] = *(_DWORD *)(HIDWORD(v7) + (v12 & 4));
            v19 = v94 == (_DWORD)v7;
            if ( v94 != (_DWORD)v7 )
            {
              v16[6] = *(_DWORD *)(HIDWORD(v7) + ((2 * v12) & 4));
              v19 = width - 7 == (_DWORD)v7;
            }
            if ( v19 )
              break;
            v16[7] = *(_DWORD *)(HIDWORD(v7) + 4 * (v12 & 1));
            v20 = *v11++;
            v12 = v20;
          }
          while ( width != (_DWORD)v7 + 8 );
        }
        return result;
      }
LABEL_76:
      code.pluginID = 0;
      code.errorCode = _rwerror(-2147483640);
      return RwErrorSet(&code);
    }
    if ( width )
    {
      v40 = *cpSpan;
      v41 = width - 4;
      v42 = width - 2;
      v43 = cpSpan + 1;
      v44 = 0;
      v95 = width - 6;
      do
      {
        LOBYTE(result[v44 / 8].pluginID) = (v40 & 0x80) != 0;
        if ( width - 1 == v44 )
          break;
        v45 = &result[v44 / 8];
        v46 = v42 == v44;
        BYTE1(result[v44 / 8].pluginID) = (v40 & 0x40) != 0;
        if ( v42 != v44 )
        {
          BYTE2(v45->pluginID) = (v40 & 0x20) != 0;
          v46 = width - 3 == v44;
        }
        if ( v46 )
          break;
        v47 = v41 == v44;
        HIBYTE(v45->pluginID) = (v40 & 0x10) != 0;
        if ( v41 != v44 )
        {
          LOBYTE(v45->errorCode) = (v40 & 8) != 0;
          v47 = width - 5 == v44;
        }
        if ( v47 )
          break;
        BYTE1(v45->errorCode) = (v40 & 4) != 0;
        v48 = v95 == v44;
        if ( v95 != v44 )
        {
          BYTE2(v45->errorCode) = (v40 & 2) != 0;
          v48 = width - 7 == v44;
        }
        if ( v48 )
          break;
        HIBYTE(v45->errorCode) = v40 & 1;
        v49 = *v43++;
        v40 = v49;
        v44 += 8;
      }
      while ( width != v44 );
    }
  }
  return result;
}
// 1EC09C: fragmented variable at d21.8 may be wrong
// 1EC09C: fragmented variable at d22.8 may be wrong
// 1EC09C: fragmented variable at d23.8 may be wrong
// 1EC2D9: failed to expand linear variable 0:d18.8,8:d20.8,16:d22.8,24:d24.8
// 1EC5EF: failed to expand linear variable 0:d18.8,8:d20.8,16:d22.8
// 1EC5F5: failed to expand linear variable 0:d19.8,8:d21.8,16:d23.8
// 1EC61D: failed to expand linear variable 0:d24.8,8:d26.8,16:d28.8
// FC: using guessed type int elf_hash_bucket[16411];

//----- (001EC644) --------------------------------------------------------
RwImage_0 *__fastcall RtBMPImageWrite(RwImage_0 *image, const RwChar *imageName)
{
  RwStream_0 *v3; // r0
  RwStream_0 *v4; // r10
  __int64 v5; // kr00_8
  int v6; // r0
  unsigned int v7; // r1
  unsigned int v8; // r0
  int v9; // r9
  char *v10; // r8
  int v11; // r0
  int v12; // r1
  RwInt32 v13; // r2
  bool v14; // zf
  RwRGBA_0 *v15; // r2
  RwUInt8 *v16; // r5
  RwUInt32 v17; // r5
  int v18; // r5
  int v19; // r6
  RwInt32 depth; // r0
  bool v21; // zf
  RwRGBA_0 *v22; // r0
  RwUInt32 v23; // r5
  unsigned int buffer; // [sp+Ch] [bp-24h] BYREF
  char v26[29]; // [sp+13h] [bp-1Dh] BYREF

  v3 = RwStreamOpen(rwSTREAMFILENAME, rwSTREAMWRITE, imageName);
  v4 = v3;
  if ( !v3 )
    return 0;
  v5 = *(_QWORD *)&image->width;
  LOBYTE(buffer) = 66;
  RwStreamWrite(v3, &buffer, 1u);
  LOBYTE(buffer) = 77;
  RwStreamWrite(v4, &buffer, 1u);
  v6 = (24 * v5) & 0x18;
  v14 = v6 == 0;
  v7 = 32 - v6 + 24 * v5;
  v8 = 0;
  if ( v14 )
    v7 = 24 * v5;
  if ( (v7 & 0x18) == 0 )
    v8 = v7 >> 3;
  buffer = v8 * HIDWORD(v5) + 54;
  RwStreamWriteInt32(v4, (const RwInt32 *)&buffer, 4u);
  LOWORD(buffer) = 0;
  RwStreamWrite(v4, &buffer, 2u);
  LOWORD(buffer) = 0;
  RwStreamWrite(v4, &buffer, 2u);
  buffer = 54;
  RwStreamWriteInt32(v4, (const RwInt32 *)&buffer, 4u);
  buffer = 40;
  RwStreamWriteInt32(v4, (const RwInt32 *)&buffer, 4u);
  buffer = v5;
  RwStreamWriteInt32(v4, (const RwInt32 *)&buffer, 4u);
  buffer = HIDWORD(v5);
  RwStreamWriteInt32(v4, (const RwInt32 *)&buffer, 4u);
  LOWORD(buffer) = 1;
  RwStreamWrite(v4, &buffer, 2u);
  LOWORD(buffer) = 24;
  RwStreamWrite(v4, &buffer, 2u);
  buffer = 0;
  RwStreamWriteInt32(v4, (const RwInt32 *)&buffer, 4u);
  buffer = 0;
  RwStreamWriteInt32(v4, (const RwInt32 *)&buffer, 4u);
  buffer = 0;
  RwStreamWriteInt32(v4, (const RwInt32 *)&buffer, 4u);
  buffer = 0;
  RwStreamWriteInt32(v4, (const RwInt32 *)&buffer, 4u);
  buffer = 0;
  RwStreamWriteInt32(v4, (const RwInt32 *)&buffer, 4u);
  buffer = 0;
  RwStreamWriteInt32(v4, (const RwInt32 *)&buffer, 4u);
  v9 = HIDWORD(v5) - 1;
  v10 = (char *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 75))(3 * v5);
  if ( HIDWORD(v5) - 1 >= 0 )
  {
    while ( !v10 )
    {
      if ( (_DWORD)v5 )
      {
        v18 = 0;
        v19 = 0;
        do
        {
          depth = image->depth;
          v21 = depth == 4;
          if ( depth != 4 )
            v21 = depth == 8;
          if ( v21 )
          {
            v22 = &image->palette[image->cpPixels[v9 * image->stride + v19]];
          }
          else if ( depth == 32 )
          {
            v22 = (RwRGBA_0 *)&image->cpPixels[v9 * image->stride + v18];
          }
          else
          {
            v22 = 0;
          }
          BYTE2(buffer) = v22->_anon_0._anon_0.red;
          BYTE1(buffer) = v22->_anon_0._anon_0.green;
          LOBYTE(buffer) = v22->_anon_0._anon_0.blue;
          RwStreamWrite(v4, &buffer, 3u);
          ++v19;
          v18 += 4;
        }
        while ( (_DWORD)v5 != v19 );
        v17 = 3 * v5;
        goto LABEL_32;
      }
LABEL_36:
      if ( --v9 <= -1 )
        goto LABEL_37;
    }
    if ( (_DWORD)v5 )
    {
      v11 = 0;
      v12 = 0;
      do
      {
        v13 = image->depth;
        v14 = v13 == 4;
        if ( v13 != 4 )
          v14 = v13 == 8;
        if ( v14 )
        {
          v15 = &image->palette[image->cpPixels[v9 * image->stride + v12]];
        }
        else if ( v13 == 32 )
        {
          v15 = (RwRGBA_0 *)&image->cpPixels[v9 * image->stride + v11];
        }
        else
        {
          v15 = 0;
        }
        v16 = (RwUInt8 *)&v10[3 * v12++];
        v11 += 4;
        v16[2] = v15->_anon_0._anon_0.red;
        v16[1] = v15->_anon_0._anon_0.green;
        *v16 = v15->_anon_0._anon_0.blue;
      }
      while ( (_DWORD)v5 != v12 );
      v17 = 3 * v5;
    }
    else
    {
      v17 = 0;
    }
    RwStreamWrite(v4, v10, v17);
LABEL_32:
    if ( v17 << 30 )
    {
      v23 = v17 + 1;
      do
      {
        v26[0] = 0;
        RwStreamWrite(v4, v26, 1u);
        v14 = (v23++ & 3) == 0;
      }
      while ( !v14 );
    }
    goto LABEL_36;
  }
LABEL_37:
  if ( v10 )
    (*((void (__fastcall **)(char *))RwEngineInstance + 76))(v10);
  RwStreamClose(v4, 0);
  return image;
}
// 1EC644: using guessed type char var_1D[29];

//----- (001EC8E0) --------------------------------------------------------
RwBool RtCharsetBufferFlush()
{
  void *v1; // [sp+4h] [bp-2Ch] BYREF
  void *v2; // [sp+8h] [bp-28h] BYREF
  void *v3; // [sp+Ch] [bp-24h] BYREF
  void *v4; // [sp+10h] [bp-20h] BYREF
  void *v5; // [sp+14h] [bp-1Ch] BYREF
  void *v6; // [sp+18h] [bp-18h] BYREF
  void *value; // [sp+1Ch] [bp-14h] BYREF

  if ( rtgBuffer.numChars )
  {
    RwRenderStateGet(rwRENDERSTATEZTESTENABLE, &value);
    RwRenderStateGet(rwRENDERSTATEZWRITEENABLE, &v6);
    RwRenderStateGet(rwRENDERSTATESRCBLEND, &v5);
    RwRenderStateGet(rwRENDERSTATEDESTBLEND, &v4);
    RwRenderStateGet(rwRENDERSTATETEXTURERASTER, &v3);
    RwRenderStateGet(rwRENDERSTATETEXTUREFILTER, &v2);
    RwRenderStateGet(rwRENDERSTATECULLMODE, &v1);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
    RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, rtgBuffer.charSet);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
    RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
    RwIm2DRenderIndexedPrimitive(
      rwPRIMTYPETRILIST,
      rtgBuffer.vertices,
      4 * rtgBuffer.numChars,
      rtgBuffer.indices,
      6 * rtgBuffer.numChars);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, value);
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, v6);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, v5);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, v4);
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, v3);
    RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, v2);
    RwRenderStateSet(rwRENDERSTATECULLMODE, v1);
  }
  rtgBuffer.charSet = 0;
  rtgBuffer.numChars = 0;
  return 1;
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (001EC9D8) --------------------------------------------------------
RtCharset *__fastcall RtCharsetPrintBuffered(
        RtCharset *charSet,
        const RwChar *string,
        RwInt32 x,
        RwInt32 y,
        RwBool hideSpaces)
{
  const char *v6; // r6
  size_t v8; // r1
  RwUInt32 numChars; // r0
  RwUInt32 v10; // r4
  RwImVertexIndex *indices; // r2
  bool v12; // cf
  RwIm2DVertex *v13; // r3
  RwImVertexIndex v14; // r0
  RwInt32 rasSize; // [sp+1Ch] [bp-3Ch] BYREF
  RtCharsetDesc_0 desc; // [sp+20h] [bp-38h] BYREF

  v6 = (const char *)string;
  if ( !(*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(string) )
    return 0;
  _rtCharsetAtariFontGet(&desc, &rasSize);
  if ( rtgBuffer.charSet && rtgBuffer.charSet != charSet )
    RtCharsetBufferFlush();
  rtgBuffer.charSet = charSet;
  v8 = strlen(v6);
  numChars = rtgBuffer.numChars;
  if ( v8 )
  {
    while ( 1 )
    {
      v10 = 1024 - numChars;
      indices = &rtgBuffer.indices[6 * numChars];
      v12 = v8 >= 1024 - numChars;
      v13 = &rtgBuffer.vertices[4 * numChars];
      v14 = 4 * numChars;
      if ( !v12 )
        break;
      rtgBuffer.numChars += CharsetProcessString((const RwChar *)v6, v10, charSet, x, y, v13, indices, v14, hideSpaces);
      RtCharsetBufferFlush();
      v6 += v10;
      rtgBuffer.charSet = charSet;
      x += desc.width * v10;
      v8 = strlen(v6);
      numChars = rtgBuffer.numChars;
      if ( !v8 )
        goto LABEL_9;
    }
    rtgBuffer.numChars += CharsetProcessString((const RwChar *)v6, v8, charSet, x, y, v13, indices, v14, hideSpaces);
    if ( !rtgBuffer.numChars )
      goto LABEL_13;
  }
  else
  {
LABEL_9:
    if ( !numChars )
LABEL_13:
      rtgBuffer.charSet = 0;
  }
  return charSet;
}

//----- (001ECB04) --------------------------------------------------------
RwInt32 __fastcall CharsetProcessString(
        const RwChar *string,
        RwUInt32 length,
        RtCharset *charSet,
        RwInt32 x,
        RwInt32 y,
        RwIm2DVertex *vertices,
        RwImVertexIndex *indices,
        RwImVertexIndex indexOffset,
        RwBool hideSpaces)
{
  int v13; // r5
  int v14; // r0
  float width; // s18
  float height; // s16
  float v17; // r0
  float v18; // s0
  int v19; // r8
  RwInt32 v20; // lr
  float v21; // s28
  int v22; // r1
  float v23; // s16
  RwInt32 v24; // r2
  int v25; // r0
  RwInt32 v26; // r12
  float v27; // s18
  float v28; // s22
  float v29; // s24
  float v30; // s26
  float v31; // s30
  float v32; // s17
  int v33; // r0
  int v34; // r1
  int v35; // r11
  int v36; // r5
  RwInt32 v37; // r8
  unsigned int v38; // r0
  int v39; // lr
  int v40; // r2
  int v41; // s0
  RwInt32 v42; // r2
  int v43; // r5
  float v44; // s0
  int v45; // s2
  int v46; // r1
  float v47; // s2
  float v48; // s0
  float v49; // s4
  float v50; // s2
  int v51; // r0
  int v52; // s10
  float v53; // s2
  RwIm2DVertex *v54; // r0
  RwIm2DVertex *v55; // r2
  float v56; // s6
  RwIm2DVertex *v57; // r3
  float v58; // s8
  RwIm2DVertex *v59; // r1
  float v60; // s10
  RwImVertexIndex *v61; // r1
  unsigned int tilewidth; // [sp+0h] [bp-B8h]
  int v64; // [sp+Ch] [bp-ACh]
  int v65; // [sp+10h] [bp-A8h]
  RwInt32 v66; // [sp+14h] [bp-A4h]
  RwInt32 height_internal; // [sp+18h] [bp-A0h]
  RwInt32 width_internal; // [sp+1Ch] [bp-9Ch]
  RwInt32 v69; // [sp+20h] [bp-98h]
  _BOOL4 v70; // [sp+24h] [bp-94h]
  int v71; // [sp+2Ch] [bp-8Ch]
  int v72; // [sp+30h] [bp-88h]
  int v73; // [sp+34h] [bp-84h]
  RtCharsetDesc_0 desc; // [sp+38h] [bp-80h] BYREF
  RwInt32 rasSize[25]; // [sp+54h] [bp-64h] BYREF

  _rtCharsetAtariFontGet(&desc, rasSize);
  v13 = *(_DWORD *)RwEngineInstance;
  v14 = *(_DWORD *)(*(_DWORD *)RwEngineInstance + 96);
  width = (float)charSet->width;
  height = (float)charSet->height;
  v72 = *(_DWORD *)(v14 + 12);
  rasSize[0] = *(_DWORD *)(v14 + 16);
  v17 = RwIm2DGetNearScreenZ();
  v18 = *(float *)(v13 + 128);
  if ( !hideSpaces )
    CharsetProcessString(char const*,unsigned int,RwRaster *,int,int,RwOpenGLVertex *,unsigned short *,unsigned short,int)::space = 1;
  v19 = 0;
  if ( length )
  {
    v20 = desc.width;
    v21 = v17;
    v22 = 32;
    width_internal = desc.width_internal;
    height_internal = desc.height_internal;
    v69 = desc.height;
    v23 = 1.0 / height;
    v70 = rasSize[0] > y && desc.height + y > 0;
    v24 = y;
    v25 = rasSize[0] - 1;
    if ( CharsetProcessString(char const*,unsigned int,RwRaster *,int,int,RwOpenGLVertex *,unsigned short *,unsigned short,int)::space )
      v22 = 0;
    v73 = v22;
    if ( y < 0 )
      v24 = 0;
    v64 = v25 - v24;
    v66 = rasSize[0];
    v65 = desc.height + y;
    if ( desc.height + y < rasSize[0] )
      v25 = desc.height + y;
    v26 = v72;
    v27 = 1.0 / width;
    v28 = 1.0 / v18;
    tilewidth = desc.tilewidth;
    v29 = v23 * 0.5;
    v30 = v27 * 0.5;
    v31 = (float)v24 + 0.5;
    v32 = (float)v25 + 0.5;
    do
    {
      v33 = *string;
      if ( v73 != v33 )
      {
        v34 = 0;
        v35 = v20 + x;
        if ( x < v26 )
          v34 = 1;
        if ( v35 >= 1 && (v34 & v70) == 1 )
        {
          v36 = v33 - 32;
          v71 = v19;
          v37 = v20;
          v38 = (v33 - 32) / tilewidth;
          v39 = v36 - v38 * tilewidth;
          v40 = v72 - 1;
          if ( v35 < v72 )
            v40 = v35;
          v41 = v40;
          v42 = x;
          if ( x < 0 )
            v42 = 0;
          v43 = v39 * width_internal;
          v44 = (float)v41;
          v45 = height_internal * v38 - (y & (y >> 31));
          v46 = v64 + v45;
          v47 = (float)v45;
          if ( v65 < v66 )
            v46 = v69 + height_internal * v38;
          v48 = v44 + 0.5;
          v49 = (float)v42 + 0.5;
          if ( x < 0 )
            v43 -= x;
          v26 = v72;
          v50 = v23 * v47;
          v51 = v72 - 1 - v42 + v43;
          if ( v35 < v72 )
            v51 = v37 + v39 * width_internal;
          v20 = v37;
          v52 = v51;
          v53 = v29 + v50;
          v54 = &vertices[(4 * v71) | 3];
          v55 = &vertices[(4 * v71) | 1];
          v56 = v29 + (float)(v23 * (float)v46);
          v57 = &vertices[4 * v71];
          v58 = v30 + (float)(v27 * (float)v43);
          v59 = &vertices[(4 * v71) | 2];
          v60 = v30 + (float)(v27 * (float)v52);
          v57->s = v58;
          v57->t = v53;
          v55->s = v58;
          v55->t = v56;
          v59->s = v60;
          v59->t = v56;
          v54->s = v60;
          v54->t = v53;
          v57->x = v49;
          v57->y = v31;
          v57->z = v21;
          v57->rhw = v28;
          *(_DWORD *)&v57->r = -1;
          *(_DWORD *)&v55->r = -1;
          v55->x = v49;
          v55->y = v32;
          v55->z = v21;
          v55->rhw = v28;
          v59->x = v48;
          v59->y = v32;
          v59->z = v21;
          v59->rhw = v28;
          *(_DWORD *)&v59->r = -1;
          *(_DWORD *)&v54->r = -1;
          v54->x = v48;
          v54->y = v31;
          v54->z = v21;
          v54->rhw = v28;
          LOWORD(v54) = indexOffset + 4 * v71;
          indices[6 * v71] = (unsigned __int16)v54;
          v19 = v71 + 1;
          v61 = &indices[6 * v71];
          *(RwImVertexIndex *)((char *)indices + ((12 * v71) | 2)) = (_WORD)v54 + 1;
          v61[3] = (unsigned __int16)v54;
          v61[2] = (_WORD)v54 + 2;
          v61[4] = (_WORD)v54 + 2;
          v61[5] = (_WORD)v54 + 3;
        }
      }
      x += v20;
      --length;
      ++string;
    }
    while ( length );
  }
  return v19;
}
// 6BD528: using guessed type char CharsetProcessString(char const*,unsigned int,RwRaster *,int,int,RwOpenGLVertex *,unsigned short *,unsigned short,int)::space;
// 1ECB04: using guessed type RwInt32 rasSize[25];

//----- (001ECE08) --------------------------------------------------------
RtCharset *__fastcall RtCharsetPrint(RtCharset *charSet, const RwChar *string, RwInt32 x, RwInt32 y)
{
  size_t v8; // r0
  RwUInt32 v9; // r6
  RwIm2DVertex *v10; // r10
  RwImVertexIndex *indices; // r0
  bool v12; // zf
  RwImVertexIndex *v13; // r5
  int v14; // r0
  int v15; // r8
  RwError_0 code; // [sp+14h] [bp-3Ch] BYREF
  void *v18; // [sp+1Ch] [bp-34h] BYREF
  void *v19; // [sp+20h] [bp-30h] BYREF
  void *v20; // [sp+24h] [bp-2Ch] BYREF
  void *v21; // [sp+28h] [bp-28h] BYREF
  void *v22; // [sp+2Ch] [bp-24h] BYREF
  void *value; // [sp+30h] [bp-20h] BYREF

  v8 = strlen((const char *)string);
  v9 = v8;
  if ( v8 )
  {
    v10 = (RwIm2DVertex *)(*((int (__fastcall **)(size_t))RwEngineInstance + 75))(112 * v8);
    indices = (RwImVertexIndex *)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(12 * v9);
    v12 = v10 == 0;
    v13 = indices;
    if ( v10 )
      v12 = indices == 0;
    if ( v12 )
    {
      if ( v10 )
        (*((void (__fastcall **)(RwIm2DVertex *))RwEngineInstance + 76))(v10);
      if ( v13 )
        (*((void (__fastcall **)(RwImVertexIndex *))RwEngineInstance + 76))(v13);
      charSet = 0;
      code.pluginID = 0;
      code.errorCode = _rwerror(-2147483629, 124 * v9);
      RwErrorSet(&code);
    }
    else
    {
      v14 = CharsetProcessString(string, v9, charSet, x, y, v10, indices, 0, 0);
      v15 = v14;
      if ( v14 <= 0 )
      {
        (*((void (__fastcall **)(RwImVertexIndex *))RwEngineInstance + 76))(v13);
        (*((void (__fastcall **)(RwIm2DVertex *))RwEngineInstance + 76))(v10);
        return 0;
      }
      else
      {
        RwRenderStateGet(rwRENDERSTATEZTESTENABLE, &code);
        RwRenderStateGet(rwRENDERSTATEZWRITEENABLE, &value);
        RwRenderStateGet(rwRENDERSTATESRCBLEND, &v22);
        RwRenderStateGet(rwRENDERSTATEDESTBLEND, &v21);
        RwRenderStateGet(rwRENDERSTATETEXTURERASTER, &v20);
        RwRenderStateGet(rwRENDERSTATETEXTUREFILTER, &v19);
        RwRenderStateGet(rwRENDERSTATECULLMODE, &v18);
        RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
        RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
        RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 1);
        RwRenderStateSet(rwRENDERSTATETEXTURERASTER, charSet);
        RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
        RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
        RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
        RwIm2DRenderIndexedPrimitive(rwPRIMTYPETRILIST, v10, 4 * v15, v13, 6 * v15);
        RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (void *)code.pluginID);
        RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, value);
        RwRenderStateSet(rwRENDERSTATESRCBLEND, v22);
        RwRenderStateSet(rwRENDERSTATEDESTBLEND, v21);
        RwRenderStateSet(rwRENDERSTATETEXTURERASTER, v20);
        RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, v19);
        RwRenderStateSet(rwRENDERSTATECULLMODE, v18);
        (*((void (__fastcall **)(RwImVertexIndex *))RwEngineInstance + 76))(v13);
        (*((void (__fastcall **)(RwIm2DVertex *))RwEngineInstance + 76))(v10);
      }
    }
  }
  return charSet;
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (001ECFE0) --------------------------------------------------------
const RtGlyphRow *__fastcall _rtCharsetAtariFontGet(RtCharsetDesc_0 *desc, RwInt32 *rasSize)
{
  desc->tilewidth = 14;
  desc->tileheight = 7;
  *(_QWORD *)&desc->width = 0xE00000008LL;
  *(_QWORD *)&desc->width_internal = 0xF00000009LL;
  desc->count = 91;
  *rasSize = 128;
  return _rtCharsetAtariFontGet(RtCharsetDesc *,int *)::charSetBits[0];
}

//----- (001ED030) --------------------------------------------------------
RtCharset *__fastcall RtCharsetGetDesc(RtCharset *charset, RtCharsetDesc_0 *desc)
{
  RtCharset *v2; // r4
  bool v3; // zf
  RwError_0 v5; // [sp+0h] [bp-10h] BYREF

  v2 = charset;
  v3 = charset == 0;
  if ( charset )
    v3 = desc == 0;
  if ( v3 )
  {
    v2 = 0;
    v5.pluginID = 0;
    v5.errorCode = _rwerror(-2147483626, desc);
    RwErrorSet(&v5);
  }
  else
  {
    desc->tilewidth = 14;
    desc->tileheight = 7;
    *(_QWORD *)&desc->width = 0xE00000008LL;
    *(_QWORD *)&desc->width_internal = 0xF00000009LL;
    desc->count = 91;
  }
  return v2;
}

//----- (001ED090) --------------------------------------------------------
RtCharset *__fastcall RtCharsetSetColors(RtCharset *charSet, const RwRGBA_0 *foreGround, const RwRGBA_0 *backGround)
{
  bool v6; // zf
  RwImage_0 *v7; // r0
  RwImage_0 *v8; // r4
  RtCharset *v9; // r5
  int v10; // r11
  RwRGBA_0 *palette; // r0
  const RtAtariGlyph *v12; // r10
  RwInt32 stride; // r0
  RwUInt8 *cpPixels; // r1
  int v15; // r4
  int v16; // r1
  RwUInt8 *v17; // r6
  int v18; // r3
  const RtAtariGlyph *v19; // r2
  int v20; // r9
  int v21; // r12
  RwImage_0 *v23; // [sp+4h] [bp-34h]
  RtCharset *raster; // [sp+8h] [bp-30h]
  RwUInt8 *v25; // [sp+10h] [bp-28h]
  RwError_0 code; // [sp+14h] [bp-24h] BYREF

  if ( !charSet )
    goto LABEL_21;
  v6 = foreGround == 0;
  if ( foreGround )
    v6 = backGround == 0;
  if ( v6 )
  {
LABEL_21:
    v9 = 0;
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483626);
    RwErrorSet(&code);
  }
  else
  {
    if ( rtgBuffer.initialised && rtgBuffer.charSet == charSet )
      RtCharsetBufferFlush();
    v7 = RwImageCreate(128, 128, 8);
    v8 = v7;
    if ( v7 )
    {
      v9 = 0;
      if ( RwImageAllocatePixels(v7) )
      {
        raster = charSet;
        v10 = 1;
        palette = v8->palette;
        *palette = *backGround;
        v12 = _rtCharsetAtariFontGet(RtCharsetDesc *,int *)::charSetBits;
        palette[1] = *foreGround;
        stride = v8->stride;
        v23 = v8;
        cpPixels = v8->cpPixels;
        v15 = 0;
        v25 = cpPixels;
        v16 = 0;
        do
        {
          v17 = &v25[9 * v15 + 15 * stride * v16];
          v18 = 0;
          v19 = v12;
          do
          {
            *((_DWORD *)v17 + 1) = 0;
            *(_DWORD *)v17 = 0;
            v17[8] = 0;
            LOBYTE(v20) = *(_BYTE *)v19;
            if ( *(_BYTE *)v19 )
            {
              v21 = 0;
              do
              {
                v17[v21] = v20 & 1;
                v20 = (unsigned __int8)v20 >> 1;
                ++v21;
              }
              while ( v20 );
            }
            ++v18;
            v19 = (const RtAtariGlyph *)((char *)v19 + 1);
            v17 += stride;
          }
          while ( v18 != 15 );
          ++v15;
          ++v10;
          ++v12;
          if ( v15 == 14 )
          {
            ++v16;
            v15 = 0;
          }
        }
        while ( v10 != 92 );
        v9 = raster;
        v8 = v23;
        RwRasterSetFromImage(raster, v23);
      }
      RwImageDestroy(v8);
    }
    else
    {
      return 0;
    }
  }
  return v9;
}

//----- (001ED1B0) --------------------------------------------------------
RwBool __fastcall RtCharsetDestroy(RtCharset *charSet)
{
  RwBool v2; // r4
  RwError_0 v4; // [sp+0h] [bp-10h] BYREF

  if ( charSet )
  {
    if ( rtgBuffer.initialised && rtgBuffer.charSet == charSet )
      RtCharsetBufferFlush();
    RwRasterDestroy(charSet);
    return 1;
  }
  else
  {
    v2 = 0;
    v4.pluginID = 0;
    v4.errorCode = _rwerror(-2147483626);
    RwErrorSet(&v4);
  }
  return v2;
}

//----- (001ED1F8) --------------------------------------------------------
RtCharset *__fastcall RtCharsetCreate(const RwRGBA_0 *foreGround, const RwRGBA_0 *backGround)
{
  bool v3; // zf
  RtCharset *v5; // r4
  RwRaster_0 *v6; // r0
  RwRaster_0 *v7; // r8
  RwError_0 v9; // [sp+0h] [bp-18h] BYREF

  v3 = foreGround == 0;
  if ( foreGround )
    v3 = backGround == 0;
  if ( v3 )
  {
    v5 = 0;
    v9.pluginID = 0;
    v9.errorCode = _rwerror(-2147483626);
    RwErrorSet(&v9);
  }
  else
  {
    v5 = 0;
    v6 = RwRasterCreate(128, 128, 0, 4);
    v7 = v6;
    if ( v6 )
    {
      if ( RtCharsetSetColors(v6, foreGround, backGround) )
      {
        return v7;
      }
      else
      {
        if ( rtgBuffer.initialised && rtgBuffer.charSet == v7 )
          RtCharsetBufferFlush();
        RwRasterDestroy(v7);
        return 0;
      }
    }
  }
  return v5;
}

//----- (001ED278) --------------------------------------------------------
void RtCharsetClose()
{
  (*((void (__fastcall **)(RwIm2DVertex *))RwEngineInstance + 76))(rtgBuffer.vertices);
  rtgBuffer.vertices = 0;
  (*((void (__fastcall **)(RwImVertexIndex *))RwEngineInstance + 76))(rtgBuffer.indices);
  rtgBuffer.initialised = 0;
  rtgBuffer.indices = 0;
}

//----- (001ED2B0) --------------------------------------------------------
RwBool RtCharsetOpen()
{
  RwBool result; // r0

  rtgBuffer.vertices = (RwIm2DVertex *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(114688);
  if ( !rtgBuffer.vertices )
    return 0;
  rtgBuffer.indices = (RwImVertexIndex *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(12288);
  if ( rtgBuffer.indices )
  {
    result = 1;
    rtgBuffer.initialised = 1;
    rtgBuffer.charSet = 0;
    rtgBuffer.numChars = 0;
  }
  else
  {
    (*((void (__fastcall **)(RwIm2DVertex *))RwEngineInstance + 76))(rtgBuffer.vertices);
    result = 0;
    rtgBuffer.vertices = 0;
  }
  return result;
}

//----- (001ED340) --------------------------------------------------------
RtDictSchema_0 *__fastcall RtDictSchemaInit(RtDictSchema_0 *schema)
{
  RwSList_0 *v2; // r1
  RtDictSchema_0 *result; // r0

  v2 = _rwSListCreate(4, schema->dictChunkType | 0x40000);
  result = 0;
  schema->dictionaries = v2;
  if ( v2 )
  {
    schema->current = 0;
    return schema;
  }
  return result;
}

//----- (001ED362) --------------------------------------------------------
RwBool __fastcall RtDictSchemaDestruct(RtDictSchema_0 *schema)
{
  _rwSListDestroy(schema->dictionaries);
  return 1;
}

//----- (001ED370) --------------------------------------------------------
RtDict_0 *__fastcall RtDictSchemaCreateDict(RtDictSchema_0 *schema)
{
  RtDict_0 *v2; // r4
  RwSList_0 *v3; // r0
  _DWORD *NewEntry; // r0
  RwError_0 v6; // [sp+0h] [bp-10h] BYREF

  v2 = (RtDict_0 *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(8);
  if ( !v2 )
  {
    v2 = 0;
    v6.pluginID = 0;
    v6.errorCode = _rwerror(-2147483629, 8);
    RwErrorSet(&v6);
    return v2;
  }
  v3 = _rwSListCreate(4, schema->dictChunkType | 0x30000);
  v2->entries = v3;
  if ( !v3 )
  {
LABEL_7:
    (*((void (__fastcall **)(RtDict_0 *))RwEngineInstance + 76))(v2);
    return 0;
  }
  v2->schema = schema;
  NewEntry = _rwSListGetNewEntry(schema->dictionaries, schema->dictChunkType | 0x30000);
  if ( !NewEntry )
  {
    _rwSListDestroy(v2->entries);
    goto LABEL_7;
  }
  *NewEntry = v2;
  return v2;
}

//----- (001ED3F4) --------------------------------------------------------
RtDict_0 *__fastcall _rtDictSchemaInitDict(RtDictSchema_0 *schema, RtDict_0 *dict)
{
  RwSList_0 *v4; // r0
  _DWORD *NewEntry; // r0

  v4 = _rwSListCreate(4, schema->dictChunkType | 0x30000);
  dict->entries = v4;
  if ( v4 )
  {
    dict->schema = schema;
    NewEntry = _rwSListGetNewEntry(schema->dictionaries, schema->dictChunkType | 0x30000);
    if ( NewEntry )
    {
      *NewEntry = dict;
      return dict;
    }
    _rwSListDestroy(dict->entries);
  }
  return 0;
}

//----- (001ED432) --------------------------------------------------------
RtDictSchema_0 *__fastcall RtDictSchemaAddDict(RtDictSchema_0 *schema, RtDict_0 *dict)
{
  RtDictSchema_0 *v2; // r4
  _DWORD *NewEntry; // r0

  v2 = schema;
  NewEntry = _rwSListGetNewEntry(schema->dictionaries, schema->dictChunkType | 0x30000);
  if ( !NewEntry )
    return 0;
  *NewEntry = dict;
  return v2;
}

//----- (001ED452) --------------------------------------------------------
RtDictSchema_0 *__fastcall RtDictSchemaRemoveDict(RtDictSchema_0 *schema, RtDict_0 *dict)
{
  RtDictSchema_0 *v2; // r4
  RtDict_0 **Begin; // r5
  RtDict_0 **End; // r0
  RwSList_0 *dictionaries; // r6
  RwInt32 NumEntries; // r0

  v2 = schema;
  Begin = (RtDict_0 **)_rwSListGetBegin(schema->dictionaries);
  End = (RtDict_0 **)_rwSListGetEnd(v2->dictionaries);
  if ( Begin == End )
    return 0;
  while ( *Begin != dict )
  {
    if ( End == ++Begin )
      return 0;
  }
  dictionaries = v2->dictionaries;
  NumEntries = _rwSListGetNumEntries(dictionaries);
  *Begin = *(RtDict_0 **)_rwSListGetEntry(dictionaries, NumEntries - 1);
  _rwSListDestroyEndEntries(v2->dictionaries, 1);
  return v2;
}

//----- (001ED4A4) --------------------------------------------------------
RtDict_0 *__fastcall RtDictSchemaGetCurrentDict(RtDictSchema_0 *schema)
{
  return schema->current;
}

//----- (001ED4A8) --------------------------------------------------------
RtDictSchema_0 *__fastcall RtDictSchemaSetCurrentDict(RtDictSchema_0 *schema, RtDict_0 *dict)
{
  schema->current = dict;
  return schema;
}

//----- (001ED4AC) --------------------------------------------------------
RwBool __fastcall _rtDictDestruct(RtDict_0 *dict)
{
  void **End; // r5
  void **i; // r6
  void *v4; // t1

  End = (void **)_rwSListGetEnd(dict->entries);
  for ( i = (void **)_rwSListGetBegin(dict->entries); End != i; ++i )
  {
    v4 = *i;
    dict->schema->destroyCB(v4);
  }
  _rwSListDestroy(dict->entries);
  return 1;
}

//----- (001ED4E6) --------------------------------------------------------
RtDictEntryType __fastcall RtDictAddEntry(RtDict_0 *dict, RtDictEntryType entry)
{
  *(_DWORD *)_rwSListGetNewEntry(dict->entries, dict->schema->dictChunkType | 0x30000) = entry;
  dict->schema->addRefCB(entry);
  return dict;
}

//----- (001ED50C) --------------------------------------------------------
RtDictEntryType __fastcall RtDictFindNamedEntry(RtDict_0 *dict, const RwChar *name)
{
  RtDictEntryGetNameCallBack *getNameCB; // r9
  void **End; // r10
  void **Begin; // r6
  void *v7; // r4
  void *v8; // t1
  int (__fastcall *v9)(int, const RwChar *); // r5
  int v10; // r0

  getNameCB = dict->schema->getNameCB;
  End = (void **)_rwSListGetEnd(dict->entries);
  Begin = (void **)_rwSListGetBegin(dict->entries);
  while ( End != Begin )
  {
    v8 = *Begin++;
    v7 = v8;
    v9 = (int (__fastcall *)(int, const RwChar *))*((_DWORD *)RwEngineInstance + 68);
    v10 = (int)getNameCB(v8);
    if ( !v9(v10, name) )
      return v7;
  }
  return 0;
}

//----- (001ED568) --------------------------------------------------------
const RtDict_0 *__fastcall RtDictForAllEntries(const RtDict_0 *dict, RtDictEntryCallBack *callBack, void *data)
{
  void **End; // r5
  void **Begin; // r4
  void *v8; // t1

  End = (void **)_rwSListGetEnd(dict->entries);
  Begin = (void **)_rwSListGetBegin(dict->entries);
  do
  {
    if ( End == Begin )
      break;
    v8 = *Begin++;
  }
  while ( (int)callBack(v8, data) );
  return dict;
}

//----- (001ED5A2) --------------------------------------------------------
RtDict_0 *__fastcall RtDictRemoveEntry(RtDict_0 *dict, RtDictEntryType entry)
{
  RtDict_0 *v2; // r8
  RtDictEntryType *End; // r4
  RtDictEntryType *Begin; // r5
  RwSList_0 *entries; // r4
  RwInt32 NumEntries; // r0

  v2 = dict;
  End = (RtDictEntryType *)_rwSListGetEnd(dict->entries);
  Begin = (RtDictEntryType *)_rwSListGetBegin(v2->entries);
  if ( Begin == End )
    return 0;
  while ( *Begin != entry )
  {
    if ( End == ++Begin )
      return 0;
  }
  v2->schema->destroyCB(entry);
  entries = v2->entries;
  NumEntries = _rwSListGetNumEntries(entries);
  *Begin = _rwSListGetEntry(entries, NumEntries);
  _rwSListDestroyEndEntries(v2->entries, 1);
  return v2;
}

//----- (001ED608) --------------------------------------------------------
RwBool __fastcall RtDictDestroy(RtDict_0 *dict)
{
  RtDictSchema_0 *schema; // r6
  RtDict_0 **Begin; // r5
  RtDict_0 **End; // r0
  RwSList_0 *dictionaries; // r8
  RwInt32 NumEntries; // r0
  void **v7; // r5
  void **i; // r6
  void *v9; // t1

  schema = dict->schema;
  if ( dict->schema->current == dict )
  {
    schema->current = 0;
    schema = dict->schema;
  }
  Begin = (RtDict_0 **)_rwSListGetBegin(schema->dictionaries);
  End = (RtDict_0 **)_rwSListGetEnd(schema->dictionaries);
  if ( Begin != End )
  {
    while ( *Begin != dict )
    {
      if ( End == ++Begin )
        goto LABEL_8;
    }
    dictionaries = schema->dictionaries;
    NumEntries = _rwSListGetNumEntries(dictionaries);
    *Begin = *(RtDict_0 **)_rwSListGetEntry(dictionaries, NumEntries - 1);
    _rwSListDestroyEndEntries(schema->dictionaries, 1);
  }
LABEL_8:
  v7 = (void **)_rwSListGetEnd(dict->entries);
  for ( i = (void **)_rwSListGetBegin(dict->entries); v7 != i; ++i )
  {
    v9 = *i;
    dict->schema->destroyCB(v9);
  }
  _rwSListDestroy(dict->entries);
  (*((void (__fastcall **)(RtDict_0 *))RwEngineInstance + 76))(dict);
  return 1;
}

//----- (001ED6A4) --------------------------------------------------------
RwUInt32 __fastcall RtDictStreamGetSize(const RtDict_0 *dict)
{
  const void **End; // r5
  const void **Begin; // r6
  RwUInt32 i; // r4
  const void *v5; // t1

  End = (const void **)_rwSListGetEnd(dict->entries);
  Begin = (const void **)_rwSListGetBegin(dict->entries);
  for ( i = 16; End != Begin; i += dict->schema->streamGetSizeCB(v5) + 12 )
    v5 = *Begin++;
  return i;
}

//----- (001ED6E6) --------------------------------------------------------
RtDict_0 *__fastcall RtDictSchemaStreamReadDict(RtDictSchema_0 *schema, RwStream_0 *stream)
{
  RtDict_0 *Dict; // r6
  bool v5; // zf
  RtDictEntryType v6; // r4
  int buffer; // [sp+4h] [bp-24h] BYREF
  RwUInt32 versionOut; // [sp+8h] [bp-20h] BYREF
  RwUInt32 lengthOut[7]; // [sp+Ch] [bp-1Ch] BYREF

  if ( !RwStreamFindChunk(stream, 1u, lengthOut, &versionOut) )
    return 0;
  if ( versionOut >= schema->compatibilityVersion )
  {
    if ( RwStreamRead(stream, &buffer, lengthOut[0]) )
    {
      RwMemNative32(&buffer, 4u);
      Dict = RtDictSchemaCreateDict(schema);
      if ( Dict )
      {
        v5 = buffer-- == 0;
        if ( v5 )
          return Dict;
        while ( RwStreamFindChunk(stream, schema->entryChunkType, lengthOut, &versionOut) )
        {
          v6 = schema->streamReadCB(stream);
          if ( !v6 )
            break;
          *(_DWORD *)_rwSListGetNewEntry(Dict->entries, Dict->schema->dictChunkType | 0x30000) = v6;
          Dict->schema->addRefCB(v6);
          schema->destroyCB(v6);
          v5 = buffer-- == 0;
          if ( v5 )
            return Dict;
        }
        RtDictDestroy(Dict);
      }
    }
    return 0;
  }
  return schema->streamReadCompatibilityCB(stream);
}

//----- (001ED79E) --------------------------------------------------------
const RtDict_0 *__fastcall RtDictStreamWrite(const RtDict_0 *dict, RwStream_0 *stream)
{
  const void **End; // r5
  const void **Begin; // r4
  RwInt32 v6; // r6
  const void *v7; // t1
  RwStream_0 *v8; // r1
  const RtDict_0 *result; // r0
  char *v10; // r4
  unsigned int v11; // r0
  int v12; // r1
  bool v13; // zf
  const void **v14; // r4
  const void **i; // r5
  const void *v16; // t1
  int mem[7]; // [sp+4h] [bp-1Ch] BYREF

  End = (const void **)_rwSListGetEnd(dict->entries);
  Begin = (const void **)_rwSListGetBegin(dict->entries);
  v6 = 16;
  if ( Begin != End )
  {
    do
    {
      v7 = *Begin++;
      v6 += dict->schema->streamGetSizeCB(v7) + 12;
    }
    while ( End != Begin );
    if ( !v6 )
      return 0;
  }
  if ( !_rwStreamWriteVersionedChunkHeader(stream, dict->schema->dictChunkType, v6, 0x36003u, 0xFFFFu) )
    return 0;
  v8 = _rwStreamWriteVersionedChunkHeader(stream, 1, 4, 0x36003u, 0xFFFFu);
  result = 0;
  if ( !v8 )
    return result;
  mem[0] = 0;
  v10 = (char *)_rwSListGetEnd(dict->entries);
  v11 = (unsigned int)_rwSListGetBegin(dict->entries);
  v13 = v11 == (_DWORD)v10;
  if ( (char *)v11 != v10 )
  {
    v11 = (unsigned int)&v10[-4 - v11];
    v12 = 1;
  }
  if ( !v13 )
    mem[0] = v12 + (v11 >> 2);
  RwMemLittleEndian32(mem, 4u);
  if ( !RwStreamWrite(stream, mem, 4u) )
    return 0;
  v14 = (const void **)_rwSListGetEnd(dict->entries);
  for ( i = (const void **)_rwSListGetBegin(dict->entries); v14 != i; ++i )
  {
    v16 = *i;
    if ( !dict->schema->streamWriteCB(v16, stream) )
      return 0;
  }
  return dict;
}
// 1ED83E: variable 'v12' is possibly undefined

//----- (001ED88C) --------------------------------------------------------
RwBool __fastcall RtDictSchemaForAllDictionaries(RtDictSchema_0 *schema, RtDictCallBack *callBack, void *data)
{
  RtDict_0 **End; // r6
  RtDict_0 **Begin; // r4
  RtDict_0 *v8; // t1

  End = (RtDict_0 **)_rwSListGetEnd(schema->dictionaries);
  Begin = (RtDict_0 **)_rwSListGetBegin(schema->dictionaries);
  do
  {
    if ( End == Begin )
      break;
    v8 = *Begin++;
  }
  while ( (int)callBack(v8, data) );
  return 1;
}

//----- (001ED8D0) --------------------------------------------------------
void __fastcall png_set_sig_bytes(png_structrp png_ptr, int num_bytes)
{
  if ( png_ptr )
  {
    if ( num_bytes <= 0 )
      num_bytes = 0;
    if ( (unsigned int)num_bytes >= 9 )
    {
      j_png_error(png_ptr, (png_const_charp)"Too many bytes for PNG signature");
      JUMPOUT(0x1ED8F0);
    }
    png_ptr->sig_bytes = num_bytes;
  }
}
// 1ED8EC: control flows out of bounds to 1ED8F0

//----- (001ED914) --------------------------------------------------------
int __fastcall png_sig_cmp(png_const_bytep sig, png_size_t start, png_size_t num_to_check)
{
  const png_byte *v4; // r0

  if ( num_to_check > 8 )
  {
    num_to_check = 8;
    if ( start <= 7 )
      goto LABEL_7;
    return -1;
  }
  if ( !num_to_check || start > 7 )
    return -1;
LABEL_7:
  v4 = &sig[start];
  if ( num_to_check + start > 8 )
    num_to_check = 8 - start;
  return sub_19C7D0(v4, (char *)sub_1ED940 + start, num_to_check);
}

//----- (001ED940) --------------------------------------------------------
int __fastcall sub_1ED940(int a1, int a2, int a3)
{
  int (*v3)(void); // r9

  *(_DWORD *)(a2 + a3) = a2;
  return v3();
}
// 1ED942: variable 'v3' is possibly undefined

//----- (001ED948) --------------------------------------------------------
voidpf __fastcall png_zalloc(voidpf png_ptr, uInt items, uInt size)
{
  if ( png_ptr )
  {
    if ( 0xFFFFFFFF / size > items )
      return sub_195720((png_const_structrp_2)png_ptr, size * items);
    j_png_warning((png_const_structrp_0)png_ptr, (png_const_charp)"Potential overflow in png_zalloc()");
  }
  return 0;
}

//----- (001ED9B0) --------------------------------------------------------
void __fastcall png_reset_crc(png_structrp png_ptr)
{
  png_ptr->crc = j_crc32(0, 0, 0);
}

//----- (001ED9C6) --------------------------------------------------------
void __fastcall png_calculate_crc(png_structrp png_ptr, png_const_bytep ptr, png_size_t length)
{
  char chunk_name_high; // r2
  _BOOL4 v6; // r3
  _BOOL4 v7; // r0

  chunk_name_high = HIBYTE(png_ptr->chunk_name);
  v6 = (png_ptr->flags & 0x800) == 0;
  v7 = (png_ptr->flags & 0x300) != 768;
  if ( (chunk_name_high & 0x20) == 0 )
    v7 = v6;
  if ( length )
  {
    if ( v7 )
      png_ptr->crc = j_crc32(png_ptr->crc, ptr, length);
  }
}
// 1EDA08: conditional instruction was optimized away because r4.4!=0

//----- (001EDA28) --------------------------------------------------------
int __fastcall png_user_version_check(png_structrp png_ptr, png_const_charp user_png_ver)
{
  int v4; // r0
  int v5; // r2
  int v6; // r3
  bool v7; // zf
  int v8; // r6
  png_uint_32 v9; // r0
  size_t v10; // r0
  size_t v11; // r0
  size_t v12; // r0
  unsigned __int8 buffer[128]; // [sp+4h] [bp-94h] BYREF

  if ( user_png_ver )
  {
    v4 = 0;
    v5 = 0;
    do
    {
      v6 = user_png_ver[v4];
      if ( v6 != (unsigned __int8)a1634[v4] )
        png_ptr->flags |= 0x20000u;
      if ( v6 == 46 )
        ++v5;
      if ( v5 > 1 )
        break;
      v7 = v4 == 6;
      if ( v4 != 6 )
      {
        ++v4;
        v7 = v6 == 0;
      }
    }
    while ( !v7 );
    if ( (png_ptr->flags & 0x20000) == 0 )
      return 1;
LABEL_15:
    v8 = 0;
    v10 = j_png_safecat(buffer, 0x80u, 0, (png_const_charp)"Application built with libpng-");
    v11 = j_png_safecat(buffer, 0x80u, v10, user_png_ver);
    v12 = j_png_safecat(buffer, 0x80u, v11, (png_const_charp)" but running with ");
    j_png_safecat(buffer, 0x80u, v12, (png_const_charp)"1.6.34");
    j_png_warning(png_ptr, buffer);
    return v8;
  }
  v9 = png_ptr->flags | 0x20000;
  png_ptr->flags = v9;
  if ( (v9 & 0x20000) != 0 )
    goto LABEL_15;
  return 1;
}

//----- (001EDB30) --------------------------------------------------------
png_structp __fastcall png_create_png_struct(
        png_const_charp user_png_ver,
        png_voidp error_ptr,
        png_error_ptr error_fn,
        png_error_ptr warn_fn,
        png_voidp mem_ptr,
        png_malloc_ptr malloc_fn,
        png_free_ptr free_fn)
{
  int v11; // r5
  png_struct *v12; // r0
  png_struct *v13; // r4
  struct __jmp_buf_tag v15; // [sp+0h] [bp-4E8h] BYREF
  png_struct v16; // [sp+100h] [bp-3E8h] BYREF

  memset(&v16, 0, sizeof(v16));
  *(_QWORD *)&v16.user_width_max = loc_1EDC00;
  *(_QWORD *)&v16.user_chunk_cache_max = loc_1EDC08;
  j_png_set_mem_fn(&v16, mem_ptr, malloc_fn, free_fn);
  j_png_set_error_fn(&v16, error_ptr, error_fn, warn_fn);
  v11 = 0;
  if ( !setjmp(&v15) )
  {
    v16.jmp_buf_ptr = (jmp_buf *)&v15;
    v16.jmp_buf_size = 0;
    v16.longjmp_fn = (png_longjmp_ptr)&longjmp;
    if ( j_png_user_version_check(&v16, user_png_ver) )
    {
      v12 = (png_struct *)j_png_malloc_warn(&v16, 0x3CCu);
      v13 = v12;
      v11 = 0;
      if ( v12 )
      {
        v16.zstream.opaque = v12;
        memset(&v16.longjmp_fn, 0, 12);
        v16.zstream.zalloc = png_zalloc;
        v16.zstream.zfree = png_zfree;
        qmemcpy(v12, &v16, sizeof(png_struct));
        return v13;
      }
    }
  }
  return (png_structp)v11;
}

//----- (001EDC24) --------------------------------------------------------
png_infop __fastcall png_create_info_struct(png_const_structrp png_ptr)
{
  png_info *v1; // r0
  png_info *v2; // r4

  if ( !png_ptr )
    return 0;
  v1 = (png_info *)j_png_malloc_base(png_ptr, 0x118u);
  v2 = v1;
  if ( v1 )
    memset(v1, 0, sizeof(png_info));
  return v2;
}

//----- (001EDC4C) --------------------------------------------------------
void __fastcall png_destroy_info_struct(png_const_structrp png_ptr, png_infopp info_ptr_ptr)
{
  bool v3; // zf
  png_info *v4; // r5

  v3 = png_ptr == 0;
  if ( png_ptr )
    v3 = info_ptr_ptr == 0;
  if ( !v3 )
  {
    v4 = *info_ptr_ptr;
    if ( *info_ptr_ptr )
    {
      *info_ptr_ptr = 0;
      j_png_free_data(png_ptr, v4, 0xFFFFu, -1);
      memset(v4, 0, sizeof(png_info));
      sub_19CD58(png_ptr, v4);
    }
  }
}

//----- (001EDC8E) --------------------------------------------------------
void __fastcall png_free_data(png_const_structrp png_ptr, png_inforp info_ptr, png_uint_32 mask, int num)
{
  bool v5; // zf
  png_uint_32 v8; // r10
  png_textp text; // r1
  png_uint_32 *p_free_me; // r9
  int v11; // r4
  int v12; // r5
  png_uint_32 v13; // r0
  png_bytep trans_alpha; // r1
  png_uint_32 valid; // r0
  png_charpp pcal_params; // r1
  int v17; // r4
  png_uint_32 v18; // r0
  png_sPLT_tp splt_palettes; // r1
  int v20; // r4
  int v21; // r5
  png_uint_32 v22; // r0
  png_unknown_chunkp unknown_chunks; // r1
  int v24; // r4
  int v25; // r5
  png_uint_32 v26; // r0
  png_bytep eXIf_buf; // r1
  png_bytep exif; // r1
  png_uint_32 v29; // r0
  png_uint_32 v30; // r0
  png_bytepp row_pointers; // r1
  png_uint_32 v32; // r4

  v5 = png_ptr == 0;
  v8 = mask;
  if ( png_ptr )
    v5 = info_ptr == 0;
  if ( !v5 )
  {
    text = info_ptr->text;
    if ( text )
    {
      p_free_me = &info_ptr->free_me;
      if ( (info_ptr->free_me & mask & 0x4000) != 0 )
      {
        if ( num == -1 )
        {
          if ( info_ptr->num_text >= 1 )
          {
            v11 = 0;
            v12 = 4;
            do
            {
              j_png_free(png_ptr, *(png_voidp *)((char *)&text->compression + v12));
              ++v11;
              text = info_ptr->text;
              v12 += 28;
            }
            while ( v11 < info_ptr->num_text );
          }
          j_png_free(png_ptr, text);
          info_ptr->num_text = 0;
          info_ptr->max_text = 0;
          info_ptr->text = 0;
        }
        else
        {
          j_png_free(png_ptr, text[num].key);
          info_ptr->text[num].key = 0;
        }
      }
    }
    else
    {
      p_free_me = &info_ptr->free_me;
    }
    v13 = *p_free_me;
    if ( (v8 & *p_free_me & 0x2000) != 0 )
    {
      trans_alpha = info_ptr->trans_alpha;
      info_ptr->valid &= ~0x10u;
      j_png_free(png_ptr, trans_alpha);
      info_ptr->num_trans = 0;
      info_ptr->trans_alpha = 0;
      v13 = *p_free_me;
    }
    if ( (v8 & v13 & 0x100) != 0 )
    {
      j_png_free(png_ptr, info_ptr->scal_s_width);
      j_png_free(png_ptr, info_ptr->scal_s_height);
      valid = info_ptr->valid;
      info_ptr->scal_s_width = 0;
      info_ptr->scal_s_height = 0;
      info_ptr->valid = valid & 0xFFFFBFFF;
      v13 = *p_free_me;
    }
    if ( (v8 & v13 & 0x80) != 0 )
    {
      j_png_free(png_ptr, info_ptr->pcal_purpose);
      j_png_free(png_ptr, info_ptr->pcal_units);
      pcal_params = info_ptr->pcal_params;
      info_ptr->pcal_units = 0;
      info_ptr->pcal_purpose = 0;
      if ( pcal_params )
      {
        if ( info_ptr->pcal_nparams )
        {
          v17 = 0;
          do
          {
            j_png_free(png_ptr, pcal_params[v17++]);
            pcal_params = info_ptr->pcal_params;
          }
          while ( v17 < info_ptr->pcal_nparams );
        }
        j_png_free(png_ptr, pcal_params);
        info_ptr->pcal_params = 0;
      }
      info_ptr->valid &= ~0x400u;
      v13 = *p_free_me;
    }
    if ( (v13 & v8 & 0x10) != 0 )
    {
      j_png_free(png_ptr, info_ptr->iccp_name);
      j_png_free(png_ptr, info_ptr->iccp_profile);
      v18 = info_ptr->valid;
      info_ptr->iccp_name = 0;
      info_ptr->iccp_profile = 0;
      info_ptr->valid = v18 & 0xFFFFEFFF;
    }
    splt_palettes = info_ptr->splt_palettes;
    if ( splt_palettes && (*p_free_me & v8 & 0x20) != 0 )
    {
      if ( num == -1 )
      {
        if ( info_ptr->splt_palettes_num >= 1 )
        {
          v20 = 0;
          v21 = 0;
          do
          {
            j_png_free(png_ptr, splt_palettes[v20].name);
            j_png_free(png_ptr, info_ptr->splt_palettes[v20].entries);
            splt_palettes = info_ptr->splt_palettes;
            ++v21;
            ++v20;
          }
          while ( v21 < info_ptr->splt_palettes_num );
        }
        j_png_free(png_ptr, splt_palettes);
        v22 = info_ptr->valid;
        info_ptr->splt_palettes = 0;
        info_ptr->splt_palettes_num = 0;
        info_ptr->valid = v22 & 0xFFFFDFFF;
      }
      else
      {
        j_png_free(png_ptr, splt_palettes[num].name);
        j_png_free(png_ptr, info_ptr->splt_palettes[num].entries);
        info_ptr->splt_palettes[num].name = 0;
        info_ptr->splt_palettes[num].entries = 0;
      }
    }
    unknown_chunks = info_ptr->unknown_chunks;
    if ( unknown_chunks && (*p_free_me & v8 & 0x200) != 0 )
    {
      if ( num == -1 )
      {
        if ( info_ptr->unknown_chunks_num >= 1 )
        {
          v24 = 0;
          v25 = 8;
          do
          {
            j_png_free(png_ptr, *(png_voidp *)&unknown_chunks->name[v25]);
            unknown_chunks = info_ptr->unknown_chunks;
            ++v24;
            v25 += 20;
          }
          while ( v24 < info_ptr->unknown_chunks_num );
        }
        j_png_free(png_ptr, unknown_chunks);
        info_ptr->unknown_chunks = 0;
        info_ptr->unknown_chunks_num = 0;
      }
      else
      {
        j_png_free(png_ptr, unknown_chunks[num].data);
        info_ptr->unknown_chunks[num].data = 0;
      }
    }
    v26 = *p_free_me;
    if ( (v8 & *p_free_me & 0x8000) != 0 )
    {
      eXIf_buf = info_ptr->eXIf_buf;
      if ( eXIf_buf )
      {
        j_png_free(png_ptr, eXIf_buf);
        info_ptr->eXIf_buf = 0;
      }
      exif = info_ptr->exif;
      if ( exif )
      {
        j_png_free(png_ptr, exif);
        info_ptr->exif = 0;
      }
      info_ptr->valid &= ~0x10000u;
      v26 = *p_free_me;
    }
    if ( (v8 & v26 & 8) != 0 )
    {
      j_png_free(png_ptr, info_ptr->hist);
      v29 = info_ptr->valid;
      info_ptr->hist = 0;
      info_ptr->valid = v29 & 0xFFFFFFBF;
      v26 = *p_free_me;
    }
    if ( (v8 & v26 & 0x1000) != 0 )
    {
      j_png_free(png_ptr, info_ptr->palette);
      v30 = info_ptr->valid;
      info_ptr->palette = 0;
      info_ptr->num_palette = 0;
      info_ptr->valid = v30 & 0xFFFFFFF7;
      v26 = *p_free_me;
    }
    if ( (v8 & v26 & 0x40) != 0 )
    {
      row_pointers = info_ptr->row_pointers;
      if ( row_pointers )
      {
        if ( info_ptr->height )
        {
          v32 = 0;
          do
          {
            j_png_free(png_ptr, row_pointers[v32++]);
            row_pointers = info_ptr->row_pointers;
          }
          while ( v32 < info_ptr->height );
        }
        j_png_free(png_ptr, row_pointers);
        info_ptr->row_pointers = 0;
        v26 = *p_free_me;
      }
      info_ptr->valid &= ~0x8000u;
    }
    if ( num != -1 )
      v8 &= 0xFFFFBDDF;
    *p_free_me = v26 & ~v8;
  }
}

//----- (001EDFD2) --------------------------------------------------------
void __fastcall png_info_init_3(png_infopp ptr_ptr, png_size_t png_info_struct_size)
{
  png_info *v3; // r0

  v3 = *ptr_ptr;
  if ( v3 )
  {
    if ( png_info_struct_size >> 3 <= 0x22 )
    {
      *ptr_ptr = 0;
      free(v3);
      v3 = (png_info *)j_png_malloc_base(0, 0x118u);
      if ( !v3 )
        return;
      *ptr_ptr = v3;
    }
    memset(v3, 0, sizeof(png_info));
  }
}

//----- (001EE008) --------------------------------------------------------
void __fastcall png_data_freer(png_const_structrp png_ptr, png_inforp info_ptr, int freer, png_uint_32 mask)
{
  bool v4; // zf
  png_uint_32 v5; // r0

  v4 = png_ptr == 0;
  if ( png_ptr )
    v4 = info_ptr == 0;
  if ( !v4 )
  {
    if ( freer == 2 )
    {
      v5 = info_ptr->free_me & ~mask;
    }
    else
    {
      if ( freer != 1 )
      {
        j_png_error(png_ptr, (png_const_charp)"Unknown freer parameter in png_data_freer");
        JUMPOUT(0x1EE038);
      }
      v5 = info_ptr->free_me | mask;
    }
    info_ptr->free_me = v5;
  }
}
// 1EE036: control flows out of bounds to 1EE038

//----- (001EE064) --------------------------------------------------------
png_voidp __fastcall png_get_io_ptr(png_const_structrp png_ptr)
{
  if ( png_ptr )
    return png_ptr->io_ptr;
  else
    return 0;
}

//----- (001EE070) --------------------------------------------------------
void __fastcall png_init_io(png_structrp png_ptr, png_FILE_p fp)
{
  if ( png_ptr )
    png_ptr->io_ptr = fp;
}

//----- (001EE080) --------------------------------------------------------
int __fastcall png_convert_to_rfc1123_buffer(unsigned __int8 *out, png_const_timep ptime)
{
  png_alloc_size_t day; // r3
  const unsigned __int8 *v6; // r0
  size_t v7; // r2
  size_t v8; // r6
  const unsigned __int8 *v9; // r0
  size_t v10; // r6
  const unsigned __int8 *v11; // r0
  size_t v12; // r6
  const unsigned __int8 *v13; // r0
  size_t v14; // r6
  const unsigned __int8 *v15; // r0
  size_t v16; // r0
  unsigned __int8 start[5]; // [sp+3h] [bp-15h] BYREF
  unsigned __int8 v18[3]; // [sp+8h] [bp-10h] BYREF

  if ( !out )
    return 0;
  if ( ptime->year > 0x270Fu )
    return 0;
  if ( (unsigned __int8)(ptime->month - 1) > 0xBu )
    return 0;
  day = ptime->day;
  if ( (unsigned __int8)(day - 1) > 0x1Eu || ptime->hour > 0x17u || ptime->minute > 0x3Bu || ptime->second > 0x3Cu )
    return 0;
  v6 = j_png_format_number(start, v18, 1, day);
  v7 = j_png_safecat(out, 0x1Du, 0, v6);
  if ( v7 <= 0x1B )
    out[v7++] = 32;
  v8 = j_png_safecat(out, 0x1Du, v7, png_convert_to_rfc1123_buffer_short_months[ptime->month - 1]);
  if ( v8 <= 0x1B )
    out[v8++] = 32;
  v9 = j_png_format_number(start, v18, 1, ptime->year);
  v10 = j_png_safecat(out, 0x1Du, v8, v9);
  if ( v10 <= 0x1B )
    out[v10++] = 32;
  v11 = j_png_format_number(start, v18, 2, ptime->hour);
  v12 = j_png_safecat(out, 0x1Du, v10, v11);
  if ( v12 <= 0x1B )
    out[v12++] = 58;
  v13 = j_png_format_number(start, v18, 2, ptime->minute);
  v14 = j_png_safecat(out, 0x1Du, v12, v13);
  if ( v14 <= 0x1B )
    out[v14++] = 58;
  v15 = j_png_format_number(start, v18, 2, ptime->second);
  v16 = j_png_safecat(out, 0x1Du, v14, v15);
  j_png_safecat(out, 0x1Du, v16, (png_const_charp)" +0000");
  return 1;
}

//----- (001EE1C4) --------------------------------------------------------
png_const_charp __fastcall png_convert_to_rfc1123(png_structrp png_ptr, png_const_timep ptime)
{
  if ( png_ptr )
  {
    if ( j_png_convert_to_rfc1123_buffer(png_ptr->time_buffer, ptime) )
      return png_ptr->time_buffer;
    j_png_warning(png_ptr, (png_const_charp)"Ignoring invalid time value");
  }
  return 0;
}

//----- (001EE208) --------------------------------------------------------
png_const_charp __fastcall png_get_copyright(png_const_structrp png_ptr)
{
  return (png_const_charp)"\n"
                          "libpng version 1.6.34 - September 29, 2017\n"
                          "Copyright (c) 1998-2002,2004,2006-2017 Glenn Randers-Pehrson\n"
                          "Copyright (c) 1996-1997 Andreas Dilger\n"
                          "Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\n";
}

//----- (001EE214) --------------------------------------------------------
png_const_charp __fastcall png_get_libpng_ver(png_const_structrp png_ptr)
{
  return (png_const_charp)"1.6.34";
}

//----- (001EE220) --------------------------------------------------------
png_const_charp __fastcall png_get_header_ver(png_const_structrp png_ptr)
{
  return (png_const_charp)"1.6.34";
}

//----- (001EE22C) --------------------------------------------------------
png_const_charp __fastcall png_get_header_version(png_const_structrp png_ptr)
{
  return (png_const_charp)" libpng version 1.6.34 - September 29, 2017\n\n";
}

//----- (001EE260) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall png_build_grayscale_palette(int bit_depth, png_colorp palette)
{
  unsigned int v2; // r0
  bool v3; // zf
  unsigned int v4; // r12
  int v5; // lr
  int v6; // r3
  int v7; // r0
  int8x16_t v8; // q8
  png_colorp v9; // r4
  int8x16_t v10; // q9
  int8x16_t v11; // q8
  int v12; // r2
  int8x16_t v13; // q10
  int8x16_t v14; // q11
  char *v15; // r4
  int v16; // r2
  png_color *v17; // r2

  if ( palette )
  {
    v2 = bit_depth - 1;
    if ( v2 <= 7 )
    {
      if ( 0x8Bu >> v2 << 31 )
      {
        v3 = (v2 | 4) == 7;
        v4 = dword_1EE310[v2];
        if ( (v2 | 4) == 7 )
          v3 = 1;
        v5 = dword_1EE330[v2];
        if ( !v3 )
        {
          v6 = 0;
          v7 = 0;
          do
          {
LABEL_11:
            v16 = v7++;
            palette[v16].red = v6;
            v17 = &palette[v16];
            v17->green = v6;
            v17->blue = v6;
            v6 += v4;
          }
          while ( v7 < v5 );
          return;
        }
        v7 = dword_1EE330[v2] & 0x110;
        v8.n128_u64[0] = 0x706050403020100LL;
        v8.n128_u64[1] = 0xF0E0D0C0B0A0908LL;
        v6 = v4 * v7;
        v9 = palette;
        v10 = vmulq_s8(vdupq_n_s8(v4), v8);
        v11 = vdupq_n_s8(16 * v4);
        v12 = v7;
        do
        {
          v13 = v10;
          v12 -= 16;
          v14 = v10;
          vst3_s8((char *)v9, *(int8x8x3_t *)v10.n128_u64);
          v15 = (char *)&v9[8];
          vst3_s8(v15, *(int8x8x3_t *)&v10.n128_i8[8]);
          v9 = (png_colorp)(v15 + 24);
          v10 = vaddq_s8(v10, v11);
        }
        while ( v12 );
        if ( v5 != v7 )
          goto LABEL_11;
      }
    }
  }
}
// 1EE260: fragmented variable at q9.16 may be wrong
// 1EE310: using guessed type int dword_1EE310[];
// 1EE330: using guessed type int dword_1EE330[7];

//----- (001EE350) --------------------------------------------------------
int __fastcall png_handle_as_unknown(png_const_structrp png_ptr, png_const_bytep chunk_name)
{
  bool v3; // zf
  int result; // r0
  unsigned int num_chunk_list; // r3
  png_bytep chunk_list; // r12
  unsigned int i; // r2

  v3 = png_ptr == 0;
  result = 0;
  if ( !v3 )
    v3 = chunk_name == 0;
  if ( !v3 )
  {
    num_chunk_list = png_ptr->num_chunk_list;
    if ( num_chunk_list )
    {
      chunk_list = png_ptr->chunk_list;
      for ( i = (unsigned int)&chunk_list[5 * num_chunk_list - 5]; *(_DWORD *)chunk_name != *(_DWORD *)i; i -= 5 )
      {
        if ( i <= (unsigned int)chunk_list )
          return 0;
      }
      return *(unsigned __int8 *)(i + 4);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (001EE388) --------------------------------------------------------
int __fastcall png_chunk_unknown_handling(png_const_structrp png_ptr, png_uint_32 chunk_name)
{
  int result; // r0
  unsigned int num_chunk_list; // r1
  png_bytep chunk_list; // r0
  unsigned int i; // r1
  int v8; // [sp+3h] [bp-5h]

  result = 0;
  HIBYTE(v8) = chunk_name;
  BYTE1(v8) = BYTE2(chunk_name);
  LOBYTE(v8) = HIBYTE(chunk_name);
  BYTE2(v8) = BYTE1(chunk_name);
  if ( png_ptr )
  {
    num_chunk_list = png_ptr->num_chunk_list;
    if ( num_chunk_list )
    {
      chunk_list = png_ptr->chunk_list;
      for ( i = (unsigned int)&chunk_list[5 * num_chunk_list - 5]; v8 != *(_DWORD *)i; i -= 5 )
      {
        if ( i <= (unsigned int)chunk_list )
          return 0;
      }
      return *(unsigned __int8 *)(i + 4);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (001EE3E0) --------------------------------------------------------
int __fastcall png_reset_zstream(png_structrp png_ptr)
{
  if ( png_ptr )
    return sub_19A3CC((z_streamp_1)&png_ptr->zstream);
  else
    return -2;
}

//----- (001EE3F2) --------------------------------------------------------
png_uint_32 png_access_version_number()
{
  return 10634;
}

//----- (001EE3F8) --------------------------------------------------------
void __fastcall png_zstream_error(png_structrp png_ptr, int ret)
{
  unsigned int v2; // r1

  if ( !png_ptr->zstream.msg )
  {
    v2 = ret + 7;
    if ( v2 > 9 )
      png_ptr->zstream.msg = "unexpected zlib return code";
    else
      png_ptr->zstream.msg = (unsigned __int8 *)(&off_660940)[v2];
  }
}
// 660940: using guessed type char *off_660940;

//----- (001EE428) --------------------------------------------------------
void __fastcall png_colorspace_set_gamma(png_const_structrp png_ptr, png_colorspacerp colorspace, png_fixed_point gAMA)
{
  const png_struct *v5; // r8
  png_uint_16 *p_flags; // r4
  png_uint_16 flags; // r5
  const char *v8; // r1
  signed __int16 v9; // r1
  int v10; // r2
  double v11; // r0

  v5 = png_ptr;
  if ( (unsigned int)(gAMA - 16) >= 0x2540BE31 )
  {
    p_flags = &colorspace->flags;
    flags = colorspace->flags;
    v8 = "gamma value out of range";
LABEL_6:
    *p_flags = flags | 0x8000;
    v10 = 1;
LABEL_7:
    sub_18A980(png_ptr, (png_const_charp)v8, v10);
    return;
  }
  v9 = colorspace->flags;
  flags = v9;
  if ( (png_ptr->mode & 0x8000) != 0 && (v9 & 8) != 0 )
  {
    v8 = "duplicate";
    p_flags = &colorspace->flags;
    goto LABEL_6;
  }
  if ( v9 >= 0 )
  {
    if ( v9 << 31 )
    {
      if ( !colorspace->gamma
        || (v11 = floor((double)colorspace->gamma * 100000.0 / (double)gAMA + 0.5), v11 > 2147483650.0)
        || v11 < -2147483650.0
        || (unsigned int)((int)v11 - 95000) >= 0x2711 )
      {
        if ( (flags & 0x20) != 0 )
        {
          png_ptr = v5;
          v10 = 2;
          v8 = "gamma value does not match sRGB";
          goto LABEL_7;
        }
        j_png_chunk_report(v5, (png_const_charp)"gamma value does not match libpng estimate", 0);
      }
    }
    colorspace->flags = flags | 9;
    colorspace->gamma = gAMA;
  }
}

//----- (001EE588) --------------------------------------------------------
void __fastcall png_colorspace_sync_info(png_const_structrp png_ptr, png_inforp info_ptr)
{
  png_uint_16 flags; // r2
  png_uint_32 valid; // r12
  unsigned int v4; // r3
  unsigned int v5; // r0
  png_uint_32 v6; // r3

  flags = info_ptr->colorspace.flags;
  if ( (flags & 0x8000) != 0 )
  {
    info_ptr->valid &= 0xFFFFE7FA;
    png_free_data(png_ptr, info_ptr, 0x10u, -1);
  }
  else
  {
    valid = info_ptr->valid;
    v4 = valid & 0xFFFFF7FF;
    if ( (flags & 0x80) != 0 )
      v4 = valid | 0x800;
    v5 = v4 & 0xFFFFFFFB;
    if ( (flags & 2) != 0 )
      v5 = v4 | 4;
    v6 = v5 & 0xFFFFFFFE;
    if ( (flags & 1) != 0 )
      v6 = v5 | 1;
    info_ptr->valid = v6;
  }
}

//----- (001EE5D6) --------------------------------------------------------
void __fastcall png_colorspace_sync(png_const_structrp png_ptr, png_inforp info_ptr)
{
  png_uint_16 flags; // r0
  png_uint_32 valid; // r1
  unsigned int v6; // r2
  unsigned int v7; // r1
  png_uint_32 v8; // r2

  if ( info_ptr )
  {
    qmemcpy(&info_ptr->colorspace, &png_ptr->colorspace, sizeof(info_ptr->colorspace));
    flags = info_ptr->colorspace.flags;
    if ( (flags & 0x8000) != 0 )
    {
      info_ptr->valid &= 0xFFFFE7FA;
      png_free_data(png_ptr, info_ptr, 0x10u, -1);
    }
    else
    {
      valid = info_ptr->valid;
      v6 = valid & 0xFFFFF7FF;
      if ( (flags & 0x80) != 0 )
        v6 = valid | 0x800;
      v7 = v6 & 0xFFFFFFFB;
      if ( (flags & 2) != 0 )
        v7 = v6 | 4;
      v8 = v7 & 0xFFFFFFFE;
      if ( (flags & 1) != 0 )
        v8 = v7 | 1;
      info_ptr->valid = v8;
    }
  }
}

//----- (001EE648) --------------------------------------------------------
int __fastcall png_colorspace_set_chromaticities(
        png_const_structrp png_ptr,
        png_colorspacerp colorspace,
        const png_xy_0 *xy,
        int preferred)
{
  int v8; // r0
  png_uint_16 flags; // r11
  __int64 v10; // d17
  __int64 v11; // d18
  __int64 v12; // d19
  png_fixed_point blue_Z; // r0
  __int64 v14; // d16
  __int64 v15; // d17
  __int64 v16; // d18
  __int64 v17; // d19
  bool v18; // zf
  png_uint_16 v19; // r1
  int result; // r0
  const char *v21; // r1
  png_XYZ_0 v22; // [sp+0h] [bp-40h] BYREF

  v8 = png_colorspace_check_xy(&v22, xy);
  if ( v8 == 1 )
  {
    v21 = "invalid chromaticities";
    colorspace->flags |= 0x8000u;
LABEL_12:
    j_png_benign_error(png_ptr, (png_const_charp)v21);
    return 0;
  }
  if ( v8 )
  {
    colorspace->flags |= 0x8000u;
    j_png_error(png_ptr, (png_const_charp)"internal error checking chromaticities");
    JUMPOUT(0x1EE734);
  }
  flags = colorspace->flags;
  if ( (flags & 0x8000) != 0 )
    return 0;
  if ( preferred <= 1 && (flags & 2) != 0 )
  {
    if ( png_colorspace_endpoints_match(xy, &colorspace->end_points_xy, 100) )
    {
      if ( !preferred )
        return 1;
      goto LABEL_8;
    }
    colorspace->flags = flags | 0x8000;
    v21 = "inconsistent chromaticities";
    goto LABEL_12;
  }
LABEL_8:
  v10 = *(_QWORD *)&xy->greenx;
  v11 = *(_QWORD *)&xy->bluex;
  v12 = *(_QWORD *)&xy->whitex;
  *(_QWORD *)&colorspace->end_points_xy.redx = *(_QWORD *)&xy->redx;
  *(_QWORD *)&colorspace->end_points_xy.greenx = v10;
  blue_Z = v22.blue_Z;
  *(_QWORD *)&colorspace->end_points_xy.bluex = v11;
  *(_QWORD *)&colorspace->end_points_xy.whitex = v12;
  v14 = *(_QWORD *)&v22.red_X;
  v15 = *(_QWORD *)&v22.red_Z;
  colorspace->end_points_XYZ.blue_Z = blue_Z;
  v16 = *(_QWORD *)&v22.green_Y;
  v17 = *(_QWORD *)&v22.blue_X;
  *(_QWORD *)&colorspace->end_points_XYZ.red_X = v14;
  *(_QWORD *)&colorspace->end_points_XYZ.red_Z = v15;
  *(_QWORD *)&colorspace->end_points_XYZ.green_Y = v16;
  *(_QWORD *)&colorspace->end_points_XYZ.blue_X = v17;
  v18 = png_colorspace_endpoints_match(xy, &sRGB_xy, 1000) == 0;
  v19 = flags & 0xFFBD | 2;
  result = 2;
  if ( !v18 )
    v19 = flags | 0x42;
  colorspace->flags = v19;
  return result;
}
// 1EE730: control flows out of bounds to 1EE734

//----- (001EE758) --------------------------------------------------------
int __fastcall png_colorspace_check_xy(png_XYZ_0 *XYZ, const png_xy_0 *xy)
{
  png_fixed_point redx; // r5
  int result; // r0
  png_fixed_point redy; // r1
  unsigned int greenx; // r2
  png_fixed_point greeny; // r9
  unsigned int bluex; // r11
  png_fixed_point bluey; // r8
  unsigned int whitex; // lr
  png_fixed_point whitey; // r12
  bool v13; // zf
  int v14; // r3
  int v15; // r2
  double v16; // d16
  bool v17; // zf
  int v18; // r9
  int v19; // r1
  double v20; // d16
  int v21; // r8
  bool v22; // zf
  int v23; // r9
  double v24; // d16
  int v25; // r0
  int v26; // r8
  bool v27; // zf
  int v28; // r11
  double v29; // d16
  int v30; // r0
  int v31; // r3
  int v32; // r9
  double v33; // d16
  int v34; // r11
  bool v35; // zf
  double v36; // d16
  int v37; // r1
  int v38; // r0
  bool v39; // zf
  double v40; // d16
  int v41; // r0
  double v42; // d16
  int v43; // r11
  double v44; // d13
  double v45; // d12
  double v46; // d11
  double v47; // d14
  double v48; // d16
  int v49; // r1
  int v50; // r2
  int v51; // r8
  double v52; // d16
  png_fixed_point v53; // r0
  png_fixed_point v54; // r0
  double v55; // d16
  png_fixed_point v56; // r0
  char *v57; // r0
  double v58; // d16
  png_fixed_point v59; // r0
  png_fixed_point v60; // r0
  double v61; // d16
  png_fixed_point v62; // r0
  png_fixed_point v63; // r0
  double v64; // d16
  png_fixed_point v65; // r0
  char *v66; // r0
  double v67; // d16
  png_fixed_point v68; // r0
  png_fixed_point v69; // r0
  double v70; // d16
  png_fixed_point v71; // r0
  png_fixed_point v72; // r0
  double v73; // d16
  png_fixed_point v74; // r0
  char *v75; // r0
  double v76; // d16
  png_fixed_point v77; // r0
  int v78; // [sp+0h] [bp-A0h]
  int v79; // [sp+4h] [bp-9Ch]
  int v80; // [sp+4h] [bp-9Ch]
  int v81; // [sp+8h] [bp-98h]
  int v82; // [sp+Ch] [bp-94h]
  int v83; // [sp+10h] [bp-90h]
  int v84; // [sp+10h] [bp-90h]
  int v85; // [sp+10h] [bp-90h]
  int v86; // [sp+14h] [bp-8Ch]
  int v87; // [sp+14h] [bp-8Ch]
  _BOOL4 v88; // [sp+18h] [bp-88h]
  png_fixed_point v89; // [sp+1Ch] [bp-84h]
  png_xy_0 xy2; // [sp+20h] [bp-80h] BYREF

  redx = xy->redx;
  if ( xy->redx > (unsigned int)&elf_hash_chain[8526] )
    return 1;
  redy = xy->redy;
  result = 1;
  if ( redy >= 0 && redy <= (int)&elf_hash_chain[8526] - redx )
  {
    greenx = xy->greenx;
    if ( greenx > (unsigned int)&elf_hash_chain[8526] )
      return 1;
    greeny = xy->greeny;
    result = 1;
    if ( greeny < 0 || greeny > (int)((int)&elf_hash_chain[8526] - greenx) )
      return result;
    bluex = xy->bluex;
    if ( bluex > (unsigned int)&elf_hash_chain[8526] )
      return 1;
    bluey = xy->bluey;
    result = 1;
    if ( bluey < 0 || bluey > (int)((int)&elf_hash_chain[8526] - bluex) )
      return result;
    whitex = xy->whitex;
    if ( whitex > (unsigned int)&elf_hash_chain[8526] )
      return 1;
    whitey = xy->whitey;
    result = 1;
    if ( whitey < 5 || whitey > (int)((int)&elf_hash_chain[8526] - whitex) )
      return result;
    v14 = greenx - bluex;
    v13 = greenx == bluex;
    v81 = redy - bluey;
    v15 = 0;
    v89 = xy->whitey;
    if ( !v13 )
      v13 = redy == bluey;
    if ( !v13 )
    {
      v83 = v14;
      v16 = floor((double)v14 * (double)(redy - bluey) / 7.0 + 0.5);
      result = 2;
      if ( v16 > 2147483650.0 )
        return result;
      whitey = v89;
      if ( v16 < -2147483650.0 )
        return result;
      v14 = v83;
      v15 = (int)v16;
    }
    v17 = redx == bluex;
    v18 = greeny - bluey;
    v82 = redx - bluex;
    v19 = 0;
    v86 = v18;
    if ( redx != bluex )
      v17 = v18 == 0;
    if ( !v17 )
    {
      v84 = v14;
      v79 = v15;
      v20 = floor((double)v82 * (double)v18 / 7.0 + 0.5);
      result = 2;
      if ( v20 > 2147483650.0 )
        return result;
      whitey = v89;
      if ( v20 < -2147483650.0 )
        return result;
      v15 = v79;
      v14 = v84;
      v19 = (int)v20;
    }
    v21 = whitey - bluey;
    v22 = v14 == 0;
    v85 = v19;
    v23 = 0;
    if ( v14 )
      v22 = v21 == 0;
    if ( !v22 )
    {
      v80 = v15;
      v24 = floor((double)v14 * (double)v21 / 7.0 + 0.5);
      result = 2;
      if ( v24 > 2147483650.0 )
        return result;
      whitey = v89;
      if ( v24 < -2147483650.0 )
        return result;
      v15 = v80;
      v23 = (int)v24;
    }
    v25 = 0;
    v78 = v21;
    v26 = whitex - bluex;
    v27 = v86 == 0;
    if ( v86 )
      v27 = whitex == bluex;
    if ( !v27 )
    {
      v28 = v15;
      v29 = floor((double)v86 * (double)v26 / 7.0 + 0.5);
      result = 2;
      if ( v29 > 2147483650.0 )
        return result;
      whitey = v89;
      if ( v29 < -2147483650.0 )
        return result;
      v15 = v28;
      v25 = (int)v29;
    }
    v30 = v23 - v25;
    if ( !v30 )
      return 1;
    v31 = 0;
    v32 = v15 - v85;
    v88 = v15 == v85 || whitey == 0;
    if ( !v88 )
    {
      v33 = floor((double)whitey * (double)v32 / (double)v30 + 0.5);
      result = 1;
      if ( v33 > 2147483650.0 )
        return result;
      whitey = v89;
      if ( v33 < -2147483650.0 )
        return result;
      v31 = (int)v33;
    }
    if ( v31 <= whitey )
      return 1;
    v34 = 0;
    v87 = v31;
    v35 = v81 == 0;
    if ( v81 )
      v35 = v26 == 0;
    if ( !v35 )
    {
      v36 = floor((double)v81 * (double)v26 / 7.0 + 0.5);
      result = 2;
      if ( v36 > 2147483650.0 )
        return result;
      whitey = v89;
      if ( v36 < -2147483650.0 )
        return result;
      v34 = (int)v36;
    }
    v37 = v82;
    v38 = 0;
    v39 = v82 == 0;
    if ( v82 )
    {
      v37 = v78;
      v39 = v78 == 0;
    }
    if ( !v39 )
    {
      v40 = floor((double)v82 * (double)v37 / 7.0 + 0.5);
      result = 2;
      if ( v40 > 2147483650.0 )
        return result;
      whitey = v89;
      if ( v40 < -2147483650.0 )
        return result;
      v38 = (int)v40;
    }
    v41 = v34 - v38;
    if ( !v41 || v88 )
      return 1;
    v42 = floor((double)whitey * (double)v32 / (double)v41 + 0.5);
    result = 1;
    if ( v42 > 2147483650.0 || v42 < -2147483650.0 )
      return result;
    v43 = (int)v42;
    if ( (int)v42 <= v89 )
      return 1;
    v44 = floor(1.0e10 / (double)v89 + 0.5);
    v45 = (double)v87;
    v46 = (double)v43;
    v47 = floor(1.0e10 / (double)v87 + 0.5);
    v48 = floor(1.0e10 / (double)v43 + 0.5);
    v49 = (int)v44;
    if ( v44 < -2147483650.0 )
      v49 = 0;
    if ( v44 > 2147483650.0 )
      v49 = 0;
    v50 = v49;
    if ( v47 >= -2147483650.0 )
      v50 = v49 - (int)v47;
    if ( v47 > 2147483650.0 )
      v50 = v49;
    v51 = v50;
    if ( v48 >= -2147483650.0 )
      v51 = v50 - (int)v48;
    if ( v48 > 2147483650.0 )
      v51 = v50;
    if ( v51 < 1 || !v87 )
      return 1;
    if ( redx )
    {
      v52 = floor((double)redx * 100000.0 / v45 + 0.5);
      result = 1;
      if ( v52 > 2147483650.0 || v52 < -2147483650.0 )
        return result;
      v53 = (int)v52;
    }
    else
    {
      v53 = 0;
    }
    XYZ->red_X = v53;
    v54 = xy->redy;
    if ( v54 )
    {
      v55 = floor((double)v54 * 100000.0 / v45 + 0.5);
      result = 1;
      if ( v55 > 2147483650.0 || v55 < -2147483650.0 )
        return result;
      v56 = (int)v55;
    }
    else
    {
      v56 = 0;
    }
    XYZ->red_Y = v56;
    v57 = (char *)&elf_hash_chain[8526] - xy->redx - xy->redy;
    if ( v57 )
    {
      v58 = floor((double)(int)v57 * 100000.0 / v45 + 0.5);
      result = 1;
      if ( v58 > 2147483650.0 || v58 < -2147483650.0 )
        return result;
      v59 = (int)v58;
    }
    else
    {
      v59 = 0;
    }
    XYZ->red_Z = v59;
    if ( !v43 )
      return 1;
    v60 = xy->greenx;
    if ( v60 )
    {
      v61 = floor((double)v60 * 100000.0 / v46 + 0.5);
      result = 1;
      if ( v61 > 2147483650.0 || v61 < -2147483650.0 )
        return result;
      v62 = (int)v61;
    }
    else
    {
      v62 = 0;
    }
    XYZ->green_X = v62;
    v63 = xy->greeny;
    if ( v63 )
    {
      v64 = floor((double)v63 * 100000.0 / v46 + 0.5);
      result = 1;
      if ( v64 > 2147483650.0 || v64 < -2147483650.0 )
        return result;
      v65 = (int)v64;
    }
    else
    {
      v65 = 0;
    }
    XYZ->green_Y = v65;
    v66 = (char *)&elf_hash_chain[8526] - xy->greenx - xy->greeny;
    if ( v66 )
    {
      v67 = floor((double)(int)v66 * 100000.0 / v46 + 0.5);
      result = 1;
      if ( v67 > 2147483650.0 || v67 < -2147483650.0 )
        return result;
      v68 = (int)v67;
    }
    else
    {
      v68 = 0;
    }
    XYZ->green_Z = v68;
    v69 = xy->bluex;
    if ( v69 )
    {
      v70 = floor((double)v51 * (double)v69 / 100000.0 + 0.5);
      result = 1;
      if ( v70 > 2147483650.0 || v70 < -2147483650.0 )
        return result;
      v71 = (int)v70;
    }
    else
    {
      v71 = 0;
    }
    XYZ->blue_X = v71;
    v72 = xy->bluey;
    if ( v72 )
    {
      v73 = floor((double)v51 * (double)v72 / 100000.0 + 0.5);
      result = 1;
      if ( v73 > 2147483650.0 || v73 < -2147483650.0 )
        return result;
      v74 = (int)v73;
    }
    else
    {
      v74 = 0;
    }
    XYZ->blue_Y = v74;
    v75 = (char *)&elf_hash_chain[8526] - xy->bluex - xy->bluey;
    if ( !v75 )
    {
      v77 = 0;
LABEL_122:
      XYZ->blue_Z = v77;
      result = png_xy_from_XYZ(&xy2, XYZ);
      if ( !result )
        return png_colorspace_endpoints_match(xy, &xy2, 5) == 0;
      return result;
    }
    v76 = floor((double)v51 * (double)(int)v75 / 100000.0 + 0.5);
    result = 1;
    if ( v76 <= 2147483650.0 && v76 >= -2147483650.0 )
    {
      v77 = (int)v76;
      goto LABEL_122;
    }
  }
  return result;
}
// 1EEB54: conditional instruction was optimized away because r12.4>=5
// 10168: using guessed type int elf_hash_chain[22025];

//----- (001EF018) --------------------------------------------------------
int __fastcall png_colorspace_set_endpoints(
        png_const_structrp png_ptr,
        png_colorspacerp colorspace,
        const png_XYZ_0 *XYZ_in,
        int preferred)
{
  png_fixed_point green_Y; // r8
  png_fixed_point v5; // r12
  png_fixed_point green_Z; // lr
  __int64 v8; // d17
  int v10; // r11
  __int64 v11; // d18
  __int64 v12; // d19
  int blue_Z; // r0
  bool v14; // nf
  bool v15; // nf
  bool v16; // nf
  bool v17; // nf
  bool v18; // cc
  int v19; // r1
  int *v20; // r2
  int v21; // r0
  png_uint_16 flags; // r6
  __int64 v23; // d17
  __int64 v24; // d18
  __int64 v25; // d19
  png_fixed_point v26; // r0
  __int64 v27; // d16
  __int64 v28; // d17
  __int64 v29; // d18
  __int64 v30; // d19
  bool v31; // zf
  png_uint_16 v32; // r1
  int result; // r0
  double v34; // r0
  png_fixed_point v35; // r0
  double v36; // r0
  png_fixed_point v37; // r0
  double v38; // r0
  png_fixed_point v39; // r0
  double v40; // r0
  int v41; // r3
  png_fixed_point v42; // r0
  double v43; // r0
  int v44; // r12
  png_fixed_point v45; // r0
  double v46; // r0
  png_fixed_point v47; // r0
  double v48; // r0
  png_fixed_point v49; // r0
  const char *v50; // r1
  double v51; // d16
  int v52; // r1
  png_fixed_point v53; // r0
  double v54; // r0
  png_fixed_point v55; // r0
  int v56; // [sp+4h] [bp-9Ch]
  int v57; // [sp+8h] [bp-98h]
  int v58; // [sp+10h] [bp-90h]
  png_xy_0 xy; // [sp+18h] [bp-88h] BYREF
  png_XYZ_0 XYZ; // [sp+38h] [bp-68h] BYREF
  png_XYZ_0 v61; // [sp+60h] [bp-40h] BYREF

  v8 = *(_QWORD *)&XYZ_in->red_Z;
  v10 = preferred;
  v11 = *(_QWORD *)&XYZ_in->green_Y;
  v12 = *(_QWORD *)&XYZ_in->blue_X;
  blue_Z = XYZ_in->blue_Z;
  *(_QWORD *)&XYZ.red_X = *(_QWORD *)&XYZ_in->red_X;
  *(_QWORD *)&XYZ.red_Z = v8;
  *(_QWORD *)&XYZ.green_Y = v11;
  *(_QWORD *)&XYZ.blue_X = v12;
  XYZ.blue_Z = blue_Z;
  v14 = XYZ.red_Y < 0;
  if ( XYZ.red_Y >= 0 )
  {
    green_Y = XYZ.green_Y;
    v14 = XYZ.green_Y < 0;
  }
  if ( v14 )
    goto LABEL_77;
  v15 = XYZ.blue_Y < 0;
  if ( XYZ.blue_Y >= 0 )
  {
    blue_Z = XYZ.red_X;
    v15 = XYZ.red_X < 0;
  }
  if ( v15 )
    goto LABEL_77;
  v16 = XYZ.green_X < 0;
  if ( XYZ.green_X >= 0 )
  {
    preferred = XYZ.blue_X;
    v16 = XYZ.blue_X < 0;
  }
  if ( v16 )
    goto LABEL_77;
  v17 = XYZ.red_Z < 0;
  if ( XYZ.red_Z >= 0 )
  {
    green_Z = XYZ.green_Z;
    v17 = XYZ.green_Z < 0;
  }
  if ( v17 )
    goto LABEL_77;
  v18 = 0x7FFFFFFF - XYZ.red_Y < XYZ.green_X;
  if ( 0x7FFFFFFF - XYZ.red_Y >= XYZ.green_X )
  {
    v5 = XYZ.blue_Z;
    v18 = XYZ.blue_Z < 0;
  }
  if ( v18 )
    goto LABEL_77;
  v19 = green_Y + XYZ.red_Y;
  if ( 0x7FFFFFFF - (green_Y + XYZ.red_Y) < preferred )
    goto LABEL_77;
  v20 = (int *)(XYZ.blue_Y + v19);
  if ( !(XYZ.blue_Y + v19) )
    goto LABEL_77;
  if ( v20 != &elf_hash_chain[8526] )
  {
    v56 = v5;
    v57 = preferred;
    v58 = XYZ.blue_Y + v19;
    if ( blue_Z )
    {
      v34 = floor((double)blue_Z * 100000.0 / (double)(int)v20 + 0.5);
      v20 = (int *)v58;
      if ( v34 > 2147483650.0 || v34 < -2147483650.0 )
        goto LABEL_77;
      v35 = (int)v34;
    }
    else
    {
      v35 = 0;
    }
    XYZ.red_X = v35;
    if ( XYZ.red_Y )
    {
      v36 = floor((double)XYZ.red_Y * 100000.0 / (double)(int)v20 + 0.5);
      v20 = (int *)v58;
      if ( v36 > 2147483650.0 || v36 < -2147483650.0 )
        goto LABEL_77;
      v37 = (int)v36;
    }
    else
    {
      v37 = 0;
    }
    XYZ.red_Y = v37;
    if ( XYZ.red_Z )
    {
      v38 = floor((double)XYZ.red_Z * 100000.0 / (double)(int)v20 + 0.5);
      v20 = (int *)v58;
      if ( v38 > 2147483650.0 || v38 < -2147483650.0 )
        goto LABEL_77;
      v39 = (int)v38;
    }
    else
    {
      v39 = 0;
    }
    XYZ.red_Z = v39;
    if ( XYZ.green_X )
    {
      v40 = floor((double)XYZ.green_X * 100000.0 / (double)(int)v20 + 0.5);
      v20 = (int *)v58;
      v41 = green_Z;
      if ( v40 > 2147483650.0 || v40 < -2147483650.0 )
        goto LABEL_77;
      v42 = (int)v40;
    }
    else
    {
      v42 = 0;
      v41 = green_Z;
    }
    XYZ.green_X = v42;
    if ( green_Y )
    {
      v43 = floor((double)green_Y * 100000.0 / (double)(int)v20 + 0.5);
      v41 = green_Z;
      v20 = (int *)v58;
      v44 = v57;
      if ( v43 > 2147483650.0 || v43 < -2147483650.0 )
        goto LABEL_77;
      v45 = (int)v43;
    }
    else
    {
      v45 = 0;
      v44 = v57;
    }
    XYZ.green_Y = v45;
    if ( v41 )
    {
      v46 = floor((double)v41 * 100000.0 / (double)(int)v20 + 0.5);
      v44 = v57;
      v20 = (int *)v58;
      if ( v46 > 2147483650.0 || v46 < -2147483650.0 )
        goto LABEL_77;
      v47 = (int)v46;
    }
    else
    {
      v47 = 0;
    }
    XYZ.green_Z = v47;
    if ( v44 )
    {
      v48 = floor((double)v44 * 100000.0 / (double)(int)v20 + 0.5);
      v20 = (int *)v58;
      if ( v48 > 2147483650.0 || v48 < -2147483650.0 )
        goto LABEL_77;
      v49 = (int)v48;
    }
    else
    {
      v49 = 0;
    }
    XYZ.blue_X = v49;
    if ( XYZ.blue_Y )
    {
      v51 = floor((double)XYZ.blue_Y * 100000.0 / (double)(int)v20 + 0.5);
      v52 = v56;
      if ( v51 > 2147483650.0 || v51 < -2147483650.0 )
        goto LABEL_77;
      v53 = (int)v51;
    }
    else
    {
      v53 = 0;
      v52 = v56;
    }
    XYZ.blue_Y = v53;
    if ( !v52 )
    {
      v55 = 0;
      goto LABEL_82;
    }
    v54 = floor((double)v52 * 100000.0 / (double)v58 + 0.5);
    if ( v54 <= 2147483650.0 && v54 >= -2147483650.0 )
    {
      v55 = (int)v54;
LABEL_82:
      XYZ.blue_Z = v55;
      goto LABEL_19;
    }
LABEL_77:
    v50 = "invalid end points";
    colorspace->flags |= 0x8000u;
LABEL_78:
    j_png_benign_error(png_ptr, (png_const_charp)v50);
    return 0;
  }
LABEL_19:
  v21 = png_xy_from_XYZ(&xy, &XYZ);
  if ( !v21 )
  {
    v61 = XYZ;
    v21 = png_colorspace_check_xy(&v61, &xy);
  }
  if ( v21 == 1 )
    goto LABEL_77;
  if ( v21 )
  {
    colorspace->flags |= 0x8000u;
    j_png_error(png_ptr, (png_const_charp)"internal error checking chromaticities");
    JUMPOUT(0x1EF590);
  }
  flags = colorspace->flags;
  if ( (flags & 0x8000) != 0 )
    return 0;
  if ( v10 <= 1 && (flags & 2) != 0 )
  {
    if ( png_colorspace_endpoints_match(&xy, &colorspace->end_points_xy, 100) )
    {
      if ( !v10 )
        return 1;
      goto LABEL_28;
    }
    colorspace->flags = flags | 0x8000;
    v50 = "inconsistent chromaticities";
    goto LABEL_78;
  }
LABEL_28:
  v23 = *(_QWORD *)&xy.greenx;
  v24 = *(_QWORD *)&xy.bluex;
  v25 = *(_QWORD *)&xy.whitex;
  *(_QWORD *)&colorspace->end_points_xy.redx = *(_QWORD *)&xy.redx;
  *(_QWORD *)&colorspace->end_points_xy.greenx = v23;
  v26 = XYZ.blue_Z;
  *(_QWORD *)&colorspace->end_points_xy.bluex = v24;
  *(_QWORD *)&colorspace->end_points_xy.whitex = v25;
  v27 = *(_QWORD *)&XYZ.red_X;
  v28 = *(_QWORD *)&XYZ.red_Z;
  colorspace->end_points_XYZ.blue_Z = v26;
  v29 = *(_QWORD *)&XYZ.green_Y;
  v30 = *(_QWORD *)&XYZ.blue_X;
  *(_QWORD *)&colorspace->end_points_XYZ.red_X = v27;
  *(_QWORD *)&colorspace->end_points_XYZ.red_Z = v28;
  *(_QWORD *)&colorspace->end_points_XYZ.green_Y = v29;
  *(_QWORD *)&colorspace->end_points_XYZ.blue_X = v30;
  v31 = png_colorspace_endpoints_match(&xy, &sRGB_xy, 1000) == 0;
  v32 = flags & 0xFFBD | 2;
  result = 2;
  if ( !v31 )
    v32 = flags | 0x42;
  colorspace->flags = v32;
  return result;
}
// 1EF58E: control flows out of bounds to 1EF590
// 1EF0A2: variable 'green_Y' is possibly undefined
// 1EF194: variable 'v5' is possibly undefined
// 1EF306: variable 'green_Z' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];

//----- (001EF5C8) --------------------------------------------------------
int __fastcall png_colorspace_set_sRGB(png_const_structrp png_ptr, png_colorspacerp colorspace, int intent)
{
  png_uint_16 v4; // r5
  int flags; // r6
  const char *reason; // r0
  double v8; // r0

  v4 = intent;
  flags = colorspace->flags;
  if ( (flags & 0x8000) != 0 )
    return 0;
  if ( (unsigned int)intent >= 4 )
  {
    reason = "invalid sRGB rendering intent";
LABEL_19:
    png_icc_profile_error(png_ptr, colorspace, (png_const_charp)"sRGB", intent, (png_const_charp)reason);
    return 0;
  }
  if ( (flags & 4) != 0 && colorspace->rendering_intent != intent )
  {
    reason = "inconsistent rendering intents";
    goto LABEL_19;
  }
  if ( (flags & 0x20) != 0 )
  {
    j_png_benign_error(png_ptr, (png_const_charp)"duplicate sRGB information ignored");
    return 0;
  }
  if ( (flags & 2) != 0 && !png_colorspace_endpoints_match(&sRGB_xy, &colorspace->end_points_xy, 100) )
  {
    j_png_chunk_report(png_ptr, (png_const_charp)"cHRM chunk does not match sRGB", 2);
    flags = colorspace->flags;
  }
  if ( flags << 31 )
  {
    if ( !colorspace->gamma
      || (v8 = floor((double)colorspace->gamma * 100000.0 / 45455.0 + 0.5), v8 > 2147483650.0)
      || v8 < -2147483650.0
      || (unsigned int)((int)v8 - 95000) >= 0x2711 )
    {
      j_png_chunk_report(png_ptr, (png_const_charp)"gamma value does not match sRGB", 2);
      LOWORD(flags) = colorspace->flags;
    }
  }
  colorspace->rendering_intent = v4;
  colorspace->end_points_xy = sRGB_xy;
  *(_QWORD *)&colorspace->end_points_XYZ.red_X = *(_QWORD *)&png_colorspace_set_sRGB_sRGB_XYZ.red_X;
  *(_QWORD *)&colorspace->end_points_XYZ.red_Z = *(_QWORD *)&png_colorspace_set_sRGB_sRGB_XYZ.red_Z;
  colorspace->end_points_XYZ.blue_Z = 95053;
  colorspace->gamma = 45455;
  colorspace->flags = flags | 0xE7;
  *(_QWORD *)&colorspace->end_points_XYZ.green_Y = *(_QWORD *)&png_colorspace_set_sRGB_sRGB_XYZ.green_Y;
  *(_QWORD *)&colorspace->end_points_XYZ.blue_X = *(_QWORD *)&png_colorspace_set_sRGB_sRGB_XYZ.blue_X;
  return 1;
}

//----- (001EF7C4) --------------------------------------------------------
int __fastcall png_icc_profile_error(
        png_const_structrp png_ptr,
        png_colorspacerp colorspace,
        png_const_charp name,
        png_alloc_size_t value,
        png_const_charp reason)
{
  size_t v9; // r0
  size_t v10; // r0
  size_t v11; // r10
  png_alloc_size_t v12; // r0
  bool v13; // cc
  bool v14; // cc
  bool v15; // cc
  bool v16; // cc
  const unsigned __int8 *v17; // r0
  size_t v18; // r0
  size_t v19; // r2
  int v20; // r2
  char v22; // r4
  unsigned __int8 *v23; // r3
  unsigned __int8 start[24]; // [sp+4h] [bp-FCh] BYREF
  unsigned __int8 buffer[196]; // [sp+1Ch] [bp-E4h] BYREF
  int v26; // [sp+E0h] [bp-20h]

  if ( colorspace )
    colorspace->flags |= 0x8000u;
  v9 = j_png_safecat(buffer, 0xC4u, 0, (png_const_charp)"profile '");
  v10 = j_png_safecat(buffer, v9 + 79, v9, name);
  v11 = j_png_safecat(buffer, 0xC4u, v10, (png_const_charp)"': ");
  v12 = HIBYTE(value);
  if ( (HIBYTE(value) & 0xDF) - 65 >= 0x1Au )
  {
    v13 = v12 > 0x20;
    if ( v12 != 32 )
      v13 = HIBYTE(value) - 48 > 9u;
    if ( v13 )
      goto LABEL_20;
  }
  if ( (HIWORD(value) & 0xDF) - 65 >= 0x1Au )
  {
    v14 = BYTE2(value) > 0x20u;
    if ( BYTE2(value) != 32 )
      v14 = (unsigned int)(unsigned __int8)__ROR4__(value, 16) - 48 > 9;
    if ( v14 )
      goto LABEL_20;
  }
  if ( ((value >> 8) & 0xDF) - 65 >= 0x1A )
  {
    v15 = BYTE1(value) > 0x20u;
    if ( BYTE1(value) != 32 )
      v15 = (unsigned int)(unsigned __int8)__ROR4__(value, 8) - 48 > 9;
    if ( v15 )
      goto LABEL_20;
  }
  if ( (value & 0xDF) - 65 < 0x1A )
    goto LABEL_24;
  v16 = (unsigned __int8)value > 0x20u;
  if ( (unsigned __int8)value != 32 )
    v16 = (unsigned int)(unsigned __int8)value - 48 > 9;
  if ( v16 )
  {
LABEL_20:
    v17 = j_png_format_number(start, buffer, 3, value);
    v18 = j_png_safecat(buffer, 0xC4u, v11, v17);
    v19 = j_png_safecat(buffer, 0xC4u, v18, (png_const_charp)"h: ");
  }
  else
  {
LABEL_24:
    buffer[v11] = 39;
    v22 = 63;
    v23 = &buffer[v11];
    if ( v12 - 32 >= 0x5F )
      LOBYTE(v12) = 63;
    v23[1] = v12;
    LOBYTE(v12) = 63;
    if ( (unsigned int)BYTE2(value) - 32 < 0x5F )
      v12 = HIWORD(value);
    v23[2] = v12;
    LOBYTE(v12) = 63;
    if ( (unsigned int)BYTE1(value) - 32 < 0x5F )
      v12 = value >> 8;
    v19 = v11 + 8;
    v23[3] = v12;
    if ( (unsigned int)(unsigned __int8)value - 32 < 0x5F )
      v22 = value;
    v23[4] = v22;
    v23[5] = 39;
    v23[6] = 58;
    v23[7] = 32;
  }
  j_png_safecat(buffer, 0xC4u, v19, reason);
  v20 = 1;
  if ( colorspace )
    v20 = 2;
  j_png_chunk_report(png_ptr, buffer, v20);
  return _stack_chk_guard - v26;
}
// 1EF7C4: using guessed type unsigned __int8 buffer[196];
// 1EF7C4: using guessed type unsigned __int8 start[24];

//----- (001EF974) --------------------------------------------------------
int __fastcall png_colorspace_endpoints_match(const png_xy_0 *xy1, const png_xy_0 *xy2, int delta)
{
  png_fixed_point whitex; // r12
  png_fixed_point v4; // lr
  png_fixed_point whitey; // r12
  png_fixed_point v6; // lr
  png_fixed_point redy; // r12
  png_fixed_point v8; // lr
  png_fixed_point greenx; // r12
  png_fixed_point v10; // lr
  png_fixed_point greeny; // r12
  png_fixed_point v12; // lr
  png_fixed_point bluex; // r12
  png_fixed_point v14; // lr
  png_fixed_point bluey; // r1
  int v16; // r3
  png_fixed_point v17; // lr
  int v18; // r0
  png_fixed_point v19; // r12
  png_fixed_point v20; // r1

  whitex = xy2->whitex;
  v4 = xy1->whitex;
  if ( v4 < whitex - delta )
    return 0;
  if ( v4 > whitex + delta )
    return 0;
  whitey = xy2->whitey;
  v6 = xy1->whitey;
  if ( v6 < whitey - delta )
    return 0;
  if ( v6 > whitey + delta )
    return 0;
  if ( xy1->redx < xy2->redx - delta )
    return 0;
  if ( xy1->redx > xy2->redx + delta )
    return 0;
  redy = xy2->redy;
  v8 = xy1->redy;
  if ( v8 < redy - delta )
    return 0;
  if ( v8 > redy + delta )
    return 0;
  greenx = xy2->greenx;
  v10 = xy1->greenx;
  if ( v10 < greenx - delta )
    return 0;
  if ( v10 > greenx + delta )
    return 0;
  greeny = xy2->greeny;
  v12 = xy1->greeny;
  if ( v12 < greeny - delta )
    return 0;
  if ( v12 > greeny + delta )
    return 0;
  bluex = xy2->bluex;
  v14 = xy1->bluex;
  if ( v14 < bluex - delta || v14 > bluex + delta )
    return 0;
  bluey = xy2->bluey;
  v16 = 0;
  v17 = xy1->bluey;
  v18 = 0;
  v19 = bluey - delta;
  v20 = bluey + delta;
  if ( v17 >= v19 )
    v18 = 1;
  if ( v17 <= v20 )
    v16 = 1;
  return v18 & v16;
}

//----- (001EFA44) --------------------------------------------------------
int __fastcall png_icc_check_length(
        png_const_structrp png_ptr,
        png_colorspacerp colorspace,
        png_const_charp name,
        png_uint_32 profile_length)
{
  const char *reason; // r12
  png_uint_32 user_chunk_malloc_max; // lr
  int v6; // r12

  if ( profile_length <= 0x83 )
  {
    reason = "too short";
LABEL_6:
    png_icc_profile_error(png_ptr, colorspace, name, profile_length, (png_const_charp)reason);
    return 0;
  }
  user_chunk_malloc_max = png_ptr->user_chunk_malloc_max;
  v6 = 1;
  if ( user_chunk_malloc_max && user_chunk_malloc_max < profile_length )
  {
    reason = "exceeds application limits";
    goto LABEL_6;
  }
  return v6;
}

//----- (001EFAA0) --------------------------------------------------------
int __fastcall png_icc_check_header(
        png_const_structrp png_ptr,
        png_colorspacerp colorspace,
        png_const_charp name,
        png_uint_32 profile_length,
        png_const_bytep profile,
        int color_type)
{
  png_alloc_size_t v9; // r4
  const char *reason; // r0
  const char *v11; // r0
  int result; // r0
  signed int v13; // r3
  const char *v14; // r0
  bool v15; // zf

  v9 = bswap32(*(_DWORD *)profile);
  if ( v9 != profile_length )
  {
    v11 = "length does not match profile";
LABEL_10:
    png_icc_profile_error(png_ptr, colorspace, name, v9, (png_const_charp)v11);
    return 0;
  }
  if ( profile_length << 30 && profile[8] >= 4u )
  {
    reason = "invalid length";
LABEL_5:
    png_icc_profile_error(png_ptr, colorspace, name, profile_length, (png_const_charp)reason);
    return 0;
  }
  v9 = bswap32(*((_DWORD *)profile + 32));
  if ( v9 > 0x1555554A || 12 * v9 + 132 > profile_length )
  {
    v11 = "tag count too large";
    goto LABEL_10;
  }
  profile_length = bswap32(*((_DWORD *)profile + 16));
  if ( profile_length >= 0xFFFF )
  {
    reason = "invalid rendering intent";
    goto LABEL_5;
  }
  if ( profile_length >= 4 )
    png_icc_profile_error(png_ptr, 0, name, profile_length, (png_const_charp)"intent outside defined range");
  profile_length = bswap32(*((_DWORD *)profile + 9));
  if ( profile_length != 1633907568 )
  {
    reason = "invalid signature";
    goto LABEL_5;
  }
  if ( memcmp(profile + 68, D50_nCIEXYZ, 0xCu) )
    png_icc_profile_error(png_ptr, 0, name, 0, (png_const_charp)"PCS illuminant is not D50");
  profile_length = bswap32(*((_DWORD *)profile + 4));
  if ( profile_length == 1196573017 )
  {
    if ( (color_type & 2) != 0 )
    {
      profile_length = 1196573017;
      reason = "Gray color space not permitted on RGB PNG";
      goto LABEL_5;
    }
  }
  else
  {
    if ( profile_length != 1380401696 )
    {
      reason = "invalid ICC profile color space";
      goto LABEL_5;
    }
    if ( (color_type & 2) == 0 )
    {
      profile_length = 1380401696;
      reason = "RGB color space not permitted on grayscale PNG";
      goto LABEL_5;
    }
  }
  v13 = bswap32(*((_DWORD *)profile + 3));
  if ( v13 > 1852662635 )
  {
    if ( v13 > 1935896177 )
    {
      if ( v13 == 1935896178 || v13 == 1936744803 )
        goto LABEL_42;
    }
    else
    {
      if ( v13 == 1852662636 )
      {
        v13 = 1852662636;
        v14 = "unexpected NamedColor ICC profile class";
        goto LABEL_41;
      }
      if ( v13 == 1886549106 )
        goto LABEL_42;
    }
LABEL_39:
    v14 = "unrecognized ICC profile class";
LABEL_41:
    png_icc_profile_error(png_ptr, 0, name, v13, (png_const_charp)v14);
    goto LABEL_42;
  }
  if ( v13 == 1633842036 )
  {
    profile_length = 1633842036;
    reason = "invalid embedded Abstract ICC profile";
    goto LABEL_5;
  }
  if ( v13 == 1818848875 )
  {
    profile_length = 1818848875;
    reason = "unexpected DeviceLink ICC profile class";
    goto LABEL_5;
  }
  if ( v13 != 1835955314 )
    goto LABEL_39;
LABEL_42:
  profile_length = bswap32(*((_DWORD *)profile + 5));
  result = 1;
  v15 = profile_length == 1281450528;
  if ( profile_length != 1281450528 )
    v15 = profile_length == 1482250784;
  if ( !v15 )
  {
    reason = "unexpected ICC PCS encoding";
    goto LABEL_5;
  }
  return result;
}

//----- (001EFD50) --------------------------------------------------------
int __fastcall png_icc_check_tag_table(
        png_const_structrp png_ptr,
        png_colorspacerp colorspace,
        png_const_charp name,
        png_uint_32 profile_length,
        png_const_bytep profile)
{
  unsigned int v8; // r11
  png_const_bytep v9; // r6
  unsigned int v10; // r4
  png_uint_32 v11; // r1
  png_alloc_size_t v12; // r3
  bool v13; // cc

  v8 = bswap32(*((_DWORD *)profile + 32));
  if ( !v8 )
    return 1;
  v9 = profile + 132;
  v10 = 0;
  while ( 1 )
  {
    v11 = _byteswap_ulong(*((_DWORD *)v9 + 1));
    v12 = bswap32(*(_DWORD *)v9);
    v13 = v11 > profile_length;
    if ( v11 <= profile_length )
      v13 = bswap32(*((_DWORD *)v9 + 2)) > profile_length - v11;
    if ( v13 )
      break;
    if ( v9[7] << 30 )
      png_icc_profile_error(png_ptr, 0, name, v12, (png_const_charp)"ICC profile tag start not a multiple of 4");
    ++v10;
    v9 += 12;
    if ( v10 >= v8 )
      return 1;
  }
  png_icc_profile_error(png_ptr, colorspace, name, v12, (png_const_charp)"ICC profile tag outside profile");
  return 0;
}

//----- (001EFE24) --------------------------------------------------------
void __fastcall png_icc_set_sRGB(
        png_const_structrp png_ptr,
        png_colorspacerp colorspace,
        png_const_bytep profile,
        uLong adler)
{
  unsigned int v7; // r12
  int v8; // r4
  unsigned int v9; // r0
  uInt v10; // r10
  const $BB579FDA78F46B419E952942DC2A0C00 *i; // r5
  png_uint_32 length; // r1
  bool v13; // zf
  uLong v14; // r0
  uLong v15; // r0
  const char *v16; // r1
  const png_struct *v17; // r0
  int v18; // r2

  if ( (png_ptr->options & 0x30) != 48 )
  {
    v7 = 0x10000;
    v8 = 0;
    v9 = bswap32(*((_DWORD *)profile + 21));
    v10 = 0;
    for ( i = png_sRGB_checks; ; ++i )
    {
      if ( v9 == i->md5[0]
        && bswap32(*((_DWORD *)profile + 22)) == i->md5[1]
        && bswap32(*((_DWORD *)profile + 23)) == i->md5[2]
        && bswap32(*((_DWORD *)profile + 24)) == i->md5[3] )
      {
        if ( !v10 )
        {
          v10 = bswap32(*(_DWORD *)profile);
          v7 = bswap32(*((_DWORD *)profile + 16));
        }
        length = i->length;
        v13 = v10 == length;
        if ( v10 == length )
          v13 = v7 == i->intent;
        if ( v13 )
          break;
      }
      if ( (unsigned int)++v8 >= 7 )
        return;
    }
    if ( !adler )
    {
      v14 = j_adler32(0, 0, 0);
      adler = j_adler32(v14, profile, v10);
    }
    if ( adler != i->adler || (v15 = j_crc32(0, 0, 0), j_crc32(v15, profile, v10) != i->crc) )
    {
      sub_18A980(png_ptr, (png_const_charp)"Not recognizing known sRGB profile that has been edited", 0);
      return;
    }
    if ( (unsigned int)(v8 - 5) > 1 )
    {
      if ( (unsigned int)(v8 - 4) > 2 )
      {
LABEL_24:
        png_colorspace_set_sRGB(png_ptr, colorspace, bswap32(*((_DWORD *)profile + 16)));
        return;
      }
      v16 = "out-of-date sRGB profile with no signature";
      v17 = png_ptr;
      v18 = 0;
    }
    else
    {
      v16 = "known incorrect sRGB profile";
      v17 = png_ptr;
      v18 = 2;
    }
    j_png_chunk_report(v17, (png_const_charp)v16, v18);
    goto LABEL_24;
  }
}

//----- (001EFFA0) --------------------------------------------------------
int __fastcall png_colorspace_set_ICC(
        png_const_structrp png_ptr,
        png_colorspacerp colorspace,
        png_const_charp name,
        png_uint_32 profile_length,
        png_const_bytep profile,
        int color_type)
{
  if ( (colorspace->flags & 0x8000u) == 0 )
  {
    if ( profile_length > 0x83 )
    {
      if ( j_png_icc_check_header(png_ptr, colorspace, name, profile_length, profile, color_type)
        && j_png_icc_check_tag_table(png_ptr, colorspace, name, profile_length, profile) )
      {
        j_png_icc_set_sRGB(png_ptr, colorspace, profile, 0);
        return 1;
      }
    }
    else
    {
      png_icc_profile_error(png_ptr, colorspace, name, profile_length, (png_const_charp)"too short");
    }
  }
  return 0;
}

//----- (001F0018) --------------------------------------------------------
void __fastcall png_colorspace_set_rgb_coefficients(png_structrp png_ptr)
{
  png_fixed_point blue_Y; // r5
  png_fixed_point green_Y; // r6
  int v3; // r8
  png_fixed_point red_Y; // r0
  bool v6; // cc
  double v7; // r0
  int v8; // r9
  double v9; // r0
  int v10; // r6
  double v11; // r0
  double v12; // d16
  int v13; // r0
  int v14; // r2
  int v15; // r1
  bool v16; // cc
  bool v17; // cc

  if ( png_ptr->rgb_to_gray_coefficients_set || (png_ptr->colorspace.flags & 2) == 0 )
    return;
  red_Y = png_ptr->colorspace.end_points_XYZ.red_Y;
  v6 = red_Y < 0;
  if ( red_Y >= 0 )
  {
    green_Y = png_ptr->colorspace.end_points_XYZ.green_Y;
    blue_Y = png_ptr->colorspace.end_points_XYZ.blue_Y;
    v3 = green_Y + red_Y + blue_Y;
    v6 = v3 < 1;
  }
  if ( v6 )
    goto LABEL_42;
  if ( red_Y )
  {
    v7 = floor((double)red_Y * 32768.0 / (double)v3 + 0.5);
    if ( v7 > 2147483650.0 )
      goto LABEL_42;
    if ( v7 < -2147483650.0 )
      goto LABEL_42;
    v8 = (int)v7;
    if ( green_Y < 0 )
      goto LABEL_42;
  }
  else
  {
    v8 = 0;
    if ( green_Y < 0 )
      goto LABEL_42;
  }
  if ( (unsigned int)v8 > 0x8000 )
    goto LABEL_42;
  if ( green_Y )
  {
    v9 = floor((double)green_Y * 32768.0 / (double)v3 + 0.5);
    if ( v9 > 2147483650.0 )
      goto LABEL_42;
    if ( v9 < -2147483650.0 )
      goto LABEL_42;
    v10 = (int)v9;
    if ( blue_Y < 0 )
      goto LABEL_42;
  }
  else
  {
    v10 = 0;
    if ( blue_Y < 0 )
      goto LABEL_42;
  }
  if ( (unsigned int)v10 > 0x8000 )
    goto LABEL_42;
  if ( blue_Y )
  {
    v11 = floor((double)blue_Y * 32768.0 / (double)v3 + 0.5);
    v12 = v11;
    if ( v11 > 2147483650.0 )
      goto LABEL_42;
    if ( v11 < -2147483650.0 )
      goto LABEL_42;
    v13 = (int)v11;
    if ( (unsigned int)(int)v12 > 0x8000 )
      goto LABEL_42;
  }
  else
  {
    v13 = 0;
  }
  v14 = v10 + v8 + v13;
  if ( v14 > 32769 )
  {
LABEL_42:
    j_png_error(png_ptr, (png_const_charp)"internal error handling cHRM->XYZ");
    goto LABEL_43;
  }
  v15 = v14 < 0x8000;
  if ( v14 == 32769 )
    v15 = -1;
  if ( v15 )
  {
    v16 = v10 < v8;
    if ( v10 >= v8 )
      v16 = v10 < v13;
    if ( v16 )
    {
      v17 = v8 < v10;
      if ( v8 >= v10 )
        v17 = v8 < v13;
      if ( v17 )
        v13 += v15;
      else
        v8 += v15;
    }
    else
    {
      v10 += v15;
    }
  }
  if ( v13 + v10 + v8 != 0x8000 )
  {
LABEL_43:
    j_png_error(png_ptr, (png_const_charp)"internal error handling cHRM coefficients");
    JUMPOUT(0x1F0200);
  }
  png_ptr->rgb_to_gray_green_coeff = v10;
  png_ptr->rgb_to_gray_red_coeff = v8;
}
// 1F01FE: control flows out of bounds to 1F0200
// 1F0070: variable 'v3' is possibly undefined
// 1F00B6: variable 'green_Y' is possibly undefined
// 1F011C: variable 'blue_Y' is possibly undefined

//----- (001F0268) --------------------------------------------------------
int __fastcall png_muldiv(png_fixed_point_p res, png_fixed_point a, png_int_32 times, png_int_32 divisor)
{
  bool v5; // zf
  int result; // r0
  double v7; // d16

  if ( !divisor )
    return 0;
  v5 = a == 0;
  if ( a )
    v5 = times == 0;
  if ( v5 )
  {
    *res = 0;
    return 1;
  }
  v7 = floor((double)a * (double)times / (double)divisor + 0.5);
  result = 0;
  if ( v7 <= 2147483650.0 && v7 >= -2147483650.0 )
  {
    *res = (int)v7;
    return 1;
  }
  return result;
}

//----- (001F02F8) --------------------------------------------------------
void __fastcall png_check_IHDR(
        png_const_structrp png_ptr,
        png_uint_32 width,
        png_uint_32 height,
        int bit_depth,
        int color_type,
        int interlace_type,
        int compression_type,
        int filter_type)
{
  int v12; // r6
  const char *v13; // r1
  const char *v14; // r1
  int v16; // r9
  png_uint_32 mode; // r0
  bool v18; // zf

  if ( !width )
  {
    v13 = "Image width is zero in IHDR";
LABEL_8:
    j_png_warning(png_ptr, (png_const_charp)v13);
    v12 = 1;
    goto LABEL_9;
  }
  if ( (int)width <= -1 )
  {
    j_png_warning(png_ptr, (png_const_charp)"Invalid image width in IHDR");
    v12 = 1;
  }
  else
  {
    v12 = 0;
  }
  if ( ((width + 7) & 0xFFFFFFF8) >= 0x1FFFFFF9 )
  {
    v13 = "Image width is too large for this architecture";
    goto LABEL_8;
  }
LABEL_9:
  if ( png_ptr->user_width_max < width )
  {
    j_png_warning(png_ptr, (png_const_charp)"Image width exceeds user limit in IHDR");
    v12 = 1;
  }
  if ( height )
  {
    if ( (int)height > -1 )
      goto LABEL_16;
    v14 = "Invalid image height in IHDR";
  }
  else
  {
    v14 = "Image height is zero in IHDR";
  }
  j_png_warning(png_ptr, (png_const_charp)v14);
  v12 = 1;
LABEL_16:
  if ( png_ptr->user_height_max < height )
  {
    j_png_warning(png_ptr, (png_const_charp)"Image height exceeds user limit in IHDR");
    v12 = 1;
  }
  if ( (unsigned int)bit_depth > 0x10 || ((1 << bit_depth) & ((unsigned int)&elf_hash_bucket[16390] + 2)) == 0 )
    goto LABEL_45;
  while ( 1 )
  {
    v16 = color_type | 4;
    if ( (unsigned int)color_type > 6 || v16 == 5 )
    {
      j_png_warning(png_ptr, (png_const_charp)"Invalid color type in IHDR");
      v12 = 1;
    }
    if ( bit_depth >= 9 && color_type == 3 || bit_depth <= 7 && (color_type == 4 || v16 == 6) )
    {
      j_png_warning(png_ptr, (png_const_charp)"Invalid color type/bit depth combination in IHDR");
      v12 = 1;
    }
    if ( interlace_type >= 2 )
    {
      j_png_warning(png_ptr, (png_const_charp)"Unknown interlace method in IHDR");
      v12 = 1;
    }
    if ( compression_type )
    {
      j_png_warning(png_ptr, (png_const_charp)"Unknown compression method in IHDR");
      v12 = 1;
    }
    color_type = filter_type;
    if ( (png_ptr->mode & 0x1000) != 0 && png_ptr->mng_features_permitted )
      j_png_warning(png_ptr, (png_const_charp)"MNG features are not allowed in a PNG datastream");
    if ( filter_type )
    {
      if ( filter_type != 64 )
        goto LABEL_41;
      mode = png_ptr->mng_features_permitted & 4;
      if ( !mode )
        goto LABEL_41;
      v18 = v16 == 6;
      if ( v16 == 6 )
      {
        mode = png_ptr->mode;
        v18 = (mode & 0x1000) == 0;
      }
      if ( !v18 )
      {
LABEL_41:
        j_png_warning(png_ptr, (png_const_charp)"Unknown filter method in IHDR");
        mode = png_ptr->mode;
        v12 = 1;
      }
      if ( (mode & 0x1000) != 0 )
      {
        j_png_warning(png_ptr, (png_const_charp)"Invalid filter method in IHDR");
        goto LABEL_44;
      }
    }
    if ( v12 != 1 )
      break;
LABEL_44:
    j_png_error(png_ptr, (png_const_charp)"Invalid IHDR data");
LABEL_45:
    j_png_warning(png_ptr, (png_const_charp)"Invalid bit depth in IHDR");
    v12 = 1;
  }
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (001F0548) --------------------------------------------------------
int __fastcall png_check_fp_number(png_const_charp string, png_size_t size, int *statep, png_size_tp whereami)
{
  png_size_t v4; // r12
  unsigned int v5; // lr
  int v6; // r4

  v4 = *whereami;
  v5 = *statep;
  if ( *whereami < size )
  {
    while ( 1 )
    {
      v6 = 4;
      switch ( string[v4] )
      {
        case '+':
          break;
        case '-':
          v6 = 132;
          break;
        case '.':
          v6 = 16;
          break;
        case '0':
          v6 = 8;
          break;
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          v6 = 264;
          break;
        case 'E':
        case 'e':
          v6 = 32;
          break;
        default:
          goto LABEL_30;
      }
      switch ( v5 & 3 | v6 & 0x3F )
      {
        case 4u:
          if ( (v5 & 0x3C) == 0 )
            goto LABEL_25;
          goto LABEL_30;
        case 6u:
          if ( (v5 & 0x3C) == 0 )
          {
            v5 |= 4u;
            if ( ++v4 < size )
              continue;
          }
          goto LABEL_30;
        case 8u:
          if ( (v5 & 0x10) != 0 )
            v5 = v5 & 0x180 | 0x11;
          goto LABEL_3;
        case 9u:
LABEL_3:
          ++v4;
          v5 |= v6 | 0x40;
          if ( v4 < size )
            continue;
          goto LABEL_30;
        case 10u:
          v5 |= 0x48u;
          if ( ++v4 < size )
            continue;
          goto LABEL_30;
        case 16u:
          if ( (v5 & 0x10) != 0 )
            goto LABEL_30;
          if ( (v5 & 8) != 0 )
          {
LABEL_25:
            v5 |= v6;
            if ( ++v4 >= size )
              goto LABEL_30;
          }
          else
          {
            ++v4;
            v5 = v5 & 0x1C0 | v6 | 1;
            if ( v4 >= size )
              goto LABEL_30;
          }
          break;
        case 32u:
        case 33u:
          if ( (v5 & 8) != 0 )
          {
            ++v4;
            v5 = v5 & 0x1C0 | 2;
            if ( v4 < size )
              continue;
          }
          goto LABEL_30;
        default:
          goto LABEL_30;
      }
    }
  }
LABEL_30:
  *statep = v5;
  *whereami = v4;
  return (v5 >> 3) & 1;
}

//----- (001F06E0) --------------------------------------------------------
int __fastcall png_check_fp_string(png_const_charp string, png_size_t size)
{
  int v2; // r4
  bool v5; // zf
  png_size_t v7; // [sp+0h] [bp-18h] BYREF
  int statep[5]; // [sp+4h] [bp-14h] BYREF

  v2 = 0;
  v7 = 0;
  statep[0] = 0;
  if ( j_png_check_fp_number(string, size, statep, &v7) )
  {
    v5 = v7 == size;
    if ( v7 != size )
      v5 = string[v7] == 0;
    if ( v5 )
      return statep[0];
    else
      return 0;
  }
  return v2;
}
// 1F06E0: using guessed type int statep[5];

//----- (001F0720) --------------------------------------------------------
void __fastcall png_ascii_from_fp(
        png_const_structrp png_ptr,
        png_charp ascii,
        png_size_t size,
        int a4,
        double fp,
        unsigned int precision)
{
  png_charp v6; // r5
  unsigned int v7; // r11
  double v8; // d9
  png_size_t v9; // r4
  int v10; // r0
  int v11; // r1
  int v12; // r2
  png_size_t v13; // r6
  double v14; // d16
  double v15; // d18
  double v16; // d17
  double v17; // d16
  _BYTE *v18; // r0
  int v19; // r4
  int v20; // r2
  int v21; // r3
  double v22; // d19
  double v23; // d21
  double v24; // d19
  double v25; // d20
  double v26; // d16
  int v27; // r4
  int v28; // r9
  int v29; // r10
  int v30; // r0
  int v31; // t1
  int v32; // r1
  double v33; // d16
  double v34; // d17
  int v35; // r1
  int v36; // r0
  unsigned int v37; // r2
  unsigned int v38; // t1
  int v39; // r2
  int v40; // r1
  int v41; // r0
  bool v42; // cc
  int8x16_t *v43; // r4
  png_size_t v44; // r0
  unsigned int v45; // r3
  unsigned int v46; // r12
  unsigned int v47; // r1
  unsigned int v48; // r2
  int8x16_t *v49; // r2
  unsigned int v50; // r3
  unsigned int v51; // r12
  int8x16_t *v52; // r5
  unsigned int v53; // r6
  int8x16_t *v54; // r0
  int8x16_t v55; // q8
  int8x16_t v56; // q8
  char *v57; // r6
  const png_struct *v58; // [sp+0h] [bp-68h]
  unsigned int v59; // [sp+4h] [bp-64h]
  double iptr; // [sp+8h] [bp-60h] BYREF
  int e; // [sp+14h] [bp-54h] BYREF
  char v62[8]; // [sp+1Ah] [bp-4Eh] BYREF

  v6 = ascii;
  v7 = precision;
  if ( !precision )
    v7 = 15;
  if ( v7 >= 0x10 )
    v7 = 16;
  if ( v7 + 5 > size )
  {
LABEL_119:
    j_png_error(png_ptr, (png_const_charp)"ASCII conversion buffer too small");
    JUMPOUT(0x1F0C18);
  }
  v8 = fp;
  if ( fp < 0.0 )
  {
    v8 = -fp;
    *ascii = 45;
    v6 = ascii + 1;
    --size;
  }
  if ( v8 < 2.22507386e-308 || v8 > 1.79769313e308 )
  {
    if ( v8 < 2.22507386e-308 )
    {
      v18 = v6 + 1;
      *v6 = 48;
    }
    else
    {
      v6[2] = 102;
      *(_WORD *)v6 = 28265;
      v18 = v6 + 3;
    }
    *v18 = 0;
    return;
  }
  v58 = png_ptr;
  v9 = size;
  frexp(v8, &e);
  e = (77 * e) >> 8;
  v10 = e;
  if ( e <= -1 )
  {
    v17 = 0.0;
    v13 = v9;
    if ( e < -307 )
      goto LABEL_29;
    v12 = -e;
    v11 = 1;
    if ( -e >= 1 )
      goto LABEL_12;
  }
  else
  {
    v11 = 0;
    v12 = e;
    v13 = v9;
    if ( e >= 1 )
    {
LABEL_12:
      v14 = 10.0;
      v15 = 1.0;
      do
      {
        v16 = v15 * v14;
        if ( (v12 & 1) == 0 )
          v16 = v15;
        v12 >>= 1;
        v14 = v14 * v14;
        v15 = v16;
      }
      while ( v12 > 0 );
      v17 = 1.0 / v16;
      if ( !v11 )
        v17 = v16;
      goto LABEL_26;
    }
  }
  v17 = 1.0;
LABEL_26:
  if ( v17 < 2.22507386e-308 )
  {
LABEL_29:
    while ( 1 )
    {
      v19 = v10 + 1;
      if ( v10 >= -1 )
        break;
      if ( v10 <= -309 )
      {
        v17 = 0.0;
        e = ++v10;
      }
      else
      {
        v20 = ~v10;
        v21 = 1;
LABEL_33:
        v22 = 1.0;
        if ( v20 >= 1 )
        {
          v23 = 1.0;
          v24 = 10.0;
          do
          {
            v25 = v23 * v24;
            if ( (v20 & 1) == 0 )
              v25 = v23;
            v20 >>= 1;
            v24 = v24 * v24;
            v23 = v25;
          }
          while ( v20 > 0 );
          v22 = 1.0 / v25;
          if ( !v21 )
            v22 = v25;
          if ( v22 > 1.79769313e308 )
            goto LABEL_43;
        }
        ++v10;
        e = v19;
        v17 = v22;
        if ( v22 >= 2.22507386e-308 )
        {
          v10 = v19;
          v17 = v22;
          if ( v22 >= v8 )
            goto LABEL_43;
        }
      }
    }
    v21 = 0;
    v20 = v10 + 1;
    goto LABEL_33;
  }
LABEL_43:
  v26 = v8 / v17;
  if ( v26 >= 1.0 )
  {
    do
    {
      v26 = v26 / 10.0;
      ++v10;
    }
    while ( v26 >= 1.0 );
    e = v10;
  }
  v27 = 0;
  if ( (unsigned int)v10 >= 0xFFFFFFFE )
  {
    e = 0;
    v27 = -v10;
  }
  v28 = 0;
  v59 = v7;
  v29 = v27;
  do
  {
    v33 = v26 * 10.0;
    if ( v27 + 1 + v28 < v29 + v7 )
    {
      v26 = modf(v33, &iptr);
      v34 = iptr;
      goto LABEL_77;
    }
    v34 = floor(v33 + 0.5);
    v26 = 0.0;
    iptr = v34;
    if ( v34 > 9.0 )
    {
      if ( v27 )
      {
        v26 = 0.0;
        --v27;
        iptr = 1.0;
        if ( !v28 )
          --v29;
LABEL_81:
        v30 = e;
        v39 = e != -1;
        v7 = v59;
        v32 = 0;
        if ( v27 )
        {
          v40 = v27;
          do
          {
            if ( v39 << 31 )
            {
              if ( !v30 )
              {
                --v13;
                *v6++ = 46;
                v30 = e;
              }
              e = v30 - 1;
            }
            *v6++ = 48;
            v30 = e;
            v39 = e != -1;
            --v40;
          }
          while ( v40 );
          v32 = v27;
        }
        if ( v39 != 1 )
          goto LABEL_93;
        goto LABEL_90;
      }
      if ( !v28 )
      {
        v28 = 0;
        goto LABEL_52;
      }
      v35 = e;
      v36 = v28;
      while ( 1 )
      {
        ++v35;
        v37 = *(v6 - 1);
        if ( v35 )
        {
          e = v35;
        }
        else
        {
          if ( v37 == 46 )
          {
            v38 = *(v6 - 2);
            v6 -= 2;
            v37 = v38;
            ++v13;
            v35 = 1;
            e = 1;
            goto LABEL_74;
          }
          v35 = -1;
        }
        --v6;
LABEL_74:
        v28 = v36 - 1;
        v34 = (double)(int)(v37 - 47);
        iptr = v34;
        if ( v37 >= 0x39 )
        {
          if ( --v36 )
            continue;
        }
        if ( v37 < 0x39 )
          break;
LABEL_52:
        v30 = e + 1;
        if ( e != -1 )
        {
          ++e;
          v7 = v59;
          goto LABEL_57;
        }
        v31 = *--v6;
        v7 = v59;
        if ( v31 == 46 )
        {
          v32 = 0;
          v26 = 0.0;
          v30 = 1;
          e = 1;
          ++v13;
          iptr = 1.0;
          goto LABEL_92;
        }
        v30 = e;
LABEL_57:
        v26 = 0.0;
        v32 = 0;
        iptr = 1.0;
        if ( v30 == -1 )
        {
LABEL_93:
          v27 = 0;
          v28 = v28 + 1 - v29 + v32;
          v29 = 0;
          *v6++ = (int)iptr + 48;
          goto LABEL_94;
        }
LABEL_90:
        if ( !v30 )
        {
          --v13;
          *v6++ = 46;
          v30 = e;
        }
LABEL_92:
        e = v30 - 1;
        goto LABEL_93;
      }
    }
LABEL_77:
    if ( v34 != 0.0 )
      goto LABEL_81;
    ++v27;
    if ( !v28 )
      ++v29;
    v7 = v59;
LABEL_94:
    ;
  }
  while ( v26 > 2.22507386e-308 && v28 + v27 < v29 + v7 );
  v41 = e;
  if ( (unsigned int)(e + 1) <= 3 )
  {
    --e;
    if ( v41 >= 1 )
    {
      do
      {
        *v6++ = 48;
        v42 = e-- <= 0;
      }
      while ( !v42 );
    }
    goto LABEL_117;
  }
  *v6 = 69;
  v43 = (int8x16_t *)(v6 + 1);
  v44 = v13 - v28;
  v45 = e;
  if ( e <= -1 )
  {
    v46 = v44 - 2;
    v6[1] = 45;
    v43 = (int8x16_t *)(v6 + 2);
    v45 = -e;
  }
  else
  {
    v46 = v44 - 1;
  }
  v47 = 0;
  if ( v45 )
  {
    do
    {
      v42 = v45 > 9;
      v48 = v45 % 0xA;
      v45 /= 0xAu;
      v62[v47++] = v48 | 0x30;
    }
    while ( v42 );
  }
  if ( v46 <= v47 )
  {
    png_ptr = v58;
    goto LABEL_119;
  }
  if ( v47 )
  {
    v49 = v43;
    v50 = v47;
    if ( v47 <= 0xF )
      goto LABEL_123;
    v51 = v47 & 0xFFFFFFF0;
    v49 = v43;
    v50 = v47;
    if ( (v47 & 0xFFFFFFF0) == 0 )
      goto LABEL_123;
    if ( v43 < (int8x16_t *)&v62[v47] )
    {
      v49 = v43;
      v50 = v47;
      if ( v62 < (char *)v43 + v47 )
        goto LABEL_123;
    }
    v52 = (int8x16_t *)((char *)&iptr + v47 + 2);
    v50 = v47 - v51;
    v49 = (int8x16_t *)((char *)v43 + v51);
    v53 = v47 & 0xFFFFFFF0;
    v54 = v43;
    do
    {
      v55 = *v52;
      v53 -= 16;
      --v52;
      v56 = vrev64q_s8(v55);
      *v54++ = vextq_s8(v56, v56, 8u);
    }
    while ( v53 );
    if ( v47 != v51 )
    {
LABEL_123:
      do
      {
        v57 = &v62[v50--];
        v49->n128_u8[0] = *(v57 - 1);
        v49 = (int8x16_t *)((char *)v49 + 1);
      }
      while ( v50 );
    }
    v6 = (png_charp)v43 + v47;
  }
  else
  {
    v6 = (png_charp)v43;
  }
LABEL_117:
  *v6 = 0;
}
// 1F0C14: control flows out of bounds to 1F0C18

//----- (001F0C24) --------------------------------------------------------
void __fastcall png_ascii_from_fixed(png_const_structrp png_ptr, png_charp ascii, png_size_t size, png_fixed_point fp)
{
  png_charp v4; // r9
  unsigned int v5; // r5
  unsigned int v6; // r0
  unsigned int v7; // r1
  bool v8; // cc
  unsigned int v9; // r6
  png_charp v10; // r1
  unsigned int v11; // r12
  int8x16_t *v12; // r3
  unsigned int v13; // r2
  int8x16_t *v14; // r4
  int8x16_t v15; // q8
  int8x16_t v16; // q8
  char *v17; // r2
  char *v18; // r0
  char v19[5]; // [sp+2h] [bp-26h] BYREF
  char v20; // [sp+7h] [bp-21h] BYREF

  v4 = ascii;
  if ( size < 0xD || fp <= -1 && (fp = -fp, *ascii = 45, v4 = ascii + 1, (unsigned int)fp > 0x80000000) )
  {
    j_png_error(png_ptr, (png_const_charp)"ASCII conversion buffer too small");
    JUMPOUT(0x1F0D88);
  }
  if ( !fp )
    goto LABEL_12;
  v5 = 16;
  v6 = -5;
  do
  {
    v19[v6 + 5] = fp % 0xAu + 48;
    v7 = v5;
    if ( fp != 10 * (fp / 0xAu) )
      v7 = v6 + 6;
    ++v6;
    if ( v5 == 16 )
      v5 = v7;
    v8 = (unsigned int)fp > 9;
    fp /= 0xAu;
  }
  while ( v8 );
  v9 = v6 + 5;
  if ( v6 == -5 )
  {
LABEL_12:
    *v4++ = 48;
    goto LABEL_13;
  }
  if ( v9 >= 6 )
  {
    if ( v6 >= 0x10 )
    {
      v11 = v6 & 0xFFFFFFF0;
      if ( (v6 & 0xFFFFFFF0) != 0 )
      {
        if ( v4 >= (png_charp)&v19[v6 + 5] || (v10 = v4, &v20 >= (char *)&v4[v6]) )
        {
          v12 = (int8x16_t *)&v19[v6 - 11];
          v9 = v6 - v11 + 5;
          v10 = &v4[v11];
          v13 = v6 & 0xFFFFFFF0;
          v14 = (int8x16_t *)v4;
          do
          {
            v15 = *v12;
            v13 -= 16;
            --v12;
            v16 = vrev64q_s8(v15);
            *v14++ = vextq_s8(v16, v16, 8u);
          }
          while ( v13 );
          if ( v6 == v11 )
            goto LABEL_26;
        }
      }
      else
      {
        v10 = v4;
      }
    }
    else
    {
      v10 = v4;
    }
    do
    {
      v17 = &v19[v9--];
      *v10++ = *(v17 - 1);
    }
    while ( v9 > 5 );
LABEL_26:
    v4 += v6;
    v9 = 5;
  }
  if ( v5 <= 5 )
  {
    *v4 = 46;
    if ( v9 > 4 )
    {
      ++v4;
      if ( v9 < v5 )
        goto LABEL_13;
    }
    else
    {
      memset(v4 + 1, 48, 5 - v9);
      v4 += 6 - v9;
      if ( v9 < v5 )
        goto LABEL_13;
    }
    do
    {
      v18 = &v19[v9--];
      *v4++ = *(v18 - 1);
    }
    while ( v9 >= v5 );
  }
LABEL_13:
  *v4 = 0;
}
// 1F0D86: control flows out of bounds to 1F0D88

//----- (001F0D98) --------------------------------------------------------
png_fixed_point __fastcall png_fixed(png_const_structrp png_ptr, double fp, png_const_charp text)
{
  double v5; // r0

  v5 = floor(fp * 100000.0 + 0.5);
  if ( v5 > 2147483650.0 || v5 < -2147483650.0 )
    j_png_fixed_error(png_ptr, text);
  return (int)v5;
}

//----- (001F0E08) --------------------------------------------------------
png_fixed_point __fastcall png_muldiv_warn(
        png_const_structrp png_ptr,
        png_fixed_point a,
        png_int_32 times,
        png_int_32 divisor)
{
  bool v5; // zf
  png_fixed_point result; // r0
  double v7; // r0

  if ( !divisor )
  {
LABEL_8:
    j_png_warning(png_ptr, (png_const_charp)"fixed point overflow ignored");
    return 0;
  }
  v5 = a == 0;
  result = 0;
  if ( a )
    v5 = times == 0;
  if ( !v5 )
  {
    v7 = floor((double)a * (double)times / (double)divisor + 0.5);
    if ( v7 <= 2147483650.0 && v7 >= -2147483650.0 )
      return (int)v7;
    goto LABEL_8;
  }
  return result;
}

//----- (001F0EB8) --------------------------------------------------------
png_fixed_point __fastcall png_reciprocal(png_fixed_point a)
{
  double v1; // d16
  png_fixed_point result; // r0

  v1 = floor(1.0e10 / (double)a + 0.5);
  result = (int)v1;
  if ( v1 < -2147483650.0 )
    result = 0;
  if ( v1 > 2147483650.0 )
    return 0;
  return result;
}

//----- (001F0F28) --------------------------------------------------------
int __fastcall png_gamma_significant(png_fixed_point gamma_val)
{
  return (unsigned int)(gamma_val - 95000) > 0x2710;
}

//----- (001F0F40) --------------------------------------------------------
png_fixed_point __fastcall png_reciprocal2(png_fixed_point a, png_fixed_point b)
{
  bool v2; // zf
  double v3; // r0

  v2 = a == 0;
  if ( a )
    v2 = b == 0;
  if ( v2 )
    return 0;
  v3 = floor(1.0e15 / (double)a / (double)b + 0.5);
  if ( v3 < -2147483650.0 || v3 > 2147483650.0 )
    return 0;
  else
    return (int)v3;
}

//----- (001F0FC8) --------------------------------------------------------
png_byte __fastcall png_gamma_8bit_correct(unsigned int value, png_fixed_point gamma_val)
{
  double v2; // r0

  if ( value - 1 <= 0xFD )
  {
    v2 = pow((double)(int)value / 255.0, (double)gamma_val * 0.00001);
    return (unsigned int)floor(v2 * 255.0 + 0.5);
  }
  return value;
}

//----- (001F1048) --------------------------------------------------------
png_uint_16 __fastcall png_gamma_16bit_correct(unsigned int value, png_fixed_point gamma_val)
{
  double v2; // r0

  if ( value - 1 <= 0xFFFD )
  {
    v2 = pow((double)(int)value / 65535.0, (double)gamma_val * 0.00001);
    return (unsigned int)floor(v2 * 65535.0 + 0.5);
  }
  return value;
}

//----- (001F10C8) --------------------------------------------------------
png_uint_16 __fastcall png_gamma_correct(png_structrp png_ptr, unsigned int value, png_fixed_point gamma_val)
{
  int bit_depth; // r3
  unsigned int v4; // r0
  double v5; // r0
  double v6; // r0

  bit_depth = png_ptr->bit_depth;
  v4 = value - 1;
  if ( bit_depth == 8 )
  {
    if ( v4 <= 0xFD )
    {
      v5 = pow((double)(int)value / 255.0, (double)gamma_val * 0.00001);
      value = (unsigned int)floor(v5 * 255.0 + 0.5);
    }
    LOWORD(value) = (unsigned __int8)value;
  }
  else if ( v4 <= 0xFFFD )
  {
    v6 = pow((double)(int)value / 65535.0, (double)gamma_val * 0.00001);
    return (unsigned int)floor(v6 * 65535.0 + 0.5);
  }
  return value;
}

//----- (001F11B0) --------------------------------------------------------
void __fastcall png_destroy_gamma_table(png_structrp png_ptr)
{
  png_uint_16pp gamma_16_table; // r1
  int v3; // r0
  int v4; // r5
  int v5; // r6
  png_bytep gamma_to_1; // r1
  png_uint_16pp gamma_16_from_1; // r1
  int v8; // r0
  int v9; // r6
  int v10; // r5
  png_uint_16pp gamma_16_to_1; // r1
  int v12; // r0
  int v13; // r6
  int v14; // r5

  j_png_free(png_ptr, png_ptr->gamma_table);
  gamma_16_table = png_ptr->gamma_16_table;
  png_ptr->gamma_table = 0;
  if ( gamma_16_table )
  {
    v3 = 8 - png_ptr->gamma_shift;
    if ( v3 != 31 )
    {
      v4 = 0;
      v5 = 1 << v3;
      do
      {
        j_png_free(png_ptr, gamma_16_table[v4]);
        gamma_16_table = png_ptr->gamma_16_table;
        ++v4;
      }
      while ( v4 < v5 );
    }
    j_png_free(png_ptr, gamma_16_table);
    png_ptr->gamma_16_table = 0;
  }
  j_png_free(png_ptr, png_ptr->gamma_from_1);
  gamma_to_1 = png_ptr->gamma_to_1;
  png_ptr->gamma_from_1 = 0;
  j_png_free(png_ptr, gamma_to_1);
  gamma_16_from_1 = png_ptr->gamma_16_from_1;
  png_ptr->gamma_to_1 = 0;
  if ( gamma_16_from_1 )
  {
    v8 = 8 - png_ptr->gamma_shift;
    if ( v8 != 31 )
    {
      v9 = 0;
      v10 = 1 << v8;
      do
      {
        j_png_free(png_ptr, gamma_16_from_1[v9]);
        gamma_16_from_1 = png_ptr->gamma_16_from_1;
        ++v9;
      }
      while ( v9 < v10 );
    }
    j_png_free(png_ptr, gamma_16_from_1);
    png_ptr->gamma_16_from_1 = 0;
  }
  gamma_16_to_1 = png_ptr->gamma_16_to_1;
  if ( gamma_16_to_1 )
  {
    v12 = 8 - png_ptr->gamma_shift;
    if ( v12 != 31 )
    {
      v13 = 0;
      v14 = 1 << v12;
      do
      {
        j_png_free(png_ptr, gamma_16_to_1[v13]);
        gamma_16_to_1 = png_ptr->gamma_16_to_1;
        ++v13;
      }
      while ( v13 < v14 );
    }
    j_png_free(png_ptr, gamma_16_to_1);
    png_ptr->gamma_16_to_1 = 0;
  }
}

//----- (001F12A0) --------------------------------------------------------
void __fastcall png_build_gamma_table(png_structrp png_ptr, int bit_depth)
{
  png_structrp v2; // r10
  png_bytep gamma_table; // r0
  bool v5; // zf
  int *v6; // r6
  int v7; // r0
  int v8; // r1
  double v9; // r0
  unsigned int red; // r1
  unsigned __int8 v11; // r2
  int screen_gamma; // r0
  unsigned __int8 v13; // r1
  int v14; // r3
  unsigned int v15; // r8
  double v16; // r0
  double v17; // d18
  double v18; // d9
  _QWORD *v19; // r5
  int v20; // r4
  double v21; // d8
  double v22; // r0
  unsigned int v23; // r0
  _QWORD *v24; // r5
  double v25; // d12
  _QWORD *v26; // r5
  int v27; // r0
  int v28; // r4
  double v29; // kr10_8
  double v30; // d12
  double v31; // r0
  unsigned int v32; // r0
  int gamma; // r1
  double v34; // r0
  _QWORD *v35; // r5
  int v36; // r0
  double v37; // d16
  int v38; // r4
  char v39; // r4
  unsigned int v40; // r11
  char v41; // r9
  png_uint_16 **v42; // r6
  unsigned int v43; // r5
  unsigned int v44; // r8
  int v45; // r10
  unsigned int v46; // r9
  double v47; // r0
  unsigned int v48; // kr00_4
  int v49; // r1
  unsigned int v50; // r2
  int v51; // r2
  unsigned int v52; // r3
  _QWORD *v53; // r5
  int v54; // s0
  int v55; // r4
  double v56; // d9
  double v57; // r0
  unsigned int v58; // r0
  _QWORD *v59; // r5
  double v60; // d16
  png_fixed_point v61; // r3
  int v62; // r0
  double v63; // r0
  png_fixed_point v64; // r3
  int v65; // [sp+4h] [bp-6Ch]
  png_struct *v66; // [sp+8h] [bp-68h]
  unsigned int shift; // [sp+Ch] [bp-64h]
  int y_4; // [sp+14h] [bp-5Ch]

  v2 = png_ptr;
  gamma_table = png_ptr->gamma_table;
  v5 = gamma_table == 0;
  if ( !gamma_table )
    v5 = v2->gamma_16_table == 0;
  if ( !v5 )
  {
    j_png_warning(v2, (png_const_charp)"gamma table being rebuilt");
    j_png_destroy_gamma_table(v2);
  }
  v6 = &elf_hash_chain[8526];
  if ( bit_depth > 8 )
  {
    if ( (v2->color_type & 2) != 0 )
    {
      red = v2->sig_bit.red;
      if ( v2->sig_bit.green > red )
        red = v2->sig_bit.green;
      if ( v2->sig_bit.blue > red )
        LOBYTE(red) = v2->sig_bit.blue;
    }
    else
    {
      LOBYTE(red) = v2->sig_bit.gray;
    }
    v11 = 0;
    screen_gamma = v2->screen_gamma;
    if ( (unsigned __int8)(red - 1) < 0xFu )
      v11 = 16 - red;
    v13 = v11;
    if ( v11 < 5u )
      v13 = 5;
    v14 = v2->transformations & 0x4000400;
    if ( !v14 )
      v13 = v11;
    if ( v13 >= 8u )
      v13 = 8;
    v15 = v13;
    v2->gamma_shift = v13;
    shift = v13;
    if ( v14 )
    {
      if ( screen_gamma < 1 )
      {
        v18 = 1.0;
      }
      else
      {
        v16 = floor((double)v2->colorspace.gamma * 0.00001 * (double)screen_gamma + 0.5);
        v17 = 0.0;
        v18 = 0.0;
        if ( v16 >= -2147483650.0 )
          v17 = (double)(int)v16 * 0.00001;
        if ( v16 <= 2147483650.0 )
          v18 = v17;
      }
      v39 = 8 - v15;
      v40 = 1 << (8 - v15);
      v41 = 16 - v15;
      v42 = (png_uint_16 **)j_png_calloc(v2, 4 * v40);
      v43 = 0;
      v2->gamma_16_table = v42;
      do
        v42[v43++] = (png_uint_16 *)j_png_malloc(v2, 0x200u);
      while ( v43 < v40 );
      v65 = 1 << (8 - v15);
      v66 = v2;
      v44 = 0xFFu >> v15;
      y_4 = (1 << v41) - 1;
      v45 = 0;
      v46 = 0;
      do
      {
        v47 = pow((double)(257 * v45 + 128) / 65535.0, v18);
        v48 = (unsigned int)floor(v47 * 65535.0 + 0.5) * y_4 + 0x8000;
        if ( v46 <= v48 / 0xFFFF )
        {
          do
          {
            v49 = v46 & v44;
            v50 = v46++ >> v39;
            v42[v49][v50] = 257 * v45;
          }
          while ( v48 / 0xFFFF + 1 != v46 );
          v46 = v48 / 0xFFFF + 1;
        }
        ++v45;
      }
      while ( v45 != 255 );
      v2 = v66;
      if ( v46 < v65 << 8 )
      {
        do
        {
          v51 = v46 & v44;
          v52 = v46++ >> v39;
          v42[v51][v52] = -1;
        }
        while ( v65 << 8 != v46 );
      }
    }
    else
    {
      if ( screen_gamma >= 1 )
      {
        gamma = v2->colorspace.gamma;
        if ( gamma
          && (v34 = floor(1.0e15 / (double)gamma / (double)screen_gamma + 0.5), v34 >= -2147483650.0)
          && v34 <= 2147483650.0 )
        {
          v6 = (int *)(int)v34;
        }
        else
        {
          v6 = 0;
        }
      }
      png_build_16bit_table(v2, &v2->gamma_16_table, v15, (const png_fixed_point)v6);
    }
    if ( (v2->transformations & (unsigned int)&defaultCoeffs[6145]) != 0 )
    {
      v60 = floor(1.0e10 / (double)v2->colorspace.gamma + 0.5);
      v61 = (int)v60;
      if ( v60 < -2147483650.0 )
        v61 = 0;
      if ( v60 > 2147483650.0 )
        v61 = 0;
      png_build_16bit_table(v2, &v2->gamma_16_to_1, shift, v61);
      v62 = v2->screen_gamma;
      if ( v62 < 1 )
      {
        v64 = v2->colorspace.gamma;
      }
      else
      {
        v63 = floor(1.0e10 / (double)v62 + 0.5);
        v64 = (int)v63;
        if ( v63 < -2147483650.0 )
          v64 = 0;
        if ( v63 > 2147483650.0 )
          v64 = 0;
      }
      png_build_16bit_table(v2, &v2->gamma_16_from_1, shift, v64);
    }
  }
  else
  {
    v7 = v2->screen_gamma;
    if ( v7 >= 1 )
    {
      v8 = v2->colorspace.gamma;
      if ( v8 && (v9 = floor(1.0e15 / (double)v8 / (double)v7 + 0.5), v9 >= -2147483650.0) && v9 <= 2147483650.0 )
        v6 = (int *)(int)v9;
      else
        v6 = 0;
    }
    v19 = j_png_malloc(v2, 0x100u);
    v2->gamma_table = (png_bytep)v19;
    if ( (unsigned int)(v6 - 23750) <= 0x2710 )
    {
      qmemcpy(v19 + 4, " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvw", 88);
      v19[15] = 0x7F7E7D7C7B7A7978LL;
      v19[16] = 0x8786858483828180LL;
      v19[17] = 0x8F8E8D8C8B8A8988LL;
      v19[18] = 0x9796959493929190LL;
      v19[19] = 0x9F9E9D9C9B9A9998LL;
      v19[20] = 0xA7A6A5A4A3A2A1A0LL;
      v19[21] = 0xAFAEADACABAAA9A8LL;
      v19[22] = 0xB7B6B5B4B3B2B1B0LL;
      v19[23] = 0xBFBEBDBCBBBAB9B8LL;
      v19[24] = 0xC7C6C5C4C3C2C1C0LL;
      v19[25] = 0xCFCECDCCCBCAC9C8LL;
      v19[26] = 0xD7D6D5D4D3D2D1D0LL;
      v19[27] = 0xDFDEDDDCDBDAD9D8LL;
      v19[28] = 0xE7E6E5E4E3E2E1E0LL;
      v19[29] = 0xEFEEEDECEBEAE9E8LL;
      v19[30] = 0xF7F6F5F4F3F2F1F0LL;
      v19[31] = 0xFFFEFDFCFBFAF9F8LL;
      *v19 = loc_1F1C70;
      v19[1] = loc_1F1C78;
      v24 = v19 + 2;
      *v24 = loc_1F1C80;
      v24[1] = loc_1F1C88;
    }
    else
    {
      v20 = 0;
      v21 = 0.0;
      do
      {
        if ( (unsigned int)(v20 - 1) > 0xFD )
        {
          LOBYTE(v23) = v20;
        }
        else
        {
          v22 = pow(v21 / 255.0, (double)(int)v6 * 0.00001);
          v23 = (unsigned int)floor(v22 * 255.0 + 0.5);
        }
        v21 = v21 + 1.0;
        *((_BYTE *)v19 + v20++) = v23;
      }
      while ( v20 != 256 );
    }
    if ( (v2->transformations & (unsigned int)&defaultCoeffs[6145]) != 0 )
    {
      v25 = floor(1.0e10 / (double)v2->colorspace.gamma + 0.5);
      v26 = j_png_malloc(v2, 0x100u);
      v27 = (int)v25;
      v2->gamma_to_1 = (png_bytep)v26;
      if ( v25 < -2147483650.0 )
        v27 = 0;
      if ( v25 > 2147483650.0 )
        v27 = 0;
      if ( (unsigned int)(v27 - 95000) <= 0x2710 )
      {
        qmemcpy(
          v26 + 4,
          " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvw",
          88);
        v26[15] = 0x7F7E7D7C7B7A7978LL;
        v26[16] = 0x8786858483828180LL;
        v26[17] = 0x8F8E8D8C8B8A8988LL;
        v26[18] = 0x9796959493929190LL;
        v26[19] = 0x9F9E9D9C9B9A9998LL;
        v26[20] = 0xA7A6A5A4A3A2A1A0LL;
        v26[21] = 0xAFAEADACABAAA9A8LL;
        v26[22] = 0xB7B6B5B4B3B2B1B0LL;
        v26[23] = 0xBFBEBDBCBBBAB9B8LL;
        v26[24] = 0xC7C6C5C4C3C2C1C0LL;
        v26[25] = 0xCFCECDCCCBCAC9C8LL;
        v26[26] = 0xD7D6D5D4D3D2D1D0LL;
        v26[27] = 0xDFDEDDDCDBDAD9D8LL;
        v26[28] = 0xE7E6E5E4E3E2E1E0LL;
        v26[29] = 0xEFEEEDECEBEAE9E8LL;
        v26[30] = 0xF7F6F5F4F3F2F1F0LL;
        v26[31] = 0xFFFEFDFCFBFAF9F8LL;
        *v26 = loc_1F1C70;
        v26[1] = loc_1F1C78;
        v35 = v26 + 2;
        *v35 = loc_1F1C80;
        v35[1] = loc_1F1C88;
      }
      else
      {
        v28 = 0;
        v29 = (double)v27 * 0.00001;
        v30 = 0.0;
        do
        {
          if ( (unsigned int)(v28 - 1) > 0xFD )
          {
            LOBYTE(v32) = v28;
          }
          else
          {
            v31 = pow(v30 / 255.0, v29);
            v32 = (unsigned int)floor(v31 * 255.0 + 0.5);
          }
          v30 = v30 + 1.0;
          *((_BYTE *)v26 + v28++) = v32;
        }
        while ( v28 != 256 );
      }
      v36 = v2->screen_gamma;
      if ( v36 < 1 )
      {
        v38 = v2->colorspace.gamma;
      }
      else
      {
        v37 = floor(1.0e10 / (double)v36 + 0.5);
        v38 = (int)v37;
        if ( v37 < -2147483650.0 )
          v38 = 0;
        if ( v37 > 2147483650.0 )
          v38 = 0;
      }
      v53 = j_png_malloc(v2, 0x100u);
      v2->gamma_from_1 = (png_bytep)v53;
      if ( (unsigned int)(v38 - 95000) <= 0x2710 )
      {
        qmemcpy(
          v53 + 4,
          " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvw",
          88);
        v53[15] = 0x7F7E7D7C7B7A7978LL;
        v53[16] = 0x8786858483828180LL;
        v53[17] = 0x8F8E8D8C8B8A8988LL;
        v53[18] = 0x9796959493929190LL;
        v53[19] = 0x9F9E9D9C9B9A9998LL;
        v53[20] = 0xA7A6A5A4A3A2A1A0LL;
        v53[21] = 0xAFAEADACABAAA9A8LL;
        v53[22] = 0xB7B6B5B4B3B2B1B0LL;
        v53[23] = 0xBFBEBDBCBBBAB9B8LL;
        v53[24] = 0xC7C6C5C4C3C2C1C0LL;
        v53[25] = 0xCFCECDCCCBCAC9C8LL;
        v53[26] = 0xD7D6D5D4D3D2D1D0LL;
        v53[27] = 0xDFDEDDDCDBDAD9D8LL;
        v53[28] = 0xE7E6E5E4E3E2E1E0LL;
        v53[29] = 0xEFEEEDECEBEAE9E8LL;
        v53[30] = 0xF7F6F5F4F3F2F1F0LL;
        v53[31] = 0xFFFEFDFCFBFAF9F8LL;
        *v53 = loc_1F1C70;
        v53[1] = loc_1F1C78;
        v59 = v53 + 2;
        *v59 = loc_1F1C80;
        v59[1] = loc_1F1C88;
      }
      else
      {
        v54 = v38;
        v55 = 0;
        v56 = 0.0;
        do
        {
          if ( (unsigned int)(v55 - 1) > 0xFD )
          {
            LOBYTE(v58) = v55;
          }
          else
          {
            v57 = pow(v56 / 255.0, (double)v54 * 0.00001);
            v58 = (unsigned int)floor(v57 * 255.0 + 0.5);
          }
          v56 = v56 + 1.0;
          *((_BYTE *)v53 + v55++) = v58;
        }
        while ( v55 != 256 );
      }
    }
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (001F1D48) --------------------------------------------------------
void __fastcall png_build_16bit_table(
        png_structrp png_ptr,
        png_uint_16pp *ptable,
        const unsigned int shift,
        const png_fixed_point gamma_val)
{
  char v6; // r6
  unsigned int v8; // r9
  double v9; // d9
  png_uint_16 *v10; // r5
  int j; // r8
  double v12; // r0
  int i; // r4
  unsigned int v14; // r0
  unsigned int v15; // [sp+4h] [bp-54h]
  png_uint_16 **v16; // [sp+8h] [bp-50h]
  unsigned int v17; // [sp+Ch] [bp-4Ch]
  int v19; // [sp+14h] [bp-44h]

  v6 = 8 - shift;
  v19 = (1 << (16 - shift)) - 1;
  v17 = 1 << (8 - shift);
  v8 = 0;
  v16 = (png_uint_16 **)j_png_calloc(png_ptr, 4 * v17);
  *ptable = v16;
  v15 = gamma_val - 95000;
  v9 = (double)gamma_val * 0.00001;
  do
  {
    v10 = (png_uint_16 *)j_png_malloc(png_ptr, 0x200u);
    v16[v8] = v10;
    if ( v15 <= 0x2710 )
    {
      for ( i = 0; i != 256; ++i )
      {
        v14 = (i << v6) + v8;
        if ( shift )
          v14 = (0xFFFF * v14 + (1 << (15 - shift))) / v19;
        v10[i] = v14;
      }
    }
    else
    {
      for ( j = 0; j != 256; ++j )
      {
        v12 = pow(1.0 / (double)v19 * (double)((j << v6) + v8), v9);
        v10[j] = (unsigned int)floor(v12 * 65535.0 + 0.5);
      }
    }
    ++v8;
  }
  while ( v8 < v17 );
}

//----- (001F1E80) --------------------------------------------------------
int __fastcall png_set_option(png_structrp png_ptr, int option, int onoff)
{
  int v3; // r12
  int v4; // r3
  png_uint_32 options; // r12

  v3 = 1;
  if ( png_ptr && (unsigned int)option <= 0xB && (option & 1) == 0 )
  {
    v4 = 2;
    options = png_ptr->options;
    if ( onoff )
      v4 = 3;
    png_ptr->options = (unsigned __int8)((v4 << option) | options & ~(unsigned __int8)(3 << option));
    return (int)(options & (3 << option)) >> option;
  }
  return v3;
}

//----- (001F1EC8) --------------------------------------------------------
void __fastcall png_image_free(png_imagep image)
{
  png_imagep v1; // r4
  bool v2; // zf

  v1 = image;
  v2 = image == 0;
  if ( image )
  {
    image = (png_imagep)image->opaque;
    v2 = v1->opaque == 0;
  }
  if ( !v2 && !image->width )
  {
    j_png_safe_execute(v1, png_image_free_function, v1);
    v1->opaque = 0;
  }
}

//----- (001F1EF8) --------------------------------------------------------
int __fastcall png_image_free_function(png_voidp argument)
{
  int *v2; // r4
  int v3; // r1
  FILE *v4; // r0
  __int64 v5; // d17
  __int64 v6; // d18
  __int64 png_ptr[2]; // [sp+0h] [bp-28h] BYREF
  __int64 v9; // [sp+10h] [bp-18h]

  v2 = *(int **)argument;
  v3 = **(_DWORD **)argument;
  if ( !v3 )
    return 0;
  if ( (v2[5] & 2) != 0 )
  {
    v4 = *(FILE **)(v3 + 288);
    *((_BYTE *)v2 + 20) &= ~2u;
    if ( v4 )
    {
      *(_DWORD *)(v3 + 288) = 0;
      fclose(v4);
    }
  }
  v5 = *((_QWORD *)v2 + 1);
  v6 = *((_QWORD *)v2 + 2);
  png_ptr[0] = *(_QWORD *)v2;
  png_ptr[1] = v5;
  v9 = v6;
  *(_DWORD *)argument = png_ptr;
  j_png_free((png_const_structrp_2)png_ptr[0], v2);
  if ( BYTE4(v9) << 31 )
    j_png_destroy_write_struct((png_structpp)png_ptr, (png_infopp)png_ptr + 1);
  else
    j_png_destroy_read_struct((png_structpp)png_ptr, (png_infopp)png_ptr + 1, 0);
  return 1;
}

//----- (001F1F74) --------------------------------------------------------
int __fastcall png_image_error(png_imagep image, png_const_charp error_message)
{
  bool v3; // zf
  png_uint_32 opaque; // r0

  j_png_safecat(image->message, 0x40u, 0, error_message);
  v3 = image == 0;
  opaque = image->warning_or_error | 2;
  image->warning_or_error = opaque;
  if ( image )
  {
    opaque = (png_uint_32)image->opaque;
    v3 = image->opaque == 0;
  }
  if ( v3 || *(_DWORD *)(opaque + 8) )
    return 0;
  j_png_safe_execute(image, png_image_free_function, image);
  image->opaque = 0;
  return 0;
}

//----- (001F1FC0) --------------------------------------------------------
int __fastcall png_xy_from_XYZ(png_xy_0 *xy, const png_XYZ_0 *XYZ)
{
  png_fixed_point red_X; // r0
  int v5; // r6
  double v6; // d16
  int result; // r0
  png_fixed_point v8; // r0
  png_fixed_point red_Y; // r0
  double v10; // d16
  png_fixed_point v11; // r0
  png_fixed_point green_X; // r0
  int v13; // r10
  __int64 v14; // kr00_8
  double v15; // d16
  png_fixed_point v16; // r0
  png_fixed_point green_Y; // r0
  double v18; // d16
  png_fixed_point v19; // r0
  png_fixed_point blue_X; // r0
  int v21; // r11
  double v22; // d16
  png_fixed_point v23; // r0
  png_fixed_point blue_Y; // r0
  double v25; // d16
  png_fixed_point v26; // r0
  int v27; // r6
  __int64 v28; // kr08_8
  double v29; // d16
  png_fixed_point v30; // r0
  int v31; // r0
  double v32; // d16
  png_fixed_point v33; // r0
  png_fixed_point v34; // [sp+4h] [bp-24h]
  png_fixed_point v35; // [sp+8h] [bp-20h]

  red_X = XYZ->red_X;
  v5 = XYZ->red_Y + XYZ->red_X + XYZ->red_Z;
  if ( !v5 )
    return 1;
  if ( red_X )
  {
    v6 = floor((double)red_X * 100000.0 / (double)v5 + 0.5);
    result = 1;
    if ( v6 > 2147483650.0 || v6 < -2147483650.0 )
      return result;
    v8 = (int)v6;
  }
  else
  {
    v8 = 0;
  }
  xy->redx = v8;
  red_Y = XYZ->red_Y;
  if ( red_Y )
  {
    v10 = floor((double)red_Y * 100000.0 / (double)v5 + 0.5);
    result = 1;
    if ( v10 > 2147483650.0 || v10 < -2147483650.0 )
      return result;
    v11 = (int)v10;
  }
  else
  {
    v11 = 0;
  }
  xy->redy = v11;
  green_X = XYZ->green_X;
  v13 = XYZ->green_Y + green_X + XYZ->green_Z;
  if ( !v13 )
    return 1;
  v14 = *(_QWORD *)&XYZ->red_X;
  if ( green_X )
  {
    v15 = floor((double)green_X * 100000.0 / (double)v13 + 0.5);
    result = 1;
    if ( v15 > 2147483650.0 || v15 < -2147483650.0 )
      return result;
    v16 = (int)v15;
  }
  else
  {
    v16 = 0;
  }
  xy->greenx = v16;
  green_Y = XYZ->green_Y;
  if ( green_Y )
  {
    v18 = floor((double)green_Y * 100000.0 / (double)v13 + 0.5);
    result = 1;
    if ( v18 > 2147483650.0 || v18 < -2147483650.0 )
      return result;
    v19 = (int)v18;
  }
  else
  {
    v19 = 0;
  }
  xy->greeny = v19;
  blue_X = XYZ->blue_X;
  v21 = XYZ->blue_Y + blue_X + XYZ->blue_Z;
  if ( !v21 )
    return 1;
  v35 = XYZ->green_X;
  v34 = XYZ->green_Y;
  if ( blue_X )
  {
    v22 = floor((double)blue_X * 100000.0 / (double)v21 + 0.5);
    result = 1;
    if ( v22 > 2147483650.0 || v22 < -2147483650.0 )
      return result;
    v23 = (int)v22;
  }
  else
  {
    v23 = 0;
  }
  xy->bluex = v23;
  blue_Y = XYZ->blue_Y;
  if ( blue_Y )
  {
    v25 = floor((double)blue_Y * 100000.0 / (double)v21 + 0.5);
    result = 1;
    if ( v25 > 2147483650.0 || v25 < -2147483650.0 )
      return result;
    v26 = (int)v25;
  }
  else
  {
    v26 = 0;
  }
  xy->bluey = v26;
  v27 = v13 + v5 + v21;
  if ( !v27 )
    return 1;
  v28 = *(_QWORD *)&XYZ->blue_X;
  if ( v35 + (_DWORD)v14 + (_DWORD)v28 )
  {
    v29 = floor((double)(v35 + (int)v14 + (int)v28) * 100000.0 / (double)v27 + 0.5);
    result = 1;
    if ( v29 > 2147483650.0 || v29 < -2147483650.0 )
      return result;
    v30 = (int)v29;
  }
  else
  {
    v30 = 0;
  }
  xy->whitex = v30;
  v31 = v34 + HIDWORD(v14) + HIDWORD(v28);
  if ( !v31 )
  {
    v33 = 0;
    goto LABEL_47;
  }
  v32 = floor((double)v31 * 100000.0 / (double)v27 + 0.5);
  result = 1;
  if ( v32 <= 2147483650.0 && v32 >= -2147483650.0 )
  {
    v33 = (int)v32;
LABEL_47:
    xy->whitey = v33;
    return 0;
  }
  return result;
}

//----- (001F2350) --------------------------------------------------------
void __fastcall png_error(png_const_structrp_0 png_ptr, png_const_charp error_message)
{
  png_error_ptr error_fn; // r2
  bool v4; // zf
  png_const_charp v6; // r2

  v4 = png_ptr == 0;
  if ( png_ptr )
  {
    error_fn = png_ptr->error_fn;
    v4 = error_fn == 0;
  }
  if ( !v4 )
    error_fn((png_structp)png_ptr, error_message);
  v6 = (png_const_charp)"undefined";
  if ( error_message )
    v6 = error_message;
  fprintf((FILE *)stderr, "libpng error: %s", v6);
  fputc(10, (FILE *)stderr);
  j_png_longjmp(png_ptr, 1);
}
// 1F236C: variable 'error_fn' is possibly undefined

//----- (001F23B8) --------------------------------------------------------
size_t __fastcall png_safecat(png_charp buffer, size_t bufsize, size_t pos, png_const_charp string)
{
  size_t v4; // r12
  bool v5; // cc
  unsigned __int8 v6; // r1
  png_const_charp v7; // r3
  int v8; // t1

  if ( buffer && pos < bufsize )
  {
    v5 = string != 0;
    if ( string )
    {
      v4 = bufsize - 1;
      v5 = bufsize - 1 > pos;
    }
    if ( v5 )
    {
      v6 = *string;
      if ( *string )
      {
        v7 = string + 1;
        do
        {
          buffer[pos++] = v6;
          if ( pos >= v4 )
            break;
          v8 = *v7++;
          v6 = v8;
        }
        while ( v8 );
      }
    }
    buffer[pos] = 0;
  }
  return pos;
}
// 1F23D6: variable 'v4' is possibly undefined

//----- (001F23E8) --------------------------------------------------------
png_charp __fastcall png_format_number(png_const_charp start, png_charp end, int format, png_alloc_size_t number)
{
  unsigned __int8 *v4; // r1
  const unsigned __int8 *v5; // lr
  int v6; // r9
  int v7; // r6
  png_alloc_size_t v8; // r5
  const unsigned __int8 *v9; // r4
  png_alloc_size_t v10; // r12
  png_alloc_size_t v11; // r3
  int v12; // r3
  bool v13; // zf
  int v15; // [sp+0h] [bp-20h]

  *(end - 1) = 0;
  v4 = end - 1;
  if ( v4 > start )
  {
    v15 = 0;
    v5 = "0123456789ABCDEF";
    v6 = 1;
    v7 = 0;
    while ( 1 )
    {
      if ( !number && v7 >= v6 )
        return v4;
      switch ( format )
      {
        case 1:
          goto LABEL_7;
        case 2:
          v6 = 2;
LABEL_7:
          ++v7;
          *--v4 = png_format_number_digits[number % 0xA];
          number /= 0xAu;
          if ( v4 <= start )
            return v4;
          continue;
        case 3:
          goto LABEL_10;
        case 4:
          v6 = 2;
LABEL_10:
          v8 = number & 0xF;
          number >>= 4;
          ++v7;
          *--v4 = png_format_number_digits[v8];
          if ( v4 <= start )
            return v4;
          continue;
        case 5:
          v10 = number / 0xA;
          v11 = number % 0xA;
          v9 = v5;
          if ( v15 | v11 )
          {
            *--v4 = v5[v11];
            v12 = 1;
          }
          else
          {
            v12 = 0;
          }
          v15 = v12;
          v6 = 5;
          goto LABEL_17;
        default:
          v9 = v5;
          v10 = 0;
LABEL_17:
          v13 = format == 5;
          if ( format == 5 )
            v13 = v7 == 4;
          if ( !v13 || v4 <= start )
          {
            number = v10;
            ++v7;
LABEL_25:
            v5 = v9;
            if ( v4 <= start )
              return v4;
            continue;
          }
          if ( v15 )
          {
            v7 = 5;
            *--v4 = 46;
            number = v10;
            goto LABEL_25;
          }
          v5 = v9;
          if ( v10 )
          {
            v7 = 5;
            v15 = 0;
            number = v10;
            if ( v4 <= start )
              return v4;
          }
          else
          {
            *--v4 = 48;
            v7 = 5;
            number = 0;
            v15 = 0;
            if ( v4 <= start )
              return v4;
          }
          break;
      }
    }
  }
  return v4;
}

//----- (001F251C) --------------------------------------------------------
void __fastcall png_warning(png_const_structrp_0 png_ptr, png_const_charp warning_message)
{
  int v2; // r2
  void (*warning_fn)(void); // r3

  if ( png_ptr )
  {
    if ( *warning_message == 35 )
    {
      if ( warning_message[1] == 32 )
      {
        v2 = 1;
      }
      else if ( warning_message[2] == 32 )
      {
        v2 = 2;
      }
      else if ( warning_message[3] == 32 )
      {
        v2 = 3;
      }
      else if ( warning_message[4] == 32 )
      {
        v2 = 4;
      }
      else if ( warning_message[5] == 32 )
      {
        v2 = 5;
      }
      else if ( warning_message[6] == 32 )
      {
        v2 = 6;
      }
      else if ( warning_message[7] == 32 )
      {
        v2 = 7;
      }
      else if ( warning_message[8] == 32 )
      {
        v2 = 8;
      }
      else if ( warning_message[9] == 32 )
      {
        v2 = 9;
      }
      else if ( warning_message[10] == 32 )
      {
        v2 = 10;
      }
      else if ( warning_message[11] == 32 )
      {
        v2 = 11;
      }
      else if ( warning_message[12] == 32 )
      {
        v2 = 12;
      }
      else if ( warning_message[13] == 32 )
      {
        v2 = 13;
      }
      else
      {
        v2 = 15;
        if ( warning_message[14] == 32 )
          v2 = 14;
      }
    }
    else
    {
      v2 = 0;
    }
    warning_fn = (void (*)(void))png_ptr->warning_fn;
    if ( warning_fn )
    {
      warning_fn();
      return;
    }
  }
  else
  {
    v2 = 0;
  }
  fprintf((FILE *)stderr, "libpng warning: %s", (const char *)&warning_message[v2]);
  sub_18F47C(10, (FILE *)stderr);
}

//----- (001F25FC) --------------------------------------------------------
void __fastcall png_warning_parameter(unsigned __int8 (*p)[32], int number, png_const_charp string)
{
  unsigned int v3; // r1
  unsigned __int8 *v4; // lr
  int v5; // r1
  png_const_charp v6; // r2
  int v7; // r3
  int v8; // r0

  v3 = number - 1;
  if ( v3 <= 7 )
  {
    v4 = &(*p)[32 * v3];
    if ( v4 )
    {
      if ( string && (LOBYTE(v5) = *string) != 0 )
      {
        v6 = string + 1;
        v7 = 0;
        do
        {
          v8 = v7 + 1;
          v4[v7] = v5;
          if ( (unsigned int)(v7 + 1) > 0x1E )
            break;
          v5 = v6[v7++];
        }
        while ( v5 );
      }
      else
      {
        v8 = 0;
      }
      v4[v8] = 0;
    }
  }
}

//----- (001F263C) --------------------------------------------------------
void __fastcall png_warning_parameter_unsigned(
        unsigned __int8 (*p)[32],
        int number,
        int format,
        png_alloc_size_t value)
{
  char *v4; // lr
  int v5; // r12
  int v6; // r6
  int v7; // r9
  png_alloc_size_t v8; // r1
  png_alloc_size_t v9; // r1
  png_alloc_size_t v10; // r5
  int v11; // r0
  bool v12; // zf
  unsigned __int8 *v13; // r0
  int v14; // r4
  int v15; // r3
  unsigned __int8 (*v16)[32]; // [sp+4h] [bp-44h]
  int v17; // [sp+8h] [bp-40h]
  char v19[23]; // [sp+10h] [bp-38h] BYREF
  char v20; // [sp+27h] [bp-21h] BYREF

  v4 = &v20;
  v5 = 0;
  v6 = 1;
  v7 = 0;
  v20 = 0;
  v17 = 0;
LABEL_28:
  while ( v7 < v6 || value )
  {
    switch ( format )
    {
      case 1:
        goto LABEL_4;
      case 2:
        v6 = 2;
LABEL_4:
        v8 = value % 0xA;
        value /= 0xAu;
        v5 = png_format_number_digits[v8];
        goto LABEL_7;
      case 3:
        goto LABEL_6;
      case 4:
        v6 = 2;
LABEL_6:
        v9 = value & 0xF;
        value >>= 4;
        v5 = png_format_number_digits[v9];
LABEL_7:
        *--v4 = v5;
        ++v7;
        if ( v4 <= v19 )
          goto LABEL_30;
        goto LABEL_28;
      case 5:
        v16 = p;
        v10 = value / 0xA;
        if ( v17 | (value % 0xA) )
        {
          v5 = png_format_number_digits[value % 0xA];
          v11 = 1;
          *--v4 = v5;
        }
        else
        {
          v11 = 0;
        }
        v17 = v11;
        v6 = 5;
        goto LABEL_14;
      default:
        v10 = 0;
        v16 = p;
LABEL_14:
        v12 = format == 5;
        if ( format == 5 )
          v12 = v7 == 4;
        if ( !v12 || v4 <= v19 )
        {
          value = v10;
          ++v7;
          goto LABEL_25;
        }
        if ( v17 )
        {
          v5 = 46;
          *--v4 = 46;
LABEL_24:
          v7 = 5;
          value = v10;
          goto LABEL_25;
        }
        if ( v10 )
        {
          v17 = 0;
          goto LABEL_24;
        }
        v5 = 48;
        *--v4 = 48;
        v7 = 5;
        value = 0;
        v17 = 0;
LABEL_25:
        p = v16;
        if ( v4 <= v19 )
          goto LABEL_30;
        break;
    }
  }
LABEL_30:
  if ( (unsigned int)(number - 1) <= 7 )
  {
    v13 = &(*p)[32 * number - 32];
    if ( v13 )
    {
      if ( v4 )
      {
        v14 = 0;
        if ( v5 << 24 )
        {
          v15 = 0;
          do
          {
            v14 = v15 + 1;
            v13[v15] = v5;
            if ( (unsigned int)(v15 + 1) > 0x1E )
              break;
            v5 = (unsigned __int8)v4[++v15];
          }
          while ( v5 );
        }
      }
      else
      {
        v14 = 0;
      }
      v13[v14] = 0;
    }
  }
}

//----- (001F27C0) --------------------------------------------------------
void __fastcall png_warning_parameter_signed(unsigned __int8 (*p)[32], int number, int format, png_int_32 value)
{
  int v4; // lr
  char *v5; // r12
  unsigned int v6; // r11
  int v7; // r6
  int v8; // r9
  unsigned int v9; // r1
  int v10; // r0
  unsigned int v11; // r0
  int v12; // r1
  bool v13; // zf
  unsigned __int8 *v14; // r0
  int v15; // r4
  int v16; // r3
  int v18; // [sp+8h] [bp-40h]
  char v20[23]; // [sp+10h] [bp-38h] BYREF
  char v21; // [sp+27h] [bp-21h] BYREF

  v4 = 0;
  v5 = &v21;
  v6 = value;
  v7 = 1;
  v21 = 0;
  if ( value < 0 )
    v6 = -value;
  v8 = 0;
  v18 = 0;
LABEL_4:
  while ( v8 < v7 || v6 )
  {
    switch ( format )
    {
      case 1:
        goto LABEL_8;
      case 2:
        v7 = 2;
LABEL_8:
        ++v8;
        v9 = v6 % 0xA;
        v6 /= 0xAu;
        v4 = png_format_number_digits[v9];
        goto LABEL_11;
      case 3:
        goto LABEL_10;
      case 4:
        v7 = 2;
LABEL_10:
        v10 = v6 & 0xF;
        v6 >>= 4;
        ++v8;
        v4 = png_format_number_digits[v10];
LABEL_11:
        *--v5 = v4;
        if ( v5 <= v20 )
          goto LABEL_32;
        goto LABEL_4;
      case 5:
        v11 = v6 / 0xA;
        if ( v18 | (v6 % 0xA) )
        {
          v4 = png_format_number_digits[v6 % 0xA];
          v12 = 1;
          *--v5 = v4;
        }
        else
        {
          v12 = 0;
        }
        v18 = v12;
        v7 = 5;
        goto LABEL_18;
      default:
        v11 = 0;
LABEL_18:
        v13 = format == 5;
        if ( format == 5 )
          v13 = v8 == 4;
        if ( !v13 || v5 <= v20 )
        {
          v6 = v11;
          ++v8;
          if ( v5 <= v20 )
            goto LABEL_32;
          goto LABEL_4;
        }
        if ( v18 )
        {
          v4 = 46;
          *--v5 = 46;
          goto LABEL_29;
        }
        if ( v11 )
        {
          v18 = 0;
LABEL_29:
          v8 = 5;
          v6 = v11;
          if ( v5 <= v20 )
            goto LABEL_32;
          goto LABEL_4;
        }
        v4 = 48;
        *--v5 = 48;
        v8 = 5;
        v6 = 0;
        v18 = 0;
        if ( v5 <= v20 )
          goto LABEL_32;
        break;
    }
  }
LABEL_32:
  if ( value <= -1 && v5 > v20 )
  {
    v4 = 45;
    *--v5 = 45;
  }
  if ( (unsigned int)(number - 1) <= 7 )
  {
    v14 = &(*p)[32 * number - 32];
    if ( v14 )
    {
      if ( v5 )
      {
        v15 = 0;
        if ( v4 << 24 )
        {
          v16 = 0;
          do
          {
            v15 = v16 + 1;
            v14[v16] = v4;
            if ( (unsigned int)(v16 + 1) > 0x1E )
              break;
            v4 = (unsigned __int8)v5[++v16];
          }
          while ( v4 );
        }
      }
      else
      {
        v15 = 0;
      }
      v14[v15] = 0;
    }
  }
}

//----- (001F2970) --------------------------------------------------------
void __fastcall png_formatted_warning(png_const_structrp_0 png_ptr, unsigned __int8 (*p)[32], png_const_charp message)
{
  unsigned int v3; // r8
  int v4; // r5
  png_const_charp v5; // r9
  int v6; // r3
  unsigned __int8 (*v7)[32]; // r4
  int v8; // r6
  int v10; // r5
  unsigned __int8 v11; // r3
  unsigned __int8 *v12; // r6
  unsigned __int8 warning_message[192]; // [sp+4h] [bp-DCh] BYREF

  v3 = 0;
  while ( 1 )
  {
    v4 = *message;
    if ( !*message )
      break;
    if ( !p || v4 != 64 )
      goto LABEL_17;
    v5 = message + 1;
    v4 = message[1];
    if ( message[1] )
    {
      v6 = 0;
      v7 = p;
      do
      {
        ++v7;
        v8 = v6 + 1;
        if ( v6 == 9 )
          break;
      }
      while ( png_formatted_warning_valid_parameters[v6++] != v4 );
      if ( v8 - 1 > 7 )
        goto LABEL_18;
      v10 = -32;
      while ( &(*v7)[v10] < (unsigned __int8 *)v7 )
      {
        v11 = (*v7)[v10];
        if ( !v11 )
          break;
        v12 = &warning_message[v3 + v10++];
        v12[32] = v11;
        if ( v3 + v10 + 32 >= 0xBF )
        {
          v3 += v10 + 32;
          goto LABEL_21;
        }
      }
      v3 += v10 + 32;
LABEL_21:
      message += 2;
      if ( v3 >= 0xBF )
        break;
    }
    else
    {
      LOBYTE(v4) = 64;
LABEL_17:
      v5 = message;
LABEL_18:
      warning_message[v3++] = v4;
      message = v5 + 1;
      if ( v3 >= 0xBF )
        break;
    }
  }
  warning_message[v3] = 0;
  j_png_warning(png_ptr, warning_message);
}
// 1F29C8: conditional instruction was optimized away because r8.4<BFu
// 1F2970: using guessed type unsigned __int8 warning_message[192];

//----- (001F2A54) --------------------------------------------------------
void __fastcall png_benign_error(png_const_structrp_0 png_ptr, png_const_charp error_message)
{
  const unsigned __int8 *v3; // r2
  char v4; // r1
  png_uint_32 v5; // r0
  bool v6; // zf
  bool v7; // zf
  unsigned __int8 buffer[214]; // [sp+6h] [bp-E2h] BYREF

  v3 = error_message;
  v4 = BYTE2(png_ptr->flags);
  v5 = png_ptr->mode & 0x8000;
  if ( (v4 & 0x10) == 0 )
  {
    v7 = v5 == 0;
    if ( v5 )
      v7 = png_ptr->chunk_name == 0;
    if ( v7 )
      j_png_error(png_ptr, v3);
    j_png_chunk_error(png_ptr, v3);
    JUMPOUT(0x1F2AEC);
  }
  v6 = v5 == 0;
  if ( v5 )
    v6 = png_ptr->chunk_name == 0;
  if ( v6 )
  {
    png_warning(png_ptr, v3);
  }
  else
  {
    png_format_buffer(png_ptr, buffer, v3);
    j_png_warning(png_ptr, buffer);
  }
}
// 1F2AEA: control flows out of bounds to 1F2AEC
// 1F2AE6: variable 'v3' is possibly undefined

//----- (001F2AF8) --------------------------------------------------------
void __fastcall png_chunk_warning(png_const_structrp_0 png_ptr, png_const_charp warning_message)
{
  const png_struct *v3; // r0
  unsigned __int8 buffer[8]; // [sp+6h] [bp-E2h] BYREF

  if ( png_ptr )
  {
    png_format_buffer(png_ptr, buffer, warning_message);
    v3 = png_ptr;
    warning_message = buffer;
  }
  else
  {
    v3 = 0;
  }
  j_png_warning(v3, warning_message);
}

//----- (001F2B48) --------------------------------------------------------
void __fastcall png_chunk_error(png_const_structrp_0 png_ptr, png_const_charp error_message)
{
  const unsigned __int8 *v3; // r2
  png_const_structrp_0 v4; // r0
  png_const_charp v5; // r1
  unsigned __int8 buffer[8]; // [sp+2h] [bp-DEh] BYREF

  v3 = error_message;
  if ( !png_ptr )
    j_png_error(0, error_message);
  png_format_buffer(png_ptr, buffer, v3);
  j_png_error(png_ptr, buffer);
  png_app_warning(v4, v5);
}
// 1F2B64: variable 'v3' is possibly undefined
// 1F2B6D: variable 'v4' is possibly undefined
// 1F2B6D: variable 'v5' is possibly undefined

//----- (001F2B70) --------------------------------------------------------
void __fastcall png_app_warning(png_const_structrp_0 png_ptr, png_const_charp error_message)
{
  png_const_structrp_0 v2; // r0
  png_const_charp v3; // r1

  if ( (png_ptr->flags & 0x200000) != 0 )
  {
    png_warning(png_ptr, error_message);
  }
  else
  {
    j_png_error(png_ptr, error_message);
    png_app_error(v2, v3);
  }
}
// 1F2B7F: variable 'v2' is possibly undefined
// 1F2B7F: variable 'v3' is possibly undefined

//----- (001F2B82) --------------------------------------------------------
void __fastcall png_app_error(png_const_structrp_0 png_ptr, png_const_charp error_message)
{
  png_const_structrp_0 v2; // r0
  png_charp v3; // r1
  png_const_charp v4; // r2

  if ( (png_ptr->flags & 0x400000) != 0 )
  {
    png_warning(png_ptr, error_message);
  }
  else
  {
    j_png_error(png_ptr, error_message);
    png_format_buffer(v2, v3, v4);
  }
}
// 1F2B91: variable 'v2' is possibly undefined
// 1F2B91: variable 'v3' is possibly undefined
// 1F2B91: variable 'v4' is possibly undefined

//----- (001F2B94) --------------------------------------------------------
void __fastcall png_format_buffer(png_const_structrp_0 png_ptr, png_charp buffer, png_const_charp error_message)
{
  png_uint_32 chunk_name; // r0
  png_uint_32 v4; // r12
  int v5; // r3
  unsigned __int8 v6; // r4
  unsigned __int8 v7; // r3
  int v8; // r12
  png_uint_32 v9; // lr
  unsigned __int8 *v10; // r5
  unsigned __int8 v11; // r6
  int v12; // lr
  png_uint_32 v13; // r3
  unsigned __int8 v14; // r6
  unsigned __int8 *v15; // r5
  int v16; // r3
  unsigned __int8 v17; // r3
  unsigned __int8 *v18; // r6
  int v19; // r0
  int v20; // r12
  unsigned __int8 *v21; // lr
  int v22; // r0
  int v23; // r3

  chunk_name = png_ptr->chunk_name;
  v4 = HIBYTE(chunk_name);
  if ( HIBYTE(chunk_name) - 65 > 0x39u || HIBYTE(chunk_name) - 91 <= 5u )
  {
    v6 = png_digit[chunk_name >> 28];
    v7 = png_digit[HIBYTE(chunk_name) & 0xF];
    *buffer = 91;
    buffer[1] = v6;
    LOBYTE(v4) = 93;
    buffer[2] = v7;
    v5 = 3;
  }
  else
  {
    v5 = 0;
  }
  buffer[v5] = v4;
  v8 = v5 + 1;
  v9 = HIWORD(chunk_name);
  if ( (unsigned int)(unsigned __int8)__ROR4__(chunk_name, 16) - 65 > 0x39
    || (unsigned int)(unsigned __int8)__ROR4__(chunk_name, 16) - 91 < 6 )
  {
    v10 = &buffer[v5];
    buffer[v8] = 91;
    v11 = png_digit[(chunk_name >> 20) & 0xF];
    LOBYTE(v9) = 93;
    v8 = v5 | 4;
    v10[3] = png_digit[BYTE2(chunk_name) & 0xF];
    v10[2] = v11;
  }
  buffer[v8] = v9;
  v12 = v8 + 1;
  v13 = chunk_name >> 8;
  if ( (unsigned int)(unsigned __int8)__ROR4__(chunk_name, 8) - 65 > 0x39
    || (unsigned int)(unsigned __int8)__ROR4__(chunk_name, 8) - 91 < 6 )
  {
    buffer[v12] = 91;
    v14 = png_digit[(unsigned __int16)chunk_name >> 12];
    v12 = v8 + 4;
    v15 = &buffer[v8];
    v15[3] = png_digit[BYTE1(chunk_name) & 0xF];
    LOBYTE(v13) = 93;
    v15[2] = v14;
  }
  buffer[v12] = v13;
  v16 = v12 + 1;
  if ( (unsigned int)(unsigned __int8)chunk_name - 65 > 0x39 || (unsigned int)(unsigned __int8)chunk_name - 91 < 6 )
  {
    buffer[v16] = 91;
    v17 = png_digit[(unsigned __int8)chunk_name >> 4];
    v18 = &buffer[v12];
    v18[3] = png_digit[chunk_name & 0xF];
    LOBYTE(chunk_name) = 93;
    v18[2] = v17;
    v16 = v12 + 4;
  }
  buffer[v16] = chunk_name;
  v19 = v16 + 1;
  if ( error_message )
  {
    v20 = v16 + 3;
    buffer[v19] = 58;
    v21 = &buffer[v16 + 3];
    buffer[v16 + 2] = 32;
    v22 = 0;
    while ( error_message[v22] )
    {
      v21[v22] = error_message[v22];
      v23 = v22 + 1;
      if ( v22++ >= 194 )
      {
        v19 = v20 + v23;
        goto LABEL_20;
      }
    }
    v19 = v22 + v20;
  }
LABEL_20:
  buffer[v19] = 0;
}

//----- (001F2D00) --------------------------------------------------------
void __fastcall png_chunk_benign_error(png_const_structrp_0 png_ptr, png_const_charp error_message)
{
  unsigned __int8 buffer[214]; // [sp+6h] [bp-E2h] BYREF

  if ( (png_ptr->flags & 0x100000) == 0 )
  {
    j_png_chunk_error(png_ptr, error_message);
    JUMPOUT(0x1F2D50);
  }
  png_format_buffer(png_ptr, buffer, error_message);
  j_png_warning(png_ptr, buffer);
}
// 1F2D4E: control flows out of bounds to 1F2D50

//----- (001F2D58) --------------------------------------------------------
void __fastcall png_chunk_report(png_const_structrp_0 png_ptr, png_const_charp message, int error)
{
  const unsigned __int8 *v4; // r3
  png_uint_32 flags; // r0
  unsigned __int8 buffer[214]; // [sp+6h] [bp-E2h] BYREF

  v4 = message;
  if ( (png_ptr->mode & 0x8000) != 0 )
  {
    if ( error <= 1 || (png_ptr->flags & 0x100000) != 0 )
    {
      png_format_buffer(png_ptr, buffer, message);
      j_png_warning(png_ptr, buffer);
      return;
    }
LABEL_11:
    j_png_chunk_error(png_ptr, v4);
    JUMPOUT(0x1F2DF4);
  }
  flags = png_ptr->flags;
  if ( error > 0 )
  {
    if ( (flags & 0x400000) != 0 )
      goto LABEL_9;
    goto LABEL_10;
  }
  if ( (flags & 0x200000) == 0 )
  {
LABEL_10:
    j_png_error(png_ptr, message);
    goto LABEL_11;
  }
LABEL_9:
  png_warning(png_ptr, message);
}
// 1F2DF0: control flows out of bounds to 1F2DF4
// 1F2DF0: variable 'v4' is possibly undefined

//----- (001F2E04) --------------------------------------------------------
void __fastcall __noreturn png_fixed_error(png_const_structrp_0 png_ptr, png_const_charp name)
{
  unsigned __int8 v3; // r12
  const unsigned __int8 *v4; // r1
  unsigned int i; // r3
  _BYTE v6[232]; // [sp+0h] [bp-E8h] BYREF

  v3 = 0;
  v4 = v6;
  qmemcpy(v6, "fixed point overflow in ", 24);
  if ( !name )
    goto LABEL_6;
  for ( i = 0; i < 0xC3; ++i )
  {
    if ( !name[i] )
      break;
    v6[i + 24] = name[i];
  }
  while ( 1 )
  {
    v4[i + 24] = v3;
    j_png_error(png_ptr, v4);
LABEL_6:
    i = 0;
  }
}
// 1F2E44: variable 'v3' is possibly undefined
// 1F2E42: variable 'v4' is possibly undefined
// 1F2E48: variable 'png_ptr' is possibly undefined

//----- (001F2E54) --------------------------------------------------------
jmp_buf *__fastcall png_set_longjmp_fn(png_structrp_0 png_ptr, png_longjmp_ptr longjmp_fn, size_t jmp_buf_size)
{
  jmp_buf *result; // r0
  size_t v7; // r1

  if ( !png_ptr )
    return 0;
  result = png_ptr->jmp_buf_ptr;
  if ( result )
  {
    v7 = png_ptr->jmp_buf_size;
    if ( v7 )
    {
      if ( v7 == jmp_buf_size )
        goto LABEL_14;
    }
    else
    {
      if ( result != (jmp_buf *)png_ptr )
      {
        j_png_error(png_ptr, (png_const_charp)"Libpng jmp_buf still allocated");
        JUMPOUT(0x1F2ECC);
      }
      if ( jmp_buf_size == 256 )
        goto LABEL_14;
    }
    j_png_warning(png_ptr, (png_const_charp)"Application jmp_buf size changed");
    return 0;
  }
  png_ptr->jmp_buf_size = 0;
  if ( jmp_buf_size > 0x100 )
  {
    result = (jmp_buf *)j_png_malloc_warn(png_ptr, jmp_buf_size);
    png_ptr->jmp_buf_ptr = result;
    if ( !result )
      return 0;
    png_ptr->jmp_buf_size = jmp_buf_size;
  }
  else
  {
    png_ptr->jmp_buf_ptr = (jmp_buf *)png_ptr;
    result = (jmp_buf *)png_ptr;
  }
LABEL_14:
  png_ptr->longjmp_fn = longjmp_fn;
  return result;
}
// 1F2EC8: control flows out of bounds to 1F2ECC

//----- (001F2F10) --------------------------------------------------------
void __fastcall png_free_jmpbuf(png_structrp_0 png_ptr)
{
  png_struct *jmp_buf_ptr; // r5
  bool v3; // zf
  struct __jmp_buf_tag v4; // [sp+0h] [bp-110h] BYREF

  if ( png_ptr )
  {
    jmp_buf_ptr = (png_struct *)png_ptr->jmp_buf_ptr;
    if ( jmp_buf_ptr )
    {
      v3 = jmp_buf_ptr == png_ptr;
      if ( jmp_buf_ptr != png_ptr )
        v3 = png_ptr->jmp_buf_size == 0;
      if ( !v3 && !setjmp(&v4) )
      {
        png_ptr->jmp_buf_size = 0;
        png_ptr->longjmp_fn = (png_longjmp_ptr)&longjmp;
        png_ptr->jmp_buf_ptr = (jmp_buf *)&v4;
        j_png_free(png_ptr, jmp_buf_ptr);
      }
    }
    png_ptr->longjmp_fn = 0;
    png_ptr->jmp_buf_ptr = 0;
    png_ptr->jmp_buf_size = 0;
  }
}

//----- (001F2F68) --------------------------------------------------------
void __fastcall __noreturn png_longjmp(png_const_structrp_0 png_ptr, int val)
{
  png_longjmp_ptr longjmp_fn; // r2
  bool v3; // zf
  jmp_buf *jmp_buf_ptr; // r0

  v3 = png_ptr == 0;
  if ( png_ptr )
  {
    longjmp_fn = png_ptr->longjmp_fn;
    v3 = longjmp_fn == 0;
  }
  if ( !v3 )
  {
    jmp_buf_ptr = png_ptr->jmp_buf_ptr;
    if ( jmp_buf_ptr )
      longjmp_fn((int *)jmp_buf_ptr, val);
    abort();
  }
  abort();
}
// 1F2F84: variable 'longjmp_fn' is possibly undefined

//----- (001F2F8A) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall png_set_error_fn(
        png_structrp_0 png_ptr,
        png_voidp error_ptr,
        png_error_ptr error_fn,
        png_error_ptr warning_fn)
{
  if ( png_ptr )
  {
    *(_QWORD *)&png_ptr->error_fn = *(_QWORD *)&error_fn;
    png_ptr->error_ptr = error_ptr;
  }
}
// 1F2F8A: variables would overlap: r2.4 and r2.8

//----- (001F2F98) --------------------------------------------------------
png_voidp __fastcall png_get_error_ptr(png_const_structrp_0 png_ptr)
{
  if ( png_ptr )
    return png_ptr->error_ptr;
  else
    return 0;
}

//----- (001F2FA4) --------------------------------------------------------
void __fastcall __noreturn png_safe_error(png_structp png_nonconst_ptr, png_const_charp error_message)
{
  _BYTE *error_ptr; // lr
  int v3; // r2
  int v4; // r5
  int v5; // r4
  struct __jmp_buf_tag *v6; // r0
  bool v7; // zf
  int v8; // r2
  png_const_charp v9; // r1
  int v10; // r4
  int v11; // r5
  int v12; // r1

  error_ptr = png_nonconst_ptr->error_ptr;
  if ( error_ptr )
  {
    if ( error_message && (LOBYTE(v3) = *error_message) != 0 )
    {
      v4 = 0;
      do
      {
        v5 = v4 + 1;
        error_ptr[v4 + 32] = v3;
        if ( (unsigned int)(v4 + 1) > 0x3E )
          break;
        v3 = error_message[++v4];
      }
      while ( v3 );
    }
    else
    {
      v5 = 0;
    }
    error_ptr[v5 + 32] = 0;
    v6 = *(struct __jmp_buf_tag **)error_ptr;
    *((_DWORD *)error_ptr + 7) |= 2u;
    v7 = v6 == 0;
    if ( v6 )
    {
      v6 = (struct __jmp_buf_tag *)v6->__jmpbuf[2];
      v7 = v6 == 0;
    }
    if ( !v7 )
      longjmp(v6, 1);
    strcpy(error_ptr + 32, "bad longjmp: ");
    if ( error_message && (LOBYTE(v8) = *error_message) != 0 )
    {
      v9 = error_message + 1;
      v10 = 0;
      do
      {
        error_ptr[v10 + 45] = v8;
        v11 = v10 + 1;
        if ( (unsigned int)(v10 + 14) > 0x3E )
          break;
        v8 = v9[v10++];
      }
      while ( v8 );
      v12 = v11 + 13;
    }
    else
    {
      v12 = 13;
    }
    error_ptr[v12 + 32] = 0;
  }
  abort();
}

//----- (001F3068) --------------------------------------------------------
void __fastcall png_safe_warning(png_structp png_nonconst_ptr, png_const_charp warning_message)
{
  _BYTE *error_ptr; // lr
  int v3; // r2
  png_const_charp v4; // r1
  int v5; // r4
  int v6; // r0

  error_ptr = png_nonconst_ptr->error_ptr;
  if ( !*((_DWORD *)error_ptr + 7) )
  {
    if ( warning_message && (LOBYTE(v3) = *warning_message) != 0 )
    {
      v4 = warning_message + 1;
      v5 = 0;
      do
      {
        v6 = v5 + 1;
        error_ptr[v5 + 32] = v3;
        if ( (unsigned int)(v5 + 1) > 0x3E )
          break;
        v3 = v4[v5++];
      }
      while ( v3 );
    }
    else
    {
      v6 = 0;
    }
    error_ptr[v6 + 32] = 0;
    *((_DWORD *)error_ptr + 7) |= 1u;
  }
}

//----- (001F30B4) --------------------------------------------------------
int __fastcall png_safe_execute(png_imagep image_in, int (*function)(png_voidp), png_voidp arg)
{
  jmp_buf env; // [sp+4h] [bp-11Ch] BYREF
  png_voidp error_buf; // [sp+104h] [bp-1Ch]
  int v8; // [sp+108h] [bp-18h]
  png_imagep v9; // [sp+10Ch] [bp-14h]

  v9 = image_in;
  error_buf = image_in->opaque->error_buf;
  v8 = setjmp((struct __jmp_buf_tag *)env) == 0;
  if ( v8 )
  {
    v9->opaque->error_buf = env;
    v8 = function(arg);
  }
  v9->opaque->error_buf = error_buf;
  if ( !v8 )
    j_png_image_free(v9);
  return v8;
}

//----- (001F3110) --------------------------------------------------------
png_uint_32 __fastcall png_get_valid(png_const_structrp_1 png_ptr, png_const_inforp info_ptr, png_uint_32 flag)
{
  png_uint_32 result; // r0

  result = 0;
  if ( png_ptr )
  {
    if ( info_ptr )
      return info_ptr->valid & flag;
  }
  return result;
}

//----- (001F3124) --------------------------------------------------------
png_size_t __fastcall png_get_rowbytes(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  png_size_t result; // r0

  result = 0;
  if ( png_ptr )
  {
    if ( info_ptr )
      return info_ptr->rowbytes;
  }
  return result;
}

//----- (001F3136) --------------------------------------------------------
png_bytepp __fastcall png_get_rows(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  png_bytepp result; // r0

  result = 0;
  if ( png_ptr )
  {
    if ( info_ptr )
      return info_ptr->row_pointers;
  }
  return result;
}

//----- (001F314A) --------------------------------------------------------
png_uint_32 __fastcall png_get_image_width(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  png_uint_32 result; // r0

  result = 0;
  if ( png_ptr )
  {
    if ( info_ptr )
      return info_ptr->width;
  }
  return result;
}

//----- (001F315C) --------------------------------------------------------
png_uint_32 __fastcall png_get_image_height(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  png_uint_32 result; // r0

  result = 0;
  if ( png_ptr )
  {
    if ( info_ptr )
      return info_ptr->height;
  }
  return result;
}

//----- (001F316E) --------------------------------------------------------
png_byte __fastcall png_get_bit_depth(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  png_byte result; // r0

  result = 0;
  if ( png_ptr )
  {
    if ( info_ptr )
      return info_ptr->bit_depth;
  }
  return result;
}

//----- (001F3180) --------------------------------------------------------
png_byte __fastcall png_get_color_type(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  png_byte result; // r0

  result = 0;
  if ( png_ptr )
  {
    if ( info_ptr )
      return info_ptr->color_type;
  }
  return result;
}

//----- (001F3192) --------------------------------------------------------
png_byte __fastcall png_get_filter_type(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  png_byte result; // r0

  result = 0;
  if ( png_ptr )
  {
    if ( info_ptr )
      return info_ptr->filter_type;
  }
  return result;
}

//----- (001F31A4) --------------------------------------------------------
png_byte __fastcall png_get_interlace_type(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  png_byte result; // r0

  result = 0;
  if ( png_ptr )
  {
    if ( info_ptr )
      return info_ptr->interlace_type;
  }
  return result;
}

//----- (001F31B6) --------------------------------------------------------
png_byte __fastcall png_get_compression_type(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  png_byte result; // r0

  result = 0;
  if ( png_ptr )
  {
    if ( info_ptr )
      return info_ptr->compression_type;
  }
  return result;
}

//----- (001F31C8) --------------------------------------------------------
png_uint_32 __fastcall png_get_x_pixels_per_meter(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  bool v2; // zf
  png_uint_32 result; // r0

  v2 = png_ptr == 0;
  result = 0;
  if ( !v2 )
    v2 = info_ptr == 0;
  if ( !v2 )
  {
    if ( (info_ptr->valid & 0x80) != 0 && info_ptr->phys_unit_type == 1 )
      return info_ptr->x_pixels_per_unit;
    else
      return 0;
  }
  return result;
}

//----- (001F31EE) --------------------------------------------------------
png_uint_32 __fastcall png_get_y_pixels_per_meter(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  bool v2; // zf
  png_uint_32 result; // r0

  v2 = png_ptr == 0;
  result = 0;
  if ( !v2 )
    v2 = info_ptr == 0;
  if ( !v2 )
  {
    if ( (info_ptr->valid & 0x80) != 0 && info_ptr->phys_unit_type == 1 )
      return info_ptr->y_pixels_per_unit;
    else
      return 0;
  }
  return result;
}

//----- (001F3214) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
png_uint_32 __fastcall png_get_pixels_per_meter(png_uint_32 png_ptr, png_const_inforp info_ptr)
{
  bool v2; // zf
  int v3; // r1
  int v4; // r1
  int v5; // r1
  bool v6; // zf
  int v7; // r1

  v2 = png_ptr == 0;
  if ( png_ptr )
    v2 = v3 == 0;
  if ( v2 || (*(_BYTE *)(v4 + 8) & 0x80) == 0 )
    return 0;
  png_ptr = *(unsigned __int8 *)(v5 + 200);
  v6 = png_ptr == 1;
  if ( png_ptr == 1 )
  {
    *(_QWORD *)&png_ptr = *(_QWORD *)(v7 + 192);
    v6 = png_ptr == v7;
  }
  if ( !v6 )
    return 0;
  return png_ptr;
}
// 1F3214: variables would overlap: r0.4 and r0.8

//----- (001F3238) --------------------------------------------------------
float __fastcall png_get_pixel_aspect_ratio(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  bool v2; // zf
  float v3; // s0
  png_uint_32 x_pixels_per_unit; // r0

  v2 = png_ptr == 0;
  v3 = 0.0;
  if ( png_ptr )
    v2 = info_ptr == 0;
  if ( !v2 && (info_ptr->valid & 0x80) != 0 )
  {
    x_pixels_per_unit = info_ptr->x_pixels_per_unit;
    if ( x_pixels_per_unit )
      return (float)info_ptr->y_pixels_per_unit / (float)x_pixels_per_unit;
  }
  return v3;
}

//----- (001F3270) --------------------------------------------------------
png_fixed_point __fastcall png_get_pixel_aspect_ratio_fixed(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  bool v2; // zf
  png_int_32 x_pixels_per_unit; // r3
  bool v4; // cc
  png_fixed_point v6; // [sp+4h] [bp-Ch] BYREF

  v2 = png_ptr == 0;
  if ( png_ptr )
    v2 = info_ptr == 0;
  if ( v2 )
    return 0;
  if ( (info_ptr->valid & 0x80) == 0 )
    return 0;
  x_pixels_per_unit = info_ptr->x_pixels_per_unit;
  v4 = x_pixels_per_unit < 0;
  if ( !x_pixels_per_unit )
    return 0;
  if ( x_pixels_per_unit >= 0 )
  {
    info_ptr = (png_const_inforp)info_ptr->y_pixels_per_unit;
    v4 = (int)info_ptr < 1;
  }
  if ( !v4 && j_png_muldiv(&v6, (png_fixed_point)info_ptr, (png_int_32)&elf_hash_chain[8526], x_pixels_per_unit) )
    return v6;
  else
    return 0;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (001F32B4) --------------------------------------------------------
png_int_32 __fastcall png_get_x_offset_microns(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  bool v2; // zf
  png_int_32 result; // r0

  v2 = png_ptr == 0;
  result = 0;
  if ( !v2 )
    v2 = info_ptr == 0;
  if ( !v2 )
  {
    if ( BYTE1(info_ptr->valid) << 31 && info_ptr->offset_unit_type == 1 )
      return info_ptr->x_offset;
    else
      return 0;
  }
  return result;
}

//----- (001F32DA) --------------------------------------------------------
png_int_32 __fastcall png_get_y_offset_microns(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  bool v2; // zf
  png_int_32 result; // r0

  v2 = png_ptr == 0;
  result = 0;
  if ( !v2 )
    v2 = info_ptr == 0;
  if ( !v2 )
  {
    if ( BYTE1(info_ptr->valid) << 31 && info_ptr->offset_unit_type == 1 )
      return info_ptr->y_offset;
    else
      return 0;
  }
  return result;
}

//----- (001F3300) --------------------------------------------------------
png_int_32 __fastcall png_get_x_offset_pixels(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  bool v2; // zf
  png_int_32 result; // r0

  v2 = png_ptr == 0;
  result = 0;
  if ( !v2 )
    v2 = info_ptr == 0;
  if ( !v2 )
  {
    if ( BYTE1(info_ptr->valid) << 31 && !info_ptr->offset_unit_type )
      return info_ptr->x_offset;
    else
      return 0;
  }
  return result;
}

//----- (001F3324) --------------------------------------------------------
png_int_32 __fastcall png_get_y_offset_pixels(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  bool v2; // zf
  png_int_32 result; // r0

  v2 = png_ptr == 0;
  result = 0;
  if ( !v2 )
    v2 = info_ptr == 0;
  if ( !v2 )
  {
    if ( BYTE1(info_ptr->valid) << 31 && !info_ptr->offset_unit_type )
      return info_ptr->y_offset;
    else
      return 0;
  }
  return result;
}

//----- (001F3348) --------------------------------------------------------
png_uint_32 __fastcall png_get_pixels_per_inch(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  png_fixed_point x_pixels_per_unit; // r2
  bool v3; // zf
  int phys_unit_type; // r0
  bool v5; // zf
  int v6; // r1
  png_uint_32 result; // r0
  png_fixed_point res; // [sp+4h] [bp-Ch] BYREF

  v3 = png_ptr == 0;
  if ( png_ptr )
    v3 = info_ptr == 0;
  if ( v3 || (info_ptr->valid & 0x80) == 0 )
    goto LABEL_8;
  phys_unit_type = info_ptr->phys_unit_type;
  v5 = phys_unit_type == 1;
  if ( phys_unit_type == 1 )
  {
    x_pixels_per_unit = info_ptr->x_pixels_per_unit;
    v5 = x_pixels_per_unit == info_ptr->y_pixels_per_unit;
  }
  if ( v5 )
  {
    if ( x_pixels_per_unit < 0 )
      return 0;
  }
  else
  {
LABEL_8:
    x_pixels_per_unit = 0;
  }
  v6 = j_png_muldiv(&res, x_pixels_per_unit, 127, 5000);
  result = res;
  if ( !v6 )
    return 0;
  return result;
}
// 1F3378: variable 'x_pixels_per_unit' is possibly undefined

//----- (001F3394) --------------------------------------------------------
png_uint_32 __fastcall png_get_x_pixels_per_inch(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  bool v2; // zf
  png_fixed_point x_pixels_per_unit; // r1
  png_uint_32 result; // r0
  int v5; // r1
  png_fixed_point res; // [sp+4h] [bp-Ch] BYREF

  v2 = png_ptr == 0;
  if ( png_ptr )
    v2 = info_ptr == 0;
  if ( !v2 && (info_ptr->valid & 0x80) != 0 && info_ptr->phys_unit_type == 1 )
  {
    x_pixels_per_unit = info_ptr->x_pixels_per_unit;
    if ( x_pixels_per_unit < 0 )
      return 0;
  }
  else
  {
    x_pixels_per_unit = 0;
  }
  v5 = j_png_muldiv(&res, x_pixels_per_unit, 127, 5000);
  result = res;
  if ( !v5 )
    return 0;
  return result;
}

//----- (001F33DA) --------------------------------------------------------
png_uint_32 __fastcall png_get_y_pixels_per_inch(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  bool v2; // zf
  png_fixed_point y_pixels_per_unit; // r1
  png_uint_32 result; // r0
  int v5; // r1
  png_fixed_point res; // [sp+4h] [bp-Ch] BYREF

  v2 = png_ptr == 0;
  if ( png_ptr )
    v2 = info_ptr == 0;
  if ( !v2 && (info_ptr->valid & 0x80) != 0 && info_ptr->phys_unit_type == 1 )
  {
    y_pixels_per_unit = info_ptr->y_pixels_per_unit;
    if ( y_pixels_per_unit < 0 )
      return 0;
  }
  else
  {
    y_pixels_per_unit = 0;
  }
  v5 = j_png_muldiv(&res, y_pixels_per_unit, 127, 5000);
  result = res;
  if ( !v5 )
    return 0;
  return result;
}

//----- (001F3420) --------------------------------------------------------
png_fixed_point __fastcall png_get_x_offset_inches_fixed(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  bool v2; // zf
  png_fixed_point x_offset; // r1

  v2 = png_ptr == 0;
  x_offset = 0;
  if ( png_ptr )
    v2 = info_ptr == 0;
  if ( !v2 )
  {
    if ( BYTE1(info_ptr->valid) << 31 )
    {
      if ( info_ptr->offset_unit_type == 1 )
        x_offset = info_ptr->x_offset;
      else
        x_offset = 0;
    }
    else
    {
      x_offset = 0;
    }
  }
  return sub_198438(png_ptr, x_offset, 500, 127);
}

//----- (001F3450) --------------------------------------------------------
png_fixed_point __fastcall png_get_y_offset_inches_fixed(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  bool v2; // zf
  png_fixed_point y_offset; // r1

  v2 = png_ptr == 0;
  y_offset = 0;
  if ( png_ptr )
    v2 = info_ptr == 0;
  if ( !v2 )
  {
    if ( BYTE1(info_ptr->valid) << 31 )
    {
      if ( info_ptr->offset_unit_type == 1 )
        y_offset = info_ptr->y_offset;
      else
        y_offset = 0;
    }
    else
    {
      y_offset = 0;
    }
  }
  return sub_198438(png_ptr, y_offset, 500, 127);
}

//----- (001F3480) --------------------------------------------------------
float __fastcall png_get_x_offset_inches(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  float v2; // s0
  bool v3; // zf

  v2 = 0.0;
  if ( png_ptr )
  {
    v3 = info_ptr == 0;
    if ( info_ptr )
      v3 = BYTE1(info_ptr->valid) << 31 == 0;
    if ( !v3 && info_ptr->offset_unit_type == 1 )
      return (double)info_ptr->x_offset * 0.00003937;
  }
  return v2;
}

//----- (001F34C8) --------------------------------------------------------
float __fastcall png_get_y_offset_inches(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  float v2; // s0
  bool v3; // zf

  v2 = 0.0;
  if ( png_ptr )
  {
    v3 = info_ptr == 0;
    if ( info_ptr )
      v3 = BYTE1(info_ptr->valid) << 31 == 0;
    if ( !v3 && info_ptr->offset_unit_type == 1 )
      return (double)info_ptr->y_offset * 0.00003937;
  }
  return v2;
}

//----- (001F3510) --------------------------------------------------------
png_uint_32 __fastcall png_get_pHYs_dpi(
        png_const_structrp_1 png_ptr,
        png_const_inforp info_ptr,
        png_uint_32 *res_x,
        png_uint_32 *res_y,
        _DWORD *a5)
{
  bool v5; // zf
  png_uint_32 result; // r0
  int phys_unit_type; // r0

  v5 = png_ptr == 0;
  result = 0;
  if ( !v5 )
    v5 = info_ptr == 0;
  if ( !v5 )
  {
    if ( (info_ptr->valid & 0x80) != 0 )
    {
      if ( res_x )
      {
        *res_x = info_ptr->x_pixels_per_unit;
        result = 128;
      }
      else
      {
        result = 0;
      }
      if ( res_y )
      {
        *res_y = info_ptr->y_pixels_per_unit;
        result = 128;
      }
      if ( a5 )
      {
        phys_unit_type = info_ptr->phys_unit_type;
        *a5 = phys_unit_type;
        if ( phys_unit_type == 1 )
        {
          if ( res_x )
            *res_x = (unsigned int)((double)*res_x * 0.0254 + 0.5);
          if ( res_y )
            *res_y = (unsigned int)((double)*res_y * 0.0254 + 0.5);
        }
        return 128;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (001F35B0) --------------------------------------------------------
png_byte __fastcall png_get_channels(png_const_structrp_1 png_ptr, png_const_inforp info_ptr)
{
  png_byte result; // r0

  result = 0;
  if ( png_ptr )
  {
    if ( info_ptr )
      return info_ptr->channels;
  }
  return result;
}

//----- (001F35C2) --------------------------------------------------------
png_const_bytep __fastcall png_get_signature(png_const_bytep png_ptr, png_const_inforp info_ptr)
{
  if ( info_ptr )
    info_ptr = (png_const_inforp)((char *)info_ptr + 32);
  if ( png_ptr )
    return (png_const_bytep)info_ptr;
  return png_ptr;
}

//----- (001F35D0) --------------------------------------------------------
png_uint_32 __fastcall png_get_bKGD(png_const_structrp_1 png_ptr, png_inforp_0 info_ptr, png_color_16p *background)
{
  png_uint_32 result; // r0
  bool v5; // zf

  result = 0;
  if ( png_ptr )
  {
    v5 = info_ptr == 0;
    if ( info_ptr )
    {
      result = 0;
      v5 = background == 0;
    }
    if ( !v5 && (info_ptr->valid & 0x20) != 0 )
    {
      *background = &info_ptr->background;
      return 32;
    }
  }
  return result;
}

//----- (001F35F8) --------------------------------------------------------
png_uint_32 __fastcall png_get_cHRM(
        png_const_structrp_1 png_ptr,
        png_const_inforp info_ptr,
        double *white_x,
        double *white_y,
        double *red_x,
        double *red_y,
        double *green_x,
        double *green_y,
        double *blue_x,
        double *blue_y)
{
  bool v10; // zf
  png_uint_32 result; // r0

  v10 = png_ptr == 0;
  result = 0;
  if ( !v10 )
    v10 = info_ptr == 0;
  if ( !v10 )
  {
    if ( (info_ptr->colorspace.flags & 2) != 0 )
    {
      if ( white_x )
        *white_x = (double)info_ptr->colorspace.end_points_xy.whitex * 0.00001;
      if ( white_y )
        *white_y = (double)info_ptr->colorspace.end_points_xy.whitey * 0.00001;
      if ( red_x )
        *red_x = (double)info_ptr->colorspace.end_points_xy.redx * 0.00001;
      if ( red_y )
        *red_y = (double)info_ptr->colorspace.end_points_xy.redy * 0.00001;
      if ( green_x )
        *green_x = (double)info_ptr->colorspace.end_points_xy.greenx * 0.00001;
      if ( green_y )
        *green_y = (double)info_ptr->colorspace.end_points_xy.greeny * 0.00001;
      if ( blue_x )
        *blue_x = (double)info_ptr->colorspace.end_points_xy.bluex * 0.00001;
      if ( blue_y )
        *blue_y = (double)info_ptr->colorspace.end_points_xy.bluey * 0.00001;
      return 4;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (001F36E0) --------------------------------------------------------
png_uint_32 __fastcall png_get_cHRM_XYZ(
        png_const_structrp_1 png_ptr,
        png_const_inforp info_ptr,
        double *red_X,
        double *red_Y,
        double *red_Z,
        double *green_X,
        double *green_Y,
        double *green_Z,
        double *blue_X,
        double *blue_Y,
        double *blue_Z)
{
  bool v11; // zf
  png_uint_32 result; // r0

  v11 = png_ptr == 0;
  result = 0;
  if ( !v11 )
    v11 = info_ptr == 0;
  if ( !v11 )
  {
    if ( (info_ptr->colorspace.flags & 2) != 0 )
    {
      if ( red_X )
        *red_X = (double)info_ptr->colorspace.end_points_XYZ.red_X * 0.00001;
      if ( red_Y )
        *red_Y = (double)info_ptr->colorspace.end_points_XYZ.red_Y * 0.00001;
      if ( red_Z )
        *red_Z = (double)info_ptr->colorspace.end_points_XYZ.red_Z * 0.00001;
      if ( green_X )
        *green_X = (double)info_ptr->colorspace.end_points_XYZ.green_X * 0.00001;
      if ( green_Y )
        *green_Y = (double)info_ptr->colorspace.end_points_XYZ.green_Y * 0.00001;
      if ( green_Z )
        *green_Z = (double)info_ptr->colorspace.end_points_XYZ.green_Z * 0.00001;
      if ( blue_X )
        *blue_X = (double)info_ptr->colorspace.end_points_XYZ.blue_X * 0.00001;
      if ( blue_Y )
        *blue_Y = (double)info_ptr->colorspace.end_points_XYZ.blue_Y * 0.00001;
      if ( blue_Z )
        *blue_Z = (double)info_ptr->colorspace.end_points_XYZ.blue_Z * 0.00001;
      return 4;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (001F37E0) --------------------------------------------------------
png_uint_32 __fastcall png_get_cHRM_XYZ_fixed(
        png_const_structrp_1 png_ptr,
        png_const_inforp info_ptr,
        png_fixed_point *int_red_X,
        png_fixed_point *int_red_Y,
        png_fixed_point *int_red_Z,
        png_fixed_point *int_green_X,
        png_fixed_point *int_green_Y,
        png_fixed_point *int_green_Z,
        png_fixed_point *int_blue_X,
        png_fixed_point *int_blue_Y,
        png_fixed_point *int_blue_Z)
{
  bool v11; // zf
  png_uint_32 result; // r0

  v11 = png_ptr == 0;
  result = 0;
  if ( !v11 )
    v11 = info_ptr == 0;
  if ( !v11 )
  {
    if ( (info_ptr->colorspace.flags & 2) != 0 )
    {
      if ( int_red_X )
        *int_red_X = info_ptr->colorspace.end_points_XYZ.red_X;
      if ( int_red_Y )
        *int_red_Y = info_ptr->colorspace.end_points_XYZ.red_Y;
      if ( int_red_Z )
        *int_red_Z = info_ptr->colorspace.end_points_XYZ.red_Z;
      if ( int_green_X )
        *int_green_X = info_ptr->colorspace.end_points_XYZ.green_X;
      if ( int_green_Y )
        *int_green_Y = info_ptr->colorspace.end_points_XYZ.green_Y;
      if ( int_green_Z )
        *int_green_Z = info_ptr->colorspace.end_points_XYZ.green_Z;
      if ( int_blue_X )
        *int_blue_X = info_ptr->colorspace.end_points_XYZ.blue_X;
      if ( int_blue_Y )
        *int_blue_Y = info_ptr->colorspace.end_points_XYZ.blue_Y;
      if ( int_blue_Z )
        *int_blue_Z = info_ptr->colorspace.end_points_XYZ.blue_Z;
      return 4;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (001F3856) --------------------------------------------------------
png_uint_32 __fastcall png_get_cHRM_fixed(
        png_const_structrp_1 png_ptr,
        png_const_inforp info_ptr,
        png_fixed_point *white_x,
        png_fixed_point *white_y,
        png_fixed_point *red_x,
        png_fixed_point *red_y,
        png_fixed_point *green_x,
        png_fixed_point *green_y,
        png_fixed_point *blue_x,
        png_fixed_point *blue_y)
{
  bool v10; // zf
  png_uint_32 result; // r0

  v10 = png_ptr == 0;
  result = 0;
  if ( !v10 )
    v10 = info_ptr == 0;
  if ( !v10 )
  {
    if ( (info_ptr->colorspace.flags & 2) != 0 )
    {
      if ( white_x )
        *white_x = info_ptr->colorspace.end_points_xy.whitex;
      if ( white_y )
        *white_y = info_ptr->colorspace.end_points_xy.whitey;
      if ( red_x )
        *red_x = info_ptr->colorspace.end_points_xy.redx;
      if ( red_y )
        *red_y = info_ptr->colorspace.end_points_xy.redy;
      if ( green_x )
        *green_x = info_ptr->colorspace.end_points_xy.greenx;
      if ( green_y )
        *green_y = info_ptr->colorspace.end_points_xy.greeny;
      if ( blue_x )
        *blue_x = info_ptr->colorspace.end_points_xy.bluex;
      if ( blue_y )
        *blue_y = info_ptr->colorspace.end_points_xy.bluey;
      return 4;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (001F38C2) --------------------------------------------------------
png_uint_32 __fastcall png_get_gAMA_fixed(
        png_const_structrp_1 png_ptr,
        png_const_inforp info_ptr,
        png_fixed_point *file_gamma)
{
  png_uint_32 result; // r0
  bool v5; // zf

  result = 0;
  if ( png_ptr )
  {
    v5 = info_ptr == 0;
    if ( info_ptr )
    {
      result = 0;
      v5 = file_gamma == 0;
    }
    if ( !v5 && (info_ptr->colorspace.flags & 1) != 0 )
    {
      *file_gamma = info_ptr->colorspace.gamma;
      return 1;
    }
  }
  return result;
}

//----- (001F38E8) --------------------------------------------------------
png_uint_32 __fastcall png_get_gAMA(png_const_structrp_1 png_ptr, png_const_inforp info_ptr, double *file_gamma)
{
  bool v3; // zf
  png_uint_32 result; // r0
  bool v5; // zf

  v3 = png_ptr == 0;
  result = 0;
  if ( !v3 )
    v3 = info_ptr == 0;
  if ( !v3 )
  {
    v5 = file_gamma == 0;
    result = 0;
    if ( file_gamma )
      v5 = (info_ptr->colorspace.flags & 1) == 0;
    if ( !v5 )
    {
      result = 1;
      *file_gamma = (double)info_ptr->colorspace.gamma * 0.00001;
    }
  }
  return result;
}

//----- (001F3928) --------------------------------------------------------
png_uint_32 __fastcall png_get_sRGB(png_const_structrp_1 png_ptr, png_const_inforp info_ptr, int *file_srgb_intent)
{
  png_uint_32 result; // r0
  bool v5; // zf

  result = 0;
  if ( png_ptr )
  {
    v5 = info_ptr == 0;
    if ( info_ptr )
    {
      result = 0;
      v5 = file_srgb_intent == 0;
    }
    if ( !v5 && (info_ptr->valid & 0x800) != 0 )
    {
      *file_srgb_intent = info_ptr->colorspace.rendering_intent;
      return 2048;
    }
  }
  return result;
}

//----- (001F3950) --------------------------------------------------------
png_uint_32 __fastcall png_get_iCCP(
        png_const_structrp_1 png_ptr,
        png_inforp_0 info_ptr,
        png_charpp name,
        int *compression_type,
        _DWORD *a5,
        _DWORD *a6)
{
  _DWORD *v6; // lr
  bool v7; // zf
  png_uint_32 result; // r0
  bool v9; // zf
  bool v10; // zf
  __int64 v11; // r0

  v7 = png_ptr == 0;
  result = 0;
  if ( !v7 )
    v7 = info_ptr == 0;
  if ( !v7 )
  {
    result = 0;
    v9 = a6 == 0;
    if ( a6 )
    {
      v6 = a5;
      v9 = a5 == 0;
    }
    if ( !v9 )
    {
      v10 = compression_type == 0;
      if ( compression_type )
        v10 = name == 0;
      if ( !v10 && (info_ptr->valid & 0x1000) != 0 )
      {
        v11 = *(_QWORD *)&info_ptr->iccp_name;
        *name = (unsigned __int8 *)v11;
        *v6 = HIDWORD(v11);
        *a6 = bswap32(*(_DWORD *)HIDWORD(v11));
        *compression_type = 0;
        return 4096;
      }
    }
  }
  return result;
}
// 1F3990: variable 'v6' is possibly undefined

//----- (001F39AA) --------------------------------------------------------
int __fastcall png_get_sPLT(png_const_structrp_1 png_ptr, png_inforp_0 info_ptr, png_sPLT_tpp spalettes)
{
  bool v3; // zf
  int result; // r0

  v3 = png_ptr == 0;
  result = 0;
  if ( !v3 )
    v3 = info_ptr == 0;
  if ( !v3 )
  {
    if ( spalettes )
    {
      result = info_ptr->splt_palettes_num;
      *spalettes = info_ptr->splt_palettes;
    }
  }
  return result;
}

//----- (001F39C4) --------------------------------------------------------
png_uint_32 __fastcall png_get_eXIf(png_const_structrp_1 png_ptr, png_inforp_0 info_ptr, png_bytep *exif)
{
  j_png_warning(png_ptr, (png_const_charp)"png_get_eXIf does not work; use png_get_eXIf_1");
  return 0;
}

//----- (001F3A04) --------------------------------------------------------
png_uint_32 __fastcall png_get_eXIf_1(
        png_const_structrp_1 png_ptr,
        png_const_inforp info_ptr,
        png_uint_32 *num_exif,
        png_bytep *exif)
{
  png_uint_32 result; // r0
  bool v6; // zf

  result = 0;
  if ( png_ptr )
  {
    v6 = info_ptr == 0;
    if ( info_ptr )
    {
      result = 0;
      v6 = exif == 0;
    }
    if ( !v6 && (info_ptr->valid & 0x10000) != 0 )
    {
      *(_QWORD *)num_exif = *(_QWORD *)&info_ptr->num_exif;
      return 0x10000;
    }
  }
  return result;
}

//----- (001F3A32) --------------------------------------------------------
png_uint_32 __fastcall png_get_hIST(png_const_structrp_1 png_ptr, png_inforp_0 info_ptr, png_uint_16p *hist)
{
  png_uint_32 result; // r0
  bool v5; // zf

  result = 0;
  if ( png_ptr )
  {
    v5 = info_ptr == 0;
    if ( info_ptr )
    {
      result = 0;
      v5 = hist == 0;
    }
    if ( !v5 && (info_ptr->valid & 0x40) != 0 )
    {
      *hist = info_ptr->hist;
      return 64;
    }
  }
  return result;
}

//----- (001F3A58) --------------------------------------------------------
png_uint_32 __fastcall png_get_IHDR(
        png_const_structrp_1 png_ptr,
        png_const_inforp info_ptr,
        png_uint_32 *width,
        png_uint_32 *height,
        int *bit_depth,
        int *color_type,
        int *interlace_type,
        int *compression_type,
        int *filter_type)
{
  bool v9; // zf
  int v10; // r12
  int v11; // lr

  v9 = png_ptr == 0;
  v10 = 0;
  if ( png_ptr )
    v9 = info_ptr == 0;
  if ( !v9 )
  {
    if ( width )
      *width = info_ptr->width;
    if ( height )
      *height = info_ptr->height;
    if ( bit_depth )
      *bit_depth = info_ptr->bit_depth;
    if ( color_type )
      *color_type = info_ptr->color_type;
    if ( compression_type )
      *compression_type = info_ptr->compression_type;
    if ( filter_type )
      *filter_type = info_ptr->filter_type;
    v11 = info_ptr->interlace_type;
    if ( interlace_type )
      *interlace_type = v11;
    j_png_check_IHDR(
      png_ptr,
      info_ptr->width,
      info_ptr->height,
      info_ptr->bit_depth,
      info_ptr->color_type,
      v11,
      info_ptr->compression_type,
      info_ptr->filter_type);
    return 1;
  }
  return v10;
}

//----- (001F3AEC) --------------------------------------------------------
png_uint_32 __fastcall png_get_oFFs(
        png_const_structrp_1 png_ptr,
        png_const_inforp info_ptr,
        png_int_32 *offset_x,
        png_int_32 *offset_y,
        const png_struct *a5)
{
  png_uint_32 result; // r0
  bool v7; // zf
  bool v8; // zf
  png_int_32 y_offset; // lr

  result = 0;
  if ( png_ptr )
  {
    v7 = info_ptr == 0;
    if ( info_ptr )
    {
      png_ptr = a5;
      result = 0;
      v7 = a5 == 0;
    }
    if ( !v7 )
    {
      v8 = offset_y == 0;
      if ( offset_y )
        v8 = offset_x == 0;
      if ( !v8 && (info_ptr->valid & 0x100) != 0 )
      {
        y_offset = info_ptr->y_offset;
        *offset_x = info_ptr->x_offset;
        *offset_y = y_offset;
        png_ptr->jmp_buf_local[0] = info_ptr->offset_unit_type;
        return 256;
      }
    }
  }
  return result;
}

//----- (001F3B38) --------------------------------------------------------
png_uint_32 __fastcall png_get_pCAL(
        png_const_structrp_1 png_ptr,
        png_inforp_0 info_ptr,
        png_charp *purpose,
        png_int_32 *X0,
        png_int_32 *a5,
        _DWORD *a6,
        _DWORD *a7,
        png_charp *a8,
        const png_struct *a9)
{
  _DWORD *v9; // r8
  png_int_32 *v10; // r10
  png_uint_32 result; // r0
  bool v13; // zf
  bool v14; // zf
  bool v15; // zf
  bool v16; // zf
  png_int_32 pcal_X0; // r4
  png_int_32 pcal_X1; // r5
  png_charp pcal_units; // r6
  png_charpp pcal_params; // r11

  result = 0;
  if ( png_ptr )
  {
    v13 = info_ptr == 0;
    if ( info_ptr )
    {
      png_ptr = a9;
      result = 0;
      v13 = a9 == 0;
    }
    if ( !v13 )
    {
      v14 = a8 == 0;
      if ( a8 )
      {
        v9 = a7;
        v14 = a7 == 0;
      }
      if ( !v14 )
      {
        v15 = a6 == 0;
        if ( a6 )
        {
          v10 = a5;
          v15 = a5 == 0;
        }
        if ( !v15 )
        {
          v16 = X0 == 0;
          if ( X0 )
            v16 = purpose == 0;
          if ( !v16 && (info_ptr->valid & 0x400) != 0 )
          {
            pcal_X0 = info_ptr->pcal_X0;
            pcal_X1 = info_ptr->pcal_X1;
            pcal_units = info_ptr->pcal_units;
            pcal_params = info_ptr->pcal_params;
            *purpose = info_ptr->pcal_purpose;
            *X0 = pcal_X0;
            *v10 = pcal_X1;
            *a6 = info_ptr->pcal_type;
            *v9 = info_ptr->pcal_nparams;
            *a8 = pcal_units;
            png_ptr->jmp_buf_local[0] = (int)pcal_params;
            return 1024;
          }
        }
      }
    }
  }
  return result;
}
// 1F3BA0: variable 'v10' is possibly undefined
// 1F3BB2: variable 'v9' is possibly undefined

//----- (001F3BC8) --------------------------------------------------------
png_uint_32 __fastcall png_get_sCAL_fixed(
        png_const_structrp_1 png_ptr,
        png_const_inforp info_ptr,
        int *unit,
        png_fixed_point *width,
        _DWORD *a5)
{
  bool v6; // zf
  png_uint_32 result; // r0
  double v10; // r0
  double v11; // r0

  v6 = png_ptr == 0;
  result = 0;
  if ( !v6 )
    v6 = info_ptr == 0;
  if ( !v6 )
  {
    if ( (info_ptr->valid & 0x4000) != 0 )
    {
      *unit = info_ptr->scal_unit;
      v10 = atof((const char *)info_ptr->scal_s_width);
      *width = j_png_fixed(png_ptr, v10, (png_const_charp)"sCAL width");
      v11 = atof((const char *)info_ptr->scal_s_height);
      *a5 = j_png_fixed(png_ptr, v11, (png_const_charp)"sCAL height");
      return 0x4000;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (001F3C50) --------------------------------------------------------
png_uint_32 __fastcall png_get_sCAL(
        png_const_structrp_1 png_ptr,
        png_const_inforp info_ptr,
        int *unit,
        double *width,
        double *a5)
{
  bool v6; // zf
  png_uint_32 result; // r0

  v6 = png_ptr == 0;
  result = 0;
  if ( !v6 )
    v6 = info_ptr == 0;
  if ( !v6 )
  {
    if ( (info_ptr->valid & 0x4000) != 0 )
    {
      *unit = info_ptr->scal_unit;
      *width = atof((const char *)info_ptr->scal_s_width);
      *a5 = atof((const char *)info_ptr->scal_s_height);
      return 0x4000;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (001F3CA2) --------------------------------------------------------
png_uint_32 __fastcall png_get_sCAL_s(
        png_const_structrp_1 png_ptr,
        png_const_inforp info_ptr,
        int *unit,
        png_charpp width,
        _DWORD *a5)
{
  bool v5; // zf
  png_uint_32 result; // r0
  __int64 v7; // r0

  v5 = png_ptr == 0;
  result = 0;
  if ( !v5 )
    v5 = info_ptr == 0;
  if ( !v5 )
  {
    if ( (info_ptr->valid & 0x4000) != 0 )
    {
      *unit = info_ptr->scal_unit;
      v7 = *(_QWORD *)&info_ptr->scal_s_width;
      *width = (unsigned __int8 *)v7;
      result = 0x4000;
      *a5 = HIDWORD(v7);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (001F3CD6) --------------------------------------------------------
png_uint_32 __fastcall png_get_pHYs(
        png_const_structrp_1 png_ptr,
        png_const_inforp info_ptr,
        png_uint_32 *res_x,
        png_uint_32 *res_y,
        int *unit_type)
{
  bool v5; // zf
  png_uint_32 result; // r0

  v5 = png_ptr == 0;
  result = 0;
  if ( !v5 )
    v5 = info_ptr == 0;
  if ( !v5 )
  {
    if ( (info_ptr->valid & 0x80) != 0 )
    {
      if ( res_x )
      {
        *res_x = info_ptr->x_pixels_per_unit;
        result = 128;
      }
      else
      {
        result = 0;
      }
      if ( res_y )
      {
        *res_y = info_ptr->y_pixels_per_unit;
        result = 128;
      }
      if ( unit_type )
      {
        *unit_type = info_ptr->phys_unit_type;
        return 128;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (001F3D1A) --------------------------------------------------------
png_uint_32 __fastcall png_get_PLTE(
        png_const_structrp_1 png_ptr,
        png_inforp_0 info_ptr,
        png_colorp *palette,
        int *num_palette)
{
  png_uint_32 result; // r0
  bool v6; // zf

  result = 0;
  if ( png_ptr )
  {
    v6 = info_ptr == 0;
    if ( info_ptr )
    {
      result = 0;
      v6 = palette == 0;
    }
    if ( !v6 && (info_ptr->valid & 8) != 0 )
    {
      *palette = info_ptr->palette;
      *num_palette = info_ptr->num_palette;
      return 8;
    }
  }
  return result;
}

//----- (001F3D48) --------------------------------------------------------
png_uint_32 __fastcall png_get_sBIT(png_const_structrp_1 png_ptr, png_inforp_0 info_ptr, png_color_8p *sig_bit)
{
  png_uint_32 result; // r0
  bool v5; // zf

  result = 0;
  if ( png_ptr )
  {
    v5 = info_ptr == 0;
    if ( info_ptr )
    {
      result = 0;
      v5 = sig_bit == 0;
    }
    if ( !v5 && (info_ptr->valid & 2) != 0 )
    {
      *sig_bit = &info_ptr->sig_bit;
      return 2;
    }
  }
  return result;
}

//----- (001F3D6E) --------------------------------------------------------
int __fastcall png_get_text(png_const_structrp_1 png_ptr, png_inforp_0 info_ptr, png_textp *text_ptr, int *num_text)
{
  bool v4; // zf
  int result; // r0

  v4 = png_ptr == 0;
  if ( png_ptr )
    v4 = info_ptr == 0;
  if ( v4 || (result = info_ptr->num_text, result < 1) )
  {
    result = 0;
  }
  else if ( text_ptr )
  {
    *text_ptr = info_ptr->text;
  }
  if ( num_text )
    *num_text = result;
  return result;
}

//----- (001F3D94) --------------------------------------------------------
png_uint_32 __fastcall png_get_tIME(png_const_structrp_1 png_ptr, png_inforp_0 info_ptr, png_timep *mod_time)
{
  png_uint_32 result; // r0
  bool v5; // zf

  result = 0;
  if ( png_ptr )
  {
    v5 = info_ptr == 0;
    if ( info_ptr )
    {
      result = 0;
      v5 = mod_time == 0;
    }
    if ( !v5 && (info_ptr->valid & 0x200) != 0 )
    {
      *mod_time = &info_ptr->mod_time;
      return 512;
    }
  }
  return result;
}

//----- (001F3DBC) --------------------------------------------------------
png_uint_32 __fastcall png_get_tRNS(
        png_const_structrp_1 png_ptr,
        png_inforp_0 info_ptr,
        png_bytep *trans_alpha,
        int *num_trans,
        png_color_16 **a5)
{
  bool v5; // zf
  png_uint_32 result; // r0

  v5 = png_ptr == 0;
  result = 0;
  if ( !v5 )
    v5 = info_ptr == 0;
  if ( !v5 )
  {
    if ( (info_ptr->valid & 0x10) != 0 )
    {
      if ( info_ptr->color_type == 3 )
      {
        if ( trans_alpha )
        {
          *trans_alpha = info_ptr->trans_alpha;
          result = 16;
        }
        else
        {
          result = 0;
        }
        if ( a5 )
          *a5 = &info_ptr->trans_color;
      }
      else
      {
        if ( a5 )
        {
          *a5 = &info_ptr->trans_color;
          result = 16;
        }
        else
        {
          result = 0;
        }
        if ( trans_alpha )
          *trans_alpha = 0;
      }
      if ( num_trans )
      {
        *num_trans = info_ptr->num_trans;
        return 16;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (001F3E2A) --------------------------------------------------------
int __fastcall png_get_unknown_chunks(
        png_const_structrp_1 png_ptr,
        png_inforp_0 info_ptr,
        png_unknown_chunkpp unknowns)
{
  bool v3; // zf
  int result; // r0

  v3 = png_ptr == 0;
  result = 0;
  if ( !v3 )
    v3 = info_ptr == 0;
  if ( !v3 )
  {
    if ( unknowns )
    {
      result = info_ptr->unknown_chunks_num;
      *unknowns = info_ptr->unknown_chunks;
    }
  }
  return result;
}

//----- (001F3E44) --------------------------------------------------------
png_byte __fastcall png_get_rgb_to_gray_status(png_const_structrp_1 png_ptr)
{
  if ( png_ptr )
    return png_ptr->rgb_to_gray_status;
  else
    return 0;
}

//----- (001F3E50) --------------------------------------------------------
png_voidp __fastcall png_get_user_chunk_ptr(png_const_structrp_1 png_ptr)
{
  if ( png_ptr )
    return png_ptr->user_chunk_ptr;
  else
    return 0;
}

//----- (001F3E5C) --------------------------------------------------------
png_size_t __fastcall png_get_compression_buffer_size(png_const_structrp_1 png_ptr)
{
  png_size_t *p_IDAT_read_size; // r2

  if ( !png_ptr )
    return 0;
  p_IDAT_read_size = &png_ptr->IDAT_read_size;
  if ( (png_ptr->mode & 0x8000) == 0 )
    p_IDAT_read_size = &png_ptr->zbuffer_size;
  return *p_IDAT_read_size;
}

//----- (001F3E78) --------------------------------------------------------
png_uint_32 __fastcall png_get_user_width_max(png_const_structrp_1 png_ptr)
{
  if ( png_ptr )
    return png_ptr->user_width_max;
  else
    return 0;
}

//----- (001F3E84) --------------------------------------------------------
png_uint_32 __fastcall png_get_user_height_max(png_const_structrp_1 png_ptr)
{
  if ( png_ptr )
    return png_ptr->user_height_max;
  else
    return 0;
}

//----- (001F3E90) --------------------------------------------------------
png_uint_32 __fastcall png_get_chunk_cache_max(png_const_structrp_1 png_ptr)
{
  if ( png_ptr )
    return png_ptr->user_chunk_cache_max;
  else
    return 0;
}

//----- (001F3E9C) --------------------------------------------------------
png_alloc_size_t __fastcall png_get_chunk_malloc_max(png_const_structrp_1 png_ptr)
{
  if ( png_ptr )
    return png_ptr->user_chunk_malloc_max;
  else
    return 0;
}

//----- (001F3EA8) --------------------------------------------------------
png_uint_32 __fastcall png_get_io_state(png_const_structrp_1 png_ptr)
{
  return png_ptr->io_state;
}

//----- (001F3EAE) --------------------------------------------------------
png_uint_32 __fastcall png_get_io_chunk_type(png_const_structrp_1 png_ptr)
{
  return png_ptr->chunk_name;
}

//----- (001F3EB4) --------------------------------------------------------
int __fastcall png_get_palette_max(png_const_structp png_ptr, png_const_infop info_ptr)
{
  int result; // r0

  result = -1;
  if ( png_ptr )
  {
    if ( info_ptr )
      return png_ptr->num_palette_max;
  }
  return result;
}

//----- (001F3ECC) --------------------------------------------------------
void __fastcall png_destroy_png_struct(png_structrp_1 png_ptr)
{
  png_struct v2; // [sp+0h] [bp-3D8h] BYREF

  if ( png_ptr )
  {
    qmemcpy(&v2, png_ptr, sizeof(v2));
    memset(png_ptr, 0, sizeof(png_struct));
    if ( v2.free_fn )
      v2.free_fn(&v2, png_ptr);
    else
      free(png_ptr);
    j_png_free_jmpbuf(&v2);
  }
}

//----- (001F3F34) --------------------------------------------------------
void __fastcall png_free(png_const_structrp_2 png_ptr, png_voidp ptr)
{
  bool v2; // zf
  void (*free_fn)(void); // r2

  v2 = png_ptr == 0;
  if ( png_ptr )
    v2 = ptr == 0;
  if ( !v2 )
  {
    free_fn = (void (*)(void))png_ptr->free_fn;
    if ( free_fn )
      free_fn();
    else
      j_free(ptr);
  }
}

//----- (001F3F50) --------------------------------------------------------
png_voidp __fastcall png_calloc(png_const_structrp_2 png_ptr, png_alloc_size_t size)
{
  png_malloc_ptr malloc_fn; // r2
  png_voidp v5; // r0
  void *v6; // r6

  if ( !png_ptr )
    return 0;
  if ( !size
    || ((malloc_fn = png_ptr->malloc_fn) == 0 ? (v5 = malloc(size)) : (v5 = malloc_fn((png_structp)png_ptr, size)),
        (v6 = v5) == 0) )
  {
    j_png_error(png_ptr, (png_const_charp)"Out of memory");
    JUMPOUT(0x1F3F98);
  }
  memset(v5, 0, size);
  return v6;
}
// 1F3F96: control flows out of bounds to 1F3F98

//----- (001F3F9C) --------------------------------------------------------
png_voidp __fastcall png_malloc(png_const_structrp_2 png_ptr, png_alloc_size_t size)
{
  png_malloc_ptr malloc_fn; // r2
  png_voidp result; // r0

  if ( !png_ptr )
    return 0;
  if ( !size
    || ((malloc_fn = png_ptr->malloc_fn) == 0 ? (result = malloc(size)) : (result = (png_voidp)((int (__fastcall *)(png_const_structrp_2))malloc_fn)(png_ptr)),
        !result) )
  {
    j_png_error(png_ptr, (png_const_charp)"Out of memory");
    JUMPOUT(0x1F3FCC);
  }
  return result;
}
// 1F3FC8: control flows out of bounds to 1F3FCC

//----- (001F3FD0) --------------------------------------------------------
png_voidp __fastcall png_malloc_base(png_const_structrp_2 png_ptr, png_alloc_size_t size)
{
  int (*malloc_fn)(void); // r2
  bool v4; // zf

  if ( !size )
    return 0;
  v4 = png_ptr == 0;
  if ( png_ptr )
  {
    malloc_fn = (int (*)(void))png_ptr->malloc_fn;
    v4 = malloc_fn == 0;
  }
  if ( v4 )
    return sub_194878(size);
  else
    return (png_voidp)malloc_fn();
}
// 1F3FEA: variable 'malloc_fn' is possibly undefined

//----- (001F3FEC) --------------------------------------------------------
png_voidp __fastcall png_malloc_array(png_const_structrp_2 png_ptr, int nelements, size_t element_size)
{
  size_t v3; // r5
  bool v4; // zf

  v3 = element_size;
  if ( nelements < 1 || !element_size )
  {
    j_png_error(png_ptr, (png_const_charp)"internal error: array alloc");
    JUMPOUT(0x1F404C);
  }
  if ( 0xFFFFFFFF / element_size < nelements || !(element_size * nelements) )
    return 0;
  v4 = png_ptr == 0;
  if ( png_ptr )
  {
    element_size = (size_t)png_ptr->malloc_fn;
    v4 = element_size == 0;
  }
  if ( v4 )
    return sub_194878(v3 * nelements);
  else
    return (png_voidp)((int (__fastcall *)(png_const_structrp_2))element_size)(png_ptr);
}
// 1F404A: control flows out of bounds to 1F404C

//----- (001F4068) --------------------------------------------------------
char *__fastcall png_realloc_array(
        png_const_structrp_2 png_ptr,
        png_const_voidp old_array,
        int old_elements,
        int add_elements,
        unsigned int a5)
{
  int v5; // r6
  bool v6; // cc
  int v9; // r5
  bool v10; // zf
  char *v11; // r0
  char *v12; // r5

  v5 = old_elements;
  v6 = old_elements < 0;
  if ( old_elements >= 0 )
    v6 = add_elements < 1;
  if ( v6 || !a5 || !old_array && old_elements >= 1 )
  {
    j_png_error(png_ptr, (png_const_charp)"internal error: array realloc");
    JUMPOUT(0x1F4104);
  }
  if ( 0x7FFFFFFF - old_elements < add_elements )
    return 0;
  v9 = add_elements + old_elements;
  if ( 0xFFFFFFFF / a5 < add_elements + old_elements || !(v9 * a5) )
    return 0;
  v10 = png_ptr == 0;
  if ( png_ptr )
  {
    old_elements = (int)png_ptr->malloc_fn;
    v10 = old_elements == 0;
  }
  v11 = v10 ? (char *)malloc(v9 * a5) : (char *)((int (__fastcall *)(png_const_structrp_2))old_elements)(png_ptr);
  v12 = v11;
  if ( !v11 )
    return 0;
  if ( v5 >= 1 )
    qmemcpy(v11, old_array, a5 * v5);
  memset(&v12[a5 * v5], 0, a5 * add_elements);
  return v12;
}
// 1F4100: control flows out of bounds to 1F4104

//----- (001F4124) --------------------------------------------------------
png_voidp __fastcall png_malloc_default(png_const_structrp_2 png_ptr, png_alloc_size_t size)
{
  png_voidp result; // r0

  if ( !png_ptr )
    return 0;
  if ( !size || (result = malloc(size)) == 0 )
  {
    j_png_error(png_ptr, (png_const_charp)"Out of Memory");
    return 0;
  }
  return result;
}

//----- (001F4158) --------------------------------------------------------
png_voidp __fastcall png_malloc_warn(png_const_structrp_2 png_ptr, png_alloc_size_t size)
{
  png_malloc_ptr malloc_fn; // r2
  png_voidp result; // r0

  if ( !png_ptr )
    return 0;
  if ( !size
    || ((malloc_fn = png_ptr->malloc_fn) == 0 ? (result = malloc(size)) : (result = (png_voidp)((int (__fastcall *)(png_const_structrp_2))malloc_fn)(png_ptr)),
        !result) )
  {
    j_png_warning(png_ptr, (png_const_charp)"Out of memory");
    return 0;
  }
  return result;
}

//----- (001F418C) --------------------------------------------------------
void __fastcall png_free_default(png_const_structrp_2 png_ptr, png_voidp ptr)
{
  bool v2; // zf

  v2 = png_ptr == 0;
  if ( png_ptr )
    v2 = ptr == 0;
  if ( !v2 )
    j_free(ptr);
}

//----- (001F419A) --------------------------------------------------------
void __fastcall png_set_mem_fn(
        png_structrp_1 png_ptr,
        png_voidp mem_ptr,
        png_malloc_ptr malloc_fn,
        png_free_ptr free_fn)
{
  png_voidp *p_mem_ptr; // r0

  if ( png_ptr )
  {
    p_mem_ptr = &png_ptr->mem_ptr;
    *p_mem_ptr = mem_ptr;
    p_mem_ptr[1] = malloc_fn;
    p_mem_ptr[2] = free_fn;
  }
}

//----- (001F41A6) --------------------------------------------------------
png_voidp __fastcall png_get_mem_ptr(png_const_structrp_2 png_ptr)
{
  if ( png_ptr )
    return png_ptr->mem_ptr;
  else
    return 0;
}

//----- (001F41B4) --------------------------------------------------------
void __fastcall png_process_data(
        png_structrp_2 png_ptr,
        png_inforp_1 info_ptr,
        png_bytep buffer,
        png_size_t buffer_size)
{
  bool v5; // zf
  png_size_t save_buffer_size; // r0
  png_size_t v8; // r0
  int process_mode; // r0

  v5 = png_ptr == 0;
  if ( png_ptr )
    v5 = info_ptr == 0;
  if ( !v5 )
  {
    save_buffer_size = png_ptr->save_buffer_size;
    png_ptr->current_buffer_ptr = buffer;
    png_ptr->current_buffer = buffer;
    v8 = save_buffer_size + buffer_size;
    png_ptr->buffer_size = v8;
    png_ptr->current_buffer_size = buffer_size;
    while ( png_ptr->buffer_size )
    {
      process_mode = png_ptr->process_mode;
      if ( process_mode == 2 )
      {
        j_png_push_read_IDAT(png_ptr);
      }
      else if ( process_mode == 1 )
      {
        j_png_push_read_chunk(png_ptr, info_ptr);
      }
      else
      {
        if ( process_mode )
        {
          png_ptr->buffer_size = 0;
          return;
        }
        j_png_push_read_sig(png_ptr, info_ptr);
      }
    }
  }
}

//----- (001F4210) --------------------------------------------------------
void __fastcall png_push_restore_buffer(png_structrp_2 png_ptr, png_bytep buffer, png_size_t buffer_length)
{
  png_size_t save_buffer_size; // r3

  save_buffer_size = png_ptr->save_buffer_size;
  png_ptr->current_buffer_ptr = buffer;
  png_ptr->current_buffer = buffer;
  png_ptr->buffer_size = save_buffer_size + buffer_length;
  png_ptr->current_buffer_size = buffer_length;
}

//----- (001F4220) --------------------------------------------------------
void __fastcall png_process_some_data(png_structrp_2 png_ptr, png_inforp_1 info_ptr)
{
  int process_mode; // r2

  if ( png_ptr )
  {
    process_mode = png_ptr->process_mode;
    if ( process_mode == 2 )
    {
      png_push_read_IDAT(png_ptr);
    }
    else if ( process_mode == 1 )
    {
      png_push_read_chunk(png_ptr, info_ptr);
    }
    else if ( process_mode )
    {
      png_ptr->buffer_size = 0;
    }
    else
    {
      png_push_read_sig(png_ptr, info_ptr);
    }
  }
}

//----- (001F4246) --------------------------------------------------------
png_size_t __fastcall png_process_data_pause(png_structrp_2 png_ptr, int save)
{
  png_size_t save_buffer_size; // r1
  png_size_t buffer_size; // r2

  if ( !png_ptr )
    return 0;
  if ( save )
  {
    j_png_push_save_buffer(png_ptr);
    return 0;
  }
  save_buffer_size = png_ptr->save_buffer_size;
  buffer_size = png_ptr->buffer_size;
  png_ptr->buffer_size = 0;
  if ( buffer_size <= save_buffer_size )
    return 0;
  else
    return buffer_size - save_buffer_size;
}

//----- (001F4274) --------------------------------------------------------
void __fastcall png_push_save_buffer(png_structrp_2 png_ptr)
{
  png_bytep save_buffer_ptr; // r5
  png_size_t save_buffer_size; // r0
  png_bytep save_buffer; // r6
  unsigned int v5; // r12
  bool v6; // cf
  png_bytep v7; // r3
  png_bytep v8; // r2
  unsigned int v9; // r1
  __int64 v10; // d16
  __int64 v11; // d17
  png_size_t v12; // r0
  png_byte v13; // t1
  size_t current_buffer_size; // r2
  size_t v15; // r1
  png_size_t v16; // r6
  png_byte *v17; // r0
  size_t v18; // r2
  png_size_t v19; // r0
  png_size_t v20; // r1
  png_byte *v21; // r0

  save_buffer_size = png_ptr->save_buffer_size;
  if ( !save_buffer_size )
  {
    save_buffer_size = 0;
    goto LABEL_18;
  }
  save_buffer = png_ptr->save_buffer;
  save_buffer_ptr = png_ptr->save_buffer_ptr;
  if ( save_buffer_ptr == save_buffer )
    goto LABEL_18;
  if ( save_buffer_size < 0x10 )
    goto LABEL_14;
  v5 = save_buffer_size & 0xFFFFFFF0;
  if ( (save_buffer_size & 0xFFFFFFF0) == 0 )
    goto LABEL_14;
  v6 = save_buffer >= &save_buffer_ptr[save_buffer_size];
  if ( save_buffer < &save_buffer_ptr[save_buffer_size] )
    v6 = save_buffer_ptr >= &save_buffer[save_buffer_size];
  if ( v6 )
  {
    v7 = &save_buffer[v5];
    v8 = &save_buffer_ptr[v5];
    v9 = save_buffer_size & 0xFFFFFFF0;
    do
    {
      v10 = *(_QWORD *)save_buffer_ptr;
      v11 = *((_QWORD *)save_buffer_ptr + 1);
      save_buffer_ptr += 16;
      v9 -= 16;
      *(_QWORD *)save_buffer = v10;
      *((_QWORD *)save_buffer + 1) = v11;
      save_buffer += 16;
    }
    while ( v9 );
    if ( save_buffer_size == v5 )
      goto LABEL_17;
  }
  else
  {
LABEL_14:
    v5 = 0;
    v8 = png_ptr->save_buffer_ptr;
    v7 = png_ptr->save_buffer;
  }
  v12 = save_buffer_size - v5;
  do
  {
    v13 = *v8++;
    --v12;
    *v7++ = v13;
  }
  while ( v12 );
LABEL_17:
  save_buffer_size = png_ptr->save_buffer_size;
LABEL_18:
  current_buffer_size = png_ptr->current_buffer_size;
  v15 = current_buffer_size + save_buffer_size;
  if ( current_buffer_size + save_buffer_size <= png_ptr->save_buffer_max )
    goto LABEL_25;
  if ( save_buffer_size > -257 - current_buffer_size )
  {
    j_png_error(png_ptr, (png_const_charp)"Potential overflow of save_buffer");
    goto LABEL_29;
  }
  v16 = v15 + 256;
  save_buffer_ptr = png_ptr->save_buffer;
  v17 = (png_byte *)j_png_malloc_warn(png_ptr, v15 + 256);
  png_ptr->save_buffer = v17;
  if ( !v17 )
  {
LABEL_29:
    j_png_free(png_ptr, save_buffer_ptr);
    j_png_error(png_ptr, (png_const_charp)"Insufficient memory for save_buffer");
    goto LABEL_30;
  }
  v18 = png_ptr->save_buffer_size;
  if ( !save_buffer_ptr )
  {
    if ( !v18 )
      goto LABEL_24;
LABEL_30:
    j_png_error(png_ptr, (png_const_charp)"save_buffer error");
    JUMPOUT(0x1F438C);
  }
  qmemcpy(v17, save_buffer_ptr, v18);
LABEL_24:
  j_png_free(png_ptr, save_buffer_ptr);
  current_buffer_size = png_ptr->current_buffer_size;
  png_ptr->save_buffer_max = v16;
LABEL_25:
  if ( current_buffer_size )
  {
    qmemcpy(&png_ptr->save_buffer[png_ptr->save_buffer_size], png_ptr->current_buffer_ptr, current_buffer_size);
    v19 = png_ptr->save_buffer_size;
    v20 = png_ptr->current_buffer_size;
    png_ptr->current_buffer_size = 0;
    png_ptr->save_buffer_size = v19 + v20;
  }
  v21 = png_ptr->save_buffer;
  png_ptr->buffer_size = 0;
  png_ptr->save_buffer_ptr = v21;
}
// 1F438A: control flows out of bounds to 1F438C
// 1F4376: variable 'save_buffer_ptr' is possibly undefined

//----- (001F43E8) --------------------------------------------------------
png_uint_32 __fastcall png_process_data_skip(png_structrp_2 png_ptr)
{
  j_png_app_warning(
    png_ptr,
    (png_const_charp)"png_process_data_skip is not implemented in any current version of libpng");
  return 0;
}

//----- (001F43FC) --------------------------------------------------------
void __fastcall png_push_read_sig(png_structrp_2 png_ptr, png_inforp_1 info_ptr)
{
  png_size_t sig_bytes; // r10
  unsigned int buffer_size; // r8
  png_size_t v5; // r6
  png_size_t save_buffer_size; // r9
  png_byte *v7; // r0
  size_t v8; // r5
  png_byte *v9; // r11
  size_t v10; // r5
  bool v11; // zf
  png_bytep current_buffer_ptr; // r11
  __int64 v13; // r0
  png_byte *signature; // r5
  png_bytep save_buffer_ptr; // [sp+4h] [bp-24h]
  png_info *v16; // [sp+8h] [bp-20h]

  sig_bytes = png_ptr->sig_bytes;
  buffer_size = png_ptr->buffer_size;
  v5 = 8 - sig_bytes;
  if ( buffer_size < 8 - sig_bytes )
    v5 = png_ptr->buffer_size;
  if ( png_ptr )
  {
    save_buffer_size = png_ptr->save_buffer_size;
    v7 = &info_ptr->signature[sig_bytes];
    v16 = info_ptr;
    if ( save_buffer_size )
    {
      v8 = save_buffer_size;
      save_buffer_ptr = png_ptr->save_buffer_ptr;
      if ( save_buffer_size > v5 )
        v8 = v5;
      v9 = &info_ptr->signature[sig_bytes];
      qmemcpy(v7, png_ptr->save_buffer_ptr, v8);
      buffer_size -= v8;
      png_ptr->buffer_size = buffer_size;
      png_ptr->save_buffer_size = save_buffer_size - v8;
      info_ptr = v16;
      png_ptr->save_buffer_ptr = &save_buffer_ptr[v8];
      v7 = &v9[v8];
      v10 = v5 - v8;
    }
    else
    {
      v10 = v5;
    }
    v11 = v10 == 0;
    if ( v10 )
    {
      save_buffer_size = png_ptr->current_buffer_size;
      v11 = save_buffer_size == 0;
    }
    if ( !v11 )
    {
      current_buffer_ptr = png_ptr->current_buffer_ptr;
      if ( v10 >= save_buffer_size )
        v10 = save_buffer_size;
      qmemcpy(v7, png_ptr->current_buffer_ptr, v10);
      HIDWORD(v13) = save_buffer_size - v10;
      LODWORD(v13) = buffer_size - v10;
      *(_QWORD *)&png_ptr->buffer_size = v13;
      info_ptr = v16;
      png_ptr->current_buffer_ptr = &current_buffer_ptr[v10];
    }
  }
  signature = info_ptr->signature;
  png_ptr->sig_bytes = v5 + sig_bytes;
  if ( j_png_sig_cmp(info_ptr->signature, sig_bytes, v5) )
  {
    if ( sig_bytes > 3 || !j_png_sig_cmp(signature, sig_bytes, v5 - 4) )
      j_png_error(png_ptr, (png_const_charp)"PNG file corrupted by ASCII conversion");
    j_png_error(png_ptr, (png_const_charp)"Not a PNG file");
    JUMPOUT(0x1F44F4);
  }
  if ( png_ptr->sig_bytes >= 8u )
    png_ptr->process_mode = 1;
}
// 1F44F2: control flows out of bounds to 1F44F4

//----- (001F452C) --------------------------------------------------------
void __fastcall png_push_read_chunk(png_structrp_2 png_ptr, png_inforp_1 info_ptr)
{
  png_uint_32 mode; // r0
  png_size_t buffer_size; // r5
  png_size_t save_buffer_size; // r4
  png_byte *v7; // r9
  size_t v8; // r6
  png_bytep save_buffer_ptr; // r10
  png_size_t current_buffer_size; // r4
  png_bytep current_buffer_ptr; // r10
  __int64 v12; // r0
  unsigned int v13; // r1
  png_uint_32 *p_chunk_name; // r5
  int chunk_name; // r6
  bool v16; // zf
  int v17; // r3
  png_uint_32 v18; // r2
  png_uint_32 v19; // r2
  png_uint_32 push_length; // r2
  png_progressive_info_ptr info_fn; // r2
  png_uint_32 v22; // r0
  unsigned int pixel_depth; // r1
  png_uint_32 iwidth; // r0
  unsigned int v25; // r0
  png_progressive_end_ptr end_fn; // r2
  png_uint_32 v27; // r0
  png_uint_32 v28; // r2
  png_uint_32 v29; // r2
  png_uint_32 v30; // r2
  png_uint_32 v31; // r2
  png_uint_32 v32; // r2
  png_uint_32 v33; // r2
  png_uint_32 v34; // r2
  png_uint_32 v35; // r2
  png_uint_32 v36; // r2
  png_uint_32 v37; // r2
  png_uint_32 v38; // r2
  png_uint_32 v39; // r2
  png_uint_32 v40; // r2
  png_uint_32 v41; // r2
  png_uint_32 v42; // r2
  png_uint_32 v43; // r2
  png_uint_32 v44; // r2
  png_size_t v45; // r0
  png_size_t v46; // r1
  png_byte v47[4]; // [sp+4h] [bp-24h] BYREF
  png_byte buf[32]; // [sp+8h] [bp-20h] BYREF

  mode = png_ptr->mode;
  if ( (mode & 0x100) == 0 )
  {
    buffer_size = png_ptr->buffer_size;
    if ( buffer_size <= 7 )
      goto LABEL_38;
    save_buffer_size = png_ptr->save_buffer_size;
    v7 = buf;
    v8 = 4;
    if ( save_buffer_size )
    {
      if ( save_buffer_size < 4 )
        v8 = png_ptr->save_buffer_size;
      save_buffer_ptr = png_ptr->save_buffer_ptr;
      qmemcpy(buf, save_buffer_ptr, v8);
      buffer_size -= v8;
      png_ptr->buffer_size = buffer_size;
      png_ptr->save_buffer_size = save_buffer_size - v8;
      png_ptr->save_buffer_ptr = &save_buffer_ptr[v8];
      if ( v8 == 4 )
        goto LABEL_12;
      v7 = &buf[v8];
      v8 = 4 - v8;
    }
    current_buffer_size = png_ptr->current_buffer_size;
    if ( current_buffer_size )
    {
      current_buffer_ptr = png_ptr->current_buffer_ptr;
      if ( v8 >= current_buffer_size )
        v8 = png_ptr->current_buffer_size;
      qmemcpy(v7, png_ptr->current_buffer_ptr, v8);
      HIDWORD(v12) = current_buffer_size - v8;
      LODWORD(v12) = buffer_size - v8;
      *(_QWORD *)&png_ptr->buffer_size = v12;
      png_ptr->current_buffer_ptr = &current_buffer_ptr[v8];
    }
LABEL_12:
    png_ptr->push_length = j_png_get_uint_31(png_ptr, buf);
    j_png_reset_crc(png_ptr);
    j_png_crc_read(png_ptr, v47, 4u);
    v13 = bswap32(*(unsigned int *)v47);
    png_ptr->chunk_name = v13;
    j_png_check_chunk_name(png_ptr, v13);
    j_png_check_chunk_length(png_ptr, png_ptr->push_length);
    mode = png_ptr->mode | 0x100;
    png_ptr->mode = mode;
  }
  p_chunk_name = &png_ptr->chunk_name;
  chunk_name = png_ptr->chunk_name;
  if ( chunk_name != 1229209940 )
  {
    if ( chunk_name == 1229278788 )
    {
      push_length = png_ptr->push_length;
      if ( push_length + 4 <= png_ptr->buffer_size )
      {
        j_png_handle_IEND(png_ptr, info_ptr, push_length);
        end_fn = png_ptr->end_fn;
        png_ptr->process_mode = 6;
        if ( end_fn )
          end_fn(png_ptr, info_ptr);
        goto LABEL_46;
      }
      goto LABEL_38;
    }
    if ( chunk_name != 1229472850 )
      goto LABEL_29;
    if ( png_ptr->push_length == 13 )
    {
      if ( png_ptr->buffer_size <= 0x10 )
        goto LABEL_38;
      j_png_handle_IHDR(png_ptr, info_ptr, 0xDu);
      goto LABEL_46;
    }
LABEL_108:
    j_png_error(png_ptr, (png_const_charp)"Invalid IHDR length");
    JUMPOUT(0x1F4A4C);
  }
  if ( (mode & 8) != 0 )
  {
    mode |= 0x2000u;
    png_ptr->mode = mode;
  }
  if ( !(mode << 31) )
  {
    j_png_error(png_ptr, (png_const_charp)"Missing IHDR before IDAT");
LABEL_107:
    j_png_error(png_ptr, (png_const_charp)"Missing PLTE before IDAT");
    goto LABEL_108;
  }
  if ( (mode & 2) == 0 && png_ptr->color_type == 3 )
    goto LABEL_107;
  png_ptr->process_mode = 2;
  v16 = (mode & 0x2004) == 4;
  if ( (mode & 0x2004) == 4 )
    v16 = png_ptr->push_length == 0;
  if ( !v16 )
  {
    png_ptr->mode = mode | 4;
    if ( (mode & 8) != 0 )
      j_png_benign_error(png_ptr, (png_const_charp)"Too many IDATs found");
LABEL_29:
    v17 = j_png_chunk_unknown_handling(png_ptr, chunk_name);
    if ( v17 )
    {
      v18 = png_ptr->push_length;
      if ( v18 + 4 <= png_ptr->buffer_size )
      {
        j_png_handle_unknown(png_ptr, info_ptr, v18, v17);
        if ( chunk_name == 1347179589 )
          png_ptr->mode |= 2u;
        goto LABEL_46;
      }
LABEL_38:
      j_png_push_save_buffer(png_ptr);
      return;
    }
    if ( chunk_name == 1347179589 )
    {
      v19 = png_ptr->push_length;
      if ( v19 + 4 > png_ptr->buffer_size )
        goto LABEL_38;
      j_png_handle_PLTE(png_ptr, info_ptr, v19);
      goto LABEL_46;
    }
    if ( chunk_name == 1229209940 )
    {
      info_fn = png_ptr->info_fn;
      v22 = png_ptr->push_length;
      png_ptr->process_mode = 2;
      png_ptr->idat_size = v22;
      if ( info_fn )
        info_fn(png_ptr, info_ptr);
      pixel_depth = png_ptr->pixel_depth;
      iwidth = png_ptr->iwidth;
      if ( pixel_depth < 8 )
        v25 = (iwidth * pixel_depth + 7) >> 3;
      else
        v25 = iwidth * (pixel_depth >> 3);
      png_ptr->zstream.next_out = png_ptr->row_buf;
      png_ptr->zstream.avail_out = v25 + 1;
      return;
    }
    v27 = *p_chunk_name;
    if ( *p_chunk_name == 1665684045 )
    {
      v29 = png_ptr->push_length;
      if ( v29 + 4 > png_ptr->buffer_size )
        goto LABEL_38;
      j_png_handle_cHRM(png_ptr, info_ptr, v29);
    }
    else if ( v27 == 1933723988 )
    {
      v30 = png_ptr->push_length;
      if ( v30 + 4 > png_ptr->buffer_size )
        goto LABEL_38;
      j_png_handle_sBIT(png_ptr, info_ptr, v30);
    }
    else if ( v27 == 1732332865 )
    {
      v28 = png_ptr->push_length;
      if ( v28 + 4 > png_ptr->buffer_size )
        goto LABEL_38;
      j_png_handle_gAMA(png_ptr, info_ptr, v28);
    }
    else if ( chunk_name == 1934772034 )
    {
      v31 = png_ptr->push_length;
      if ( v31 + 4 > png_ptr->buffer_size )
        goto LABEL_38;
      j_png_handle_sRGB(png_ptr, info_ptr, v31);
    }
    else
    {
      if ( v27 != 1766015824 )
      {
        if ( chunk_name <= 1933787467 )
        {
          if ( chunk_name <= 1866876530 )
          {
            if ( chunk_name == 1649100612 )
            {
              v43 = png_ptr->push_length;
              if ( v43 + 4 > png_ptr->buffer_size )
                goto LABEL_38;
              j_png_handle_bKGD(png_ptr, info_ptr, v43);
              goto LABEL_46;
            }
            if ( chunk_name == 1749635924 )
            {
              v36 = png_ptr->push_length;
              if ( v36 + 4 > png_ptr->buffer_size )
                goto LABEL_38;
              j_png_handle_hIST(png_ptr, info_ptr, v36);
              goto LABEL_46;
            }
          }
          else
          {
            switch ( chunk_name )
            {
              case 1866876531:
                v39 = png_ptr->push_length;
                if ( v39 + 4 > png_ptr->buffer_size )
                  goto LABEL_38;
                j_png_handle_oFFs(png_ptr, info_ptr, v39);
                goto LABEL_46;
              case 1883455820:
                v40 = png_ptr->push_length;
                if ( v40 + 4 > png_ptr->buffer_size )
                  goto LABEL_38;
                j_png_handle_pCAL(png_ptr, info_ptr, v40);
                goto LABEL_46;
              case 1883789683:
                v34 = png_ptr->push_length;
                if ( v34 + 4 > png_ptr->buffer_size )
                  goto LABEL_38;
                j_png_handle_pHYs(png_ptr, info_ptr, v34);
                goto LABEL_46;
            }
          }
        }
        else if ( chunk_name > 1950960964 )
        {
          switch ( chunk_name )
          {
            case 1950960965:
              v41 = png_ptr->push_length;
              if ( v41 + 4 > png_ptr->buffer_size )
                goto LABEL_38;
              j_png_handle_tIME(png_ptr, info_ptr, v41);
              goto LABEL_46;
            case 1951551059:
              v42 = png_ptr->push_length;
              if ( v42 + 4 > png_ptr->buffer_size )
                goto LABEL_38;
              j_png_handle_tRNS(png_ptr, info_ptr, v42);
              goto LABEL_46;
            case 2052348020:
              v35 = png_ptr->push_length;
              if ( v35 + 4 > png_ptr->buffer_size )
                goto LABEL_38;
              j_png_handle_zTXt(png_ptr, info_ptr, v35);
              goto LABEL_46;
          }
        }
        else
        {
          switch ( chunk_name )
          {
            case 1933787468:
              v37 = png_ptr->push_length;
              if ( v37 + 4 > png_ptr->buffer_size )
                goto LABEL_38;
              j_png_handle_sCAL(png_ptr, info_ptr, v37);
              goto LABEL_46;
            case 1934642260:
              v38 = png_ptr->push_length;
              if ( v38 + 4 > png_ptr->buffer_size )
                goto LABEL_38;
              j_png_handle_sPLT(png_ptr, info_ptr, v38);
              goto LABEL_46;
            case 1950701684:
              v33 = png_ptr->push_length;
              if ( v33 + 4 > png_ptr->buffer_size )
                goto LABEL_38;
              j_png_handle_tEXt(png_ptr, info_ptr, v33);
              goto LABEL_46;
          }
        }
        v44 = png_ptr->push_length;
        v45 = png_ptr->buffer_size;
        v46 = v44 + 4;
        if ( chunk_name == 1767135348 )
        {
          if ( v46 > v45 )
            goto LABEL_38;
          j_png_handle_iTXt(png_ptr, info_ptr, v44);
        }
        else
        {
          if ( v46 > v45 )
            goto LABEL_38;
          j_png_handle_unknown(png_ptr, info_ptr, v44, 0);
        }
        goto LABEL_46;
      }
      v32 = png_ptr->push_length;
      if ( v32 + 4 > png_ptr->buffer_size )
        goto LABEL_38;
      j_png_handle_iCCP(png_ptr, info_ptr, v32);
    }
LABEL_46:
    png_ptr->mode &= ~0x100u;
  }
}
// 1F4A4A: control flows out of bounds to 1F4A4C
// 1F452C: using guessed type png_byte buf[32];

//----- (001F4AB0) --------------------------------------------------------
void __fastcall png_push_read_IDAT(png_structrp_2 png_ptr)
{
  png_size_t v2; // r10
  png_size_t v3; // r6
  png_byte *v4; // r8
  size_t v5; // r5
  png_bytep save_buffer_ptr; // r9
  png_size_t v7; // r6
  png_bytep v8; // r9
  __int64 v9; // r0
  png_uint_32 v10; // r1
  png_uint_32 v11; // r0
  png_uint_32 idat_size; // r0
  png_size_t save_buffer_size; // r5
  png_size_t v14; // r2
  png_size_t buffer_size; // r3
  png_byte *v16; // r1
  png_size_t current_buffer_size; // r5
  png_bytep current_buffer_ptr; // r1
  __int64 v19; // r2
  bool v20; // zf
  png_uint_32 mode; // r0
  char flags; // r0
  unsigned int v23; // [sp+0h] [bp-20h] BYREF
  png_byte buf[28]; // [sp+4h] [bp-1Ch] BYREF

  if ( BYTE1(png_ptr->mode) << 31 )
  {
    idat_size = png_ptr->idat_size;
    if ( !idat_size )
      goto LABEL_25;
LABEL_16:
    save_buffer_size = png_ptr->save_buffer_size;
    if ( !save_buffer_size )
      goto LABEL_24;
    if ( idat_size < save_buffer_size )
      save_buffer_size = idat_size;
    j_png_calculate_crc(png_ptr, png_ptr->save_buffer_ptr, save_buffer_size);
    j_png_process_IDAT_data(png_ptr, png_ptr->save_buffer_ptr, save_buffer_size);
    v14 = png_ptr->save_buffer_size;
    idat_size = png_ptr->idat_size - save_buffer_size;
    buffer_size = png_ptr->buffer_size;
    v16 = &png_ptr->save_buffer_ptr[save_buffer_size];
    png_ptr->idat_size = idat_size;
    png_ptr->buffer_size = buffer_size - save_buffer_size;
    png_ptr->save_buffer_size = v14 - save_buffer_size;
    png_ptr->save_buffer_ptr = v16;
    if ( idat_size )
    {
LABEL_24:
      current_buffer_size = png_ptr->current_buffer_size;
      if ( !current_buffer_size )
        return;
      if ( idat_size < current_buffer_size )
        current_buffer_size = idat_size;
      j_png_calculate_crc(png_ptr, png_ptr->current_buffer_ptr, current_buffer_size);
      j_png_process_IDAT_data(png_ptr, png_ptr->current_buffer_ptr, current_buffer_size);
      current_buffer_ptr = png_ptr->current_buffer_ptr;
      v19 = *(_QWORD *)&png_ptr->buffer_size;
      v20 = png_ptr->idat_size == current_buffer_size;
      png_ptr->idat_size -= current_buffer_size;
      png_ptr->buffer_size = v19 - current_buffer_size;
      png_ptr->current_buffer_size = HIDWORD(v19) - current_buffer_size;
      png_ptr->current_buffer_ptr = &current_buffer_ptr[current_buffer_size];
      if ( !v20 )
        return;
    }
    goto LABEL_25;
  }
  v2 = png_ptr->buffer_size;
  if ( v2 <= 7 )
  {
LABEL_26:
    j_png_push_save_buffer(png_ptr);
    return;
  }
  v3 = png_ptr->save_buffer_size;
  v4 = buf;
  v5 = 4;
  if ( !v3 )
    goto LABEL_8;
  if ( v3 < 4 )
    v5 = png_ptr->save_buffer_size;
  save_buffer_ptr = png_ptr->save_buffer_ptr;
  qmemcpy(buf, save_buffer_ptr, v5);
  v2 -= v5;
  png_ptr->buffer_size = v2;
  png_ptr->save_buffer_size = v3 - v5;
  png_ptr->save_buffer_ptr = &save_buffer_ptr[v5];
  if ( v5 != 4 )
  {
    v4 = &buf[v5];
    v5 = 4 - v5;
LABEL_8:
    v7 = png_ptr->current_buffer_size;
    if ( v7 )
    {
      v8 = png_ptr->current_buffer_ptr;
      if ( v5 >= v7 )
        v5 = png_ptr->current_buffer_size;
      qmemcpy(v4, png_ptr->current_buffer_ptr, v5);
      HIDWORD(v9) = v7 - v5;
      LODWORD(v9) = v2 - v5;
      *(_QWORD *)&png_ptr->buffer_size = v9;
      png_ptr->current_buffer_ptr = &v8[v5];
    }
  }
  png_ptr->push_length = j_png_get_uint_31(png_ptr, buf);
  j_png_reset_crc(png_ptr);
  j_png_crc_read(png_ptr, (png_bytep)&v23, 4u);
  v10 = png_ptr->mode | 0x100;
  v11 = bswap32(v23);
  png_ptr->chunk_name = v11;
  png_ptr->mode = v10;
  if ( v11 != 1229209940 )
  {
    flags = png_ptr->flags;
    png_ptr->process_mode = 1;
    if ( (flags & 8) == 0 )
    {
      j_png_error(png_ptr, (png_const_charp)"Not enough compressed data");
      JUMPOUT(0x1F4C7C);
    }
    return;
  }
  idat_size = png_ptr->push_length;
  png_ptr->idat_size = idat_size;
  if ( idat_size )
    goto LABEL_16;
LABEL_25:
  if ( png_ptr->buffer_size <= 3 )
    goto LABEL_26;
  j_png_crc_finish(png_ptr, 0);
  mode = png_ptr->mode;
  png_ptr->zowner = 0;
  png_ptr->mode = mode & 0xFFFFFEF7 | 8;
}
// 1F4C7A: control flows out of bounds to 1F4C7C
// 1F4AB0: using guessed type png_byte buf[28];

//----- (001F4C98) --------------------------------------------------------
void __fastcall png_push_fill_buffer(png_structp png_ptr, png_bytep buffer, png_size_t length)
{
  png_size_t v4; // r6
  png_bytep v5; // r8
  size_t save_buffer_size; // r5
  png_byte *v7; // r0
  png_size_t v8; // r1
  bool v9; // zf
  __int64 v10; // kr00_8
  png_byte *v11; // r0

  v4 = length;
  v5 = buffer;
  if ( png_ptr )
  {
    save_buffer_size = png_ptr->save_buffer_size;
    if ( save_buffer_size )
    {
      if ( save_buffer_size > length )
        save_buffer_size = length;
      qmemcpy(buffer, png_ptr->save_buffer_ptr, save_buffer_size);
      v5 += save_buffer_size;
      v4 -= save_buffer_size;
      v7 = &png_ptr->save_buffer_ptr[save_buffer_size];
      v8 = png_ptr->save_buffer_size - save_buffer_size;
      png_ptr->buffer_size -= save_buffer_size;
      png_ptr->save_buffer_size = v8;
      png_ptr->save_buffer_ptr = v7;
    }
    v9 = v4 == 0;
    if ( v4 )
    {
      save_buffer_size = png_ptr->current_buffer_size;
      v9 = save_buffer_size == 0;
    }
    if ( !v9 )
    {
      if ( v4 < save_buffer_size )
        save_buffer_size = v4;
      qmemcpy(v5, png_ptr->current_buffer_ptr, save_buffer_size);
      v10 = *(_QWORD *)&png_ptr->buffer_size;
      v11 = &png_ptr->current_buffer_ptr[save_buffer_size];
      png_ptr->buffer_size = v10 - save_buffer_size;
      png_ptr->current_buffer_size = HIDWORD(v10) - save_buffer_size;
      png_ptr->current_buffer_ptr = v11;
    }
  }
}

//----- (001F4D1C) --------------------------------------------------------
void __fastcall png_push_have_end(png_structrp_2 png_ptr, png_inforp_1 info_ptr)
{
  void (*end_fn)(void); // r2

  end_fn = (void (*)(void))png_ptr->end_fn;
  if ( end_fn )
    end_fn();
}

//----- (001F4D28) --------------------------------------------------------
void __fastcall png_push_have_info(png_structrp_2 png_ptr, png_inforp_1 info_ptr)
{
  void (*info_fn)(void); // r2

  info_fn = (void (*)(void))png_ptr->info_fn;
  if ( info_fn )
    info_fn();
}

//----- (001F4D34) --------------------------------------------------------
void __fastcall png_process_IDAT_data(png_structrp_2 png_ptr, png_bytep buffer, png_size_t buffer_length)
{
  bool v3; // zf
  unsigned int pixel_depth; // r1
  png_uint_32 iwidth; // r0
  unsigned int v7; // r0
  unsigned int v8; // r6
  png_uint_32 v9; // r0
  png_uint_32 v10; // r1
  bool v11; // cf
  png_uint_32 flags; // r0
  const char *v13; // r1
  png_uint_32 num_rows; // r1
  png_uint_32 row_number; // r2
  png_uint_32 v16; // r0
  bool v17; // cf

  v3 = buffer == 0;
  if ( buffer )
    v3 = buffer_length == 0;
  if ( v3 )
    goto LABEL_35;
  png_ptr->zstream.next_in = buffer;
  png_ptr->zstream.avail_in = buffer_length;
  while ( (png_ptr->flags & 8) == 0 )
  {
    if ( !png_ptr->zstream.avail_out )
    {
      pixel_depth = png_ptr->pixel_depth;
      iwidth = png_ptr->iwidth;
      if ( pixel_depth < 8 )
        v7 = (iwidth * pixel_depth + 7) >> 3;
      else
        v7 = iwidth * (pixel_depth >> 3);
      png_ptr->zstream.next_out = png_ptr->row_buf;
      png_ptr->zstream.avail_out = v7 + 1;
    }
    v8 = j_inflate((z_streamp_1)&png_ptr->zstream, 2);
    if ( v8 >= 2 )
    {
      num_rows = png_ptr->num_rows;
      row_number = png_ptr->row_number;
      v16 = png_ptr->flags | 8;
      png_ptr->zowner = 0;
      png_ptr->flags = v16;
      v17 = row_number >= num_rows;
      if ( row_number < num_rows )
        v17 = png_ptr->pass >= 7u;
      if ( !v17 )
      {
        if ( v8 == -3 )
        {
          sub_197EE8(png_ptr, (png_const_charp)"IDAT: ADLER32 checksum mismatch");
          return;
        }
        j_png_error(png_ptr, (png_const_charp)"Decompression error in IDAT");
LABEL_35:
        j_png_error(png_ptr, (png_const_charp)"No IDAT data (internal error)");
        JUMPOUT(0x1F4E60);
      }
      v13 = "Truncated compressed data in IDAT";
LABEL_31:
      sub_194634(png_ptr, (png_const_charp)v13);
      return;
    }
    if ( png_ptr->zstream.next_out != png_ptr->row_buf )
    {
      v9 = png_ptr->num_rows;
      v10 = png_ptr->row_number;
      v11 = v10 >= v9;
      if ( v10 < v9 )
        v11 = png_ptr->pass >= 7u;
      if ( v11 )
      {
        j_png_warning(png_ptr, (png_const_charp)"Extra compressed data in IDAT");
        flags = png_ptr->flags;
        png_ptr->zowner = 0;
        png_ptr->flags = flags | 8;
        return;
      }
      if ( !png_ptr->zstream.avail_out )
        j_png_push_process_row(png_ptr);
    }
    if ( v8 == 1 )
      png_ptr->flags |= 8u;
    buffer_length = png_ptr->zstream.avail_in;
    if ( !buffer_length )
      return;
  }
  if ( buffer_length )
  {
    v13 = "Extra compression data in IDAT";
    goto LABEL_31;
  }
}
// 1F4E5E: control flows out of bounds to 1F4E60

//----- (001F4EE4) --------------------------------------------------------
void __fastcall png_push_process_row(png_structrp_2 png_ptr)
{
  png_uint_32 iwidth; // r0
  png_byte color_type; // r1
  unsigned int rowbytes; // r2
  png_bytep row_buf; // r1
  unsigned int filter; // r0
  png_uint_32 transformations; // r3
  unsigned int pixel_depth; // r0
  unsigned int maximum_pixel_depth; // r1
  bool v10; // zf
  png_progressive_row_ptr v11; // r5
  png_uint_32 row_number; // r2
  int v13; // r3
  png_bytep v14; // r1
  png_structrp_2 v15; // r0
  unsigned int pass; // r12
  int v17; // r5
  png_progressive_row_ptr row_fn; // r4
  int v19; // r0
  png_progressive_row_ptr v20; // r5
  png_progressive_row_ptr v21; // r5
  png_progressive_row_ptr v22; // r5
  png_progressive_row_ptr v23; // r5
  png_progressive_row_ptr v24; // r5
  png_progressive_row_ptr v25; // r5
  png_progressive_row_ptr v26; // r5
  int v27; // r0
  int v28; // r5
  png_progressive_row_ptr v29; // r4
  int v30; // r0
  png_progressive_row_ptr v31; // r5
  png_progressive_row_ptr v32; // r5
  png_progressive_row_ptr v33; // r5
  png_progressive_row_ptr v34; // r5
  int v35; // r0
  png_progressive_row_ptr v36; // r5
  png_progressive_row_ptr v37; // r5
  png_progressive_row_ptr v38; // r5
  int v39; // r5
  png_progressive_row_ptr v40; // r4
  int v41; // r5
  png_progressive_row_ptr v42; // r4
  png_progressive_row_ptr v43; // r5
  png_progressive_row_ptr v44; // r5
  png_progressive_row_ptr v45; // r5
  int v46; // r5
  png_progressive_row_ptr v47; // r4
  int v48; // r5
  png_progressive_row_ptr v49; // r4
  png_row_info row_info; // [sp+4h] [bp-1Ch] BYREF

  iwidth = png_ptr->iwidth;
  color_type = png_ptr->color_type;
  row_info.width = iwidth;
  row_info.color_type = color_type;
  row_info.bit_depth = png_ptr->bit_depth;
  row_info.channels = png_ptr->channels;
  row_info.pixel_depth = png_ptr->pixel_depth;
  if ( row_info.pixel_depth < 8u )
    rowbytes = (iwidth * row_info.pixel_depth + 7) >> 3;
  else
    rowbytes = iwidth * (row_info.pixel_depth >> 3);
  row_buf = png_ptr->row_buf;
  row_info.rowbytes = rowbytes;
  filter = *row_buf;
  if ( *row_buf )
  {
    if ( filter > 4 )
    {
      j_png_error(png_ptr, (png_const_charp)"bad adaptive filter value");
      goto LABEL_124;
    }
    j_png_read_filter_row(png_ptr, &row_info, row_buf + 1, (png_const_bytep)png_ptr->prev_row + 1, filter);
    row_buf = png_ptr->row_buf;
    rowbytes = row_info.rowbytes;
  }
  qmemcpy(png_ptr->prev_row, row_buf, rowbytes + 1);
  if ( png_ptr->transformations )
    j_png_do_read_transformations(png_ptr, &row_info);
  pixel_depth = row_info.pixel_depth;
  if ( png_ptr->transformed_pixel_depth )
  {
    if ( png_ptr->transformed_pixel_depth == row_info.pixel_depth )
      goto LABEL_13;
    j_png_error(png_ptr, (png_const_charp)"internal progressive row size calculation error");
  }
  maximum_pixel_depth = png_ptr->maximum_pixel_depth;
  png_ptr->transformed_pixel_depth = pixel_depth;
  if ( pixel_depth > maximum_pixel_depth )
  {
LABEL_124:
    j_png_error(png_ptr, (png_const_charp)"progressive row overflow");
    JUMPOUT(0x1F53C8);
  }
LABEL_13:
  v10 = png_ptr->interlaced == 0;
  if ( png_ptr->interlaced )
  {
    transformations = png_ptr->transformations;
    v10 = (transformations & 2) == 0;
  }
  if ( !v10 )
  {
    pass = png_ptr->pass;
    if ( pass <= 5 )
    {
      j_png_do_read_interlace(&row_info, png_ptr->row_buf + 1, png_ptr->pass, transformations);
      pass = png_ptr->pass;
    }
    switch ( pass )
    {
      case 0u:
        v17 = 0;
        do
        {
          row_fn = png_ptr->row_fn;
          if ( row_fn )
            row_fn(png_ptr, png_ptr->row_buf + 1, png_ptr->row_number, 0);
          j_png_read_push_finish_row(png_ptr);
          v19 = png_ptr->pass;
          if ( v17 > 6 )
            break;
          ++v17;
        }
        while ( !png_ptr->pass );
        if ( v19 == 2 )
        {
          v20 = png_ptr->row_fn;
          if ( v20 )
            v20(png_ptr, 0, png_ptr->row_number, 2);
          j_png_read_push_finish_row(png_ptr);
          v19 = png_ptr->pass;
          if ( v19 == 2 )
          {
            v21 = png_ptr->row_fn;
            if ( v21 )
              v21(png_ptr, 0, png_ptr->row_number, 2);
            j_png_read_push_finish_row(png_ptr);
            v19 = png_ptr->pass;
            if ( v19 == 2 )
            {
              v22 = png_ptr->row_fn;
              if ( v22 )
                v22(png_ptr, 0, png_ptr->row_number, 2);
              j_png_read_push_finish_row(png_ptr);
              v19 = png_ptr->pass;
              if ( v19 == 2 )
              {
                v23 = png_ptr->row_fn;
                if ( v23 )
                  v23(png_ptr, 0, png_ptr->row_number, 2);
                j_png_read_push_finish_row(png_ptr);
                v19 = png_ptr->pass;
              }
            }
          }
        }
        if ( v19 == 4 && png_ptr->height <= 4 )
        {
          v24 = png_ptr->row_fn;
          if ( v24 )
            v24(png_ptr, 0, png_ptr->row_number, 4);
          j_png_read_push_finish_row(png_ptr);
          v19 = png_ptr->pass;
          if ( v19 == 4 )
          {
            v25 = png_ptr->row_fn;
            if ( v25 )
              v25(png_ptr, 0, png_ptr->row_number, 4);
            j_png_read_push_finish_row(png_ptr);
            v19 = png_ptr->pass;
          }
        }
        if ( v19 == 6 && png_ptr->height <= 4 )
          goto LABEL_121;
        return;
      case 1u:
        v28 = 0;
        do
        {
          v29 = png_ptr->row_fn;
          if ( v29 )
            v29(png_ptr, png_ptr->row_buf + 1, png_ptr->row_number, 1);
          j_png_read_push_finish_row(png_ptr);
          v30 = png_ptr->pass;
          if ( v28 > 6 )
            break;
          ++v28;
        }
        while ( v30 == 1 );
        if ( v30 == 2 )
        {
          v31 = png_ptr->row_fn;
          if ( v31 )
            v31(png_ptr, 0, png_ptr->row_number, 2);
          j_png_read_push_finish_row(png_ptr);
          if ( png_ptr->pass == 2 )
          {
            v32 = png_ptr->row_fn;
            if ( v32 )
              v32(png_ptr, 0, png_ptr->row_number, 2);
            j_png_read_push_finish_row(png_ptr);
            if ( png_ptr->pass == 2 )
            {
              v33 = png_ptr->row_fn;
              if ( v33 )
                v33(png_ptr, 0, png_ptr->row_number, 2);
              j_png_read_push_finish_row(png_ptr);
              if ( png_ptr->pass == 2 )
              {
                v11 = png_ptr->row_fn;
                if ( !v11 )
                  goto LABEL_20;
                row_number = png_ptr->row_number;
                v15 = png_ptr;
                v14 = 0;
                v13 = 2;
                goto LABEL_19;
              }
            }
          }
        }
        return;
      case 2u:
        v34 = png_ptr->row_fn;
        if ( v34 )
          v34(png_ptr, png_ptr->row_buf + 1, png_ptr->row_number, 2);
        j_png_read_push_finish_row(png_ptr);
        v35 = png_ptr->pass;
        if ( v35 == 2 )
        {
          v36 = png_ptr->row_fn;
          if ( v36 )
            v36(png_ptr, png_ptr->row_buf + 1, png_ptr->row_number, 2);
          j_png_read_push_finish_row(png_ptr);
          v35 = png_ptr->pass;
          if ( v35 == 2 )
          {
            v37 = png_ptr->row_fn;
            if ( v37 )
              v37(png_ptr, png_ptr->row_buf + 1, png_ptr->row_number, 2);
            j_png_read_push_finish_row(png_ptr);
            v35 = png_ptr->pass;
            if ( v35 == 2 )
            {
              v38 = png_ptr->row_fn;
              if ( v38 )
                v38(png_ptr, png_ptr->row_buf + 1, png_ptr->row_number, 2);
              j_png_read_push_finish_row(png_ptr);
              v35 = png_ptr->pass;
              if ( v35 == 2 )
              {
                v39 = 0;
                do
                {
                  v40 = png_ptr->row_fn;
                  if ( v40 )
                    v40(png_ptr, 0, png_ptr->row_number, 2);
                  j_png_read_push_finish_row(png_ptr);
                  v35 = png_ptr->pass;
                  if ( v39 > 2 )
                    break;
                  ++v39;
                }
                while ( v35 == 2 );
              }
            }
          }
        }
        goto LABEL_97;
      case 3u:
        v41 = 0;
        do
        {
          v42 = png_ptr->row_fn;
          if ( v42 )
            v42(png_ptr, png_ptr->row_buf + 1, png_ptr->row_number, 3);
          j_png_read_push_finish_row(png_ptr);
          v35 = png_ptr->pass;
          if ( v41 > 2 )
            break;
          ++v41;
        }
        while ( v35 == 3 );
LABEL_97:
        if ( v35 != 4 )
          return;
        v43 = png_ptr->row_fn;
        if ( v43 )
          v43(png_ptr, 0, png_ptr->row_number, 4);
        j_png_read_push_finish_row(png_ptr);
        if ( png_ptr->pass != 4 )
          return;
        v11 = png_ptr->row_fn;
        if ( !v11 )
          goto LABEL_20;
        row_number = png_ptr->row_number;
        v15 = png_ptr;
        v14 = 0;
        v13 = 4;
        goto LABEL_19;
      case 4u:
        v44 = png_ptr->row_fn;
        if ( v44 )
          v44(png_ptr, png_ptr->row_buf + 1, png_ptr->row_number, 4);
        j_png_read_push_finish_row(png_ptr);
        v27 = png_ptr->pass;
        if ( v27 == 4 )
        {
          v45 = png_ptr->row_fn;
          if ( v45 )
            v45(png_ptr, png_ptr->row_buf + 1, png_ptr->row_number, 4);
          j_png_read_push_finish_row(png_ptr);
          v27 = png_ptr->pass;
          if ( v27 == 4 )
          {
            v46 = 0;
            do
            {
              v47 = png_ptr->row_fn;
              if ( v47 )
                v47(png_ptr, 0, png_ptr->row_number, 4);
              j_png_read_push_finish_row(png_ptr);
              v27 = png_ptr->pass;
              if ( v46 > 0 )
                break;
              ++v46;
            }
            while ( v27 == 4 );
          }
        }
        goto LABEL_120;
      case 5u:
        v48 = 0;
        do
        {
          v49 = png_ptr->row_fn;
          if ( v49 )
            v49(png_ptr, png_ptr->row_buf + 1, png_ptr->row_number, 5);
          j_png_read_push_finish_row(png_ptr);
          v27 = png_ptr->pass;
          if ( v48 > 0 )
            break;
          ++v48;
        }
        while ( v27 == 5 );
        goto LABEL_120;
      default:
        v26 = png_ptr->row_fn;
        if ( v26 )
          v26(png_ptr, png_ptr->row_buf + 1, png_ptr->row_number, pass);
        j_png_read_push_finish_row(png_ptr);
        v27 = png_ptr->pass;
LABEL_120:
        if ( v27 != 6 )
          return;
LABEL_121:
        v11 = png_ptr->row_fn;
        if ( !v11 )
          goto LABEL_20;
        row_number = png_ptr->row_number;
        v15 = png_ptr;
        v14 = 0;
        v13 = 6;
        break;
    }
    goto LABEL_19;
  }
  v11 = png_ptr->row_fn;
  if ( v11 )
  {
    row_number = png_ptr->row_number;
    v13 = png_ptr->pass;
    v14 = png_ptr->row_buf + 1;
    v15 = png_ptr;
LABEL_19:
    v11(v15, v14, row_number, v13);
  }
LABEL_20:
  j_png_read_push_finish_row(png_ptr);
}
// 1F53C6: control flows out of bounds to 1F53C8
// 1F50B8: conditional instruction was optimized away because r0.4==4
// 1F4F88: variable 'pixel_depth' is possibly undefined
// 1F4FDE: variable 'transformations' is possibly undefined

//----- (001F5430) --------------------------------------------------------
void __fastcall png_push_have_row(png_structrp_2 png_ptr, png_bytep row)
{
  png_progressive_row_ptr row_fn; // r12

  row_fn = png_ptr->row_fn;
  if ( row_fn )
    row_fn(png_ptr, row, png_ptr->row_number, png_ptr->pass);
}

//----- (001F5448) --------------------------------------------------------
void __fastcall png_read_push_finish_row(png_structrp_2 png_ptr)
{
  png_uint_32 row_number; // r1
  png_uint_32 num_rows; // r0
  png_bytep prev_row; // r0
  size_t v5; // r1
  int pass; // r10
  unsigned int v7; // r4
  unsigned int v8; // r5
  png_uint_32 v9; // r6
  char transformations; // r1
  unsigned int v11; // r11
  png_uint_32 v12; // r9
  bool v13; // cf

  row_number = png_ptr->row_number;
  num_rows = png_ptr->num_rows;
  png_ptr->row_number = ++row_number;
  if ( row_number < num_rows || !png_ptr->interlaced )
    return;
  prev_row = png_ptr->prev_row;
  v5 = png_ptr->rowbytes + 1;
  png_ptr->row_number = 0;
  memset(prev_row, 0, v5);
  pass = png_ptr->pass;
  while ( 1 )
  {
    if ( (unsigned __int8)pass == 4 )
    {
      if ( png_ptr->width > 1 )
      {
        pass = 5;
        goto LABEL_17;
      }
      goto LABEL_12;
    }
    if ( (unsigned __int8)pass != 2 )
      break;
    if ( png_ptr->width < 3 )
      goto LABEL_12;
    pass = 3;
LABEL_17:
    v7 = (unsigned __int8)pass;
LABEL_18:
    v8 = png_read_push_finish_row_png_pass_inc[v7];
    v9 = png_ptr->width + v8 - 1 - png_read_push_finish_row_png_pass_start[v7];
    transformations = png_ptr->transformations;
    png_ptr->iwidth = v9 / v8;
    if ( (transformations & 2) == 0 )
    {
      v11 = png_read_push_finish_row_png_pass_yinc[v7];
      v12 = png_ptr->height + v11 - 1 - png_read_push_finish_row_png_pass_ystart[v7];
      v13 = v9 >= v8;
      png_ptr->num_rows = v12 / v11;
      if ( v9 >= v8 )
        v13 = v12 >= v11;
      if ( !v13 )
        continue;
    }
    goto LABEL_23;
  }
  if ( !(_BYTE)pass && png_ptr->width < 5 )
  {
LABEL_12:
    pass += 2;
    goto LABEL_17;
  }
  v7 = (unsigned __int8)(pass + 1);
  if ( v7 >= 8 )
    goto LABEL_23;
  if ( v7 != 7 )
  {
    ++pass;
    goto LABEL_18;
  }
  LOBYTE(pass) = 7;
LABEL_23:
  png_ptr->pass = pass;
}

//----- (001F555C) --------------------------------------------------------
void __fastcall png_progressive_combine_row(png_const_structrp_3 png_ptr, png_bytep old_row, png_const_bytep new_row)
{
  bool v3; // zf

  v3 = png_ptr == 0;
  if ( png_ptr )
    v3 = new_row == 0;
  if ( !v3 )
    sub_193A44(png_ptr, old_row, 1);
}

//----- (001F556C) --------------------------------------------------------
void __fastcall png_set_progressive_read_fn(
        png_structrp_2 png_ptr,
        png_voidp progressive_ptr,
        png_progressive_info_ptr info_fn,
        png_progressive_row_ptr row_fn,
        void (*a5)(png_structp, png_infop))
{
  if ( png_ptr )
  {
    png_ptr->info_fn = info_fn;
    png_ptr->row_fn = row_fn;
    png_ptr->end_fn = a5;
    sub_18D9DC(png_ptr, progressive_ptr, png_push_fill_buffer);
  }
}

//----- (001F559C) --------------------------------------------------------
png_voidp __fastcall png_get_progressive_ptr(png_const_structrp_3 png_ptr)
{
  if ( png_ptr )
    return png_ptr->io_ptr;
  else
    return 0;
}

//----- (001F55A8) --------------------------------------------------------
png_structp __fastcall png_create_read_struct(
        png_const_charp user_png_ver,
        png_voidp error_ptr,
        png_error_ptr error_fn,
        png_error_ptr warn_fn)
{
  png_structp png_struct; // r0
  png_struct *v5; // r4
  int v6; // r0

  png_struct = j_png_create_png_struct(user_png_ver, error_ptr, error_fn, warn_fn, 0, 0, 0);
  v5 = png_struct;
  if ( png_struct )
  {
    png_struct->IDAT_read_size = 0x2000;
    v6 = png_struct->flags | 0x300000;
    v5->mode = 0x8000;
    v5->flags = v6;
    j_png_set_read_fn(v5, 0, 0);
  }
  return v5;
}

//----- (001F55E6) --------------------------------------------------------
png_structp __fastcall png_create_read_struct_2(
        png_const_charp user_png_ver,
        png_voidp error_ptr,
        png_error_ptr error_fn,
        png_error_ptr warn_fn,
        png_voidp mem_ptr,
        png_malloc_ptr malloc_fn,
        png_free_ptr free_fn)
{
  png_structp png_struct; // r0
  png_struct *v8; // r4
  int v9; // r0

  png_struct = j_png_create_png_struct(user_png_ver, error_ptr, error_fn, warn_fn, mem_ptr, malloc_fn, free_fn);
  v8 = png_struct;
  if ( png_struct )
  {
    png_struct->IDAT_read_size = 0x2000;
    v9 = png_struct->flags | 0x300000;
    v8->mode = 0x8000;
    v8->flags = v9;
    j_png_set_read_fn(v8, 0, 0);
  }
  return v8;
}

//----- (001F5628) --------------------------------------------------------
void __fastcall png_read_info(png_structrp_3 png_ptr, png_inforp_2 info_ptr)
{
  bool v3; // zf
  png_uint_32 chunk_header; // r6
  int chunk_name; // r5
  png_uint_32 mode; // r0
  int v8; // r1
  int v9; // r3

  v3 = png_ptr == 0;
  if ( png_ptr )
    v3 = info_ptr == 0;
  if ( v3 )
    return;
  j_png_read_sig(png_ptr, info_ptr);
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            chunk_header = j_png_read_chunk_header(png_ptr);
            chunk_name = png_ptr->chunk_name;
            mode = png_ptr->mode;
            if ( chunk_name == 1229209940 )
            {
              if ( !(mode << 31) )
              {
                j_png_chunk_error(png_ptr, (png_const_charp)"Missing IHDR before IDAT");
LABEL_74:
                j_png_chunk_error(png_ptr, (png_const_charp)"Missing PLTE before IDAT");
                JUMPOUT(0x1F5964);
              }
              if ( (mode & 2) == 0 && png_ptr->color_type == 3 )
                goto LABEL_74;
              if ( (mode & 8) != 0 )
              {
                j_png_chunk_benign_error(png_ptr, (png_const_charp)"Too many IDATs found");
                mode = png_ptr->mode;
              }
              v8 = 4;
            }
            else
            {
              if ( (mode & 4) == 0 )
                goto LABEL_16;
              mode |= 0x2000u;
              v8 = 8;
              png_ptr->mode = mode;
            }
            png_ptr->mode = mode | v8;
LABEL_16:
            if ( chunk_name != 1229278788 )
              break;
            j_png_handle_IEND(png_ptr, info_ptr, chunk_header);
          }
          if ( chunk_name != 1229472850 )
            break;
          j_png_handle_IHDR(png_ptr, info_ptr, chunk_header);
        }
        v9 = j_png_chunk_unknown_handling(png_ptr, chunk_name);
        if ( v9 )
          break;
        if ( chunk_name == 1347179589 )
        {
          j_png_handle_PLTE(png_ptr, info_ptr, chunk_header);
        }
        else
        {
          if ( chunk_name == 1229209940 )
            goto LABEL_71;
          if ( chunk_name > 1883789682 )
          {
            if ( chunk_name <= 1934772033 )
            {
              if ( chunk_name > 1933787467 )
              {
                if ( chunk_name == 1933787468 )
                {
                  j_png_handle_sCAL(png_ptr, info_ptr, chunk_header);
                }
                else if ( chunk_name == 1934642260 )
                {
                  j_png_handle_sPLT(png_ptr, info_ptr, chunk_header);
                }
                else
                {
LABEL_70:
                  j_png_handle_unknown(png_ptr, info_ptr, chunk_header, 0);
                }
              }
              else if ( chunk_name == 1883789683 )
              {
                j_png_handle_pHYs(png_ptr, info_ptr, chunk_header);
              }
              else
              {
                if ( chunk_name != 1933723988 )
                  goto LABEL_70;
                j_png_handle_sBIT(png_ptr, info_ptr, chunk_header);
              }
            }
            else if ( chunk_name <= 1950960964 )
            {
              if ( chunk_name == 1934772034 )
              {
                j_png_handle_sRGB(png_ptr, info_ptr, chunk_header);
              }
              else
              {
                if ( chunk_name != 1950701684 )
                  goto LABEL_70;
                j_png_handle_tEXt(png_ptr, info_ptr, chunk_header);
              }
            }
            else
            {
              switch ( chunk_name )
              {
                case 1950960965:
                  j_png_handle_tIME(png_ptr, info_ptr, chunk_header);
                  break;
                case 1951551059:
                  j_png_handle_tRNS(png_ptr, info_ptr, chunk_header);
                  break;
                case 2052348020:
                  j_png_handle_zTXt(png_ptr, info_ptr, chunk_header);
                  break;
                default:
                  goto LABEL_70;
              }
            }
          }
          else if ( chunk_name <= 1749635923 )
          {
            if ( chunk_name > 1700284773 )
            {
              if ( chunk_name == 1700284774 )
              {
                j_png_handle_eXIf(png_ptr, info_ptr, chunk_header);
              }
              else
              {
                if ( chunk_name != 1732332865 )
                  goto LABEL_70;
                j_png_handle_gAMA(png_ptr, info_ptr, chunk_header);
              }
            }
            else if ( chunk_name == 1649100612 )
            {
              j_png_handle_bKGD(png_ptr, info_ptr, chunk_header);
            }
            else
            {
              if ( chunk_name != 1665684045 )
                goto LABEL_70;
              j_png_handle_cHRM(png_ptr, info_ptr, chunk_header);
            }
          }
          else if ( chunk_name <= 1767135347 )
          {
            if ( chunk_name == 1749635924 )
            {
              j_png_handle_hIST(png_ptr, info_ptr, chunk_header);
            }
            else
            {
              if ( chunk_name != 1766015824 )
                goto LABEL_70;
              j_png_handle_iCCP(png_ptr, info_ptr, chunk_header);
            }
          }
          else
          {
            switch ( chunk_name )
            {
              case 1767135348:
                j_png_handle_iTXt(png_ptr, info_ptr, chunk_header);
                break;
              case 1866876531:
                j_png_handle_oFFs(png_ptr, info_ptr, chunk_header);
                break;
              case 1883455820:
                j_png_handle_pCAL(png_ptr, info_ptr, chunk_header);
                break;
              default:
                goto LABEL_70;
            }
          }
        }
      }
      j_png_handle_unknown(png_ptr, info_ptr, chunk_header, v9);
      if ( chunk_name != 1347179589 )
        break;
      png_ptr->mode |= 2u;
    }
  }
  while ( chunk_name != 1229209940 );
  chunk_header = 0;
LABEL_71:
  png_ptr->idat_size = chunk_header;
}
// 1F5960: control flows out of bounds to 1F5964

//----- (001F59B4) --------------------------------------------------------
void __fastcall png_read_update_info(png_structrp_3 png_ptr, png_inforp_2 info_ptr)
{
  if ( png_ptr )
  {
    if ( (png_ptr->flags & 0x40) != 0 )
    {
      sub_197D9C(png_ptr, (png_const_charp)"png_read_update_info/png_start_read_image: duplicate call");
    }
    else
    {
      j_png_read_start_row(png_ptr);
      sub_19A8FC(png_ptr, info_ptr);
    }
  }
}

//----- (001F59F0) --------------------------------------------------------
void __fastcall png_start_read_image(png_structrp_3 png_ptr)
{
  if ( png_ptr )
  {
    if ( (png_ptr->flags & 0x40) != 0 )
      sub_197D9C(png_ptr, (png_const_charp)"png_start_read_image/png_read_update_info: duplicate call");
    else
      sub_190D5C(png_ptr);
  }
}

//----- (001F5A10) --------------------------------------------------------
void __fastcall png_read_row(png_structrp_3 png_ptr, png_bytep row, png_bytep dsp_row)
{
  png_uint_32 iwidth; // r0
  png_byte color_type; // r1
  unsigned int v8; // r0
  png_size_t rowbytes; // r5
  png_bytep row_buf; // r1
  unsigned int filter; // r0
  png_uint_32 bit_depth; // r3
  png_bytep v13; // r1
  png_uint_32 width; // r0
  int v15; // r2
  png_uint_32 row_number; // r0
  int v17; // r12
  _BYTE *v18; // r1
  int v19; // r5
  int v20; // r6
  _BYTE *v21; // r1
  unsigned int v22; // r5
  __int16 v23; // r2
  unsigned int pixel_depth; // r0
  unsigned int maximum_pixel_depth; // r1
  bool v26; // zf
  const png_struct *v27; // r0
  png_byte *v28; // r1
  int v29; // r2
  unsigned int pass; // r2
  png_read_status_ptr read_row_fn; // r3
  png_row_info row_info; // [sp+4h] [bp-24h] BYREF

  if ( png_ptr )
  {
    if ( (png_ptr->flags & 0x40) == 0 )
      j_png_read_start_row(png_ptr);
    iwidth = png_ptr->iwidth;
    color_type = png_ptr->color_type;
    row_info.width = iwidth;
    row_info.color_type = color_type;
    row_info.bit_depth = png_ptr->bit_depth;
    row_info.channels = png_ptr->channels;
    row_info.pixel_depth = png_ptr->pixel_depth;
    if ( row_info.pixel_depth < 8u )
      v8 = (iwidth * row_info.pixel_depth + 7) >> 3;
    else
      v8 = iwidth * (row_info.pixel_depth >> 3);
    row_info.rowbytes = v8;
    if ( !png_ptr->interlaced || (png_ptr->transformations & 2) == 0 )
    {
LABEL_9:
      if ( (png_ptr->mode & 4) != 0 )
      {
        *png_ptr->row_buf = -1;
        rowbytes = row_info.rowbytes;
        j_png_read_IDAT_data(png_ptr, png_ptr->row_buf, row_info.rowbytes + 1);
        row_buf = png_ptr->row_buf;
        filter = *row_buf;
        if ( !*row_buf )
        {
LABEL_13:
          qmemcpy(png_ptr->prev_row, row_buf, rowbytes + 1);
          if ( (png_ptr->mng_features_permitted & 4) == 0
            || png_ptr->filter_type != 64
            || (row_info.color_type & 2) == 0 )
          {
            goto LABEL_57;
          }
          bit_depth = row_info.bit_depth;
          v13 = png_ptr->row_buf;
          width = row_info.width;
          if ( row_info.bit_depth != 16 )
          {
            if ( row_info.bit_depth == 8 )
            {
              if ( row_info.color_type != 2 )
              {
                if ( row_info.color_type != 6 )
                  goto LABEL_57;
                v15 = 4;
                if ( !row_info.width )
                  goto LABEL_57;
                goto LABEL_51;
              }
              v15 = 3;
              if ( row_info.width )
              {
LABEL_51:
                v18 = v13 + 1;
                do
                {
                  --width;
                  v19 = (unsigned __int8)v18[1];
                  v20 = (unsigned __int8)v18[2];
                  *v18 += v19;
                  bit_depth = v20 + v19;
                  v18[2] = v20 + v19;
                  v18 += v15;
                }
                while ( width );
              }
            }
LABEL_57:
            if ( png_ptr->transformations )
              j_png_do_read_transformations(png_ptr, &row_info);
            pixel_depth = row_info.pixel_depth;
            if ( png_ptr->transformed_pixel_depth )
            {
              if ( png_ptr->transformed_pixel_depth == row_info.pixel_depth )
                goto LABEL_63;
              j_png_error(png_ptr, (png_const_charp)"internal sequential row size calculation error");
            }
            maximum_pixel_depth = png_ptr->maximum_pixel_depth;
            png_ptr->transformed_pixel_depth = pixel_depth;
            if ( pixel_depth <= maximum_pixel_depth )
            {
LABEL_63:
              v26 = png_ptr->interlaced == 0;
              if ( png_ptr->interlaced )
              {
                bit_depth = png_ptr->transformations;
                v26 = (bit_depth & 2) == 0;
              }
              if ( v26 )
              {
                if ( row )
                  j_png_combine_row(png_ptr, row, -1);
                if ( !dsp_row )
                  goto LABEL_78;
                v27 = png_ptr;
                v28 = dsp_row;
                v29 = -1;
              }
              else
              {
                pass = png_ptr->pass;
                if ( pass <= 5 )
                  j_png_do_read_interlace(&row_info, png_ptr->row_buf + 1, pass, bit_depth);
                if ( dsp_row )
                  j_png_combine_row(png_ptr, dsp_row, 1);
                if ( !row )
                  goto LABEL_78;
                v27 = png_ptr;
                v28 = row;
                v29 = 0;
              }
              j_png_combine_row(v27, v28, v29);
LABEL_78:
              j_png_read_finish_row(png_ptr);
              read_row_fn = png_ptr->read_row_fn;
              if ( read_row_fn )
                read_row_fn(png_ptr, png_ptr->row_number, png_ptr->pass);
              return;
            }
LABEL_83:
            j_png_error(png_ptr, (png_const_charp)"sequential row overflow");
            JUMPOUT(0x1F5CF4);
          }
          if ( row_info.color_type == 2 )
          {
            v17 = 6;
            if ( !row_info.width )
              goto LABEL_57;
          }
          else
          {
            if ( row_info.color_type != 6 )
              goto LABEL_57;
            v17 = 8;
            if ( !row_info.width )
              goto LABEL_57;
          }
          v21 = v13 + 6;
          do
          {
            --width;
            v22 = ((unsigned __int8)*(v21 - 2) | ((unsigned __int8)*(v21 - 3) << 8))
                + ((unsigned __int8)*(v21 - 4) | ((unsigned __int8)*(v21 - 5) << 8));
            v23 = _byteswap_ushort(*(_WORD *)(v21 - 3)) + _byteswap_ushort(*(_WORD *)(v21 - 1));
            *(v21 - 4) += *(v21 - 2);
            *v21 = v23;
            bit_depth = v22 >> 8;
            *(v21 - 5) = BYTE1(v22);
            *(v21 - 1) = HIBYTE(v23);
            v21 += v17;
          }
          while ( width );
          goto LABEL_57;
        }
        if ( filter <= 4 )
        {
          j_png_read_filter_row(png_ptr, &row_info, row_buf + 1, (png_const_bytep)png_ptr->prev_row + 1, filter);
          row_buf = png_ptr->row_buf;
          rowbytes = row_info.rowbytes;
          goto LABEL_13;
        }
      }
      else
      {
        j_png_error(png_ptr, (png_const_charp)"Invalid attempt to read row data");
      }
      j_png_error(png_ptr, (png_const_charp)"bad adaptive filter value");
      goto LABEL_83;
    }
    row_number = png_ptr->row_number;
    switch ( png_ptr->pass )
    {
      case 0u:
        if ( !(row_number << 29) )
          goto LABEL_9;
        goto LABEL_43;
      case 1u:
        if ( row_number << 29 || png_ptr->width <= 4 )
          goto LABEL_43;
        goto LABEL_9;
      case 2u:
        if ( (png_ptr->row_number & 7) == 4 )
          goto LABEL_9;
        if ( !dsp_row || (row_number & 4) == 0 )
          goto LABEL_45;
        goto LABEL_44;
      case 3u:
        if ( row_number << 30 || png_ptr->width <= 2 )
          goto LABEL_43;
        goto LABEL_9;
      case 4u:
        if ( (png_ptr->row_number & 3) == 2 )
          goto LABEL_9;
        if ( !dsp_row || (row_number & 2) == 0 )
          goto LABEL_45;
        goto LABEL_44;
      case 5u:
        if ( !(row_number << 31) && png_ptr->width > 1 )
          goto LABEL_9;
LABEL_43:
        if ( dsp_row )
LABEL_44:
          j_png_combine_row(png_ptr, dsp_row, 1);
LABEL_45:
        j_png_read_finish_row(png_ptr);
        break;
      default:
        if ( !(row_number << 31) )
          goto LABEL_45;
        goto LABEL_9;
    }
  }
}
// 1F5CF0: control flows out of bounds to 1F5CF4
// 1F5C4C: variable 'pixel_depth' is possibly undefined
// 1F5C98: variable 'bit_depth' is possibly undefined

//----- (001F5D7C) --------------------------------------------------------
void __fastcall png_read_rows(png_structrp_3 png_ptr, png_bytepp row, png_bytepp display_row, png_uint_32 num_rows)
{
  png_uint_32 v5; // r4
  png_bytepp v6; // r6
  png_bytepp v7; // r5
  bool v8; // zf
  png_byte *v9; // r2
  png_byte *v10; // t1
  png_byte *v11; // t1
  png_byte *v12; // t1
  bool v13; // zf
  png_byte *v14; // t1

  v5 = num_rows;
  v6 = display_row;
  v7 = row;
  if ( png_ptr )
  {
    v8 = row == 0;
    if ( row )
      v8 = display_row == 0;
    if ( v8 )
    {
      if ( row )
      {
        if ( num_rows )
        {
          do
          {
            v12 = *v7++;
            j_png_read_row(png_ptr, v12, 0);
            --v5;
          }
          while ( v5 );
        }
      }
      else
      {
        v13 = display_row == 0;
        if ( display_row )
          v13 = num_rows == 0;
        if ( !v13 )
        {
          do
          {
            v14 = *v6++;
            j_png_read_row(png_ptr, 0, v14);
            --v5;
          }
          while ( v5 );
        }
      }
    }
    else if ( num_rows )
    {
      do
      {
        v10 = *v6++;
        v9 = v10;
        v11 = *v7++;
        j_png_read_row(png_ptr, v11, v9);
        --v5;
      }
      while ( v5 );
    }
  }
}

//----- (001F5DE4) --------------------------------------------------------
void __fastcall png_read_image(png_structrp_3 png_ptr, png_bytepp image)
{
  int v4; // r9
  png_uint_32 height; // r10
  int i; // r11
  png_uint_32 v7; // r4
  png_bytepp v8; // r6
  png_byte *v9; // t1

  if ( !png_ptr )
    return;
  if ( (png_ptr->flags & 0x40) == 0 )
  {
    v4 = j_png_set_interlace_handling(png_ptr);
    if ( (png_ptr->flags & 0x40) != 0 )
    {
      j_png_app_error(png_ptr, (png_const_charp)"png_start_read_image/png_read_update_info: duplicate call");
      if ( v4 < 1 )
        return;
    }
    else
    {
      j_png_read_start_row(png_ptr);
      if ( v4 < 1 )
        return;
    }
    goto LABEL_12;
  }
  if ( png_ptr->interlaced && (png_ptr->transformations & 2) == 0 )
  {
    j_png_warning(png_ptr, (png_const_charp)"Interlace handling should be turned on when using png_read_image");
    png_ptr->num_rows = png_ptr->height;
  }
  v4 = j_png_set_interlace_handling(png_ptr);
  if ( v4 >= 1 )
  {
LABEL_12:
    height = png_ptr->height;
    for ( i = 0; i != v4; ++i )
    {
      if ( height )
      {
        v7 = height;
        v8 = image;
        do
        {
          v9 = *v8++;
          j_png_read_row(png_ptr, v9, 0);
          --v7;
        }
        while ( v7 );
      }
    }
  }
}

//----- (001F5E98) --------------------------------------------------------
void __fastcall png_read_end(png_structrp_3 png_ptr, png_inforp_2 info_ptr)
{
  png_struct *v4; // r0
  png_info *v5; // r1
  png_uint_32 v6; // r2
  int v7; // r3
  png_uint_32 chunk_header; // r0
  int chunk_name; // r4
  png_uint_32 v10; // r6
  int v11; // r8

  if ( png_ptr )
  {
    if ( !j_png_chunk_unknown_handling(png_ptr, 0x49444154u) )
      j_png_read_finish_IDAT(png_ptr);
    if ( png_ptr->color_type == 3 && png_ptr->num_palette_max > png_ptr->num_palette )
      j_png_benign_error(png_ptr, (png_const_charp)"Read palette index exceeding num_palette");
    do
    {
      chunk_header = j_png_read_chunk_header(png_ptr);
      chunk_name = png_ptr->chunk_name;
      v10 = chunk_header;
      if ( chunk_name == 1229209940 )
        goto LABEL_58;
      png_ptr->mode |= 0x2000u;
      if ( chunk_name == 1229472850 )
      {
        j_png_handle_IHDR(png_ptr, info_ptr, chunk_header);
        continue;
      }
      if ( chunk_name != 1229278788 )
      {
LABEL_58:
        if ( !info_ptr )
          goto LABEL_73;
        v11 = j_png_chunk_unknown_handling(png_ptr, chunk_name);
        if ( v11 )
        {
          if ( chunk_name != 1229209940 )
          {
            j_png_handle_unknown(png_ptr, info_ptr, v10, v11);
            if ( chunk_name == 1347179589 )
              png_ptr->mode |= 2u;
            continue;
          }
          if ( v10 && (png_ptr->flags & 8) == 0 || (png_ptr->mode & 0x2000) != 0 )
            j_png_benign_error(png_ptr, (png_const_charp)".Too many IDATs found");
          v4 = png_ptr;
          v5 = info_ptr;
          v6 = v10;
          v7 = v11;
          goto LABEL_66;
        }
        if ( chunk_name == 1229209940 )
        {
          if ( v10 && (png_ptr->flags & 8) == 0 || (png_ptr->mode & 0x2000) != 0 )
            j_png_benign_error(png_ptr, (png_const_charp)"..Too many IDATs found");
LABEL_73:
          j_png_crc_finish(png_ptr, v10);
          continue;
        }
        if ( chunk_name <= 1883455819 )
        {
          if ( chunk_name <= 1732332864 )
          {
            if ( chunk_name > 1665684044 )
            {
              if ( chunk_name == 1665684045 )
              {
                j_png_handle_cHRM(png_ptr, info_ptr, v10);
              }
              else
              {
                if ( chunk_name != 1700284774 )
                {
LABEL_53:
                  v4 = png_ptr;
                  v5 = info_ptr;
                  v6 = v10;
                  v7 = 0;
LABEL_66:
                  j_png_handle_unknown(v4, v5, v6, v7);
                  continue;
                }
                j_png_handle_eXIf(png_ptr, info_ptr, v10);
              }
            }
            else if ( chunk_name == 1347179589 )
            {
              j_png_handle_PLTE(png_ptr, info_ptr, v10);
            }
            else
            {
              if ( chunk_name != 1649100612 )
                goto LABEL_53;
              j_png_handle_bKGD(png_ptr, info_ptr, v10);
            }
          }
          else if ( chunk_name <= 1766015823 )
          {
            if ( chunk_name == 1732332865 )
            {
              j_png_handle_gAMA(png_ptr, info_ptr, v10);
            }
            else
            {
              if ( chunk_name != 1749635924 )
                goto LABEL_53;
              j_png_handle_hIST(png_ptr, info_ptr, v10);
            }
          }
          else
          {
            switch ( chunk_name )
            {
              case 1766015824:
                j_png_handle_iCCP(png_ptr, info_ptr, v10);
                break;
              case 1767135348:
                j_png_handle_iTXt(png_ptr, info_ptr, v10);
                break;
              case 1866876531:
                j_png_handle_oFFs(png_ptr, info_ptr, v10);
                break;
              default:
                goto LABEL_53;
            }
          }
        }
        else if ( chunk_name > 1934772033 )
        {
          if ( chunk_name <= 1950960964 )
          {
            if ( chunk_name == 1934772034 )
            {
              j_png_handle_sRGB(png_ptr, info_ptr, v10);
            }
            else
            {
              if ( chunk_name != 1950701684 )
                goto LABEL_53;
              j_png_handle_tEXt(png_ptr, info_ptr, v10);
            }
          }
          else
          {
            switch ( chunk_name )
            {
              case 1950960965:
                j_png_handle_tIME(png_ptr, info_ptr, v10);
                break;
              case 1951551059:
                j_png_handle_tRNS(png_ptr, info_ptr, v10);
                break;
              case 2052348020:
                j_png_handle_zTXt(png_ptr, info_ptr, v10);
                break;
              default:
                goto LABEL_53;
            }
          }
        }
        else if ( chunk_name <= 1933723987 )
        {
          if ( chunk_name == 1883455820 )
          {
            j_png_handle_pCAL(png_ptr, info_ptr, v10);
          }
          else
          {
            if ( chunk_name != 1883789683 )
              goto LABEL_53;
            j_png_handle_pHYs(png_ptr, info_ptr, v10);
          }
        }
        else
        {
          switch ( chunk_name )
          {
            case 1933723988:
              j_png_handle_sBIT(png_ptr, info_ptr, v10);
              break;
            case 1933787468:
              j_png_handle_sCAL(png_ptr, info_ptr, v10);
              break;
            case 1934642260:
              j_png_handle_sPLT(png_ptr, info_ptr, v10);
              break;
            default:
              goto LABEL_53;
          }
        }
      }
      else
      {
        j_png_handle_IEND(png_ptr, info_ptr, chunk_header);
      }
    }
    while ( (png_ptr->mode & 0x10) == 0 );
  }
}

//----- (001F6268) --------------------------------------------------------
void __fastcall png_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr)
{
  png_struct *v3; // r4
  bool v5; // zf
  png_bytep big_prev_row; // r1
  png_bytep read_buffer; // r1
  png_bytep palette_lookup; // r1
  png_bytep quantize_index; // r1
  png_uint_32 free_me; // r0
  unsigned int v12; // r1
  png_byte *data; // r1
  png_bytep chunk_list; // r1

  v5 = png_ptr_ptr == 0;
  if ( png_ptr_ptr )
  {
    v3 = *png_ptr_ptr;
    v5 = *png_ptr_ptr == 0;
  }
  if ( !v5 )
  {
    j_png_destroy_info_struct(v3, end_info_ptr_ptr);
    j_png_destroy_info_struct(v3, info_ptr_ptr);
    *png_ptr_ptr = 0;
    j_png_destroy_gamma_table(v3);
    j_png_free(v3, v3->big_row_buf);
    big_prev_row = v3->big_prev_row;
    v3->big_row_buf = 0;
    j_png_free(v3, big_prev_row);
    read_buffer = v3->read_buffer;
    v3->big_prev_row = 0;
    j_png_free(v3, read_buffer);
    palette_lookup = v3->palette_lookup;
    v3->read_buffer = 0;
    j_png_free(v3, palette_lookup);
    quantize_index = v3->quantize_index;
    v3->palette_lookup = 0;
    j_png_free(v3, quantize_index);
    free_me = v3->free_me;
    v3->quantize_index = 0;
    if ( (free_me & 0x1000) != 0 )
    {
      j_png_zfree(v3, v3->palette);
      free_me = v3->free_me;
      v3->palette = 0;
    }
    v12 = free_me & 0xFFFFEFFF;
    v3->free_me = free_me & 0xFFFFEFFF;
    if ( (free_me & 0x2000) != 0 )
    {
      j_png_free(v3, v3->trans_alpha);
      v12 = v3->free_me;
      v3->trans_alpha = 0;
    }
    v3->free_me = v12 & 0xFFFFDFFF;
    j_inflateEnd((z_streamp_1)&v3->zstream);
    j_png_free(v3, v3->save_buffer);
    data = v3->unknown_chunk.data;
    v3->save_buffer = 0;
    j_png_free(v3, data);
    chunk_list = v3->chunk_list;
    v3->unknown_chunk.data = 0;
    j_png_free(v3, chunk_list);
    v3->chunk_list = 0;
    sub_19721C(v3);
  }
}
// 1F6282: variable 'v3' is possibly undefined

//----- (001F636C) --------------------------------------------------------
void __fastcall png_set_read_status_fn(png_structrp_3 png_ptr, png_read_status_ptr read_row_fn)
{
  if ( png_ptr )
    png_ptr->read_row_fn = read_row_fn;
}

//----- (001F6378) --------------------------------------------------------
void __fastcall png_read_png(png_structrp_3 png_ptr, png_inforp_2 info_ptr, int transforms, voidp params)
{
  bool v5; // zf
  bool v8; // nf
  png_byte **v9; // r0
  png_uint_32 height; // r1
  png_uint_32 v11; // r0
  unsigned int i; // r2
  png_uint_32 v13; // r6

  v5 = png_ptr == 0;
  if ( png_ptr )
    v5 = info_ptr == 0;
  if ( !v5 )
  {
    j_png_read_info(png_ptr, info_ptr);
    if ( info_ptr->height >= 0x40000000 )
    {
      j_png_error(png_ptr, (png_const_charp)"Image is too high to process with png_read_png()");
      JUMPOUT(0x1F6508);
    }
    if ( (transforms & 0x8000) != 0 )
      j_png_set_scale_16(png_ptr);
    if ( transforms << 31 )
      j_png_set_strip_16(png_ptr);
    if ( (transforms & 2) != 0 )
      j_png_set_strip_alpha(png_ptr);
    if ( (transforms & 4) != 0 )
      j_png_set_packing(png_ptr);
    if ( (transforms & 8) != 0 )
      j_png_set_packswap(png_ptr);
    if ( (transforms & 0x10) != 0 )
      j_png_set_expand(png_ptr);
    if ( (transforms & 0x20) != 0 )
      j_png_set_invert_mono(png_ptr);
    v8 = (transforms & 0x40) != 0;
    if ( (transforms & 0x40) != 0 )
      v8 = (info_ptr->valid & 2) != 0;
    if ( v8 )
      j_png_set_shift(png_ptr, &info_ptr->sig_bit);
    if ( (transforms & 0x80) != 0 )
      j_png_set_bgr(png_ptr);
    if ( (transforms & 0x100) != 0 )
      j_png_set_swap_alpha(png_ptr);
    if ( (transforms & 0x200) != 0 )
      j_png_set_swap(png_ptr);
    if ( (transforms & 0x400) != 0 )
      j_png_set_invert_alpha(png_ptr);
    if ( (transforms & 0x2000) != 0 )
      j_png_set_gray_to_rgb(png_ptr);
    if ( (transforms & 0x4000) != 0 )
      j_png_set_expand_16(png_ptr);
    j_png_set_interlace_handling(png_ptr);
    if ( (png_ptr->flags & 0x40) != 0 )
    {
      j_png_app_error(png_ptr, (png_const_charp)"png_read_update_info/png_start_read_image: duplicate call");
    }
    else
    {
      j_png_read_start_row(png_ptr);
      j_png_read_transform_info(png_ptr, info_ptr);
    }
    j_png_free_data(png_ptr, info_ptr, 0x40u, 0);
    if ( !info_ptr->row_pointers )
    {
      v9 = (png_byte **)j_png_malloc(png_ptr, 4 * info_ptr->height);
      height = info_ptr->height;
      info_ptr->row_pointers = v9;
      if ( height )
      {
        *v9 = 0;
        v11 = info_ptr->height;
        if ( v11 >= 2 )
        {
          for ( i = 1; i < v11; ++i )
          {
            info_ptr->row_pointers[i] = 0;
            v11 = info_ptr->height;
          }
        }
        info_ptr->free_me |= 0x40u;
        if ( v11 )
        {
          v13 = 0;
          do
            info_ptr->row_pointers[v13++] = (png_byte *)j_png_malloc(png_ptr, info_ptr->rowbytes);
          while ( v13 < info_ptr->height );
        }
      }
      else
      {
        info_ptr->free_me |= 0x40u;
      }
    }
    j_png_read_image(png_ptr, info_ptr->row_pointers);
    info_ptr->valid |= 0x8000u;
    png_read_end(png_ptr, info_ptr);
  }
}
// 1F6504: control flows out of bounds to 1F6508

//----- (001F6540) --------------------------------------------------------
int __fastcall png_image_begin_read_from_stdio(png_imagep image, FILE *file)
{
  const char *v5; // r1

  if ( !image )
    return 0;
  if ( image->version == 1 )
  {
    if ( file )
    {
      if ( png_image_read_init(image) )
      {
        image->opaque->png_ptr->io_ptr = file;
        return sub_19DB08(image, png_image_read_header, image);
      }
      return 0;
    }
    v5 = "png_image_begin_read_from_stdio: invalid argument";
  }
  else
  {
    v5 = "png_image_begin_read_from_stdio: incorrect PNG_IMAGE_VERSION";
  }
  return sub_18FD2C(image, (png_const_charp)v5);
}

//----- (001F6600) --------------------------------------------------------
int __fastcall png_image_read_init(png_imagep image)
{
  png_structp png_struct; // r0
  png_struct *v4; // r5
  int v5; // r0
  png_info *info_struct; // r6
  png_control *v7; // r0
  png_info *info_ptr_ptr; // [sp+10h] [bp-18h] BYREF
  png_struct *png_ptr_ptr; // [sp+14h] [bp-14h] BYREF

  if ( image->opaque )
    return sub_18FD2C(image, (png_const_charp)"png_image_read: opaque pointer not NULL");
  png_struct = j_png_create_png_struct((png_const_charp)"1.6.34", image, png_safe_error, png_safe_warning, 0, 0, 0);
  v4 = png_struct;
  if ( png_struct )
  {
    png_struct->IDAT_read_size = 0x2000;
    v5 = png_struct->flags | 0x300000;
    v4->mode = 0x8000;
    v4->flags = v5;
    j_png_set_read_fn(v4, 0, 0);
    png_ptr_ptr = v4;
    *(_QWORD *)&image->message[48] = 0LL;
    *(_QWORD *)&image->message[56] = 0LL;
    *(_QWORD *)&image->message[32] = 0LL;
    *(_QWORD *)&image->message[40] = 0LL;
    *(_QWORD *)&image->message[16] = 0LL;
    *(_QWORD *)&image->message[24] = 0LL;
    *(_QWORD *)image->message = 0LL;
    *(_QWORD *)&image->message[8] = 0LL;
    *(_QWORD *)&image->opaque = 0LL;
    *(_QWORD *)&image->width = 0LL;
    image->version = 1;
    *(_QWORD *)&image->format = 0LL;
    *(_QWORD *)&image->colormap_entries = 0LL;
    info_struct = j_png_create_info_struct(v4);
    info_ptr_ptr = info_struct;
    if ( info_struct )
    {
      v7 = (png_control *)j_png_malloc_warn(v4, 0x18u);
      if ( v7 )
      {
        *(_QWORD *)&v7->error_buf = 0LL;
        *(_QWORD *)&v7->size = 0LL;
        v7->png_ptr = v4;
        v7->info_ptr = info_struct;
        *((_BYTE *)v7 + 20) = 0;
        image->opaque = v7;
        return 1;
      }
      j_png_destroy_info_struct(v4, &info_ptr_ptr);
    }
    j_png_destroy_read_struct(&png_ptr_ptr, 0, 0);
  }
  else
  {
    png_ptr_ptr = 0;
    *(_QWORD *)&image->message[48] = 0LL;
    *(_QWORD *)&image->message[56] = 0LL;
    *(_QWORD *)&image->message[32] = 0LL;
    *(_QWORD *)&image->message[40] = 0LL;
    *(_QWORD *)&image->message[16] = 0LL;
    *(_QWORD *)&image->message[24] = 0LL;
    *(_QWORD *)image->message = 0LL;
    *(_QWORD *)&image->message[8] = 0LL;
    *(_QWORD *)&image->opaque = 0LL;
    *(_QWORD *)&image->width = 0LL;
    image->version = 1;
    *(_QWORD *)&image->format = 0LL;
    *(_QWORD *)&image->colormap_entries = 0LL;
  }
  return j_png_image_error(image, (png_const_charp)"png_image_read: out of memory");
}

//----- (001F677C) --------------------------------------------------------
int __fastcall png_image_read_header(png_voidp argument)
{
  __int64 v2; // kr00_8
  int v3; // r1
  int v4; // r0
  unsigned int v5; // r0

  v2 = *(_QWORD *)*(_DWORD *)argument;
  j_png_set_benign_errors(**(png_structrp_7 **)argument, 1);
  j_png_read_info((png_structrp_3)v2, (png_inforp_2)HIDWORD(v2));
  *((_DWORD *)argument + 2) = *(_DWORD *)(v2 + 448);
  *((_DWORD *)argument + 3) = *(_DWORD *)(v2 + 452);
  v3 = *(unsigned __int8 *)(v2 + 527);
  v4 = v3 & 2;
  if ( (v3 & 4) != 0 )
  {
    v4 |= 1u;
  }
  else if ( *(_WORD *)(v2 + 520) )
  {
    v4 |= 1u;
  }
  if ( *(_BYTE *)(v2 + 528) == 16 )
    v4 |= 4u;
  *((_DWORD *)argument + 4) = (8 * v3) & 8 | v4;
  if ( (v4 & 2) != 0 && (*(_WORD *)(v2 + 970) & 0x8042) == 2 )
    *((_DWORD *)argument + 5) |= 1u;
  if ( *(_BYTE *)(v2 + 527) == 3 )
  {
    v5 = *(unsigned __int16 *)(v2 + 512);
  }
  else if ( *(_BYTE *)(v2 + 527) )
  {
    v5 = 256;
  }
  else
  {
    v5 = 1 << *(_BYTE *)(v2 + 528);
  }
  if ( v5 >= 0x100 )
    v5 = 256;
  *((_DWORD *)argument + 6) = v5;
  return 1;
}

//----- (001F6834) --------------------------------------------------------
int __fastcall png_image_begin_read_from_file(png_imagep image, const unsigned __int8 *file_name)
{
  FILE *v3; // r5
  char *v5; // r1
  int *v6; // r0

  if ( image )
  {
    if ( image->version == 1 )
    {
      if ( file_name )
      {
        v3 = fopen((const char *)file_name, "rb");
        if ( v3 )
        {
          if ( png_image_read_init(image) )
          {
            image->opaque->png_ptr->io_ptr = v3;
            *((_BYTE *)image->opaque + 20) |= 2u;
            return sub_19DB08(image, png_image_read_header, image);
          }
          fclose(v3);
          return 0;
        }
        v6 = (int *)_errno(0);
        v5 = strerror(*v6);
      }
      else
      {
        v5 = "png_image_begin_read_from_file: invalid argument";
      }
    }
    else
    {
      v5 = "png_image_begin_read_from_file: incorrect PNG_IMAGE_VERSION";
    }
    return sub_18FD2C(image, (png_const_charp)v5);
  }
  return 0;
}
// 19CEE8: using guessed type int __fastcall _errno(_DWORD);

//----- (001F691C) --------------------------------------------------------
int __fastcall png_image_begin_read_from_memory(png_imagep image, png_const_voidp memory, png_size_t size)
{
  bool v6; // zf
  const char *v8; // r1

  if ( !image )
    return 0;
  if ( image->version == 1 )
  {
    v6 = memory == 0;
    if ( memory )
      v6 = size == 0;
    if ( !v6 )
    {
      if ( png_image_read_init(image) )
      {
        image->opaque->memory = (png_const_bytep)memory;
        image->opaque->size = size;
        image->opaque->png_ptr->io_ptr = image;
        image->opaque->png_ptr->read_data_fn = png_image_memory_read;
        return sub_19DB08(image, png_image_read_header, image);
      }
      return 0;
    }
    v8 = "png_image_begin_read_from_memory: invalid argument";
  }
  else
  {
    v8 = "png_image_begin_read_from_memory: incorrect PNG_IMAGE_VERSION";
  }
  return sub_18FD2C(image, (png_const_charp)v8);
}

//----- (001F6A0C) --------------------------------------------------------
void __fastcall png_image_memory_read(png_structp png_ptr, png_bytep out, png_size_t need)
{
  int v3; // r6
  int *io_ptr; // r2
  bool v6; // zf
  int v7; // r5
  unsigned int v8; // r8
  __int64 v9; // r0

  if ( png_ptr )
  {
    io_ptr = (int *)png_ptr->io_ptr;
    v6 = io_ptr == 0;
    if ( io_ptr )
    {
      v3 = *io_ptr;
      v6 = *io_ptr == 0;
    }
    if ( v6 )
    {
      j_png_error(png_ptr, (png_const_charp)"invalid memory read");
    }
    else
    {
      v7 = *(_DWORD *)(v3 + 12);
      if ( v7 )
      {
        v8 = *(_DWORD *)(v3 + 16);
        if ( v8 >= need )
        {
          qmemcpy(out, *(const void **)(v3 + 12), need);
          HIDWORD(v9) = v8 - need;
          LODWORD(v9) = v7 + need;
          *(_QWORD *)(v3 + 12) = v9;
          return;
        }
      }
    }
    j_png_error(png_ptr, (png_const_charp)"read beyond end of data");
    JUMPOUT(0x1F6A58);
  }
}
// 1F6A54: control flows out of bounds to 1F6A58
// 1F6A26: variable 'v3' is possibly undefined
// 1F6A54: variable 'png_ptr' is possibly undefined

//----- (001F6A84) --------------------------------------------------------
int __fastcall png_image_finish_read(
        png_imagep image,
        png_const_colorp background,
        void *buffer,
        png_int_32 row_stride,
        int a5)
{
  png_int_32 v6; // r9
  png_uint_32 v7; // r5
  png_uint_32 format; // r11
  unsigned int width; // r6
  const char *v10; // r1
  int v11; // r5
  unsigned int v13; // r1
  png_controlp opaque; // r0
  unsigned int v15; // r6
  bool v16; // zf
  unsigned int v17; // r1
  bool v18; // zf
  int arg[6]; // [sp+10h] [bp-48h] BYREF
  __int64 v21; // [sp+28h] [bp-30h]
  __int64 v22; // [sp+30h] [bp-28h]
  int v23; // [sp+38h] [bp-20h]

  v6 = row_stride;
  if ( !image )
    return 0;
  if ( image->version != 1 )
  {
    v10 = "png_image_finish_read: damaged PNG_IMAGE_VERSION";
    return sub_18FD2C(image, (png_const_charp)v10);
  }
  v7 = 1;
  format = image->format;
  width = image->width;
  if ( (format & 8) == 0 )
    v7 = (image->format & 3) + 1;
  if ( width <= 0x7FFFFFFF / v7 )
  {
    v13 = v7 * width;
    opaque = image->opaque;
    if ( !row_stride )
      v6 = v7 * width;
    v15 = v6;
    if ( v6 < 0 )
      v15 = -v6;
    if ( v15 < v13 )
      goto LABEL_24;
    v16 = buffer == 0;
    if ( buffer )
      v16 = opaque == 0;
    if ( v16 )
    {
LABEL_24:
      v10 = "png_image_finish_read: invalid argument";
      return sub_18FD2C(image, (png_const_charp)v10);
    }
    if ( (format & 8) != 0 )
      v17 = 1;
    else
      v17 = ((format >> 2) & 1) + 1;
    if ( image->height > 0xFFFFFFFF / v17 / v15 )
    {
      v10 = "png_image_finish_read: image too large";
      return sub_18FD2C(image, (png_const_charp)v10);
    }
    if ( (format & 8) != 0 )
    {
      v18 = a5 == 0;
      if ( a5 )
        v18 = image->colormap_entries == 0;
      if ( v18 )
      {
        v10 = "png_image_finish_read[color-map]: no color-map";
        return sub_18FD2C(image, (png_const_charp)v10);
      }
    }
    v21 = 0LL;
    v22 = 0LL;
    v23 = 0;
    arg[0] = (int)image;
    arg[2] = v6;
    arg[3] = a5;
    arg[4] = (int)background;
    arg[5] = 0;
    arg[1] = (int)buffer;
    if ( (format & 8) != 0 )
    {
      if ( j_png_safe_execute(image, png_image_read_colormap, arg) )
        v11 = j_png_safe_execute(image, png_image_read_colormapped, arg) != 0;
      else
        v11 = 0;
    }
    else
    {
      v11 = j_png_safe_execute(image, png_image_read_direct, arg);
    }
    j_png_image_free(image);
    return v11;
  }
  v10 = "png_image_finish_read: row_stride too large";
  return sub_18FD2C(image, (png_const_charp)v10);
}

//----- (001F6C38) --------------------------------------------------------
int __fastcall png_image_read_colormap(png_voidp argument)
{
  int v1; // r11
  unsigned int v2; // r10
  png_struct *v3; // r9
  int v4; // r8
  int color_type; // r0
  png_uint_32 v6; // r6
  unsigned int v7; // r4
  png_uint_16 flags; // r1
  int *v9; // r2
  unsigned __int8 *v10; // r1
  int v11; // r0
  int gamma; // r0
  int v13; // r0
  png_struct *v14; // r10
  png_uint_32 v15; // r5
  int v16; // r6
  unsigned int bit_depth; // r0
  unsigned int v18; // r0
  png_uint_32 v19; // r11
  unsigned int v20; // r8
  int v21; // r2
  int v22; // r0
  png_uint_32 gray; // r9
  png_uint_32 v24; // r10
  char v25; // r0
  png_bytep trans_alpha; // r3
  png_image_read_control *v27; // r8
  int v28; // r11
  png_uint_32 num_trans; // r1
  char v30; // r1
  unsigned int rgb_colormap; // r4
  png_uint_32 v32; // r5
  png_colorp palette; // r9
  unsigned int v34; // r6
  unsigned int v35; // r0
  unsigned int v36; // r0
  png_color *v37; // r8
  int v38; // r6
  unsigned int v39; // r10
  unsigned int v40; // r0
  unsigned int v41; // r10
  int v42; // r6
  unsigned int v43; // r8
  unsigned int v44; // r0
  unsigned int v45; // r0
  png_uint_32 v46; // r1
  int v47; // r10
  png_color *v48; // r0
  png_uint_32 v49; // r3
  png_uint_32 v50; // r0
  png_uint_32 v51; // r1
  int v52; // r5
  int v53; // r10
  bool v54; // zf
  png_uint_32 n; // r5
  png_uint_32 v56; // r2
  unsigned int v57; // r3
  unsigned int v58; // r0
  png_uint_16 v59; // r1
  size_t v60; // r11
  __int16 v61; // r5
  __int16 v62; // r3
  __int16 v63; // r1
  png_struct *v64; // r10
  unsigned int v65; // r3
  __int16 v66; // lr
  png_uint_16 v67; // r12
  unsigned int v68; // r3
  int v69; // r5
  unsigned int v70; // r9
  unsigned int v71; // r3
  png_uint_16 v72; // r0
  unsigned int v73; // r6
  int v74; // r2
  png_uint_32 v75; // r10
  int v76; // r4
  unsigned int v77; // r9
  unsigned int v78; // r6
  unsigned int v79; // r0
  unsigned int v80; // r11
  unsigned int v81; // r6
  unsigned int v82; // r0
  unsigned int v83; // r8
  unsigned int v84; // r6
  unsigned int v85; // r0
  unsigned int v86; // r0
  png_uint_32 v87; // r3
  int ga_colormap; // r10
  bool v89; // zf
  png_uint_32 i; // r5
  int v91; // r2
  bool v92; // zf
  unsigned int v93; // r3
  int v94; // r4
  png_uint_32 v95; // r5
  unsigned int v96; // r6
  png_uint_32 v97; // r5
  unsigned int v98; // r0
  png_uint_32 v99; // r5
  png_uint_32 v100; // r6
  png_uint_32 v101; // r0
  int v102; // r6
  png_uint_32 m; // r5
  png_uint_32 v104; // r0
  png_uint_32 v105; // r5
  png_uint_32 v106; // r6
  int v107; // lr
  int v108; // r1
  int v109; // r9
  const png_uint_16 *v110; // r8
  int v111; // r0
  int v112; // r1
  int v113; // r4
  int v114; // t1
  png_uint_32 v115; // r3
  bool v116; // cc
  png_uint_32 blue; // [sp+0h] [bp-80h]
  png_uint_32 bluea; // [sp+0h] [bp-80h]
  int encoding; // [sp+8h] [bp-78h]
  unsigned int v121; // [sp+10h] [bp-70h]
  int v122; // [sp+10h] [bp-70h]
  png_structrp_8 v123; // [sp+14h] [bp-6Ch]
  int v124; // [sp+18h] [bp-68h]
  int v125; // [sp+18h] [bp-68h]
  int v126; // [sp+18h] [bp-68h]
  png_uint_32 v127; // [sp+1Ch] [bp-64h]
  png_uint_32 v128; // [sp+20h] [bp-60h]
  png_uint_32 red; // [sp+30h] [bp-50h]
  unsigned int v130; // [sp+34h] [bp-4Ch]
  unsigned __int8 v131; // [sp+38h] [bp-48h]
  int v132; // [sp+38h] [bp-48h]
  png_uint_32 v133; // [sp+3Ch] [bp-44h]
  unsigned int j; // [sp+3Ch] [bp-44h]
  png_uint_32 v135; // [sp+3Ch] [bp-44h]
  png_uint_32 green; // [sp+40h] [bp-40h]
  png_uint_32 greena; // [sp+40h] [bp-40h]
  png_uint_32 v138; // [sp+44h] [bp-3Ch]
  png_uint_32 v139; // [sp+44h] [bp-3Ch]
  png_uint_32 v140; // [sp+44h] [bp-3Ch]
  png_uint_32 v141; // [sp+44h] [bp-3Ch]
  png_uint_32 v142; // [sp+44h] [bp-3Ch]
  png_uint_32 value; // [sp+48h] [bp-38h]
  png_uint_32 valuea; // [sp+48h] [bp-38h]
  png_uint_32 v145; // [sp+4Ch] [bp-34h]
  unsigned int k; // [sp+4Ch] [bp-34h]
  png_uint_32 v147; // [sp+4Ch] [bp-34h]
  int v149; // [sp+54h] [bp-2Ch]
  int v150; // [sp+54h] [bp-2Ch]
  int v151; // [sp+54h] [bp-2Ch]
  png_color_16 background_color; // [sp+58h] [bp-28h] BYREF

  v1 = *(_DWORD *)argument;
  v2 = *(_DWORD *)(*(_DWORD *)argument + 16);
  v3 = ***(png_struct ****)argument;
  v130 = v2 & 4;
  v4 = (v2 >> 2) & 1;
  color_type = v3->color_type;
  if ( (color_type & 4) != 0 )
  {
    if ( !(v2 << 31) )
      goto LABEL_4;
  }
  else if ( !(v2 << 31) && v3->num_trans )
  {
LABEL_4:
    if ( (v2 & 4) != 0 )
    {
      v6 = 0;
      v7 = 0;
      value = 0;
    }
    else
    {
      v10 = (unsigned __int8 *)*((_DWORD *)argument + 4);
      if ( !v10 )
      {
LABEL_206:
        j_png_error(v3, (png_const_charp)"background color must be supplied to remove alpha/transparency");
LABEL_207:
        j_png_error(v123, (png_const_charp)"palette color-map: too few entries");
        goto LABEL_208;
      }
      v7 = v10[1];
      if ( (v2 & 2) != 0 )
      {
        value = *v10;
        v6 = v10[2];
      }
      else
      {
        v6 = v10[1];
        value = v6;
      }
    }
    goto LABEL_10;
  }
  v6 = 255;
  if ( (v2 & 4) != 0 )
    v6 = 0xFFFF;
  v7 = v6;
  value = v6;
LABEL_10:
  flags = v3->colorspace.flags;
  if ( (flags & 1) == 0 )
  {
    if ( v3->bit_depth == 16 )
    {
      v9 = &elf_hash_chain[8526];
      if ( (*(_BYTE *)(v1 + 20) & 4) != 0 )
        v9 = elf_hash_bucket + 45203;
    }
    else
    {
      v9 = elf_hash_bucket + 45203;
    }
    v3->colorspace.flags = flags | 1;
    v3->colorspace.gamma = (png_fixed_point)v9;
  }
  v149 = (v130 >> 2) + 1;
  green = v7;
  switch ( color_type )
  {
    case 0:
      bit_depth = v3->bit_depth;
      v138 = v6;
      if ( bit_depth > 8 )
      {
        if ( *(_DWORD *)(v1 + 24) < 0x100u )
        {
LABEL_211:
          j_png_error(v3, (png_const_charp)"gray[16] color-map: too few entries");
          goto LABEL_212;
        }
        for ( i = 0; i != 256; ++i )
          png_create_colormap_entry((png_image_read_control *)argument, i, i, i, i, 0xFFu, 1);
        if ( !v3->num_trans )
        {
          v52 = 0;
          v53 = 256;
          rgb_colormap = 256;
          v27 = (png_image_read_control *)argument;
          goto LABEL_187;
        }
        v27 = (png_image_read_control *)argument;
        if ( v2 << 31 )
        {
          v101 = 0;
          v91 = (v130 >> 2) + 1;
LABEL_182:
          v150 = 254;
          png_create_colormap_entry((png_image_read_control *)argument, 0xFEu, value, v7, v6, v101, v91);
          ga_colormap = 256;
          v52 = 2;
          v16 = 1;
          goto LABEL_183;
        }
        v91 = (v130 >> 2) + 1;
        v92 = v7 == v6;
        if ( v7 == v6 )
          v92 = value == v7;
        if ( !v92 )
        {
          v101 = 255;
          if ( (v2 & 4) != 0 )
            v101 = 0xFFFF;
          goto LABEL_182;
        }
        if ( (v2 & 4) != 0 )
        {
          v93 = (255 * v6) >> 15;
          v59 = png_sRGB_base[v93];
          v58 = ((255 * (_WORD)v6) & 0x7FFF) * png_sRGB_delta[v93];
          blue = v6;
          v56 = v6;
LABEL_130:
          v6 = (unsigned __int8)((unsigned __int16)(v59 + (v58 >> 12)) >> 8);
          png_create_colormap_entry(v27, v6, v56, v56, blue, 0xFFFFu, 2);
        }
LABEL_146:
        v52 = 0;
        background_color.blue = v6;
        background_color.index = 0;
        background_color.green = v6;
        background_color.red = v6;
        background_color.gray = v6;
        j_png_set_background_fixed(v3, &background_color, 1, 0, 0);
        v53 = 256;
        rgb_colormap = 256;
LABEL_187:
        j_png_set_alpha_mode_fixed(v3, 0, (png_fixed_point)&stru_35B5C.st_value);
        goto LABEL_188;
      }
      v124 = v1;
      v18 = 1 << bit_depth;
      if ( v18 > *(_DWORD *)(v1 + 24) )
      {
LABEL_209:
        j_png_error(v3, (png_const_charp)"gray[8] color-map: too few entries");
        goto LABEL_210;
      }
      v19 = v18;
      v20 = 0xFF / (v18 - 1);
      v21 = 0;
      v123 = v3;
      if ( v3->num_trans )
      {
        v22 = 255;
        if ( (v2 & 4) != 0 )
          v22 = 0xFFFF;
        gray = v3->trans_color.gray;
        if ( !(v2 << 31) )
          v21 = v22;
        v24 = v21;
      }
      else
      {
        v24 = 0;
        gray = 256;
      }
      v99 = 0;
      v100 = 0;
      do
      {
        if ( gray == v99 )
          png_create_colormap_entry((png_image_read_control *)argument, gray, value, v7, v138, v24, v149);
        else
          png_create_colormap_entry((png_image_read_control *)argument, v99, v100, v100, v100, 0xFFu, 3);
        ++v99;
        v100 += v20;
      }
      while ( v99 < v19 );
      v3 = v123;
      if ( v123->bit_depth <= 7u )
        j_png_set_packing(v123);
      rgb_colormap = v19;
      v52 = 0;
      v53 = 256;
      v27 = (png_image_read_control *)argument;
      v1 = v124;
LABEL_188:
      if ( v3->bit_depth >= 9u )
        j_png_set_scale_16(v3);
      v116 = rgb_colormap > 0x100;
      if ( rgb_colormap <= 0x100 )
        v116 = rgb_colormap > *(_DWORD *)(v1 + 24);
      if ( v116 )
      {
LABEL_203:
        j_png_error(v3, (png_const_charp)"color map overflow (BAD internal error)");
LABEL_204:
        j_png_error(v3, (png_const_charp)"invalid PNG color type");
LABEL_205:
        j_png_error(v3, (png_const_charp)"bad processing option (internal error)");
        j_png_error(v3, (png_const_charp)"bad data option (internal error)");
        goto LABEL_206;
      }
      *(_DWORD *)(v1 + 24) = rgb_colormap;
      switch ( v52 )
      {
        case 0:
        case 3:
          if ( v53 != 256 )
            goto LABEL_202;
          goto LABEL_200;
        case 1:
          if ( v53 != 231 )
            goto LABEL_202;
          goto LABEL_200;
        case 2:
          if ( v53 == 254 && rgb_colormap > 0xFE )
            goto LABEL_200;
          goto LABEL_202;
        case 4:
          if ( v53 != 216 )
          {
LABEL_202:
            j_png_error(v3, (png_const_charp)"bad background index (internal error)");
            goto LABEL_203;
          }
LABEL_200:
          v27->colormap_processing = v52;
          return 1;
        default:
          goto LABEL_205;
      }
    case 2:
    case 6:
      if ( (v2 & 2) != 0 )
      {
        if ( color_type != 6 && !v3->num_trans )
        {
          v27 = (png_image_read_control *)argument;
          if ( *(_DWORD *)(v1 + 24) <= 0xD7u )
          {
LABEL_216:
            j_png_error(v3, (png_const_charp)"rgb color-map: too few entries");
            goto LABEL_217;
          }
          rgb_colormap = make_rgb_colormap((png_image_read_control *)argument);
          v52 = 3;
          v53 = 256;
          goto LABEL_187;
        }
        v27 = (png_image_read_control *)argument;
        v126 = v1;
        if ( v2 << 31 )
        {
          v123 = v3;
          if ( *(_DWORD *)(v1 + 24) <= 0xF3u )
          {
LABEL_215:
            j_png_error(v123, (png_const_charp)"rgb+alpha color-map: too few entries");
            goto LABEL_216;
          }
          v94 = make_rgb_colormap((png_image_read_control *)argument);
          png_create_colormap_entry((png_image_read_control *)argument, v94, 0xFFu, 0xFFu, 0xFFu, 0, 1);
          v95 = v94 + 1;
          v96 = 0;
          v150 = v94;
          do
          {
            png_create_colormap_entry((png_image_read_control *)argument, v95, v96, 0, 0, 0x80u, 1);
            png_create_colormap_entry((png_image_read_control *)argument, v95 + 1, v96, 0, 0x7Fu, 0x80u, 1);
            png_create_colormap_entry((png_image_read_control *)argument, v95 + 2, v96, 0, 0xFFu, 0x80u, 1);
            png_create_colormap_entry((png_image_read_control *)argument, v95 + 3, v96, 0x7Fu, 0, 0x80u, 1);
            png_create_colormap_entry((png_image_read_control *)argument, v95 + 4, v96, 0x7Fu, 0x7Fu, 0x80u, 1);
            png_create_colormap_entry((png_image_read_control *)argument, v95 + 5, v96, 0x7Fu, 0xFFu, 0x80u, 1);
            png_create_colormap_entry((png_image_read_control *)argument, v95 + 6, v96, 0xFFu, 0, 0x80u, 1);
            png_create_colormap_entry((png_image_read_control *)argument, v95 + 7, v96, 0xFFu, 0x7Fu, 0x80u, 1);
            png_create_colormap_entry((png_image_read_control *)argument, v95 + 8, v96, 0xFFu, 0xFFu, 0x80u, 1);
            v96 = (2 * v96) | 0x7F;
            v95 += 9;
          }
          while ( v96 < 0x100 );
          v52 = 4;
          v16 = 1;
          ga_colormap = v94 + 28;
        }
        else
        {
          if ( *(_DWORD *)(v1 + 24) <= 0xF3u )
          {
LABEL_214:
            j_png_error(v3, (png_const_charp)"rgb-alpha color-map: too few entries");
            goto LABEL_215;
          }
          v60 = (__int16)v149 * (__int16)((v2 & 3) + 1);
          v140 = v6;
          v61 = value;
          v122 = make_rgb_colormap((png_image_read_control *)argument);
          png_create_colormap_entry((png_image_read_control *)argument, v122, value, v7, v6, 0, v149);
          v62 = v7;
          v63 = v7;
          if ( (v2 & 4) != 0 )
          {
            v64 = v3;
            v65 = (255 * v6) >> 15;
            v66 = png_sRGB_delta[v65];
            v67 = png_sRGB_base[v65];
            v68 = (255 * v7) >> 15;
            v69 = png_sRGB_base[v68];
            v70 = ((255 * (_WORD)v7) & 0x7FFF) * png_sRGB_delta[v68];
            v71 = (255 * value) >> 15;
            v72 = png_sRGB_base[v71];
            v73 = ((255 * (_WORD)value) & 0x7FFF) * png_sRGB_delta[v71];
            v74 = v69 + (v70 >> 12);
            v3 = v64;
            v63 = (unsigned __int8)((unsigned __int16)(v67 + ((((255 * (_WORD)v140) & 0x7FFFu) * v66) >> 12)) >> 8);
            v27 = (png_image_read_control *)argument;
            v62 = BYTE1(v74);
            v61 = (unsigned __int8)((unsigned __int16)(v72 + (v73 >> 12)) >> 8);
          }
          rgb_colormap = v122;
          if ( !memcmp(
                  (char *)v27->colormap + v122 * v60,
                  (char *)v27->colormap
                + (unsigned __int8)(6
                                  * (6 * ((unsigned __int16)(5 * v61 + 130) >> 8)
                                   + ((unsigned __int16)(5 * v62 + 130) >> 8))
                                  + ((unsigned __int16)(5 * v63 + 130) >> 8))
                * v60,
                  v60) )
          {
            background_color.red = value;
            background_color.index = 0;
            background_color.green = green;
            background_color.gray = green;
            background_color.blue = v140;
            j_png_set_background_fixed(v3, &background_color, 1, 0, 0);
            v52 = 3;
            v53 = 256;
            v1 = v126;
            goto LABEL_187;
          }
          v75 = v122 + 1;
          v123 = v3;
          for ( j = 0; j < 0x100; j = (2 * j) | 0x7F )
          {
            v127 = v75;
            for ( k = 0; k < 0x100; k = (2 * k) | 0x7F )
            {
              v76 = (v130 >> 2) + 1;
              v77 = 0;
              v128 = v75;
              do
              {
                v78 = decode_gamma(v27, j, 1);
                v79 = 127 * decode_gamma(v27, value, v76) + (v78 << 7);
                if ( v76 == 2 )
                  v80 = (257 * v79 + ((257 * v79) >> 16) + 0x8000) >> 16;
                else
                  v80 = (unsigned __int8)((unsigned __int16)(png_sRGB_base[v79 >> 15]
                                                           + (((v79 & 0x7FFF) * png_sRGB_delta[v79 >> 15]) >> 12)) >> 8);
                v81 = decode_gamma(v27, k, 1);
                v82 = 127 * decode_gamma(v27, green, v76) + (v81 << 7);
                if ( v76 == 2 )
                  v83 = (257 * v82 + ((257 * v82) >> 16) + 0x8000) >> 16;
                else
                  v83 = (unsigned __int8)((unsigned __int16)(png_sRGB_base[v82 >> 15]
                                                           + (((v82 & 0x7FFF) * png_sRGB_delta[v82 >> 15]) >> 12)) >> 8);
                v84 = decode_gamma((png_image_read_control *)argument, v77, 1);
                v85 = 127 * decode_gamma((png_image_read_control *)argument, v140, v149) + (v84 << 7);
                if ( v130 >> 2 == 1 )
                  v86 = (257 * v85 + ((257 * v85) >> 16) + 0x8000) >> 16;
                else
                  v86 = (unsigned __int8)((unsigned __int16)(png_sRGB_base[v85 >> 15]
                                                           + (((v85 & 0x7FFF) * png_sRGB_delta[v85 >> 15]) >> 12)) >> 8);
                v87 = v83;
                v76 = (v130 >> 2) + 1;
                v27 = (png_image_read_control *)argument;
                png_create_colormap_entry((png_image_read_control *)argument, v75, v80, v87, v86, 0, v149);
                v77 = (2 * v77) | 0x7F;
                ++v75;
              }
              while ( v77 < 0x100 );
              v75 = v128 + 3;
            }
            v75 = v127 + 9;
          }
          v52 = 4;
          v150 = v122;
          v16 = 1;
          ga_colormap = v122 + 28;
          v3 = v123;
          v1 = v126;
        }
      }
      else
      {
        j_png_set_rgb_to_gray_fixed(v3, 1, -1, -1);
        v11 = v3->color_type;
        if ( v11 == 6 )
        {
          if ( !(v2 << 31) )
            goto LABEL_24;
        }
        else
        {
          v89 = v2 << 31 == 0;
          if ( v2 << 31 )
            v89 = v3->num_trans == 0;
          if ( v89 )
          {
LABEL_24:
            if ( *(_DWORD *)(v1 + 24) <= 0xFFu )
            {
LABEL_208:
              j_png_error(v3, (png_const_charp)"rgb[gray] color-map: too few entries");
              goto LABEL_209;
            }
            if ( (v11 == 6 || v3->num_trans)
              && ((gamma = v3->colorspace.gamma, gamma >= (int)&elf_hash_chain[8526])
               || gamma
               && (v13 = (unsigned __int64)(1717986919LL * (11 * gamma + 2)) >> 32,
                   j_png_gamma_significant((v13 >> 1) + ((unsigned int)v13 >> 31)))) )
            {
              v14 = v3;
              v15 = 0;
              v16 = 3;
              do
              {
                png_create_colormap_entry((png_image_read_control *)argument, v15, v15, v15, v15, 0xFFu, 3);
                ++v15;
              }
              while ( v15 != 256 );
            }
            else
            {
              v14 = v3;
              v97 = 0;
              v16 = 1;
              do
              {
                png_create_colormap_entry((png_image_read_control *)argument, v97, v97, v97, v97, 0xFFu, 1);
                ++v97;
              }
              while ( v97 != 256 );
            }
            v3 = v14;
            if ( v14->color_type != 6 && !v14->num_trans )
            {
              v27 = (png_image_read_control *)argument;
              v52 = 0;
              rgb_colormap = 256;
              v53 = 256;
              if ( v16 != 3 )
                goto LABEL_187;
              goto LABEL_188;
            }
            if ( v16 == 3 )
            {
              v98 = v7;
              if ( !v4 )
                v98 = png_sRGB_table[v7];
              bluea = v7;
              encoding = (v130 >> 2) + 1;
              v7 = (255 * (unsigned int)j_png_gamma_16bit_correct(v98, v14->colorspace.gamma) + 32895) >> 16;
            }
            else
            {
              if ( !v130 )
              {
                v27 = (png_image_read_control *)argument;
                goto LABEL_165;
              }
              bluea = v7;
              encoding = 2;
              v7 = (unsigned __int8)((unsigned __int16)(png_sRGB_base[(255 * v7) >> 15]
                                                      + ((((255 * (_WORD)v7) & 0x7FFF)
                                                        * (unsigned int)png_sRGB_delta[(255 * v7) >> 15]) >> 12)) >> 8);
            }
            v27 = (png_image_read_control *)argument;
            png_create_colormap_entry((png_image_read_control *)argument, v7, green, green, bluea, 0, encoding);
LABEL_165:
            v52 = 0;
            background_color.blue = v7;
            background_color.index = 0;
            background_color.green = v7;
            background_color.red = v7;
            background_color.gray = v7;
            j_png_set_background_fixed(v14, &background_color, 1, 0, 0);
            ga_colormap = 256;
            v150 = 256;
            goto LABEL_183;
          }
        }
        if ( *(_DWORD *)(v1 + 24) <= 0xFFu )
        {
LABEL_210:
          j_png_error(v3, (png_const_charp)"rgb[ga] color-map: too few entries");
          goto LABEL_211;
        }
        v27 = (png_image_read_control *)argument;
        ga_colormap = make_ga_colormap((png_image_read_control *)argument);
        v16 = 1;
        v52 = 1;
        v150 = 231;
      }
LABEL_183:
      if ( v3->num_trans && (v3->color_type & 4) == 0 )
        j_png_set_tRNS_to_alpha(v3);
      rgb_colormap = ga_colormap;
      v53 = v150;
      if ( v16 == 3 )
        goto LABEL_188;
      goto LABEL_187;
    case 3:
      v125 = v1;
      v25 = 0;
      if ( v3->num_trans )
        trans_alpha = v3->trans_alpha;
      else
        trans_alpha = 0;
      v27 = (png_image_read_control *)argument;
      v28 = (v130 >> 2) + 1;
      num_trans = v3->num_trans;
      if ( !trans_alpha )
        num_trans = 0;
      v145 = num_trans;
      if ( !(v2 << 31) )
        v25 = 1;
      v30 = (char)trans_alpha;
      v133 = (png_uint_32)trans_alpha;
      if ( trans_alpha )
        v30 = 1;
      v123 = v3;
      rgb_colormap = v3->num_palette;
      if ( rgb_colormap >= 0x100 )
        rgb_colormap = 256;
      if ( rgb_colormap > *(_DWORD *)(v125 + 24) )
        goto LABEL_207;
      if ( rgb_colormap )
      {
        v32 = 0;
        palette = v3->palette;
        v131 = v25 & v30;
        v139 = v6;
        v121 = rgb_colormap;
        do
        {
          if ( ((v32 < v145) & v131) != 1 || (v47 = *(unsigned __int8 *)(v133 + v32), v47 == 255) )
          {
            v48 = &palette[v32];
            v49 = v48->green;
            v50 = v48->blue;
            if ( v32 >= v145 )
              v51 = 255;
            else
              v51 = *(unsigned __int8 *)(v133 + v32);
            png_create_colormap_entry(v27, v32, palette[v32].red, v49, v50, v51, 3);
          }
          else if ( *(_BYTE *)(v133 + v32) )
          {
            v34 = decode_gamma(v27, palette[v32].red, 3);
            v35 = v34 * v47 + decode_gamma(v27, value, v28) * (v47 ^ 0xFF);
            if ( v28 == 2 )
              v36 = (257 * v35 + ((257 * v35) >> 16) + 0x8000) >> 16;
            else
              v36 = (unsigned __int8)((unsigned __int16)(png_sRGB_base[v35 >> 15]
                                                       + (((v35 & 0x7FFF) * png_sRGB_delta[v35 >> 15]) >> 12)) >> 8);
            v37 = &palette[v32];
            red = v36;
            v38 = *(unsigned __int8 *)(v133 + v32);
            v39 = decode_gamma((png_image_read_control *)argument, v37->green, 3);
            v40 = v39 * v38 + decode_gamma((png_image_read_control *)argument, green, v149) * (v38 ^ 0xFF);
            if ( v130 >> 2 == 1 )
              v41 = (257 * v40 + ((257 * v40) >> 16) + 0x8000) >> 16;
            else
              v41 = (unsigned __int8)((unsigned __int16)(png_sRGB_base[v40 >> 15]
                                                       + (((v40 & 0x7FFF) * png_sRGB_delta[v40 >> 15]) >> 12)) >> 8);
            v42 = *(unsigned __int8 *)(v133 + v32);
            v28 = (v130 >> 2) + 1;
            v43 = decode_gamma((png_image_read_control *)argument, v37->blue, 3);
            v44 = v43 * v42 + decode_gamma((png_image_read_control *)argument, v139, v149) * (v42 ^ 0xFF);
            if ( v130 >> 2 == 1 )
              v45 = (257 * v44 + ((257 * v44) >> 16) + 0x8000) >> 16;
            else
              v45 = (unsigned __int8)((unsigned __int16)(png_sRGB_base[v44 >> 15]
                                                       + (((v44 & 0x7FFF) * png_sRGB_delta[v44 >> 15]) >> 12)) >> 8);
            rgb_colormap = v121;
            v46 = *(unsigned __int8 *)(v133 + v32);
            if ( v130 )
              v46 *= 257;
            v27 = (png_image_read_control *)argument;
            png_create_colormap_entry((png_image_read_control *)argument, v32, red, v41, v45, v46, v149);
            v6 = v139;
          }
          else
          {
            png_create_colormap_entry(v27, v32, value, green, v6, 0, v28);
          }
          ++v32;
        }
        while ( v32 < rgb_colormap );
      }
      v3 = v123;
      if ( v123->bit_depth <= 7u )
        j_png_set_packing(v123);
      v52 = 0;
      v53 = 256;
      v1 = v125;
      goto LABEL_188;
    case 4:
      if ( v2 << 31 )
      {
        if ( *(_DWORD *)(v1 + 24) <= 0xFFu )
        {
LABEL_212:
          j_png_error(v3, (png_const_charp)"gray+alpha color-map: too few entries");
          goto LABEL_213;
        }
        v27 = (png_image_read_control *)argument;
        rgb_colormap = make_ga_colormap((png_image_read_control *)argument);
        v52 = 1;
        v53 = 231;
        goto LABEL_187;
      }
      if ( (v2 & 2) != 0 )
      {
        v54 = v7 == v6;
        if ( v7 == v6 )
          v54 = value == v7;
        if ( !v54 )
        {
          v141 = v6;
          v123 = v3;
          if ( *(_DWORD *)(v1 + 24) < 0x100u )
          {
LABEL_217:
            j_png_error(v123, (png_const_charp)"ga-alpha color-map: too few entries");
            JUMPOUT(0x1F7AD4);
          }
          v102 = 0;
          for ( m = 0; m != 231; ++m )
          {
            png_create_colormap_entry(
              (png_image_read_control *)argument,
              m,
              (v102 + 115) / 0xE7u,
              (v102 + 115) / 0xE7u,
              (v102 + 115) / 0xE7u,
              0xFFu,
              1);
            v102 += 256;
          }
          v104 = 255;
          if ( (v2 & 4) != 0 )
            v104 = 0xFFFF;
          v105 = v141;
          v106 = value;
          png_create_colormap_entry((png_image_read_control *)argument, 0xE7u, value, v7, v141, v104, v149);
          if ( !v4 )
          {
            v105 = png_sRGB_table[v141];
            v7 = png_sRGB_table[v7];
            v106 = png_sRGB_table[value];
          }
          v107 = 232;
          v108 = 1;
          greena = v7;
          v142 = v105;
          valuea = v106;
          do
          {
            v132 = v108;
            v109 = 51 * v108;
            v110 = png_sRGB_table;
            v111 = 255 - 51 * v108;
            v151 = v111 * v105;
            v112 = v111 * v7;
            v113 = 0;
            v147 = v112;
            v135 = v111 * v106;
            do
            {
              v114 = *v110;
              v110 += 51;
              v115 = v135 + v109 * v114;
              png_create_colormap_entry(
                (png_image_read_control *)argument,
                v107 + v113++,
                (unsigned __int16)(png_sRGB_base[v115 >> 15] + (((v115 & 0x7FFF) * png_sRGB_delta[v115 >> 15]) >> 12)) >> 8,
                (unsigned __int16)(png_sRGB_base[(v147 + v109 * v114) >> 15]
                                 + (((((_WORD)v147 + (_WORD)v109 * (_WORD)v114) & 0x7FFF)
                                   * (unsigned int)png_sRGB_delta[(v147 + v109 * v114) >> 15]) >> 12)) >> 8,
                (unsigned __int16)(png_sRGB_base[(unsigned int)(v151 + v109 * v114) >> 15]
                                 + (((((_WORD)v151 + (_WORD)v109 * (_WORD)v114) & 0x7FFF)
                                   * (unsigned int)png_sRGB_delta[(unsigned int)(v151 + v109 * v114) >> 15]) >> 12)) >> 8,
                0xFFu,
                1);
            }
            while ( v113 != 6 );
            v107 += 6;
            v7 = greena;
            v105 = v142;
            v106 = valuea;
            v108 = v132 + 1;
          }
          while ( v132 != 4 );
          v27 = (png_image_read_control *)argument;
          rgb_colormap = 256;
          v52 = 1;
          v53 = 231;
          v3 = v123;
          goto LABEL_187;
        }
      }
      v27 = (png_image_read_control *)argument;
      if ( *(_DWORD *)(v1 + 24) < 0x100u )
      {
LABEL_213:
        j_png_error(v3, (png_const_charp)"gray-alpha color-map: too few entries");
        goto LABEL_214;
      }
      for ( n = 0; n != 256; ++n )
        png_create_colormap_entry((png_image_read_control *)argument, n, n, n, n, 0xFFu, 1);
      if ( (v2 & 4) != 0 )
      {
        v56 = v7;
        v57 = (255 * v7) >> 15;
        v58 = ((255 * (_WORD)v7) & 0x7FFF) * png_sRGB_delta[v57];
        v59 = png_sRGB_base[v57];
        blue = v7;
        goto LABEL_130;
      }
      LOWORD(v6) = v7;
      goto LABEL_146;
    default:
      goto LABEL_204;
  }
}
// 1F7AD0: control flows out of bounds to 1F7AD4
// 1F79C2: conditional instruction was optimized away because r6.4==1
// 1F7A6E: variable 'v123' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 10168: using guessed type int elf_hash_chain[22025];
// 35B5C: using guessed type Elf32_Sym stru_35B5C;

//----- (001F7BF4) --------------------------------------------------------
int __fastcall png_image_read_colormapped(png_voidp argument)
{
  $3F249CB5B0414D51329FA6C52C6B6F85 *v2; // r8
  int v3; // r11
  __int64 v4; // kr00_8
  int v5; // r1
  bool v6; // zf
  int v7; // r0
  bool v8; // zf
  int v9; // r1
  bool v10; // zf
  Elf32_Sym *v11; // r1
  bool v12; // zf
  png_byte *v13; // r5
  int v14; // r6
  png_alloc_size_t rowbytes; // r0
  png_voidp v18; // r5
  int v19; // r6

  v2 = *($3F249CB5B0414D51329FA6C52C6B6F85 **)argument;
  v3 = 0;
  v4 = *(_QWORD *)**(_DWORD **)argument;
  j_png_set_keep_unknown_chunks(***(png_structrp_7 ***)argument, 1, 0, -1);
  j_png_set_keep_unknown_chunks((png_structrp_7)v4, 0, (png_const_bytep)"bKGD", 6);
  if ( !*((_DWORD *)argument + 10) )
    v3 = j_png_set_interlace_handling((png_structrp_8)v4);
  if ( (_DWORD)v4 )
  {
    if ( (*(_BYTE *)(v4 + 312) & 0x40) != 0 )
    {
      j_png_app_error(
        (png_const_structrp_0)v4,
        (png_const_charp)"png_read_update_info/png_start_read_image: duplicate call");
    }
    else
    {
      j_png_read_start_row((png_structrp_6)v4);
      j_png_read_transform_info((png_structrp_5)v4, (png_inforp_3)HIDWORD(v4));
    }
  }
  switch ( *((_DWORD *)argument + 10) )
  {
    case 0:
      v7 = *(unsigned __int8 *)(HIDWORD(v4) + 25);
      v8 = v7 == 3;
      if ( v7 != 3 )
        v8 = v7 == 0;
      if ( !v8 || *(_BYTE *)(HIDWORD(v4) + 24) != 8 )
        goto LABEL_44;
      goto LABEL_33;
    case 1:
    case 2:
      if ( *(_BYTE *)(HIDWORD(v4) + 25) != 4 )
        goto LABEL_44;
      v5 = *(unsigned __int8 *)(HIDWORD(v4) + 24);
      v6 = v5 == 8;
      if ( v5 == 8 )
        v6 = *(_DWORD *)(v4 + 580) == (_DWORD)&stru_35B5C.st_value;
      if ( !v6 || v2->colormap_entries != 256 )
        goto LABEL_44;
      goto LABEL_33;
    case 3:
      if ( *(_BYTE *)(HIDWORD(v4) + 25) != 2 )
        goto LABEL_44;
      v9 = *(unsigned __int8 *)(HIDWORD(v4) + 24);
      v10 = v9 == 8;
      if ( v9 == 8 )
        v10 = *(_DWORD *)(v4 + 580) == (_DWORD)&stru_35B5C.st_value;
      if ( !v10 || v2->colormap_entries != 216 )
        goto LABEL_44;
      goto LABEL_33;
    case 4:
      if ( __PAIR64__(*(unsigned __int8 *)(HIDWORD(v4) + 25), *(unsigned __int8 *)(HIDWORD(v4) + 24)) != 0x600000008LL )
        goto LABEL_44;
      v11 = *(Elf32_Sym **)(v4 + 580);
      v12 = v11 == (Elf32_Sym *)&stru_35B5C.st_value;
      if ( v11 == (Elf32_Sym *)&stru_35B5C.st_value )
        v12 = v2->colormap_entries == 244;
      if ( !v12 )
        goto LABEL_44;
LABEL_33:
      v14 = *((_DWORD *)argument + 2);
      v13 = (png_byte *)*((_DWORD *)argument + 1);
      if ( v14 <= -1 )
        v13 += (v2->height - 1) * -v14;
      *((_DWORD *)argument + 6) = v13;
      *((_DWORD *)argument + 7) = v14;
      if ( v3 )
      {
        if ( v3 >= 1 )
        {
          while ( 1 )
          {
            if ( v2->height )
            {
              do
              {
                j_png_read_row((png_structrp_3)v4, v13, 0);
                v13 += v14;
              }
              while ( HIDWORD(v4) != 1 );
            }
            if ( v3 < 2 )
              break;
            v13 = (png_byte *)*((_DWORD *)argument + 6);
            --v3;
          }
        }
        return 1;
      }
      else
      {
        rowbytes = j_png_get_rowbytes((png_const_structrp_1)v4, (png_const_inforp)HIDWORD(v4));
        v18 = j_png_malloc((png_const_structrp_2)v4, rowbytes);
        *((_DWORD *)argument + 5) = v18;
        v19 = j_png_safe_execute(v2, png_image_read_and_map, argument);
        *((_DWORD *)argument + 5) = 0;
        j_png_free((png_const_structrp_2)v4, v18);
        return v19;
      }
    default:
LABEL_44:
      j_png_error((png_const_structrp_0)v4, (png_const_charp)"bad color-map processing (internal error)");
      JUMPOUT(0x1F7D80);
  }
}
// 1F7D7E: control flows out of bounds to 1F7D80
// 35B5C: using guessed type Elf32_Sym stru_35B5C;

//----- (001F7DB8) --------------------------------------------------------
int __fastcall png_image_read_direct(png_voidp argument)
{
  $3F249CB5B0414D51329FA6C52C6B6F85 *v2; // r6
  int v3; // r10
  int v4; // r5
  unsigned int v5; // r8
  int v6; // r0
  png_fixed_point v7; // r2
  png_fixed_point v8; // r6
  int v9; // r9
  unsigned int v10; // r11
  int v11; // r5
  int v12; // r0
  int v13; // r4
  _DWORD *v14; // r9
  png_uint_32 v15; // r1
  unsigned int v16; // r4
  bool v17; // zf
  int v18; // r0
  unsigned int v19; // r5
  int v20; // r6
  int v21; // r8
  int v22; // r11
  png_info *v23; // r6
  const png_info *v24; // r12
  int v25; // r0
  int v26; // r6
  int v27; // r1
  int v28; // r2
  int v29; // r0
  int v30; // r3
  int v31; // r1
  int v32; // r0
  png_byte *v33; // r6
  int v34; // r5
  png_alloc_size_t rowbytes; // r0
  png_voidp v36; // r6
  int (*v37)(png_voidp); // r1
  png_alloc_size_t v38; // r0
  int v39; // r5
  png_uint_32 i; // r4
  unsigned __int8 *v42; // r0
  $3F249CB5B0414D51329FA6C52C6B6F85 *v43; // [sp+4h] [bp-44h]
  png_info *info_ptr; // [sp+8h] [bp-40h]
  _DWORD *v45; // [sp+Ch] [bp-3Ch]
  unsigned int v46; // [sp+10h] [bp-38h]
  int v47; // [sp+18h] [bp-30h]
  int v48; // [sp+18h] [bp-30h]
  png_color_16 background_color; // [sp+1Ch] [bp-2Ch] BYREF
  png_fixed_point res[8]; // [sp+28h] [bp-20h] BYREF

  v2 = *($3F249CB5B0414D51329FA6C52C6B6F85 **)argument;
  v46 = *(_DWORD *)(*(_DWORD *)argument + 16);
  v3 = ***(_DWORD ***)argument;
  info_ptr = *(png_info **)(**(_DWORD **)argument + 4);
  j_png_set_expand((png_structrp_5)v3);
  v4 = *(_BYTE *)(v3 + 527) & 2;
  if ( (*(_BYTE *)(v3 + 527) & 4) != 0 )
  {
    v4 |= 1u;
  }
  else if ( *(_WORD *)(v3 + 520) )
  {
    v4 |= 1u;
  }
  if ( *(_BYTE *)(v3 + 528) == 16 )
    v4 |= 4u;
  v5 = v4 & 0xFFFFFFF7 ^ v46;
  if ( (v5 & 2) != 0 )
  {
    if ( (v46 & 2) != 0 )
    {
      j_png_set_gray_to_rgb((png_structrp_5)v3);
      v6 = 0;
    }
    else
    {
      j_png_set_rgb_to_gray_fixed((png_structrp_5)v3, 1, -1, -1);
      v6 = v4 & 1;
    }
    v5 &= ~2u;
  }
  else
  {
    v6 = 0;
  }
  v47 = v6;
  v45 = argument;
  if ( (v4 & 4) != 0 )
  {
    v7 = (png_fixed_point)&elf_hash_chain[8526];
    if ( (v2->flags & 4) != 0 )
      v7 = -1;
  }
  else
  {
    v7 = -1;
  }
  v43 = v2;
  j_png_set_alpha_mode_fixed((png_structrp_5)v3, 0, v7);
  v8 = (png_fixed_point)&elf_hash_chain[8526];
  v9 = v4 & 1;
  v10 = v5 & 0xFFFFFFBF;
  v11 = v46 & 4;
  if ( (v46 & 4) != 0 )
    v11 = v9;
  else
    v8 = -1;
  if ( (v5 & 0x40) != 0 )
    v11 = 2;
  if ( !v47
    || j_png_muldiv(res, v8, *(_DWORD *)(v3 + 896), (png_int_32)&elf_hash_chain[8526])
    && !j_png_gamma_significant(res[0]) )
  {
    v48 = 0;
    if ( (v5 & 4) != 0 )
      goto LABEL_31;
LABEL_34:
    if ( v5 << 31 )
      goto LABEL_38;
LABEL_35:
    v13 = 0;
    v14 = v45;
    goto LABEL_50;
  }
  v12 = v47;
  if ( v11 == 1 )
    v12 = 2;
  v48 = v12;
  if ( v11 == 1 )
    v11 = 0;
  if ( (v5 & 4) == 0 )
    goto LABEL_34;
LABEL_31:
  if ( (v46 & 4) != 0 )
    j_png_set_expand_16((png_structrp_5)v3);
  else
    j_png_set_scale_16((png_structrp_5)v3);
  v10 = v5 & 0xFFFFFFBB;
  if ( !(v5 << 31) )
    goto LABEL_35;
LABEL_38:
  if ( !v9 )
  {
    v15 = 255;
    if ( (v46 & 4) != 0 )
      v15 = 0xFFFF;
    v16 = v46 & 0x20;
    j_png_set_add_alpha((png_structrp_8)v3, v15, (v16 >> 5) ^ 1);
    v17 = v16 == 0;
    v13 = 0;
    if ( !v17 )
      v10 &= 0xFFFFFF9F;
    v14 = v45;
    goto LABEL_49;
  }
  v14 = argument;
  if ( v48 )
  {
    v18 = 2;
  }
  else
  {
    if ( (v46 & 4) == 0 )
    {
      v42 = (unsigned __int8 *)*((_DWORD *)argument + 4);
      v48 = 0;
      if ( v42 )
      {
        background_color.index = 0;
        background_color.red = *v42;
        background_color.green = v42[1];
        background_color.blue = v42[2];
        background_color.gray = v42[1];
        j_png_set_background_fixed((png_structrp_5)v3, &background_color, 1, 0, 0);
        v13 = 0;
      }
      else
      {
        v13 = 1;
        v11 = 2;
      }
      goto LABEL_49;
    }
    j_png_set_strip_alpha((png_structrp_5)v3);
    v18 = 0;
  }
  v13 = 0;
  v48 = v18;
LABEL_49:
  v10 &= ~1u;
LABEL_50:
  j_png_set_alpha_mode_fixed((png_structrp_5)v3, v11, v8);
  if ( (v10 & 0x10) != 0 )
  {
    v19 = v46;
    v20 = v48;
    if ( (v46 & 2) != 0 )
      j_png_set_bgr((png_structrp_8)v3);
    else
      v19 = v46 & 0xFFFFFFEF;
    v10 &= ~0x10u;
    if ( (v10 & 0x20) == 0 )
      goto LABEL_61;
  }
  else
  {
    v19 = v46;
    v20 = v48;
    if ( (v10 & 0x20) == 0 )
      goto LABEL_61;
  }
  if ( v19 << 31 )
  {
    if ( v20 != 2 )
      j_png_set_swap_alpha((png_structrp_8)v3);
  }
  else
  {
    v19 &= ~0x20u;
  }
  v10 &= ~0x20u;
LABEL_61:
  if ( (v46 & 4) != 0 )
    j_png_set_swap((png_structrp_8)v3);
  if ( v10 )
  {
    j_png_error((png_const_structrp_0)v3, (png_const_charp)"png_read_image: unsupported transformation");
    goto LABEL_108;
  }
  v21 = 0;
  j_png_set_keep_unknown_chunks((png_structrp_7)v3, 1, 0, -1);
  j_png_set_keep_unknown_chunks((png_structrp_7)v3, 0, (png_const_bytep)"bKGD", 6);
  if ( v20 != 2 && !v13 )
    v21 = j_png_set_interlace_handling((png_structrp_8)v3);
  v22 = v20;
  if ( (*(_BYTE *)(v3 + 312) & 0x40) != 0 )
  {
    j_png_app_error(
      (png_const_structrp_0)v3,
      (png_const_charp)"png_read_update_info/png_start_read_image: duplicate call");
    v23 = info_ptr;
  }
  else
  {
    j_png_read_start_row((png_structrp_6)v3);
    v23 = info_ptr;
    j_png_read_transform_info((png_structrp_5)v3, info_ptr);
  }
  v24 = v23;
  v25 = v23->color_type & 2;
  if ( (v23->color_type & 4) == 0 )
  {
    v26 = v22;
    if ( !v13 )
      goto LABEL_75;
    j_png_error((png_const_structrp_0)v3, (png_const_charp)"png_image_read: alpha channel lost");
  }
  v26 = v22;
  if ( !v13 )
  {
    v27 = v19 & 1 | v22 ^ 2;
    v25 |= v27 != 0;
  }
LABEL_75:
  v28 = *(_DWORD *)(v3 + 316);
  v29 = v25 | v19 & 0x40;
  if ( v24->bit_depth == 16 )
    v29 |= 4u;
  v30 = (16 * v28) & 0x10 | v29;
  v31 = v30 | 0x20;
  v32 = v30;
  if ( v26 == 2 )
    v32 = v30 | 0x20;
  if ( (v19 & 0x20) == 0 )
    v32 = v30;
  if ( (v28 & 0x20000) != 0 )
    goto LABEL_87;
  if ( (v28 & 0x1000000) != 0 )
  {
    if ( (*(_DWORD *)(v3 + 312) & 0x80) == 0 )
      v32 = v30 | 0x20;
    if ( !((v26 != 2) | ((*(_DWORD *)(v3 + 312) & 0x80u) >> 7)) )
    {
      do
      {
        j_png_error((png_const_structrp_0)v3, (png_const_charp)"unexpected alpha swap transformation");
LABEL_87:
        v32 = v31;
      }
      while ( v26 == 2 );
    }
  }
  if ( v32 != v19 )
  {
LABEL_108:
    j_png_error((png_const_structrp_0)v3, (png_const_charp)"png_read_image: invalid transformations");
    JUMPOUT(0x1F81B4);
  }
  v33 = (png_byte *)v14[1];
  v34 = v14[2] << ((unsigned __int8)(v46 & 4) >> 2);
  if ( v34 <= -1 )
    v33 += (v43->height - 1) * -v34;
  v14[6] = v33;
  v14[7] = v34;
  if ( v13 )
  {
    rowbytes = j_png_get_rowbytes((png_const_structrp_1)v3, v24);
    v36 = j_png_malloc((png_const_structrp_2)v3, rowbytes);
    v37 = png_image_read_composite;
LABEL_95:
    v14[5] = v36;
    v39 = j_png_safe_execute(v43, v37, v14);
    v14[5] = 0;
    j_png_free((png_const_structrp_2)v3, v36);
    return v39;
  }
  if ( v48 == 2 )
  {
    v38 = j_png_get_rowbytes((png_const_structrp_1)v3, v24);
    v36 = j_png_malloc((png_const_structrp_2)v3, v38);
    v37 = png_image_read_background;
    goto LABEL_95;
  }
  if ( v21 >= 1 )
  {
    while ( 1 )
    {
      for ( i = v43->height; i; --i )
      {
        j_png_read_row((png_structrp_3)v3, v33, 0);
        v33 += v34;
      }
      if ( v21 < 2 )
        break;
      v33 = (png_byte *)v14[6];
      --v21;
    }
  }
  return 1;
}
// 1F81B2: control flows out of bounds to 1F81B4
// 1F8040: variable 'v25' is possibly undefined
// 1F8042: variable 'v24' is possibly undefined
// 1F80AA: variable 'v31' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];
// 1F7DB8: using guessed type png_fixed_point res[8];

//----- (001F8240) --------------------------------------------------------
void __fastcall png_create_colormap_entry(
        png_image_read_control *display,
        png_uint_32 ip,
        png_uint_32 red,
        png_uint_32 green,
        png_uint_32 blue,
        png_uint_32 alpha,
        int encoding)
{
  png_image_read_control *v7; // r6
  unsigned __int64 v8; // r10
  png_imagep image; // r4
  png_uint_32 v11; // r12
  png_uint_32 format; // r0
  int v13; // r3
  png_uint_32 v14; // r8
  int file_encoding; // r1
  unsigned int v16; // r9
  png_uint_32 v17; // lr
  bool v18; // zf
  int v19; // r2
  png_fixed_point gamma_to_linear; // r4
  int v21; // r0
  int v22; // r0
  png_fixed_point gamma; // r4
  png_fixed_point v24; // r0
  png_uint_32 v25; // r2
  int v26; // r0
  int v27; // r1
  int v28; // r3
  int v29; // r4
  int v30; // r6
  _WORD *v31; // r2
  int v32; // r4
  int v33; // r6
  _BYTE *v34; // r2
  int v35; // r3
  __int16 v36; // r2
  unsigned int v37; // r3
  unsigned int v38; // r6
  png_uint_16 v39; // r12
  __int16 v40; // r8
  png_uint_16 v41; // r0
  unsigned int v42; // r3
  int v43; // r0
  int v44; // r2
  int v45; // [sp+4h] [bp-2Ch]
  int v46; // [sp+4h] [bp-2Ch]
  $3F249CB5B0414D51329FA6C52C6B6F85 *v47; // [sp+8h] [bp-28h]
  $3F249CB5B0414D51329FA6C52C6B6F85 *v48; // [sp+8h] [bp-28h]
  png_uint_32 v49; // [sp+Ch] [bp-24h]
  png_uint_32 v50; // [sp+Ch] [bp-24h]
  int v51; // [sp+10h] [bp-20h]

  v7 = display;
  v8 = __PAIR64__(red, blue);
  image = display->image;
  v11 = ip;
  format = display->image->format;
  v13 = (format >> 2) & 1;
  if ( (format & 2) != 0 )
    goto LABEL_6;
  v14 = red ^ green | green ^ blue;
  if ( __PAIR64__(red, blue) != __PAIR64__(green, green) )
    v14 = 1;
  if ( ip >= 0x100 )
  {
    do
    {
      j_png_error(image->opaque->png_ptr, (png_const_charp)"color-map index out of range");
LABEL_6:
      v14 = 0;
    }
    while ( v11 >= 0x100 );
  }
  file_encoding = encoding;
  v16 = format & 4;
  v17 = alpha;
  v18 = encoding == 3;
  v19 = (v16 >> 2) + 1;
  if ( encoding == 3 )
  {
    file_encoding = v7->file_encoding;
    v18 = file_encoding == 0;
  }
  if ( !v18 )
    goto LABEL_10;
  v46 = v13;
  v48 = image;
  v50 = v11;
  gamma = image->opaque->png_ptr->colorspace.gamma;
  if ( !j_png_gamma_significant(gamma) )
  {
    v7->file_encoding = 4;
    v19 = (v16 >> 2) + 1;
    v17 = alpha;
    v13 = v46;
    image = v48;
    v11 = v50;
LABEL_57:
    v17 *= 257;
    LODWORD(v8) = 257 * blue;
    green *= 257;
    HIDWORD(v8) *= 257;
    if ( v14 == 1 )
      goto LABEL_16;
    goto LABEL_58;
  }
  if ( gamma > 99999 || gamma && j_png_gamma_significant((11 * gamma + 2) / 5) )
  {
    v7->file_encoding = 3;
    v24 = j_png_reciprocal(gamma);
    file_encoding = v7->file_encoding;
    v7->gamma_to_linear = v24;
    v19 = (v16 >> 2) + 1;
    v17 = alpha;
    v13 = v46;
    image = v48;
    v11 = v50;
LABEL_10:
    switch ( file_encoding )
    {
      case 1:
        goto LABEL_65;
      case 2:
        goto LABEL_15;
      case 3:
        v51 = v19;
        v45 = v13;
        v47 = image;
        v49 = v11;
        gamma_to_linear = v7->gamma_to_linear;
        HIDWORD(v8) = j_png_gamma_16bit_correct(257 * HIDWORD(v8), gamma_to_linear);
        green = j_png_gamma_16bit_correct(257 * green, gamma_to_linear);
        LODWORD(v8) = j_png_gamma_16bit_correct(257 * blue, gamma_to_linear);
        v21 = v16;
        if ( v16 )
          v21 = 1;
        if ( !(v21 | v14) )
        {
          v36 = 255 * v8;
          v37 = (unsigned int)(255 * v8) >> 15;
          LODWORD(v8) = v7;
          v38 = (unsigned int)(255 * HIDWORD(v8)) >> 15;
          v39 = png_sRGB_base[v37];
          v40 = png_sRGB_delta[v37];
          v41 = png_sRGB_base[v38];
          v42 = png_sRGB_delta[v38] * ((255 * WORD2(v8)) & 0x7FFF);
          v7 = (png_image_read_control *)v8;
          v17 = alpha;
          LODWORD(v8) = (unsigned __int8)((unsigned __int16)(v39 + ((v40 * (v36 & 0x7FFFu)) >> 12)) >> 8);
          green = (unsigned __int8)((unsigned __int16)(png_sRGB_base[(255 * green) >> 15]
                                                     + ((png_sRGB_delta[(255 * green) >> 15]
                                                       * ((255 * (_WORD)green) & 0x7FFFu)) >> 12)) >> 8);
          HIDWORD(v8) = (unsigned __int8)((unsigned __int16)(v41 + (v42 >> 12)) >> 8);
          image = v47;
          v11 = v49;
          if ( v51 == 1 )
            goto LABEL_26;
          goto LABEL_60;
        }
        v19 = v51;
        v13 = v45;
        image = v47;
        v11 = v49;
        v17 = 257 * alpha;
LABEL_15:
        if ( v14 != 1 )
          goto LABEL_58;
        break;
      case 4:
        goto LABEL_57;
      default:
        goto LABEL_25;
    }
    goto LABEL_16;
  }
  v7->file_encoding = 1;
  v19 = (v16 >> 2) + 1;
  v17 = alpha;
  v13 = v46;
  image = v48;
  v11 = v50;
LABEL_65:
  v43 = v16;
  if ( v16 )
    v43 = 1;
  if ( !(v43 | v14) )
    goto LABEL_70;
  v17 *= 257;
  LODWORD(v8) = png_sRGB_table[blue];
  green = png_sRGB_table[green];
  HIDWORD(v8) = png_sRGB_table[HIDWORD(v8)];
  if ( v14 != 1 )
  {
LABEL_58:
    if ( !v13 )
      goto LABEL_61;
    if ( v19 == 2 )
      goto LABEL_26;
    goto LABEL_60;
  }
LABEL_16:
  v22 = 6968 * HIDWORD(v8) + 23434 * green + 2366 * v8;
  if ( v16 )
  {
    file_encoding = 2;
    LODWORD(v8) = (unsigned int)(v22 + 0x4000) >> 15;
  }
  else
  {
    LODWORD(v8) = (unsigned __int8)((unsigned __int16)(png_sRGB_base[(255 * ((unsigned int)(v22 + 128) >> 8) + 64) >> 22]
                                                     + (((((255 * ((unsigned int)(v22 + 128) >> 8) + 64) >> 7) & 0x7FFF)
                                                       * png_sRGB_delta[(255 * ((unsigned int)(v22 + 128) >> 8) + 64) >> 22]) >> 12)) >> 8);
    file_encoding = 1;
    v17 = (255 * v17 + 32895) >> 16;
  }
  green = v8;
  HIDWORD(v8) = v8;
LABEL_25:
  if ( file_encoding == v19 )
    goto LABEL_26;
  do
  {
LABEL_60:
    j_png_error(image->opaque->png_ptr, (png_const_charp)"bad encoding (internal error)");
LABEL_61:
    LODWORD(v8) = (unsigned __int8)((unsigned __int16)(png_sRGB_base[(unsigned int)(255 * v8) >> 15]
                                                     + ((((255 * (_WORD)v8) & 0x7FFF)
                                                       * (unsigned int)png_sRGB_delta[(unsigned int)(255 * v8) >> 15]) >> 12)) >> 8);
    green = (unsigned __int8)((unsigned __int16)(png_sRGB_base[(255 * green) >> 15]
                                               + ((((255 * (_WORD)green) & 0x7FFF)
                                                 * (unsigned int)png_sRGB_delta[(255 * green) >> 15]) >> 12)) >> 8);
    HIDWORD(v8) = (unsigned __int8)((unsigned __int16)(png_sRGB_base[(unsigned int)(255 * HIDWORD(v8)) >> 15]
                                                     + ((((255 * WORD2(v8)) & 0x7FFF)
                                                       * (unsigned int)png_sRGB_delta[(unsigned int)(255 * HIDWORD(v8)) >> 15]) >> 12)) >> 8);
    v17 = (255 * v17 + 32895) >> 16;
LABEL_70:
    ;
  }
  while ( v19 != 1 );
LABEL_26:
  v25 = image->format;
  v26 = 0;
  v27 = v25 & 0x21;
  v28 = (v25 >> 3) & 2;
  if ( v27 == 33 )
    v26 = 1;
  if ( v16 )
  {
    v29 = v25 & 3;
    v30 = (int)v7->colormap + 2 * (v29 + 1) * v11;
    if ( (v25 & 3) != 0 )
    {
      if ( v29 != 1 )
      {
        if ( v29 != 2 )
        {
          v31 = (_WORD *)v30;
          if ( v27 != 33 )
            v31 = (_WORD *)(v30 + 6);
          *v31 = v17;
        }
        if ( v17 <= 0xFFFE )
        {
          if ( v17 )
          {
            HIDWORD(v8) = (HIDWORD(v8) * v17 + 0x7FFF) / 0xFFFF;
            green = (green * v17 + 0x7FFF) / 0xFFFF;
            LODWORD(v8) = ((unsigned int)v8 * v17 + 0x7FFF) / 0xFFFF;
          }
          else
          {
            LOWORD(v8) = 0;
            LOWORD(green) = 0;
            WORD2(v8) = 0;
          }
        }
        v26 |= v28;
        *(_WORD *)(v30 + 2 * (v26 ^ 2)) = v8;
        v44 = 2;
        if ( v27 == 33 )
          v44 = 4;
        *(_WORD *)(v30 + v44) = green;
        goto LABEL_76;
      }
      *(_WORD *)(v30 + 2 * (v26 ^ 1)) = v17;
    }
    if ( v17 > 0xFFFE )
    {
      WORD2(v8) = green;
    }
    else if ( v17 )
    {
      HIDWORD(v8) = (green * v17 + 0x7FFF) / 0xFFFF;
    }
    else
    {
      WORD2(v8) = 0;
    }
LABEL_76:
    *(_WORD *)(v30 + 2 * v26) = WORD2(v8);
    return;
  }
  v32 = v25 & 3;
  v33 = (int)v7->colormap + (v32 + 1) * v11;
  if ( (v25 & 3) != 0 )
  {
    if ( v32 == 1 )
    {
      v35 = v26 ^ 1;
      BYTE4(v8) = green;
    }
    else
    {
      if ( v32 != 2 )
      {
        v34 = (_BYTE *)v33;
        if ( v27 != 33 )
          v34 = (_BYTE *)(v33 + 3);
        *v34 = v17;
      }
      v26 |= v28;
      v35 = 1;
      LOBYTE(v17) = green;
      *(_BYTE *)(v33 + (v26 ^ 2)) = v8;
      if ( v27 == 33 )
        v35 = 2;
    }
    *(_BYTE *)(v33 + v35) = v17;
  }
  else
  {
    BYTE4(v8) = green;
  }
  *(_BYTE *)(v33 + v26) = BYTE4(v8);
}
// 1F8290: variable 'v11' is possibly undefined
// 1F8294: variable 'format' is possibly undefined
// 1F82C4: variable 'v13' is possibly undefined
// 1F868C: variable 'v19' is possibly undefined

//----- (001F8720) --------------------------------------------------------
int __fastcall make_ga_colormap(png_image_read_control *display)
{
  int v2; // r6
  png_uint_32 i; // r5
  png_uint_32 v4; // r5
  png_uint_32 j; // r10

  v2 = 0;
  for ( i = 0; i != 231; ++i )
  {
    png_create_colormap_entry(display, i, (v2 + 115) / 0xE7u, (v2 + 115) / 0xE7u, (v2 + 115) / 0xE7u, 0xFFu, 1);
    v2 += 256;
  }
  png_create_colormap_entry(display, 0xE7u, 0xFFu, 0xFFu, 0xFFu, 0, 1);
  v4 = 232;
  for ( j = 51; j != 255; j += 51 )
  {
    png_create_colormap_entry(display, v4, 0, 0, 0, j, 1);
    png_create_colormap_entry(display, v4 + 1, 0x33u, 0x33u, 0x33u, j, 1);
    png_create_colormap_entry(display, v4 + 2, 0x66u, 0x66u, 0x66u, j, 1);
    png_create_colormap_entry(display, v4 + 3, 0x99u, 0x99u, 0x99u, j, 1);
    png_create_colormap_entry(display, v4 + 4, 0xCCu, 0xCCu, 0xCCu, j, 1);
    png_create_colormap_entry(display, v4 + 5, 0xFFu, 0xFFu, 0xFFu, j, 1);
    v4 += 6;
  }
  return 256;
}

//----- (001F8820) --------------------------------------------------------
int __fastcall make_rgb_colormap(png_image_read_control *display)
{
  int v2; // r2
  png_uint_32 v3; // r4
  png_uint_32 v4; // r5
  png_uint_32 v5; // r6
  png_uint_32 v7; // [sp+Ch] [bp-24h]
  int v8; // [sp+10h] [bp-20h]

  v2 = 0;
  v3 = 0;
  do
  {
    v4 = 51 * v2;
    v5 = 0;
    v8 = v2;
    v7 = v3;
    do
    {
      png_create_colormap_entry(display, v3, v4, v5, 0, 0xFFu, 1);
      png_create_colormap_entry(display, v3 + 1, v4, v5, 0x33u, 0xFFu, 1);
      png_create_colormap_entry(display, v3 + 2, v4, v5, 0x66u, 0xFFu, 1);
      png_create_colormap_entry(display, v3 + 3, v4, v5, 0x99u, 0xFFu, 1);
      png_create_colormap_entry(display, v3 + 4, v4, v5, 0xCCu, 0xFFu, 1);
      png_create_colormap_entry(display, v3 + 5, v4, v5, 0xFFu, 0xFFu, 1);
      v5 += 51;
      v3 += 6;
    }
    while ( v5 != 306 );
    v2 = v8 + 1;
    v3 = v7 + 36;
  }
  while ( v8 != 5 );
  return 216;
}

//----- (001F88DC) --------------------------------------------------------
unsigned int __fastcall decode_gamma(png_image_read_control *display, png_uint_32 value, int encoding)
{
  int gamma; // r6
  png_fixed_point v6; // r0

  if ( encoding == 3 )
    encoding = display->file_encoding;
  if ( encoding )
  {
LABEL_9:
    switch ( encoding )
    {
      case 1:
        return png_sRGB_table[value];
      case 2:
        return value;
      case 3:
        return j_png_gamma_16bit_correct(257 * value, display->gamma_to_linear);
      case 4:
        goto LABEL_12;
      default:
        j_png_error(display->image->opaque->png_ptr, (png_const_charp)"unexpected encoding (internal error)");
        JUMPOUT(0x1F8984);
    }
  }
  gamma = display->image->opaque->png_ptr->colorspace.gamma;
  if ( j_png_gamma_significant(gamma) )
  {
    if ( gamma >= (int)&elf_hash_chain[8526] || gamma && j_png_gamma_significant((11 * gamma + 2) / 5) )
    {
      display->file_encoding = 3;
      v6 = j_png_reciprocal(gamma);
      encoding = display->file_encoding;
      display->gamma_to_linear = v6;
      goto LABEL_9;
    }
    display->file_encoding = 1;
    return png_sRGB_table[value];
  }
  else
  {
    display->file_encoding = 4;
LABEL_12:
    value *= 257;
  }
  return value;
}
// 1F8980: control flows out of bounds to 1F8984
// 10168: using guessed type int elf_hash_chain[22025];

//----- (001F89B0) --------------------------------------------------------
int __fastcall png_image_read_and_map(png_voidp argument)
{
  png_structrp_3 **v1; // r1
  int interlaced; // r0
  __int64 v3; // kr00_8
  int v4; // r4
  int v5; // r8
  int v6; // r0
  int v7; // r2
  int v8; // r9
  int v9; // r10
  unsigned int v10; // r11
  unsigned int v11; // r0
  int v12; // r2
  int v13; // r3
  png_byte *v14; // r6
  _BYTE *v15; // r0
  __int16 v16; // r2
  __int16 v17; // r3
  __int16 v18; // r4
  unsigned __int8 *v19; // r2
  unsigned int v20; // r3
  unsigned int v21; // r3
  int v22; // r3
  int v23; // r6
  int v24; // r1
  unsigned int v25; // r1
  unsigned int v26; // r3
  unsigned int v27; // r2
  int v29; // [sp+4h] [bp-3Ch]
  int v30; // [sp+8h] [bp-38h]
  int v31; // [sp+Ch] [bp-34h]
  int v32; // [sp+10h] [bp-30h]
  int v34; // [sp+18h] [bp-28h]
  png_structrp_3 *v35; // [sp+1Ch] [bp-24h]
  png_structrp_3 v36; // [sp+20h] [bp-20h]

  v1 = *(png_structrp_3 ***)argument;
  v36 = ***(png_structrp_3 ***)argument;
  interlaced = v36->interlaced;
  v29 = 1;
  if ( v36->interlaced )
  {
    if ( interlaced != 1 )
    {
      j_png_error(v36, (png_const_charp)"unknown interlace type");
      JUMPOUT(0x1F8C04);
    }
    v29 = 7;
  }
  v3 = *((_QWORD *)v1 + 1);
  v4 = 0;
  v35 = v1[3];
  v32 = *((_DWORD *)argument + 6);
  v31 = *((_DWORD *)argument + 7);
  v5 = *((_DWORD *)argument + 10) - 1;
  while ( 1 )
  {
    v30 = v4;
    if ( (unsigned __int8)interlaced != 1 )
    {
      v10 = 0;
      v34 = 1;
      v9 = 1;
      v8 = 0;
      goto LABEL_43;
    }
    v6 = 7 - v4;
    LOBYTE(v7) = 3;
    if ( v4 > 1 )
      v7 = v6 >> 1;
    v8 = ((v4 & 1) << (3 - ((v4 + 1) >> 1))) & 7;
    if ( (unsigned int)(v3 - 1 + (1 << v7) - v8) >> v7 )
    {
      v9 = 1 << (v6 >> 1);
      v10 = (!(v4 & 1) << (3 - (v4 >> 1))) & 7;
      if ( v4 < 3 )
        v11 = 8;
      else
        v11 = 8u >> ((v4 - 1) >> 1);
      v34 = v11;
LABEL_43:
      while ( v10 < (unsigned int)v35 )
      {
        v14 = (png_byte *)*((_DWORD *)argument + 5);
        j_png_read_row(v36, v14, 0);
        v24 = v32 + v10 * v31;
        v15 = (_BYTE *)(v24 + v8);
        v25 = v24 + v3;
        switch ( v5 )
        {
          case 0:
            if ( v8 < (int)v3 )
            {
              do
              {
                v26 = v14[1];
                if ( v26 < 0xE6 )
                {
                  if ( v26 >= 0x1A )
                    LOBYTE(v27) = ((unsigned __int16)(5 * *v14 + 130) >> 8)
                                + 6 * ((unsigned __int16)(5 * v26 + 130) >> 8)
                                - 30;
                  else
                    LOBYTE(v27) = -25;
                }
                else
                {
                  v27 = (231 * (unsigned int)*v14 + 128) >> 8;
                }
                *v15 = v27;
                v15 += v9;
                v14 += 2;
              }
              while ( (unsigned int)v15 < v25 );
            }
            break;
          case 1:
            if ( v8 < (int)v3 )
            {
              do
              {
                v12 = *v14;
                v13 = v14[1];
                v14 += 2;
                if ( v12 == 254 )
                  LOBYTE(v12) = -1;
                if ( !v13 )
                  LOBYTE(v12) = -2;
                *v15 = v12;
                v15 += v9;
              }
              while ( (unsigned int)v15 < v25 );
            }
            break;
          case 2:
            if ( v8 < (int)v3 )
            {
              do
              {
                v16 = *v14;
                v17 = v14[1];
                v18 = v14[2];
                v14 += 3;
                *v15 = 6 * (6 * ((unsigned __int16)(5 * v16 + 130) >> 8) + ((unsigned __int16)(5 * v17 + 130) >> 8))
                     + ((unsigned __int16)(5 * v18 + 130) >> 8);
                v15 += v9;
              }
              while ( (unsigned int)v15 < v25 );
            }
            break;
          case 3:
            if ( v8 < (int)v3 )
            {
              v19 = v14 + 3;
              do
              {
                v20 = *v19;
                if ( v20 < 0xC4 )
                {
                  if ( v20 >= 0x40 )
                  {
                    v22 = (char)*(v19 - 3);
                    v23 = 217;
                    if ( v22 < 0 )
                      v23 = 226;
                    if ( (v22 & 0x40) != 0 )
                      v23 += 9;
                    if ( v22 < 0 )
                      v23 += 3;
                    if ( (v22 & 0x40) != 0 )
                      v23 += 3;
                    v21 = (((unsigned int)v22 >> 6) & 1) + ((unsigned __int8)(v22 & 0x80) >> 7) + v23;
                  }
                  else
                  {
                    LOBYTE(v21) = -40;
                  }
                }
                else
                {
                  v21 = 6
                      * (6 * ((5 * (unsigned int)*(v19 - 3) + 130) >> 8) + ((5 * (unsigned int)*(v19 - 2) + 130) >> 8))
                      + ((5 * (unsigned int)*(v19 - 1) + 130) >> 8);
                }
                *v15 = v21;
                v15 += v9;
                v19 += 4;
              }
              while ( (unsigned int)v15 < v25 );
            }
            break;
          default:
            break;
        }
        v10 += v34;
      }
    }
    v4 = v30 + 1;
    if ( v30 + 1 >= v29 )
      return 1;
    LOBYTE(interlaced) = v36->interlaced;
  }
}
// 1F8C00: control flows out of bounds to 1F8C04

//----- (001F8C08) --------------------------------------------------------
int __fastcall png_image_read_composite(png_voidp argument)
{
  png_structrp_3 **v1; // r1
  int interlaced; // r0
  __int64 v3; // r2
  int v4; // r5
  int v5; // r8
  int v6; // r0
  int v7; // r3
  int v8; // r2
  unsigned int v9; // r3
  unsigned int v10; // r0
  png_byte *v11; // r6
  int v12; // r0
  unsigned int v13; // r12
  unsigned int v14; // r1
  int v15; // r2
  int i; // r0
  unsigned int v17; // r5
  int v19; // [sp+0h] [bp-50h]
  int v20; // [sp+4h] [bp-4Ch]
  int v21; // [sp+8h] [bp-48h]
  int v22; // [sp+Ch] [bp-44h]
  int v23; // [sp+10h] [bp-40h]
  png_structrp_3 *v24; // [sp+14h] [bp-3Ch]
  png_structrp_3 v25; // [sp+18h] [bp-38h]
  int v26; // [sp+1Ch] [bp-34h]
  int v28; // [sp+24h] [bp-2Ch]
  unsigned int v29; // [sp+28h] [bp-28h]
  int v30; // [sp+30h] [bp-20h]

  v1 = *(png_structrp_3 ***)argument;
  v25 = ***(png_structrp_3 ***)argument;
  interlaced = v25->interlaced;
  v20 = 1;
  if ( v25->interlaced )
  {
    if ( interlaced != 1 )
    {
      j_png_error(v25, (png_const_charp)"unknown interlace type");
      JUMPOUT(0x1F8DA8);
    }
    v20 = 7;
  }
  v3 = *((_QWORD *)v1 + 1);
  v4 = 0;
  v24 = v1[3];
  v5 = (unsigned int)v1[4] & 2 | 1;
  v26 = v5 * v3;
  v22 = *((_DWORD *)argument + 7);
  v19 = v3 - 1;
  while ( 1 )
  {
    v21 = v4;
    if ( (unsigned __int8)interlaced != 1 )
    {
      v30 = v5;
      v23 = 1;
      v28 = 0;
      v9 = 0;
      goto LABEL_17;
    }
    v6 = 7 - v4;
    LOBYTE(v7) = 3;
    if ( v4 > 1 )
      v7 = v6 >> 1;
    v8 = ((v4 & 1) << (3 - ((v4 + 1) >> 1))) & 7;
    if ( (unsigned int)(v19 + (1 << v7) - v8) >> v7 )
    {
      v30 = v5 << (v6 >> 1);
      v28 = (__int16)v8 * (__int16)v5;
      v9 = (!(v4 & 1) << (3 - (v4 >> 1))) & 7;
      if ( v4 < 3 )
        v10 = 8;
      else
        v10 = 8u >> ((v4 - 1) >> 1);
      v23 = v10;
LABEL_17:
      while ( v9 < (unsigned int)v24 )
      {
        v29 = v9;
        v11 = (png_byte *)*((_DWORD *)argument + 5);
        j_png_read_row(v25, v11, 0);
        if ( v28 < v26 )
        {
          v12 = *((_DWORD *)argument + 6) + v29 * v22;
          v13 = v12 + v26;
          v14 = v28 + v12;
          do
          {
            v15 = v11[v5];
            if ( v11[v5] )
            {
              for ( i = 0; i != v5; ++i )
              {
                v17 = v11[i];
                if ( v15 != 255 )
                {
                  v17 = 0xFFFF * v17 + png_sRGB_table[*(unsigned __int8 *)(v14 + i)] * (v15 ^ 0xFF);
                  LOBYTE(v17) = (unsigned __int16)(png_sRGB_base[v17 >> 15]
                                                 + (((v17 & 0x7FFF) * png_sRGB_delta[v17 >> 15]) >> 12)) >> 8;
                }
                *(_BYTE *)(v14 + i) = v17;
              }
            }
            v14 += v30;
            v11 += v5 + 1;
          }
          while ( v14 < v13 );
        }
        v9 = v29 + v23;
      }
    }
    v4 = v21 + 1;
    if ( v21 + 1 >= v20 )
      return 1;
    LOBYTE(interlaced) = v25->interlaced;
  }
}
// 1F8DA6: control flows out of bounds to 1F8DA8

//----- (001F8DB8) --------------------------------------------------------
int __fastcall png_image_read_background(png_voidp argument)
{
  png_struct ***v1; // r4
  png_struct **v2; // r0
  png_uint_32 transformations; // r1
  const png_info *v4; // r6
  png_struct **v5; // r1
  int interlaced; // r0
  int v7; // r2
  int bit_depth; // r2
  int v9; // r5
  int v10; // r0
  int v11; // r2
  int v12; // r8
  unsigned int v13; // r11
  unsigned int v14; // r0
  int v15; // r0
  unsigned int v16; // r10
  int v17; // r9
  png_byte *v18; // r6
  int v19; // r1
  unsigned int v20; // r0
  _BYTE *v21; // r1
  _BYTE *v22; // r2
  int v23; // r6
  unsigned int v24; // r3
  bool v25; // zf
  png_byte *v26; // r6
  int v27; // r1
  unsigned int v28; // r0
  _BYTE *v29; // r1
  _BYTE *v30; // r2
  int v31; // r3
  int v32; // r6
  unsigned int v33; // r3
  int v34; // r5
  int v35; // r4
  int v36; // r0
  int v37; // r3
  int v38; // r2
  int v39; // r0
  unsigned int v40; // r4
  unsigned int v41; // r1
  int v42; // r9
  int v43; // r10
  int v44; // r8
  int v45; // r11
  int v46; // r2
  unsigned int v47; // r0
  unsigned __int16 *v48; // r1
  int v49; // r3
  unsigned int v50; // r4
  unsigned int v52; // [sp+4h] [bp-64h]
  int v53; // [sp+8h] [bp-60h]
  int v54; // [sp+Ch] [bp-5Ch]
  int v55; // [sp+10h] [bp-58h]
  int v56; // [sp+10h] [bp-58h]
  int v57; // [sp+14h] [bp-54h]
  int v58; // [sp+18h] [bp-50h]
  int v59; // [sp+1Ch] [bp-4Ch]
  int v60; // [sp+20h] [bp-48h]
  int v61; // [sp+20h] [bp-48h]
  int v62; // [sp+24h] [bp-44h]
  int v63; // [sp+24h] [bp-44h]
  int v64; // [sp+2Ch] [bp-3Ch]
  int v65; // [sp+30h] [bp-38h]
  int v66; // [sp+34h] [bp-34h]
  int v67; // [sp+34h] [bp-34h]
  unsigned int v68; // [sp+38h] [bp-30h]
  png_struct *v69; // [sp+3Ch] [bp-2Ch]
  int v70; // [sp+40h] [bp-28h]
  unsigned int v71; // [sp+40h] [bp-28h]
  int v72; // [sp+44h] [bp-24h]
  int v73; // [sp+44h] [bp-24h]

  v1 = *(png_struct ****)argument;
  v2 = **(png_struct ****)argument;
  v69 = *v2;
  transformations = (*v2)->transformations;
  if ( (transformations & 0x600000) == 0 )
  {
    j_png_error(v69, (png_const_charp)"lost rgb to gray");
    goto LABEL_72;
  }
  if ( (transformations & 0x80) != 0 )
  {
LABEL_72:
    j_png_error(v69, (png_const_charp)"unexpected compose");
    goto LABEL_73;
  }
  v70 = (int)v1[2];
  v68 = (unsigned int)v1[3];
  v4 = (const png_info *)v2[1];
  if ( j_png_get_channels(v69, v4) != 2 )
  {
LABEL_73:
    j_png_error(v69, (png_const_charp)"lost/gained channels");
    goto LABEL_74;
  }
  v5 = v1[4];
  if ( ((unsigned __int8)v5 & 5) == 1 )
  {
LABEL_74:
    j_png_error(v69, (png_const_charp)"unexpected 8-bit transformation");
    goto LABEL_75;
  }
  interlaced = v69->interlaced;
  if ( !v69->interlaced )
  {
    v7 = 1;
    goto LABEL_9;
  }
  if ( interlaced != 1 )
  {
LABEL_75:
    j_png_error(v69, (png_const_charp)"unknown interlace type");
    goto LABEL_76;
  }
  v7 = 7;
LABEL_9:
  v54 = v7;
  bit_depth = v4->bit_depth;
  if ( bit_depth != 16 )
  {
    if ( bit_depth == 8 )
    {
      v9 = 0;
      v62 = *((_DWORD *)argument + 6);
      v60 = *((_DWORD *)argument + 7);
      while ( 1 )
      {
        v55 = v9;
        if ( (unsigned __int8)interlaced != 1 )
          break;
        v10 = 7 - v9;
        LOBYTE(v11) = 3;
        if ( v9 > 1 )
          v11 = v10 >> 1;
        v72 = ((v9 & 1) << (3 - ((v9 + 1) >> 1))) & 7;
        if ( (unsigned int)(v70 - 1 + (1 << v11) - v72) >> v11 )
        {
          v12 = 1 << (v10 >> 1);
          v13 = (!(v9 & 1) << (3 - (v9 >> 1))) & 7;
          if ( v9 < 3 )
            v14 = 8;
          else
            v14 = 8u >> ((v9 - 1) >> 1);
          v66 = v14;
LABEL_23:
          v15 = *((_DWORD *)argument + 4);
          if ( v15 )
          {
            if ( v13 < v68 )
            {
              v16 = *(unsigned __int8 *)(v15 + 1);
              v17 = png_sRGB_table[v16];
              do
              {
                v18 = (png_byte *)*((_DWORD *)argument + 5);
                j_png_read_row(v69, v18, 0);
                if ( v72 < v70 )
                {
                  v19 = v62 + v13 * v60;
                  v20 = v70 + v19;
                  v21 = (_BYTE *)(v19 + v72);
                  v22 = v18 + 1;
                  do
                  {
                    v23 = (unsigned __int8)*v22;
                    v24 = v16;
                    v25 = v23 == 0;
                    if ( *v22 )
                    {
                      v24 = (unsigned __int8)*(v22 - 1);
                      v25 = v23 == 255;
                    }
                    if ( !v25 )
                    {
                      v24 = (v23 ^ 0xFF) * v17 + png_sRGB_table[v24] * v23;
                      LOBYTE(v24) = (unsigned __int16)(png_sRGB_base[v24 >> 15]
                                                     + (((v24 & 0x7FFF) * png_sRGB_delta[v24 >> 15]) >> 12)) >> 8;
                    }
                    *v21 = v24;
                    v21 += v12;
                    v22 += 2;
                  }
                  while ( (unsigned int)v21 < v20 );
                }
                v13 += v66;
              }
              while ( v13 < v68 );
            }
          }
          else
          {
            while ( v13 < v68 )
            {
              v26 = (png_byte *)*((_DWORD *)argument + 5);
              j_png_read_row(v69, v26, 0);
              if ( v72 < v70 )
              {
                v27 = v62 + v13 * v60;
                v28 = v70 + v27;
                v29 = (_BYTE *)(v27 + v72);
                v30 = v26 + 1;
                do
                {
                  v31 = (unsigned __int8)*v30;
                  if ( *v30 )
                  {
                    v32 = (unsigned __int8)*(v30 - 1);
                    if ( v31 != 255 )
                    {
                      v33 = png_sRGB_table[v32] * v31 + (v31 ^ 0xFF) * png_sRGB_table[(unsigned __int8)*v29];
                      LOBYTE(v32) = (unsigned __int16)(png_sRGB_base[v33 >> 15]
                                                     + (((v33 & 0x7FFF) * png_sRGB_delta[v33 >> 15]) >> 12)) >> 8;
                    }
                    *v29 = v32;
                  }
                  v29 += v12;
                  v30 += 2;
                }
                while ( (unsigned int)v29 < v28 );
              }
              v13 += v66;
            }
          }
        }
        ++v9;
        if ( v55 + 1 >= v54 )
          return 1;
        LOBYTE(interlaced) = v69->interlaced;
      }
      v13 = 0;
      v66 = 1;
      v12 = 1;
      v72 = 0;
      goto LABEL_23;
    }
LABEL_76:
    j_png_error(v69, (png_const_charp)"unexpected bit depth");
    JUMPOUT(0x1F91F8);
  }
  v34 = (unsigned __int8)v5 & 1;
  v58 = v34 + 1;
  v35 = 0;
  v56 = 2 * (((unsigned __int8)v5 & 0x21) != 33);
  v57 = v70 - 1;
  v67 = v58 * v70;
  v53 = 2 * (((unsigned __int8)v5 & 0x21) == 33);
  v63 = *((_DWORD *)argument + 6);
  v52 = (*((_DWORD *)argument + 7) + (*((_DWORD *)argument + 7) >> 31)) & 0xFFFFFFFE;
  v61 = *((_DWORD *)argument + 7) / 2;
  while ( 1 )
  {
    v59 = v35;
    if ( (unsigned __int8)interlaced != 1 )
    {
      v40 = 0;
      v64 = 1;
      v65 = 0;
      v39 = v58;
      goto LABEL_57;
    }
    v36 = 7 - v35;
    LOBYTE(v37) = 3;
    if ( v35 > 1 )
      v37 = v36 >> 1;
    v38 = ((v35 & 1) << (3 - ((v35 + 1) >> 1))) & 7;
    if ( (unsigned int)(v57 + (1 << v37) - v38) >> v37 )
    {
      v39 = v58 << (v36 >> 1);
      v65 = (__int16)v38 * (__int16)v58;
      v40 = (!(v35 & 1) << (3 - (v35 >> 1))) & 7;
      if ( v59 < 3 )
        v41 = 8;
      else
        v41 = 8u >> ((v59 - 1) >> 1);
      v64 = v41;
LABEL_57:
      if ( v40 < v68 )
      {
        v42 = 2 * v39;
        v43 = v56 + 2 * v65 + v52 * v40;
        v73 = v63;
        v44 = v53 + 2 * v65 + v52 * v40;
        v45 = v52 * v40 + 2 * v65;
        do
        {
          v71 = v40;
          j_png_read_row(v69, *((png_bytep *)argument + 5), 0);
          if ( v65 < v67 )
          {
            v46 = v73;
            v47 = v63 + 2 * v61 * v40 + 2 * v67;
            v48 = (unsigned __int16 *)*((_DWORD *)argument + 5);
            do
            {
              v49 = v48[1];
              if ( v48[1] )
              {
                v50 = *v48;
                if ( v49 != 0xFFFF )
                  v50 = (v49 * v50 + 0x7FFF) / 0xFFFF;
              }
              else
              {
                LOWORD(v50) = 0;
              }
              *(_WORD *)(v44 + v46) = v50;
              if ( v34 )
                *(_WORD *)(v43 + v46) = v49;
              v46 += v42;
              v48 += 2;
            }
            while ( v46 + v45 < v47 );
          }
          v73 += v64 * v52;
          v40 = v71 + v64;
        }
        while ( v71 + v64 < v68 );
      }
    }
    v35 = v59 + 1;
    if ( v59 + 1 >= v54 )
      return 1;
    LOBYTE(interlaced) = v69->interlaced;
  }
}
// 1F91F4: control flows out of bounds to 1F91F8

//----- (001F9290) --------------------------------------------------------
void __fastcall png_read_data(png_structrp_4 png_ptr, png_bytep data, png_size_t length)
{
  void (*read_data_fn)(void); // r3

  read_data_fn = (void (*)(void))png_ptr->read_data_fn;
  if ( !read_data_fn )
  {
    j_png_error(png_ptr, (png_const_charp)"Call to NULL read function");
    JUMPOUT(0x1F92A4);
  }
  read_data_fn();
}
// 1F92A2: control flows out of bounds to 1F92A4

//----- (001F92C0) --------------------------------------------------------
void __fastcall png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
  if ( png_ptr && fread(data, 1u, length, (FILE *)png_ptr->io_ptr) != length )
  {
    j_png_error(png_ptr, (png_const_charp)"Read Error");
    JUMPOUT(0x1F92EC);
  }
}
// 1F92EA: control flows out of bounds to 1F92EC

//----- (001F92F8) --------------------------------------------------------
void __fastcall png_set_read_fn(png_structrp_4 png_ptr, png_voidp io_ptr, png_rw_ptr read_data_fn)
{
  png_rw_ptr write_data_fn; // r1

  if ( png_ptr )
  {
    png_ptr->io_ptr = io_ptr;
    write_data_fn = png_ptr->write_data_fn;
    if ( !read_data_fn )
      read_data_fn = png_default_read_data;
    png_ptr->read_data_fn = read_data_fn;
    if ( write_data_fn )
    {
      png_ptr->write_data_fn = 0;
      j_png_warning(png_ptr, (png_const_charp)"Can't set both read_data_fn and write_data_fn in the same structure");
    }
    png_ptr->output_flush_fn = 0;
  }
}

//----- (001F9340) --------------------------------------------------------
void __fastcall png_set_crc_action(png_structrp_5 png_ptr, int crit_action, int ancil_action)
{
  png_uint_32 v5; // r0
  png_uint_32 v6; // r0

  if ( png_ptr )
  {
    switch ( crit_action )
    {
      case 2:
        j_png_warning(png_ptr, (png_const_charp)"Can't discard critical data on CRC error");
        goto LABEL_4;
      case 3:
        v5 = png_ptr->flags & 0xFFFFF3FF | 0x400;
        goto LABEL_7;
      case 4:
        v5 = png_ptr->flags | 0xC00;
        goto LABEL_7;
      case 5:
        goto LABEL_8;
      default:
LABEL_4:
        v5 = png_ptr->flags & 0xFFFFF3FF;
LABEL_7:
        png_ptr->flags = v5;
LABEL_8:
        switch ( ancil_action )
        {
          case 1:
            v6 = png_ptr->flags & 0xFFFFFCFF | 0x200;
            goto LABEL_13;
          case 3:
            v6 = png_ptr->flags & 0xFFFFFCFF | 0x100;
            goto LABEL_13;
          case 4:
            v6 = png_ptr->flags | 0x300;
            goto LABEL_13;
          case 5:
            return;
          default:
            v6 = png_ptr->flags & 0xFFFFFCFF;
LABEL_13:
            png_ptr->flags = v6;
            break;
        }
        break;
    }
  }
}

//----- (001F93F4) --------------------------------------------------------
void __fastcall png_set_background_fixed(
        png_structrp_5 png_ptr,
        png_const_color_16p background_color,
        int background_gamma_code,
        int need_expand,
        png_fixed_point a5)
{
  png_uint_32 flags; // r5
  int v6; // r5
  png_uint_32 v7; // lr
  __int64 v8; // d16
  unsigned int v9; // r1

  if ( png_ptr )
  {
    flags = png_ptr->flags;
    if ( (flags & 0x40) != 0 )
    {
      sub_197D9C(png_ptr, (png_const_charp)"invalid after png_start_read_image or png_read_update_info");
    }
    else
    {
      v6 = flags | 0x4000;
      png_ptr->flags = v6;
      if ( background_color )
      {
        if ( background_gamma_code )
        {
          png_ptr->flags = v6 & 0xFFFFDFFF;
          v7 = png_ptr->transformations & 0xFF7BFF7F;
          png_ptr->transformations = v7 | (unsigned int)&stru_4007C.st_value;
          v8 = *(_QWORD *)&background_color->index;
          png_ptr->background.gray = background_color->gray;
          png_ptr->background_gamma = a5;
          png_ptr->background_gamma_type = background_gamma_code;
          *(_QWORD *)&png_ptr->background.index = v8;
          if ( need_expand )
            v9 = (unsigned int)&stru_4017C.st_value | v7;
          else
            v9 = (v7 | (unsigned int)&stru_4007C.st_value) & 0xFF7FFEFF;
          png_ptr->transformations = v9;
        }
        else
        {
          sub_194634(png_ptr, (png_const_charp)"Application must supply a known background gamma");
        }
      }
    }
  }
}
// 4007C: using guessed type Elf32_Sym stru_4007C;
// 4017C: using guessed type Elf32_Sym;

//----- (001F94A8) --------------------------------------------------------
void __fastcall png_set_background(
        png_structrp_5 png_ptr,
        png_const_color_16p background_color,
        int background_gamma_code,
        int need_expand,
        double background_gamma)
{
  png_fixed_point v9; // r0
  png_uint_32 flags; // r1
  int v11; // r1
  png_uint_32 v12; // r1
  __int64 v13; // d16
  unsigned int v14; // r0

  v9 = j_png_fixed(png_ptr, background_gamma, (png_const_charp)"png_set_background");
  if ( png_ptr )
  {
    flags = png_ptr->flags;
    if ( (flags & 0x40) != 0 )
    {
      sub_197D9C(png_ptr, (png_const_charp)"invalid after png_start_read_image or png_read_update_info");
    }
    else
    {
      v11 = flags | 0x4000;
      png_ptr->flags = v11;
      if ( background_color )
      {
        if ( background_gamma_code )
        {
          png_ptr->flags = v11 & 0xFFFFDFFF;
          v12 = png_ptr->transformations & 0xFF7BFF7F;
          png_ptr->transformations = v12 | (unsigned int)&stru_4007C.st_value;
          v13 = *(_QWORD *)&background_color->index;
          png_ptr->background.gray = background_color->gray;
          png_ptr->background_gamma = v9;
          png_ptr->background_gamma_type = background_gamma_code;
          *(_QWORD *)&png_ptr->background.index = v13;
          if ( need_expand )
            v14 = (unsigned int)&stru_4017C.st_value | v12;
          else
            v14 = (v12 | (unsigned int)&stru_4007C.st_value) & 0xFF7FFEFF;
          png_ptr->transformations = v14;
        }
        else
        {
          sub_194634(png_ptr, (png_const_charp)"Application must supply a known background gamma");
        }
      }
    }
  }
}
// 4007C: using guessed type Elf32_Sym stru_4007C;
// 4017C: using guessed type Elf32_Sym stru_4017C;
// 1F94A8: using guessed type double arg_0;

//----- (001F958C) --------------------------------------------------------
void __fastcall png_set_scale_16(png_structrp_5 png_ptr)
{
  png_uint_32 flags; // r1
  png_uint_32 v2; // r2

  if ( png_ptr )
  {
    flags = png_ptr->flags;
    if ( (flags & 0x40) != 0 )
    {
      sub_197D9C(png_ptr, (png_const_charp)"invalid after png_start_read_image or png_read_update_info");
    }
    else
    {
      v2 = png_ptr->transformations | 0x4000000;
      png_ptr->flags = flags | 0x4000;
      png_ptr->transformations = v2;
    }
  }
}

//----- (001F95BC) --------------------------------------------------------
void __fastcall png_set_strip_16(png_structrp_5 png_ptr)
{
  png_uint_32 flags; // r1
  png_uint_32 v2; // r2

  if ( png_ptr )
  {
    flags = png_ptr->flags;
    if ( (flags & 0x40) != 0 )
    {
      sub_197D9C(png_ptr, (png_const_charp)"invalid after png_start_read_image or png_read_update_info");
    }
    else
    {
      v2 = png_ptr->transformations | 0x400;
      png_ptr->flags = flags | 0x4000;
      png_ptr->transformations = v2;
    }
  }
}

//----- (001F95EC) --------------------------------------------------------
void __fastcall png_set_strip_alpha(png_structrp_5 png_ptr)
{
  png_uint_32 flags; // r1
  png_uint_32 v2; // r2

  if ( png_ptr )
  {
    flags = png_ptr->flags;
    if ( (flags & 0x40) != 0 )
    {
      sub_197D9C(png_ptr, (png_const_charp)"invalid after png_start_read_image or png_read_update_info");
    }
    else
    {
      v2 = png_ptr->transformations | 0x40000;
      png_ptr->flags = flags | 0x4000;
      png_ptr->transformations = v2;
    }
  }
}

//----- (001F961C) --------------------------------------------------------
void __fastcall png_set_alpha_mode_fixed(png_structrp_5 png_ptr, int mode, png_fixed_point output_gamma)
{
  png_uint_32 flags; // r0
  int *p_st_value; // r5
  png_fixed_point v7; // r0
  png_uint_32 v8; // r2
  png_uint_32 v9; // r1
  png_uint_32 v10; // r3
  int v11; // r2
  png_uint_32 v12; // r2
  png_uint_32 v13; // r2
  png_uint_32 v14; // r2
  png_fixed_point gamma; // r6
  png_uint_16 v16; // r3

  if ( png_ptr )
  {
    flags = png_ptr->flags;
    if ( (flags & 0x40) != 0 )
    {
      sub_197D9C(png_ptr, (png_const_charp)"invalid after png_start_read_image or png_read_update_info");
      return;
    }
    p_st_value = &elf_hash_chain[21457];
    png_ptr->flags = flags | 0x4000;
    if ( output_gamma > -3 )
    {
      if ( output_gamma == -2 )
        goto LABEL_12;
      if ( output_gamma != -1 )
        goto LABEL_11;
    }
    else if ( output_gamma != -100000 )
    {
      if ( output_gamma != -50000 )
      {
LABEL_11:
        p_st_value = (int *)output_gamma;
        if ( output_gamma - 1000 >= (unsigned int)&CWorld::ms_aLodPtrLists[681].m_pHead + 1 )
          goto LABEL_26;
      }
LABEL_12:
      v7 = j_png_reciprocal((png_fixed_point)p_st_value);
      switch ( mode )
      {
        case 0:
          v8 = png_ptr->flags;
          v9 = png_ptr->transformations & 0xFF7FFFFF;
          png_ptr->transformations = v9;
          v10 = v8 & 0xFFFFDFFF;
          v11 = 0;
          goto LABEL_18;
        case 1:
          v12 = png_ptr->flags;
          p_st_value = &elf_hash_chain[8526];
          v9 = png_ptr->transformations & 0xFF7FFFFF;
          png_ptr->transformations = v9;
          v10 = v12 & 0xFFFFDFFF;
          goto LABEL_17;
        case 2:
          v13 = png_ptr->flags;
          v9 = png_ptr->transformations & 0xFF7FFFFF;
          png_ptr->transformations = v9;
          v10 = v13 | 0x2000;
          goto LABEL_17;
        case 3:
          v14 = png_ptr->flags;
          v9 = png_ptr->transformations | 0x800000;
          png_ptr->transformations = v9;
          v10 = v14 & 0xFFFFDFFF;
LABEL_17:
          v11 = 1;
LABEL_18:
          gamma = png_ptr->colorspace.gamma;
          png_ptr->flags = v10;
          if ( !gamma )
          {
            v16 = png_ptr->colorspace.flags;
            gamma = v7;
            png_ptr->colorspace.gamma = v7;
            png_ptr->colorspace.flags = v16 | 1;
          }
          png_ptr->screen_gamma = (png_fixed_point)p_st_value;
          if ( !v11 )
            return;
          png_ptr->background_gamma = gamma;
          png_ptr->transformations = v9 & 0xFFFFFEFF;
          png_ptr->background.gray = 0;
          png_ptr->background_gamma_type = 2;
          *(_DWORD *)&png_ptr->background.index = 0;
          *(_DWORD *)&png_ptr->background.green = 0;
          if ( (v9 & 0x80) == 0 )
          {
            png_ptr->transformations = v9 & 0xFFFFFE7F | 0x80;
            return;
          }
LABEL_25:
          j_png_error(png_ptr, (png_const_charp)"conflicting calls to set alpha mode and background");
          break;
        default:
          j_png_error(png_ptr, (png_const_charp)"invalid alpha mode");
          goto LABEL_25;
      }
LABEL_26:
      j_png_error(png_ptr, (png_const_charp)"output gamma out of expected range");
      JUMPOUT(0x1F977C);
    }
    p_st_value = (int *)&stru_35B5C.st_value;
    png_ptr->flags = flags | 0x5000;
    goto LABEL_12;
  }
}
// 1F977A: control flows out of bounds to 1F977C
// 10168: using guessed type int elf_hash_chain[22025];
// 35B5C: using guessed type Elf32_Sym stru_35B5C;

//----- (001F97F0) --------------------------------------------------------
void __fastcall png_set_alpha_mode(png_structrp_5 png_ptr, int mode, double output_gamma)
{
  double v3; // d17
  double v6; // d18
  double v7; // r0

  v3 = output_gamma;
  v6 = output_gamma;
  if ( output_gamma < 128.0 )
    v6 = output_gamma * 100000.0;
  if ( output_gamma > 0.0 )
    v3 = v6;
  v7 = floor(v3 + 0.5);
  if ( v7 > 2147483650.0 || v7 < -2147483650.0 )
    j_png_fixed_error(png_ptr, (png_const_charp)"gamma value");
  png_set_alpha_mode_fixed(png_ptr, mode, (int)v7);
}

//----- (001F989C) --------------------------------------------------------
void __fastcall png_set_quantize(
        png_structrp_5 png_ptr,
        png_colorp palette,
        int num_palette,
        int maximum_colors,
        png_const_uint_16p histogram,
        int full_quantize)
{
  uint32x4_t v6; // q8
  png_structrp_5 v7; // r9
  png_uint_32 flags; // r0
  __int64 v11; // r0
  png_byte *v12; // r0
  png_bytep *p_quantize_sort; // r11
  int v14; // r0
  int v15; // r0
  int v16; // r12
  int v17; // r1
  png_byte *v18; // r4
  int v19; // r3
  int v20; // r4
  png_bytep v21; // r0
  int v22; // r1
  int v23; // r6
  png_color *v24; // r2
  png_byte *v25; // r3
  png_byte blue; // r3
  png_byte *v27; // r0
  int v28; // r0
  int v29; // r0
  png_voidp v30; // r8
  int v31; // r0
  int v32; // lr
  int v33; // r1
  _BYTE *v34; // r0
  png_byte *p_blue; // r3
  int v36; // r1
  int v37; // r4
  int v38; // r6
  png_byte *v39; // r11
  png_color *v40; // r10
  png_byte *v41; // r12
  int v42; // r3
  int v43; // r5
  int32x2_t v44; // d18
  int v45; // r2
  int v46; // r5
  png_byte *v47; // r8
  int v48; // r1
  int **v49; // r10
  int v50; // r4
  png_bytep v51; // r5
  int v52; // r2
  int v53; // lr
  int v54; // r11
  int v55; // r12
  int v56; // r1
  int v57; // r9
  int v58; // r4
  png_bytep v59; // r1
  int v60; // r6
  int i; // r4
  _DWORD *v62; // r1
  _DWORD *v63; // r5
  int v64; // r0
  int v65; // r1
  png_color *v66; // r2
  png_byte *v67; // r6
  png_color *v68; // r5
  png_byte v69; // r6
  int v70; // lr
  int v71; // r8
  png_bytep quantize_index; // r12
  int v73; // r0
  int v74; // r0
  int red; // r9
  png_color *v76; // r0
  int green; // r3
  int v78; // r11
  int v79; // r10
  int v80; // r0
  int v81; // r1
  int v82; // r2
  int v83; // r0
  int v84; // r1
  int v85; // r2
  png_byte v86; // r0
  int v87; // r3
  png_color *v88; // r3
  int v89; // r5
  int v90; // r4
  int v91; // r6
  int v92; // r3
  int v93; // r4
  int v94; // r3
  int v95; // r3
  unsigned __int8 *v96; // r5
  int v97; // r0
  int v98; // r0
  unsigned int v99; // r3
  png_color *v100; // r0
  unsigned int v101; // r4
  unsigned int v102; // r0
  int v103; // r2
  char *v104; // r6
  int v105; // r1
  char *v106; // r3
  int v107; // r3
  int v108; // r8
  char *v109; // r9
  char *v110; // r0
  char *v111; // r12
  int v112; // lr
  char *v113; // r3
  int v114; // r10
  char *v115; // r1
  int v116; // [sp+8h] [bp-58h]
  int v117; // [sp+Ch] [bp-54h]
  int v118; // [sp+10h] [bp-50h]
  int v119; // [sp+10h] [bp-50h]
  int v121; // [sp+18h] [bp-48h]
  signed int v122; // [sp+18h] [bp-48h]
  int v123; // [sp+1Ch] [bp-44h]
  png_byte *v124; // [sp+20h] [bp-40h]
  int v125; // [sp+20h] [bp-40h]
  png_bytep *p_index_to_palette; // [sp+24h] [bp-3Ch]
  png_bytep *v127; // [sp+24h] [bp-3Ch]
  int v128; // [sp+24h] [bp-3Ch]
  int v129; // [sp+28h] [bp-38h]
  int v130; // [sp+28h] [bp-38h]
  char *v131; // [sp+28h] [bp-38h]
  png_voidp ptr; // [sp+2Ch] [bp-34h]
  char *ptra; // [sp+2Ch] [bp-34h]
  int v134; // [sp+30h] [bp-30h]
  int v135; // [sp+30h] [bp-30h]
  png_const_structrp_2 v136; // [sp+34h] [bp-2Ch]
  __int16 v137; // [sp+40h] [bp-20h]
  png_byte v138; // [sp+42h] [bp-1Eh]

  v7 = png_ptr;
  if ( !png_ptr )
    return;
  flags = png_ptr->flags;
  if ( (flags & 0x40) != 0 )
  {
    sub_197D9C(v7, (png_const_charp)"invalid after png_start_read_image or png_read_update_info");
    return;
  }
  LODWORD(v11) = flags | 0x4000;
  HIDWORD(v11) = v7->transformations | 0x40;
  *(_QWORD *)&v7->flags = v11;
  if ( !full_quantize )
  {
    v27 = (png_byte *)j_png_malloc(v7, num_palette);
    v7->quantize_index = v27;
    if ( num_palette >= 1 )
    {
      *v27 = 0;
      if ( num_palette != 1 )
      {
        v28 = 1;
        do
        {
          v7->quantize_index[v28] = v28;
          ++v28;
        }
        while ( num_palette != v28 );
      }
    }
  }
  v136 = v7;
  if ( num_palette > maximum_colors )
  {
    v12 = (png_byte *)j_png_malloc(v7, num_palette);
    v118 = maximum_colors;
    v116 = num_palette;
    if ( histogram )
    {
      p_quantize_sort = &v7->quantize_sort;
      v7->quantize_sort = v12;
      if ( num_palette >= 1 )
      {
        *v12 = 0;
        if ( num_palette != 1 )
        {
          v14 = 1;
          do
          {
            (*p_quantize_sort)[v14] = v14;
            ++v14;
          }
          while ( num_palette != v14 );
        }
      }
      v15 = num_palette;
      do
      {
        if ( v15 <= maximum_colors )
          break;
        --v15;
        v16 = 1;
        v17 = 0;
        while ( v17 < v15 )
        {
          v18 = &(*p_quantize_sort)[v17];
          v19 = *v18;
          ++v17;
          v20 = v18[1];
          if ( histogram[v19] < (unsigned int)histogram[v20] )
          {
            v16 = 0;
            (*p_quantize_sort)[v17 - 1] = v20;
            (*p_quantize_sort)[v17] = v19;
          }
        }
      }
      while ( !v16 );
      if ( full_quantize )
      {
        if ( maximum_colors >= 1 )
        {
          v21 = *p_quantize_sort;
          v22 = 0;
          do
          {
            if ( v21[v22] >= maximum_colors )
            {
              v23 = v116;
              v24 = &palette[v116];
              do
              {
                v25 = &v21[v23];
                --v24;
                --v23;
              }
              while ( *(v25 - 1) >= maximum_colors );
              v116 = v23;
              blue = v24->blue;
              *(_WORD *)&palette[v22].red = *(_WORD *)&v24->red;
              palette[v22].blue = blue;
            }
            ++v22;
          }
          while ( v22 != maximum_colors );
        }
      }
      else
      {
        if ( maximum_colors >= 1 )
        {
          v64 = 0;
          v65 = v116;
          do
          {
            if ( (*p_quantize_sort)[v64] >= maximum_colors )
            {
              v66 = &palette[v65];
              do
              {
                v67 = &(*p_quantize_sort)[v65];
                --v66;
                --v65;
              }
              while ( *(v67 - 1) >= maximum_colors );
              v138 = v66->blue;
              v68 = &palette[v64];
              v137 = *(_WORD *)&v66->red;
              v69 = v68->blue;
              *(_WORD *)&v66->red = *(_WORD *)&v68->red;
              v66->blue = v69;
              *(_WORD *)&v68->red = v137;
              v68->blue = v138;
              v7->quantize_index[v65] = v64;
              v7->quantize_index[v64] = v65;
            }
            ++v64;
          }
          while ( v64 != maximum_colors );
        }
        if ( v116 >= 1 )
        {
          v70 = maximum_colors - 1;
          v71 = 0;
          v127 = &v7->quantize_sort;
          do
          {
            quantize_index = v7->quantize_index;
            v73 = quantize_index[v71];
            if ( v73 >= maximum_colors )
            {
              if ( maximum_colors < 2 )
              {
                v86 = 0;
              }
              else
              {
                v74 = v73;
                red = palette[v74].red;
                v76 = &palette[v74];
                green = palette->green;
                v78 = v76->green;
                v79 = v76->blue;
                v80 = red - palette->red;
                v81 = v78 - green;
                if ( v80 < 0 )
                  v80 = palette->red - red;
                v82 = v79 - palette->blue;
                if ( v81 < 0 )
                  v81 = green - v78;
                v83 = v80 + v81;
                if ( v82 < 0 )
                  v82 = palette->blue - v79;
                v84 = 0;
                v85 = v82 + v83;
                v86 = 0;
                do
                {
                  v87 = v84++;
                  v88 = &palette[v87];
                  v89 = v88[1].green;
                  v90 = v88[1].blue;
                  v91 = red - v88[1].red;
                  v92 = v78 - v89;
                  if ( v91 < 0 )
                    v91 = -v91;
                  if ( v92 < 0 )
                    v92 = v89 - v78;
                  v93 = v79 - v90;
                  v94 = v92 + v91;
                  if ( v93 < 0 )
                    v93 = -v93;
                  v95 = v94 + v93;
                  if ( v95 < v85 )
                  {
                    v86 = v84;
                    v85 = v95;
                  }
                }
                while ( v70 != v84 );
              }
              quantize_index[v71] = v86;
              v7 = (png_structrp_5)v136;
              maximum_colors = v118;
              p_quantize_sort = v127;
            }
            ++v71;
          }
          while ( v71 != v116 );
        }
      }
      j_png_free(v7, v7->quantize_sort);
LABEL_119:
      *p_quantize_sort = 0;
      goto LABEL_120;
    }
    v7->index_to_palette = v12;
    p_quantize_sort = &v7->index_to_palette;
    v7->palette_to_index = (png_bytep)j_png_malloc(v7, num_palette);
    if ( num_palette >= 1 )
    {
      v29 = 0;
      do
      {
        v7->index_to_palette[v29] = v29;
        v7->palette_to_index[v29] = v29;
        ++v29;
      }
      while ( num_palette != v29 );
    }
    v30 = j_png_calloc(v7, 0xC04u);
    v31 = 0;
    v32 = num_palette;
    if ( num_palette < 1 )
      v31 = 1;
    v33 = full_quantize;
    if ( full_quantize )
      v33 = 1;
    v117 = v31 | v33;
    v134 = 96;
    v34 = 0;
    p_index_to_palette = &v7->index_to_palette;
    ptr = v30;
LABEL_41:
    v121 = v32 - 1;
    p_blue = &palette[1].blue;
    v36 = 0;
    v129 = v32;
    while ( 1 )
    {
      v37 = v36;
      if ( v36 >= v121 )
      {
        if ( !v34 )
          goto LABEL_79;
        v48 = 0;
        while ( 1 )
        {
          v130 = v48;
          v49 = (int **)*((_DWORD *)v30 + v48);
          if ( v49 )
            break;
LABEL_77:
          v48 = v130 + 1;
          if ( v130 >= v134 )
            goto LABEL_78;
        }
        while ( 1 )
        {
          v50 = *((unsigned __int8 *)v49 + 4);
          v51 = *p_quantize_sort;
          if ( v32 > (*p_quantize_sort)[v50] )
          {
            v52 = v32;
            v53 = *((unsigned __int8 *)v49 + 5);
            if ( v52 <= v51[v53] )
            {
              v32 = v52;
            }
            else
            {
              v54 = *((unsigned __int8 *)v49 + 4);
              if ( (v52 & 1) == 0 )
                v54 = *((unsigned __int8 *)v49 + 5);
              v55 = v52 - 1;
              v56 = v52 - 1;
              v57 = v51[v54];
              *(_WORD *)&palette[v57].red = *(_WORD *)&palette[v56].red;
              palette[v57].blue = palette[v56].blue;
              if ( (v52 & 1) == 0 )
                v53 = v50;
              if ( !v117 )
              {
                v58 = 0;
                do
                {
                  v59 = v136->quantize_index;
                  v60 = v59[v58];
                  if ( v60 == v51[v54] )
                  {
                    v59[v58] = v51[v53];
                    v59 = v136->quantize_index;
                    v60 = v59[v58];
                  }
                  if ( v55 == v60 )
                    v59[v58] = (*p_index_to_palette)[v54];
                  ++v58;
                  v51 = *p_index_to_palette;
                }
                while ( v116 != v58 );
              }
              v32 = v52 - 1;
              v51[v136->palette_to_index[v55]] = v51[v54];
              v136->palette_to_index[v136->index_to_palette[v54]] = v136->palette_to_index[v55];
              v136->index_to_palette[v54] = v55;
              v136->palette_to_index[v55] = v54;
              p_quantize_sort = p_index_to_palette;
              v30 = ptr;
            }
          }
          if ( v32 <= v118 )
            break;
          v49 = (int **)*v49;
          if ( !v49 )
            goto LABEL_77;
        }
LABEL_78:
        v7 = (png_structrp_5)v136;
LABEL_80:
        maximum_colors = v118;
        for ( i = 0; i != 769; ++i )
        {
          v62 = (_DWORD *)*((_DWORD *)v30 + i);
          if ( v62 )
          {
            do
            {
              v63 = (_DWORD *)*v62;
              j_png_free(v7, v62);
              v62 = v63;
            }
            while ( v63 );
            v34 = 0;
          }
          *((_DWORD *)v30 + i) = 0;
        }
        v134 += 96;
        if ( v32 <= v118 )
        {
          j_png_free(v7, v30);
          j_png_free(v7, v7->palette_to_index);
          j_png_free(v7, v7->index_to_palette);
          v7->palette_to_index = 0;
          goto LABEL_119;
        }
        goto LABEL_41;
      }
      v38 = v36 + 1;
      v124 = p_blue;
      if ( v36 + 1 >= v32 )
        goto LABEL_53;
      v39 = p_blue;
      v40 = &palette[v36];
      v41 = &v40->blue;
      while ( 1 )
      {
        v6.n128_u16[0] = *((_WORD *)v39 - 1);
        v42 = *v39;
        v6.n128_u16[4] = *(_WORD *)&v40->red;
        v43 = *v41;
        v44.n64_u64[0] = vmovl_u16((uint16x4_t)vmovl_u8((uint8x8_t)v6.n128_u64[0]).n128_u64[0]).n128_u64[0];
        v6 = vmovl_u16((uint16x4_t)vmovl_u8(*(uint8x8_t *)&v6.n128_i8[8]).n128_u64[0]);
        v6.n128_u64[0] = vabs_s32(vsub_s32((int32x2_t)v6.n128_u64[0], v44)).n64_u64[0];
        v45 = v43 - v42;
        if ( v43 - v42 < 0 )
          v45 = v42 - v43;
        v46 = v6.n128_u32[0] + v6.n128_u32[1] + v45;
        if ( v46 > v134 )
          goto LABEL_50;
        v47 = v41;
        v34 = j_png_malloc_warn(v7, 8u);
        if ( !v34 )
          break;
        v41 = v47;
        v34[5] = v38;
        v34[4] = v37;
        *(_DWORD *)v34 = *((_DWORD *)ptr + v46);
        *((_DWORD *)ptr + v46) = v34;
        v32 = v129;
LABEL_50:
        ++v38;
        v39 += 3;
        if ( v38 >= v32 )
          goto LABEL_53;
      }
      v32 = v129;
LABEL_53:
      p_quantize_sort = p_index_to_palette;
      v30 = ptr;
      p_blue = v124 + 3;
      v36 = v37 + 1;
      if ( !v34 )
      {
LABEL_79:
        v34 = 0;
        goto LABEL_80;
      }
    }
  }
  maximum_colors = num_palette;
LABEL_120:
  if ( !v7->palette )
    v7->palette = palette;
  v7->num_palette = maximum_colors;
  if ( full_quantize )
  {
    v7->palette_lookup = (png_bytep)j_png_calloc(v7, 0x8000u);
    v96 = (unsigned __int8 *)j_png_malloc(v7, 0x8000u);
    memset(v96, 255, 0x8000u);
    if ( maximum_colors >= 1 )
    {
      v97 = 0;
      v119 = maximum_colors;
      do
      {
        v135 = v97;
        v98 = v97;
        v99 = palette[v98].red;
        v100 = &palette[v98];
        v101 = v100->green;
        v102 = v100->blue;
        v103 = -(v102 >> 3);
        v122 = v99 >> 3;
        v104 = (char *)(v102 >> 3);
        v105 = 0;
        v125 = v101 >> 3;
        do
        {
          v106 = (char *)(v105 - v122);
          if ( v105 <= v122 )
            v106 = (char *)(v122 - v105);
          v131 = v106;
          v107 = 0;
          v123 = v105;
          v128 = v105 << 10;
          do
          {
            v108 = 0;
            v109 = v104;
            v110 = (char *)(v107 - v125);
            if ( v107 <= v125 )
              v110 = (char *)(v125 - v107);
            v111 = &v131[(_DWORD)v110];
            if ( (int)v131 > (int)v110 )
              v110 = v131;
            ptra = (char *)v107;
            v112 = v128 | (32 * v107);
            do
            {
              v113 = v109;
              if ( v108 > (int)v104 )
                v113 = (char *)(v103 + v108);
              v114 = v112 | v108;
              v115 = &v113[(_DWORD)v111];
              if ( (int)v110 > (int)v113 )
                v113 = v110;
              if ( (int)&v113[(int)v115] < v96[v112 | v108] )
              {
                v96[v114] = (_BYTE)v115 + (_BYTE)v113;
                v136->palette_lookup[v114] = v135;
              }
              ++v108;
              --v109;
            }
            while ( v108 != 32 );
            v107 = (int)(ptra + 1);
          }
          while ( ptra != (_BYTE *)&dword_1C + 3 );
          v105 = v123 + 1;
        }
        while ( v123 != 31 );
        v97 = v135 + 1;
      }
      while ( v135 + 1 < v119 );
    }
    sub_19CD58(v136, v96);
  }
}
// 1F9A9A: variable 'v6' is possibly undefined
// 1C: using guessed type int dword_1C;

//----- (001F9EE0) --------------------------------------------------------
void __fastcall png_set_gamma_fixed(png_structrp_5 png_ptr, png_fixed_point scrn_gamma, png_fixed_point file_gamma)
{
  png_uint_32 flags; // r3
  char *v4; // r12
  int v5; // lr
  png_uint_16 v6; // r2

  if ( png_ptr )
  {
    flags = png_ptr->flags;
    if ( (flags & 0x40) != 0 )
    {
      sub_197D9C(png_ptr, (png_const_charp)"invalid after png_start_read_image or png_read_update_info");
      return;
    }
    v4 = (char *)&elf_hash_chain[3] + 1;
    v5 = flags | 0x4000;
    png_ptr->flags = flags | 0x4000;
    if ( scrn_gamma > -3 )
    {
      if ( scrn_gamma == -2 )
        goto LABEL_15;
      if ( scrn_gamma != -1 )
        goto LABEL_11;
    }
    else if ( scrn_gamma != -100000 )
    {
      if ( scrn_gamma != -50000 )
      {
LABEL_11:
        if ( file_gamma <= -3 )
          goto LABEL_12;
        goto LABEL_16;
      }
LABEL_15:
      scrn_gamma = (png_fixed_point)&elf_hash_chain[21457];
      if ( file_gamma <= -3 )
      {
LABEL_12:
        if ( file_gamma != -100000 )
        {
          if ( file_gamma != -50000 )
          {
LABEL_20:
            v4 = (char *)file_gamma;
            if ( file_gamma <= 0 )
            {
LABEL_24:
              j_png_error(png_ptr, (png_const_charp)"invalid file gamma in png_set_gamma");
              JUMPOUT(0x1F9FC0);
            }
          }
LABEL_21:
          if ( scrn_gamma > 0 )
            goto LABEL_22;
LABEL_23:
          j_png_error(png_ptr, (png_const_charp)"invalid screen gamma in png_set_gamma");
          goto LABEL_24;
        }
LABEL_18:
        v4 = (_BYTE *)(elf_hash_bucket + 45203);
        png_ptr->flags = v5 | 0x1000;
        if ( scrn_gamma > 0 )
        {
LABEL_22:
          png_ptr->colorspace.gamma = (png_fixed_point)v4;
          v6 = png_ptr->colorspace.flags;
          png_ptr->screen_gamma = scrn_gamma;
          png_ptr->colorspace.flags = v6 | 1;
          return;
        }
        goto LABEL_23;
      }
LABEL_16:
      if ( file_gamma == -2 )
        goto LABEL_21;
      if ( file_gamma != -1 )
        goto LABEL_20;
      goto LABEL_18;
    }
    scrn_gamma = (png_fixed_point)&stru_35B5C.st_value;
    v5 = flags | 0x5000;
    png_ptr->flags = flags | 0x5000;
    goto LABEL_11;
  }
}
// 1F9FBC: control flows out of bounds to 1F9FC0
// 1F9FBC: variable 'png_ptr' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 10168: using guessed type int elf_hash_chain[22025];
// 35B5C: using guessed type Elf32_Sym stru_35B5C;

//----- (001F9FD0) --------------------------------------------------------
void __fastcall png_set_gamma(png_structrp_5 png_ptr, double scrn_gamma, double file_gamma)
{
  double v4; // d16
  double v6; // d18
  double v7; // r0
  double v8; // d13
  double v9; // d16
  double v10; // d18
  double v11; // r0
  int v12; // s0
  double v13; // d16
  int v14; // s2
  png_uint_32 flags; // r1
  unsigned __int32 *p_st_value; // r0
  char *v17; // r12
  int v18; // lr
  png_uint_16 v19; // r1

  v4 = scrn_gamma;
  v6 = scrn_gamma;
  if ( scrn_gamma < 128.0 )
    v6 = scrn_gamma * 100000.0;
  if ( scrn_gamma > 0.0 )
    v4 = v6;
  v7 = floor(v4 + 0.5);
  v8 = v7;
  if ( v7 > 2147483650.0 || v7 < -2147483650.0 )
    j_png_fixed_error(png_ptr, (png_const_charp)"gamma value");
  v9 = file_gamma;
  v10 = file_gamma;
  if ( file_gamma < 128.0 )
    v10 = file_gamma * 100000.0;
  if ( file_gamma > 0.0 )
    v9 = v10;
  v11 = floor(v9 + 0.5);
  v12 = (int)v8;
  v13 = v11;
  if ( v11 > 2147483650.0 || v11 < -2147483650.0 )
    j_png_fixed_error(png_ptr, (png_const_charp)"gamma value");
  if ( png_ptr )
  {
    flags = png_ptr->flags;
    if ( (flags & 0x40) != 0 )
    {
      sub_197D9C(png_ptr, (png_const_charp)"invalid after png_start_read_image or png_read_update_info");
      return;
    }
    p_st_value = (unsigned __int32 *)(int)v8;
    v17 = (char *)&elf_hash_chain[3] + 1;
    v14 = (int)v13;
    v18 = flags | 0x4000;
    png_ptr->flags = flags | 0x4000;
    if ( v12 > -3 )
    {
      if ( v12 == -2 )
        goto LABEL_27;
      if ( v12 != -1 )
        goto LABEL_23;
    }
    else if ( v12 != -100000 )
    {
      if ( v12 != -50000 )
      {
LABEL_23:
        if ( v14 <= -3 )
          goto LABEL_24;
        goto LABEL_28;
      }
LABEL_27:
      p_st_value = (unsigned __int32 *)&elf_hash_chain[21457];
      if ( v14 <= -3 )
      {
LABEL_24:
        if ( v14 != -100000 )
        {
          if ( v14 != -50000 )
          {
LABEL_32:
            v17 = (char *)(int)v13;
            if ( v14 <= 0 )
            {
LABEL_39:
              j_png_error(png_ptr, (png_const_charp)"invalid file gamma in png_set_gamma");
              JUMPOUT(0x1FA198);
            }
          }
LABEL_33:
          if ( (int)p_st_value > 0 )
            goto LABEL_34;
LABEL_38:
          j_png_error(png_ptr, (png_const_charp)"invalid screen gamma in png_set_gamma");
          goto LABEL_39;
        }
LABEL_30:
        v17 = (_BYTE *)(elf_hash_bucket + 45203);
        png_ptr->flags = v18 | 0x1000;
        if ( (int)p_st_value > 0 )
        {
LABEL_34:
          png_ptr->colorspace.gamma = (png_fixed_point)v17;
          v19 = png_ptr->colorspace.flags;
          png_ptr->screen_gamma = (png_fixed_point)p_st_value;
          png_ptr->colorspace.flags = v19 | 1;
          return;
        }
        goto LABEL_38;
      }
LABEL_28:
      if ( v14 == -2 )
        goto LABEL_33;
      if ( v14 != -1 )
        goto LABEL_32;
      goto LABEL_30;
    }
    p_st_value = &stru_35B5C.st_value;
    v18 = flags | 0x5000;
    png_ptr->flags = flags | 0x5000;
    goto LABEL_23;
  }
}
// 1FA196: control flows out of bounds to 1FA198
// FC: using guessed type int elf_hash_bucket[16411];
// 10168: using guessed type int elf_hash_chain[22025];
// 35B5C: using guessed type Elf32_Sym stru_35B5C;

//----- (001FA1CC) --------------------------------------------------------
void __fastcall png_set_expand(png_structrp_5 png_ptr)
{
  png_uint_32 flags; // r1

  if ( png_ptr )
  {
    flags = png_ptr->flags;
    if ( (flags & 0x40) != 0 )
    {
      sub_197D9C(png_ptr, (png_const_charp)"invalid after png_start_read_image or png_read_update_info");
    }
    else
    {
      png_ptr->flags = flags | 0x4000;
      png_ptr->transformations |= 0x2001000u;
    }
  }
}

//----- (001FA204) --------------------------------------------------------
void __fastcall png_set_palette_to_rgb(png_structrp_5 png_ptr)
{
  png_uint_32 flags; // r1

  if ( png_ptr )
  {
    flags = png_ptr->flags;
    if ( (flags & 0x40) != 0 )
    {
      sub_197D9C(png_ptr, (png_const_charp)"invalid after png_start_read_image or png_read_update_info");
    }
    else
    {
      png_ptr->flags = flags | 0x4000;
      png_ptr->transformations |= 0x2001000u;
    }
  }
}

//----- (001FA23C) --------------------------------------------------------
void __fastcall png_set_expand_gray_1_2_4_to_8(png_structrp_5 png_ptr)
{
  png_uint_32 flags; // r1
  png_uint_32 v2; // r2

  if ( png_ptr )
  {
    flags = png_ptr->flags;
    if ( (flags & 0x40) != 0 )
    {
      sub_197D9C(png_ptr, (png_const_charp)"invalid after png_start_read_image or png_read_update_info");
    }
    else
    {
      v2 = png_ptr->transformations | 0x1000;
      png_ptr->flags = flags | 0x4000;
      png_ptr->transformations = v2;
    }
  }
}

//----- (001FA26C) --------------------------------------------------------
void __fastcall png_set_tRNS_to_alpha(png_structrp_5 png_ptr)
{
  png_uint_32 flags; // r1

  if ( png_ptr )
  {
    flags = png_ptr->flags;
    if ( (flags & 0x40) != 0 )
    {
      sub_197D9C(png_ptr, (png_const_charp)"invalid after png_start_read_image or png_read_update_info");
    }
    else
    {
      png_ptr->flags = flags | 0x4000;
      png_ptr->transformations |= 0x2001000u;
    }
  }
}

//----- (001FA2A4) --------------------------------------------------------
void __fastcall png_set_expand_16(png_structrp_5 png_ptr)
{
  png_uint_32 flags; // r1

  if ( png_ptr )
  {
    flags = png_ptr->flags;
    if ( (flags & 0x40) != 0 )
    {
      sub_197D9C(png_ptr, (png_const_charp)"invalid after png_start_read_image or png_read_update_info");
    }
    else
    {
      png_ptr->flags = flags | 0x4000;
      png_ptr->transformations |= 0x2001200u;
    }
  }
}

//----- (001FA2DC) --------------------------------------------------------
void __fastcall png_set_gray_to_rgb(png_structrp_5 png_ptr)
{
  png_uint_32 flags; // r1
  png_uint_32 v2; // r2

  if ( png_ptr )
  {
    flags = png_ptr->flags;
    if ( (flags & 0x40) != 0 )
    {
      sub_197D9C(png_ptr, (png_const_charp)"invalid after png_start_read_image or png_read_update_info");
    }
    else
    {
      v2 = png_ptr->transformations | 0x5000;
      png_ptr->flags = flags | 0x4000;
      png_ptr->transformations = v2;
    }
  }
}

//----- (001FA30C) --------------------------------------------------------
void __fastcall png_set_rgb_to_gray_fixed(
        png_structrp_5 png_ptr,
        int error_action,
        png_fixed_point red,
        png_fixed_point green)
{
  png_uint_32 flags; // r0
  const char *v6; // r1
  int color_type; // r4
  png_uint_32 v8; // r0

  if ( png_ptr )
  {
    flags = png_ptr->flags;
    if ( (flags & 0x40) != 0 )
    {
      v6 = "invalid after png_start_read_image or png_read_update_info";
      goto LABEL_6;
    }
    if ( !(LOBYTE(png_ptr->mode) << 31) )
    {
      v6 = "invalid before the PNG header has been read";
LABEL_6:
      sub_197D9C(png_ptr, (png_const_charp)v6);
      return;
    }
    png_ptr->flags = flags | 0x4000;
    if ( (unsigned int)(error_action - 1) >= 3 )
    {
      j_png_error(png_ptr, (png_const_charp)"invalid error action to rgb_to_gray");
      JUMPOUT(0x1FA3E0);
    }
    color_type = png_ptr->color_type;
    v8 = (6291456 - ((error_action - 1) << 21)) | png_ptr->transformations;
    png_ptr->transformations = v8;
    if ( color_type == 3 )
      png_ptr->transformations = v8 | 0x1000;
    if ( (green | red) < 0 || green + red > (int)&elf_hash_chain[8526] )
    {
      if ( (green | red) >= 0 )
        j_png_app_warning(png_ptr, (png_const_charp)"ignoring out of range rgb_to_gray coefficients");
      if ( !png_ptr->rgb_to_gray_red_coeff && !png_ptr->rgb_to_gray_green_coeff )
        *(_DWORD *)&png_ptr->rgb_to_gray_red_coeff = 1535777592;
    }
    else
    {
      png_ptr->rgb_to_gray_coefficients_set = 1;
      png_ptr->rgb_to_gray_green_coeff = (unsigned int)((175921861 * (unsigned __int64)((green << 10) & 0x7FFFFFF)) >> 32) >> 7;
      png_ptr->rgb_to_gray_red_coeff = (unsigned int)((175921861 * (unsigned __int64)((red << 10) & 0x7FFFFFF)) >> 32) >> 7;
    }
  }
}
// 1FA3DC: control flows out of bounds to 1FA3E0
// 10168: using guessed type int elf_hash_chain[22025];

//----- (001FA464) --------------------------------------------------------
void __fastcall png_set_rgb_to_gray(png_structrp_5 png_ptr, int error_action, double red, double green)
{
  png_fixed_point v6; // r6
  png_fixed_point v7; // r3

  v6 = j_png_fixed(png_ptr, red, (png_const_charp)"rgb to gray red coefficient");
  v7 = j_png_fixed(png_ptr, green, (png_const_charp)"rgb to gray green coefficient");
  png_set_rgb_to_gray_fixed(png_ptr, error_action, v6, v7);
}
// 1FA464: using guessed type double arg_0;

//----- (001FA4DC) --------------------------------------------------------
void __fastcall png_set_read_user_transform_fn(png_structrp_5 png_ptr, png_user_transform_ptr read_user_transform_fn)
{
  png_uint_32 transformations; // r2

  transformations = png_ptr->transformations;
  png_ptr->read_user_transform_fn = read_user_transform_fn;
  png_ptr->transformations = transformations | 0x100000;
}

//----- (001FA4F0) --------------------------------------------------------
void __fastcall png_init_read_transformations(png_structrp_5 png_ptr)
{
  int *v2; // r8
  png_fixed_point gamma; // r1
  png_fixed_point screen_gamma; // r2
  _BOOL4 v5; // r0
  png_uint_32 transformations; // r2
  png_uint_32 v7; // r1
  png_uint_32 flags; // r0
  __int64 v9; // r0
  int red; // r0
  int green; // r2
  bool v12; // zf
  png_uint_32 mode; // r2
  png_uint_32 v14; // r0
  int color_type; // r2
  unsigned int v16; // r2
  png_bytep trans_alpha; // r0
  int v18; // r5
  int v19; // r6
  int num_trans; // r6
  png_uint_32 v21; // r0
  int bit_depth; // r3
  png_uint_16 gray; // r1
  png_uint_16 v24; // r2
  png_colorp palette; // r3
  int index; // r1
  png_uint_16 v27; // r6
  png_color *v28; // r1
  png_bytep v29; // r5
  unsigned int v30; // r6
  unsigned int v31; // r1
  png_bytep v32; // r0
  __int64 v33; // t2^8
  png_byte *v34; // r0
  unsigned int v35; // r1
  int v36; // r6
  int v37; // r2
  int blue; // r3
  png_uint_16 v39; // r2
  png_uint_16 v40; // r6
  png_uint_16 v41; // r3
  png_uint_32 v42; // r0
  int v43; // r9
  __int16 blue_low; // r12
  int v45; // r5
  __int16 green_low; // lr
  __int16 red_low; // r8
  png_colorp v48; // r6
  int v49; // r0
  png_color *v50; // r0
  png_color *v51; // r1
  int v52; // r0
  __int16 v53; // r10
  int v54; // r0
  int v55; // r0
  bool v56; // zf
  int num_palette; // r1
  png_byte *p_green; // r0
  int v59; // r3
  int v60; // r6
  int background_gamma_type; // r0
  int v62; // r9
  png_colorp v63; // r11
  int *v64; // r5
  png_bytep gamma_table; // r1
  png_bytep gamma_to_1; // r2
  int v67; // r3
  int v68; // r5
  int v69; // r12
  png_byte v70; // r0
  png_byte v71; // r8
  png_uint_16 v72; // r6
  int v73; // r0
  png_fixed_point v74; // r5
  png_fixed_point background_gamma; // r0
  png_fixed_point v76; // r1
  int v77; // r6
  int v78; // r9
  unsigned int v79; // r1
  int v80; // r0
  bool v81; // zf
  png_uint_16 v82; // r0
  png_uint_16 v83; // r0
  unsigned int v84; // r1
  png_uint_16 v85; // r0
  unsigned int v86; // r1
  png_uint_16 v87; // r0
  unsigned int v88; // r1
  png_uint_16 v89; // r0
  unsigned int v90; // r1
  png_byte v91; // r0
  int v92; // r0
  __int16 v93; // r12
  __int16 v94; // lr
  __int16 v95; // r10
  int v96; // r3
  int v97; // r6
  png_color *v98; // r6
  int v99; // r1
  png_color *v100; // r2
  int v101; // r5
  int v102; // r6
  png_byte v103; // r0
  int v104; // r0
  int v105; // r8
  int v106; // r5
  __int64 v107; // r0
  __int64 v108; // r0
  bool v109; // zf
  int v110; // r1
  int v111; // r0
  int v112; // r1
  int v113; // r2
  int v114; // r6
  int v115; // r1
  int i; // r2
  int v117; // r6
  int v118; // r1
  int j; // r2
  int v120; // r6
  png_byte v121; // [sp+4h] [bp-2Ch]
  png_byte v122; // [sp+8h] [bp-28h]
  png_byte v123; // [sp+Ch] [bp-24h]
  png_fixed_point res[8]; // [sp+10h] [bp-20h] BYREF

  v2 = &elf_hash_chain[8526];
  gamma = png_ptr->colorspace.gamma;
  screen_gamma = png_ptr->screen_gamma;
  if ( !gamma )
  {
    if ( screen_gamma )
    {
      png_ptr->colorspace.gamma = j_png_reciprocal(png_ptr->screen_gamma);
    }
    else
    {
      png_ptr->screen_gamma = (png_fixed_point)&elf_hash_chain[8526];
      png_ptr->colorspace.gamma = (png_fixed_point)&elf_hash_chain[8526];
    }
    goto LABEL_10;
  }
  if ( !screen_gamma )
  {
    png_ptr->screen_gamma = j_png_reciprocal(png_ptr->colorspace.gamma);
LABEL_10:
    v5 = 0;
    goto LABEL_11;
  }
  if ( j_png_muldiv(res, gamma, screen_gamma, (png_int_32)&elf_hash_chain[8526]) )
    v5 = j_png_gamma_significant(res[0]) != 0;
  else
    v5 = 1;
LABEL_11:
  transformations = png_ptr->transformations;
  png_ptr->colorspace.flags |= 1u;
  v7 = transformations & 0xFFFFDFFF;
  if ( v5 )
    v7 = transformations | 0x2000;
  png_ptr->transformations = v7;
  if ( ((unsigned int)&stru_4007C.st_value & v7) == 0x40000 )
  {
    png_ptr->transformations = v7 & 0xFD7FFEFF;
    flags = png_ptr->flags;
    png_ptr->num_trans = 0;
    png_ptr->flags = flags & 0xFFFFDFFF;
  }
  LODWORD(v9) = j_png_gamma_significant(png_ptr->screen_gamma);
  HIDWORD(v9) = png_ptr->transformations;
  if ( !(_DWORD)v9 )
  {
    HIDWORD(v9) &= ~0x800000u;
    LODWORD(v9) = png_ptr->flags & 0xFFFFDFFF;
    *(_QWORD *)&png_ptr->flags = v9;
  }
  if ( (v9 & 0x60000000000000LL) != 0 )
  {
    j_png_colorspace_set_rgb_coefficients(png_ptr);
    HIDWORD(v9) = png_ptr->transformations;
  }
  if ( (v9 & 0x10000000000LL) != 0 )
  {
    if ( (png_ptr->color_type & 2) != 0 )
      goto LABEL_29;
    v14 = png_ptr->mode | 0x800;
    goto LABEL_28;
  }
  if ( (WORD2(v9) & 0x4080) == 16512 )
  {
    red = png_ptr->background.red;
    green = png_ptr->background.green;
    v12 = red == green;
    if ( red == green )
      v12 = red == png_ptr->background.blue;
    if ( v12 )
    {
      mode = png_ptr->mode;
      png_ptr->background.gray = red;
      v14 = mode | 0x800;
LABEL_28:
      png_ptr->mode = v14;
    }
  }
LABEL_29:
  color_type = png_ptr->color_type;
  if ( color_type != 3 )
  {
    if ( (color_type & 4) != 0 )
    {
      v21 = HIDWORD(v9);
      if ( (color_type & 2) != 0 )
        goto LABEL_72;
    }
    else
    {
      num_trans = png_ptr->num_trans;
      LODWORD(v9) = HIDWORD(v9) & 0xFF7FFFFF;
      png_ptr->flags &= ~0x2000u;
      png_ptr->transformations = HIDWORD(v9) & 0xFF7FFFFF;
      if ( !num_trans )
      {
        LODWORD(v9) = HIDWORD(v9) & 0xFF7FFE7F;
        png_ptr->transformations = HIDWORD(v9) & 0xFF7FFE7F;
      }
      if ( (color_type & 2) != 0 )
        goto LABEL_72;
    }
    if ( (v21 & 0x1100) == 4352 )
    {
      bit_depth = png_ptr->bit_depth;
      gray = png_ptr->trans_color.gray;
      v24 = png_ptr->background.gray;
      switch ( bit_depth )
      {
        case 4:
          gray *= 17;
          v24 *= 17;
          break;
        case 2:
          gray *= 85;
          v24 *= 85;
          break;
        case 1:
          gray *= 255;
          v24 *= 255;
          break;
      }
      png_ptr->background.green = v24;
      png_ptr->background.blue = v24;
      png_ptr->background.red = v24;
      if ( (v21 & 0x2000000) == 0 )
      {
        png_ptr->trans_color.green = gray;
        png_ptr->trans_color.blue = gray;
        png_ptr->trans_color.red = gray;
      }
    }
    goto LABEL_72;
  }
  v16 = png_ptr->num_trans;
  if ( png_ptr->num_trans )
  {
    trans_alpha = png_ptr->trans_alpha;
    v18 = 0;
    v19 = 0;
    while ( 1 )
    {
      if ( trans_alpha[v18] != 255 )
      {
        if ( trans_alpha[v18] )
        {
          v21 = HIDWORD(v9);
          goto LABEL_54;
        }
        v19 = 1;
      }
      if ( ++v18 >= (int)v16 )
        goto LABEL_50;
    }
  }
  v19 = 0;
LABEL_50:
  LODWORD(v9) = HIDWORD(v9) & 0xFF7FFFFF;
  png_ptr->flags &= ~0x2000u;
  png_ptr->transformations = HIDWORD(v9) & 0xFF7FFFFF;
  if ( !v19 )
  {
    LODWORD(v9) = HIDWORD(v9) & 0xFF7FFE7F;
    png_ptr->transformations = HIDWORD(v9) & 0xFF7FFE7F;
  }
LABEL_54:
  if ( (v21 & 0x1100) == 4352 )
  {
    palette = png_ptr->palette;
    index = png_ptr->background.index;
    v27 = palette[index].red;
    v28 = &palette[index];
    png_ptr->background.red = v27;
    png_ptr->background.green = v28->green;
    png_ptr->background.blue = v28->blue;
    if ( (v21 & 0x2080000) == 0x80000 )
    {
      if ( v16 )
      {
        v29 = png_ptr->trans_alpha;
        if ( v16 < 0x10 || (v30 = v16 - (v16 & 0xF), v16 == (v16 & 0xF)) )
        {
          v30 = 0;
        }
        else
        {
          v31 = v16 - (v16 & 0xF);
          v32 = png_ptr->trans_alpha;
          do
          {
            v31 -= 16;
            v33 = ~*((_QWORD *)v32 + 1);
            *(_QWORD *)v32 = ~*(_QWORD *)v32;
            *((_QWORD *)v32 + 1) = v33;
            v32 += 16;
          }
          while ( v31 );
          if ( (v16 & 0xF) == 0 )
            goto LABEL_71;
        }
        v34 = &v29[v30];
        v35 = v16 - v30;
        do
        {
          --v35;
          *v34 = ~*v34;
          ++v34;
        }
        while ( v35 );
LABEL_71:
        v21 = png_ptr->transformations;
      }
    }
  }
LABEL_72:
  if ( (v21 & 0x380) == 640 && png_ptr->bit_depth != 16 )
  {
    v36 = png_ptr->background.green;
    v37 = png_ptr->background.gray;
    blue = png_ptr->background.blue;
    png_ptr->background.red = (255 * (unsigned int)png_ptr->background.red + 32895) >> 16;
    png_ptr->background.green = (unsigned int)(255 * v36 + 32895) >> 16;
    png_ptr->background.blue = (unsigned int)(255 * blue + 32895) >> 16;
    png_ptr->background.gray = (unsigned int)(255 * v37 + 32895) >> 16;
  }
  if ( (v21 & 0x180) == 128 && (v21 & 0x4000400) != 0 && png_ptr->bit_depth == 16 )
  {
    v39 = png_ptr->background.green;
    v40 = png_ptr->background.blue;
    v41 = png_ptr->background.gray;
    png_ptr->background.red *= 257;
    png_ptr->background.green = 257 * v39;
    png_ptr->background.blue = 257 * v40;
    png_ptr->background.gray = 257 * v41;
  }
  png_ptr->background_1.gray = png_ptr->background.gray;
  *(_QWORD *)&png_ptr->background_1.index = *(_QWORD *)&png_ptr->background.index;
  if ( (v21 & 0x2000) != 0 )
    goto LABEL_101;
  if ( (v21 & 0x600000) != 0 )
  {
    if ( j_png_gamma_significant(png_ptr->colorspace.gamma) || j_png_gamma_significant(png_ptr->screen_gamma) )
      goto LABEL_101;
    v21 = png_ptr->transformations;
  }
  if ( (v21 & 0x80) != 0
    && (j_png_gamma_significant(png_ptr->colorspace.gamma)
     || j_png_gamma_significant(png_ptr->screen_gamma)
     || png_ptr->background_gamma_type == 3 && j_png_gamma_significant(png_ptr->background_gamma)) )
  {
    goto LABEL_101;
  }
  v42 = png_ptr->transformations;
  if ( (v42 & 0x800000) != 0 )
  {
    if ( !j_png_gamma_significant(png_ptr->screen_gamma) )
    {
      v42 = png_ptr->transformations;
      goto LABEL_88;
    }
LABEL_101:
    j_png_build_gamma_table(png_ptr, png_ptr->bit_depth);
    v42 = png_ptr->transformations;
    if ( (v42 & 0x80) == 0 )
    {
      if ( png_ptr->color_type == 3 )
      {
        v56 = (png_ptr->transformations & 0x1000) == 0;
        if ( (v42 & 0x1000) != 0 )
          v56 = (v42 & 0x600000) == 0;
        if ( v56 )
        {
          num_palette = png_ptr->num_palette;
          if ( png_ptr->num_palette )
          {
            p_green = &png_ptr->palette->green;
            do
            {
              --num_palette;
              v59 = *p_green;
              v60 = p_green[1];
              *(p_green - 1) = png_ptr->gamma_table[*(p_green - 1)];
              *p_green = png_ptr->gamma_table[v59];
              p_green[1] = png_ptr->gamma_table[v60];
              p_green += 3;
            }
            while ( num_palette );
            v42 = png_ptr->transformations;
          }
          v42 &= ~0x2000u;
          goto LABEL_161;
        }
      }
      goto LABEL_162;
    }
    if ( (v42 & 0x600000) != 0 )
      j_png_warning(png_ptr, (png_const_charp)"libpng does not support gamma+background+rgb_to_gray");
    if ( png_ptr->color_type == 3 )
    {
      background_gamma_type = png_ptr->background_gamma_type;
      v62 = png_ptr->num_palette;
      v63 = png_ptr->palette;
      if ( background_gamma_type == 1 )
      {
        v64 = (int *)png_ptr->screen_gamma;
      }
      else if ( background_gamma_type == 3 )
      {
        v64 = (int *)j_png_reciprocal(png_ptr->background_gamma);
        v2 = (int *)j_png_reciprocal2(png_ptr->background_gamma, png_ptr->screen_gamma);
      }
      else
      {
        v64 = &elf_hash_chain[8526];
        if ( background_gamma_type == 2 )
        {
          gamma_table = png_ptr->gamma_table;
          gamma_to_1 = png_ptr->gamma_to_1;
          v67 = png_ptr->background.blue;
          v68 = png_ptr->background.green;
          v69 = png_ptr->background.red;
          v70 = gamma_to_1[v67];
          v71 = gamma_to_1[v68];
          v121 = gamma_table[v67];
          LOBYTE(v72) = gamma_to_1[v69];
          v122 = gamma_table[v68];
          v123 = gamma_table[v69];
          if ( !png_ptr->num_palette )
            goto LABEL_160;
LABEL_151:
          v93 = v70;
          v94 = v71;
          v95 = (unsigned __int8)v72;
          v96 = 0;
          while ( v96 < png_ptr->num_trans )
          {
            v97 = png_ptr->trans_alpha[v96];
            if ( v97 == 255 )
              break;
            if ( png_ptr->trans_alpha[v96] )
            {
              v100 = &v63[v96];
              v104 = png_ptr->gamma_to_1[v100->red] * (__int16)v97 + (__int16)(v97 ^ 0xFF) * v95 + 128;
              v105 = v100->blue;
              v106 = v100->green;
              v100->red = png_ptr->gamma_from_1[(unsigned __int16)(v104 + (unsigned __int8)__ROR4__(v104, 8)) >> 8];
              v107 = *(_QWORD *)&png_ptr->gamma_from_1;
              HIDWORD(v107) = (png_ptr->trans_alpha[v96] ^ 0xFF) * v94
                            + png_ptr->trans_alpha[v96] * *(unsigned __int8 *)(HIDWORD(v107) + v106)
                            + 128;
              v100->green = *(_BYTE *)(v107
                                     + (unsigned __int8)((unsigned __int16)(WORD2(v107)
                                                                          + (unsigned __int8)__ROR4__(HIDWORD(v107), 8)) >> 8));
              v108 = *(_QWORD *)&png_ptr->gamma_from_1;
              HIDWORD(v108) = (png_ptr->trans_alpha[v96] ^ 0xFF) * v93
                            + png_ptr->trans_alpha[v96] * *(unsigned __int8 *)(HIDWORD(v108) + v105)
                            + 128;
              v103 = *(_BYTE *)(v108
                              + (unsigned __int8)((unsigned __int16)(WORD2(v108)
                                                                   + (unsigned __int8)__ROR4__(HIDWORD(v108), 8)) >> 8));
              goto LABEL_158;
            }
            v63[v96].red = v123;
            v98 = &v63[v96];
            v98->green = v122;
            v98->blue = v121;
LABEL_159:
            if ( v62 == ++v96 )
              goto LABEL_160;
          }
          v99 = v96;
          v100 = &v63[v96];
          v101 = v100->green;
          v102 = v100->blue;
          v63[v99].red = png_ptr->gamma_table[v100->red];
          v63[v99].green = png_ptr->gamma_table[v101];
          v103 = png_ptr->gamma_table[v102];
LABEL_158:
          v100->blue = v103;
          goto LABEL_159;
        }
      }
      if ( j_png_gamma_significant((png_fixed_point)v2) )
      {
        v123 = j_png_gamma_8bit_correct(png_ptr->background.red, (png_fixed_point)v2);
        v122 = j_png_gamma_8bit_correct(png_ptr->background.green, (png_fixed_point)v2);
        v91 = j_png_gamma_8bit_correct(png_ptr->background.blue, (png_fixed_point)v2);
      }
      else
      {
        v122 = png_ptr->background.green;
        v91 = png_ptr->background.blue;
        v123 = png_ptr->background.red;
      }
      v121 = v91;
      v92 = j_png_gamma_significant((png_fixed_point)v64);
      v72 = png_ptr->background.red;
      if ( v92 )
      {
        LOBYTE(v72) = j_png_gamma_8bit_correct(png_ptr->background.red, (png_fixed_point)v64);
        v71 = j_png_gamma_8bit_correct(png_ptr->background.green, (png_fixed_point)v64);
        v70 = j_png_gamma_8bit_correct(png_ptr->background.blue, (png_fixed_point)v64);
        if ( !v62 )
          goto LABEL_160;
      }
      else
      {
        v71 = png_ptr->background.green;
        v70 = png_ptr->background.blue;
        if ( !v62 )
        {
LABEL_160:
          v42 = png_ptr->transformations & 0xFFFFDF7F;
LABEL_161:
          png_ptr->transformations = v42;
          goto LABEL_162;
        }
      }
      goto LABEL_151;
    }
    v73 = png_ptr->background_gamma_type;
    switch ( v73 )
    {
      case 3:
        v74 = j_png_reciprocal(png_ptr->background_gamma);
        background_gamma = png_ptr->background_gamma;
        v76 = png_ptr->screen_gamma;
        break;
      case 2:
        v74 = j_png_reciprocal(png_ptr->colorspace.gamma);
        v76 = png_ptr->screen_gamma;
        background_gamma = png_ptr->colorspace.gamma;
        break;
      case 1:
        v74 = png_ptr->screen_gamma;
        goto LABEL_127;
      default:
        j_png_error(png_ptr, (png_const_charp)"invalid background gamma type");
        JUMPOUT(0x1FAD88);
    }
    v2 = (int *)j_png_reciprocal2(background_gamma, v76);
LABEL_127:
    v77 = j_png_gamma_significant(v74);
    v78 = j_png_gamma_significant((png_fixed_point)v2);
    if ( v77 )
      png_ptr->background_1.gray = j_png_gamma_correct(png_ptr, png_ptr->background.gray, v74);
    if ( v78 )
      png_ptr->background.gray = j_png_gamma_correct(png_ptr, png_ptr->background.gray, (png_fixed_point)v2);
    v79 = png_ptr->background.red;
    v80 = png_ptr->background.green;
    v81 = v79 == v80;
    if ( v79 == v80 )
      v81 = v79 == png_ptr->background.blue;
    if ( v81 && v79 == png_ptr->background.gray )
    {
      v82 = png_ptr->background_1.gray;
      png_ptr->background.green = v79;
      png_ptr->background.blue = v79;
      png_ptr->background_1.blue = v82;
      png_ptr->background_1.green = v82;
      png_ptr->background_1.red = v82;
    }
    else
    {
      if ( v77 )
      {
        v83 = j_png_gamma_correct(png_ptr, v79, v74);
        v84 = png_ptr->background.green;
        png_ptr->background_1.red = v83;
        v85 = j_png_gamma_correct(png_ptr, v84, v74);
        v86 = png_ptr->background.blue;
        png_ptr->background_1.green = v85;
        png_ptr->background_1.blue = j_png_gamma_correct(png_ptr, v86, v74);
      }
      if ( v78 )
      {
        v87 = j_png_gamma_correct(png_ptr, png_ptr->background.red, (png_fixed_point)v2);
        v88 = png_ptr->background.green;
        png_ptr->background.red = v87;
        v89 = j_png_gamma_correct(png_ptr, v88, (png_fixed_point)v2);
        v90 = png_ptr->background.blue;
        png_ptr->background.green = v89;
        png_ptr->background.blue = j_png_gamma_correct(png_ptr, v90, (png_fixed_point)v2);
      }
    }
    v42 = png_ptr->transformations;
    png_ptr->background_gamma_type = 1;
    goto LABEL_162;
  }
LABEL_88:
  if ( (v42 & 0x80) != 0 && png_ptr->color_type == 3 )
  {
    v43 = png_ptr->num_trans;
    if ( png_ptr->num_trans )
    {
      blue_low = LOBYTE(png_ptr->background.blue);
      v45 = 0;
      green_low = LOBYTE(png_ptr->background.green);
      red_low = LOBYTE(png_ptr->background.red);
      v48 = png_ptr->palette;
      do
      {
        v49 = png_ptr->trans_alpha[v45];
        if ( v49 != 255 )
        {
          if ( png_ptr->trans_alpha[v45] )
          {
            v51 = &v48[v45];
            v52 = v51->red * (__int16)v49 + (__int16)(v49 ^ 0xFF) * red_low + 128;
            v51->red = (unsigned __int16)(v52 + (unsigned __int8)__ROR4__(v52, 8)) >> 8;
            v53 = v51->blue;
            v54 = (png_ptr->trans_alpha[v45] ^ 0xFF) * green_low + png_ptr->trans_alpha[v45] * v51->green + 128;
            v51->green = (unsigned __int16)(v54 + (unsigned __int8)__ROR4__(v54, 8)) >> 8;
            v55 = (png_ptr->trans_alpha[v45] ^ 0xFF) * blue_low + png_ptr->trans_alpha[v45] * v53;
            v51->blue = (unsigned __int16)(v55 + 128 + (unsigned __int8)__ROR4__(v55 + 128, 8)) >> 8;
          }
          else
          {
            v48[v45].red = red_low;
            v50 = &v48[v45];
            v50->green = green_low;
            v50->blue = blue_low;
          }
        }
        ++v45;
      }
      while ( v43 != v45 );
      v42 = png_ptr->transformations;
    }
    v42 &= ~0x80u;
    goto LABEL_161;
  }
LABEL_162:
  v109 = (v42 & 0x1008) == 8;
  if ( (v42 & 0x1008) == 8 )
    v109 = png_ptr->color_type == 3;
  if ( v109 )
  {
    v110 = png_ptr->sig_bit.red;
    png_ptr->transformations = v42 & 0xFFFFFFF7;
    v111 = png_ptr->num_palette;
    if ( v110 )
    {
      v112 = 8 - v110;
      if ( v112 >= 1 )
      {
        if ( png_ptr->num_palette )
        {
          v113 = 0;
          do
          {
            v114 = v113++;
            png_ptr->palette[v114].red >>= v112;
          }
          while ( v111 != v113 );
        }
      }
    }
    if ( png_ptr->sig_bit.green )
    {
      v115 = 8 - png_ptr->sig_bit.green;
      if ( v115 >= 1 )
      {
        if ( v111 )
        {
          for ( i = 0; i != v111; ++i )
          {
            v117 = i;
            png_ptr->palette[v117].green >>= v115;
          }
        }
      }
    }
    if ( png_ptr->sig_bit.blue )
    {
      v118 = 8 - png_ptr->sig_bit.blue;
      if ( v118 >= 1 )
      {
        if ( v111 )
        {
          for ( j = 0; j != v111; ++j )
          {
            v120 = j;
            png_ptr->palette[v120].blue >>= v118;
          }
        }
      }
    }
  }
}
// 1FAD86: control flows out of bounds to 1FAD88
// 10168: using guessed type int elf_hash_chain[22025];
// 4007C: using guessed type Elf32_Sym stru_4007C;
// 1FA4F0: using guessed type png_fixed_point res[8];

//----- (001FADE0) --------------------------------------------------------
void __fastcall png_read_transform_info(png_structrp_5 png_ptr, png_inforp_3 info_ptr)
{
  png_uint_32 transformations; // lr
  int color_type; // r3
  int num_trans; // r12
  png_byte v5; // r3
  unsigned int bit_depth; // r12
  int v7; // r2
  png_byte v8; // r3
  png_byte user_transform_channels; // r2
  png_byte user_transform_depth; // r2
  png_byte v11; // r3
  png_uint_32 width; // r2
  unsigned int v13; // r2

  transformations = png_ptr->transformations;
  if ( (transformations & 0x1000) != 0 )
  {
    color_type = info_ptr->color_type;
    num_trans = png_ptr->num_trans;
    if ( color_type != 3 )
    {
      if ( (transformations & 0x2000000) != 0 && png_ptr->num_trans )
        info_ptr->color_type = color_type | 4;
      if ( info_ptr->bit_depth <= 7u )
        info_ptr->bit_depth = 8;
      info_ptr->num_trans = 0;
      if ( (transformations & 0x80) != 0 )
        goto LABEL_7;
      goto LABEL_8;
    }
    info_ptr->bit_depth = 8;
    v5 = 2;
    if ( num_trans )
      v5 = 6;
    info_ptr->color_type = v5;
    info_ptr->num_trans = 0;
    if ( !png_ptr->palette )
    {
      j_png_error(png_ptr, (png_const_charp)"Palette is NULL in indexed image");
      JUMPOUT(0x1FAF94);
    }
  }
  if ( (transformations & 0x80) != 0 )
LABEL_7:
    info_ptr->background = png_ptr->background;
LABEL_8:
  bit_depth = info_ptr->bit_depth;
  info_ptr->colorspace.gamma = png_ptr->colorspace.gamma;
  if ( bit_depth == 16 )
  {
    if ( (transformations & 0x4000000) != 0 )
    {
      bit_depth = 8;
      info_ptr->bit_depth = 8;
    }
    else
    {
      bit_depth = 16;
    }
    if ( (transformations & 0x400) != 0 )
    {
      bit_depth = 8;
      info_ptr->bit_depth = 8;
    }
  }
  if ( (transformations & 0x4000) != 0 )
    info_ptr->color_type |= 2u;
  if ( (transformations & 0x600000) != 0 )
    info_ptr->color_type &= ~2u;
  if ( (transformations & 0x40) != 0 && (info_ptr->color_type | 4) == 6 && png_ptr->palette_lookup && bit_depth == 8 )
    info_ptr->color_type = 3;
  if ( (transformations & 0x200) != 0 && bit_depth == 8 )
  {
    if ( info_ptr->color_type == 3 )
    {
      bit_depth = 8;
    }
    else
    {
      bit_depth = 16;
      info_ptr->bit_depth = 16;
    }
  }
  if ( (transformations & 4) != 0 && bit_depth <= 7 )
  {
    LOBYTE(bit_depth) = 8;
    info_ptr->bit_depth = 8;
  }
  v7 = info_ptr->color_type;
  v8 = v7 & 2 | 1;
  if ( v7 == 3 )
    v8 = 1;
  info_ptr->channels = v8;
  if ( (transformations & 0x40000) != 0 )
  {
    info_ptr->num_trans = 0;
    v7 &= 0xFBu;
    info_ptr->color_type = v7;
  }
  if ( (v7 & 4) != 0 )
    info_ptr->channels = ++v8;
  if ( (transformations & 0x8000) != 0 && (v7 | 2) == 2 )
  {
    info_ptr->channels = ++v8;
    if ( (transformations & 0x1000000) != 0 )
      info_ptr->color_type = v7 | 4;
  }
  if ( (transformations & 0x100000) != 0 )
  {
    user_transform_depth = png_ptr->user_transform_depth;
    if ( user_transform_depth )
    {
      info_ptr->bit_depth = user_transform_depth;
      LOBYTE(bit_depth) = user_transform_depth;
    }
    user_transform_channels = png_ptr->user_transform_channels;
    if ( user_transform_channels )
      info_ptr->channels = user_transform_channels;
    else
      user_transform_channels = v8;
  }
  else
  {
    user_transform_channels = v8;
  }
  v11 = bit_depth * user_transform_channels;
  width = info_ptr->width;
  info_ptr->pixel_depth = v11;
  if ( v11 < 8u )
    v13 = (width * v11 + 7) >> 3;
  else
    v13 = width * (v11 >> 3);
  info_ptr->rowbytes = v13;
  png_ptr->info_rowbytes = v13;
}
// 1FAF90: control flows out of bounds to 1FAF94

//----- (001FAFB8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall png_do_read_transformations(png_structrp_5 png_ptr, png_row_infop row_info)
{
  unsigned int flags; // r5
  const png_struct *num_trans; // r8
  png_structrp_5 v4; // r10
  png_row_infop v5; // r11
  png_bytep row_buf; // r0
  png_uint_32 transformations; // r2
  unsigned int bit_depth; // r3
  png_colorp palette; // r9
  png_bytep trans_alpha; // lr
  png_uint_32 width; // r2
  int v12; // r4
  png_uint_32 v13; // r3
  int v14; // r1
  png_byte *v15; // r1
  const png_color_16 *p_trans_color; // r2
  png_row_info *v17; // r0
  int v18; // r12
  unsigned int v19; // r3
  png_byte *v20; // r4
  char v21; // r3
  int v22; // r1
  char v23; // r0
  char v24; // r1
  char v25; // r2
  int v26; // r4
  png_uint_32 v27; // r3
  int v28; // r6
  int v29; // r4
  png_uint_32 v30; // r3
  int v31; // r6
  int v32; // r3
  png_byte *v33; // r6
  int v34; // r1
  png_uint_32 v35; // r0
  png_byte color_type; // r2
  unsigned __int8 *v37; // lr
  png_uint_32 v38; // r1
  png_bytep gamma_from_1; // r12
  bool v40; // zf
  int v41; // r9
  png_uint_32 v42; // r0
  _BYTE *v43; // r2
  unsigned int v44; // r6
  int v45; // r4
  bool v46; // zf
  unsigned __int8 v47; // r3
  bool v48; // zf
  png_uint_32 v49; // r8
  unsigned __int8 *v50; // r3
  int v51; // r6
  int v52; // r1
  unsigned int v53; // r2
  unsigned __int8 v54; // r1
  _BYTE *v55; // r0
  int v56; // r6
  int v57; // r3
  int v58; // r4
  bool v59; // zf
  png_byte *v60; // r4
  png_bytep gamma_table; // r2
  unsigned __int8 v62; // r2
  png_uint_32 v63; // r0
  unsigned int v64; // r12
  int v65; // r11
  unsigned int v66; // r9
  unsigned int v67; // r10
  int v68; // r6
  int v69; // r4
  int v70; // r2
  unsigned int v71; // r8
  bool v72; // zf
  int gamma_shift; // r2
  unsigned int v74; // r3
  png_uint_16pp gamma_16_table; // r2
  unsigned __int8 v76; // r2
  png_byte channels; // r2
  png_byte v78; // r1
  png_byte v79; // r0
  png_byte v80; // r1
  unsigned int v81; // r0
  png_row_info *v82; // r11
  png_uint_32 v83; // r0
  int v84; // r0
  png_bytep v85; // r12
  int v86; // r8
  png_uint_16pp v87; // r9
  unsigned int v88; // lr
  unsigned int v89; // r0
  unsigned __int8 *v90; // r1
  unsigned __int8 *v91; // r4
  unsigned int v92; // r2
  png_uint_16 v93; // r2
  int v94; // r12
  png_bytep v95; // lr
  png_bytep gamma_to_1; // r8
  png_bytep v97; // r11
  int v98; // r9
  unsigned __int8 *v99; // r1
  int v100; // r3
  int gray; // r2
  unsigned int v102; // r6
  png_uint_32 v103; // r0
  int v104; // r1
  int v105; // r3
  png_uint_32 v106; // r0
  int v107; // r2
  png_bytep v108; // r3
  int v109; // r6
  _BYTE *v110; // r2
  unsigned __int8 *v111; // r6
  int red; // r12
  int v113; // r4
  bool v114; // zf
  _BYTE *v115; // r4
  unsigned __int8 v116; // r2
  int v117; // r3
  bool v118; // zf
  int v119; // r3
  unsigned int v120; // r3
  int v121; // r3
  bool v122; // zf
  unsigned __int8 *v123; // r1
  int v124; // r3
  int v125; // r4
  unsigned int v126; // r3
  int v127; // r6
  int v128; // r4
  unsigned int v129; // r4
  int v130; // r4
  unsigned int v131; // r4
  int v132; // r3
  _BYTE *v133; // r1
  int v134; // lr
  int v135; // r2
  unsigned int v136; // r3
  int v137; // r8
  unsigned int v138; // r11
  int v139; // r6
  unsigned int v140; // r4
  png_uint_16 v141; // r2
  png_uint_16 green; // r2
  png_uint_16 *p_blue; // r2
  png_uint_16 v144; // r2
  png_uint_16 v145; // r2
  png_uint_16 v146; // r2
  bool v147; // zf
  int v148; // r12
  unsigned __int8 *v149; // r2
  int v150; // r3
  png_uint_16 v151; // r3
  unsigned int v152; // r1
  unsigned int v153; // r6
  unsigned int v154; // r3
  unsigned int v155; // r6
  bool v156; // zf
  int v157; // r1
  unsigned __int8 *v158; // r2
  png_uint_16 v159; // r3
  int v160; // r6
  int v161; // lr
  unsigned int v162; // r4
  png_uint_16 v163; // r3
  png_uint_16 v164; // r3
  png_uint_16 v165; // r3
  png_uint_16 v166; // r3
  int v167; // r8
  unsigned int v168; // r3
  unsigned int v169; // r6
  unsigned int v170; // r3
  unsigned int v171; // r6
  unsigned int v172; // r3
  unsigned int v173; // r6
  unsigned int v174; // r3
  unsigned int v175; // r6
  unsigned int v176; // r3
  unsigned int v177; // r6
  unsigned int v178; // r3
  unsigned int v179; // r6
  png_uint_16pp v180; // r3
  int v181; // r6
  int v182; // r5
  int v183; // r1
  unsigned __int8 *v184; // r2
  unsigned int v185; // r5
  png_uint_32 v186; // r0
  int rowbytes; // r1
  int v188; // r2
  int v189; // r0
  unsigned int v190; // r1
  int v191; // r1
  png_uint_32 v192; // r2
  int v193; // r1
  _BYTE *v194; // r0
  _BYTE *v195; // r1
  _BYTE *v196; // r2
  char v197; // t1
  int v198; // r1
  png_uint_32 v199; // r2
  __int64 v200; // r2
  png_uint_32 v201; // r0
  _BYTE *v202; // r1
  int v203; // r6
  unsigned __int8 *v204; // r4
  unsigned __int8 *v205; // r6
  unsigned int v206; // r1
  unsigned int v207; // r0
  int v208; // r1
  png_bytep v209; // r0
  png_bytep v210; // r2
  png_byte *v211; // r0
  unsigned int v212; // r1
  png_byte *v213; // r2
  char v214; // t1
  bool v215; // cc
  png_byte v216; // r2
  bool v217; // nf
  int v218; // r2
  png_uint_32 v219; // r0
  png_bytep v220; // r1
  png_size_t v221; // r2
  png_byte *v222; // r1
  png_size_t v223; // r2
  png_byte *v224; // r1
  png_byte *v225; // r1
  png_byte v226; // r2
  png_byte *v227; // r1
  png_byte v228; // r2
  png_uint_32 v229; // r0
  bool v230; // zf
  png_bytep v231; // r12
  int v232; // r6
  png_byte *v233; // r3
  int v234; // r2
  int v235; // r1
  int8x8_t *v236; // r0
  int v237; // r4
  int v238; // r2
  int v239; // r5
  int v240; // r1
  unsigned int v241; // r1
  unsigned int v242; // r2
  unsigned int v243; // r3
  unsigned int v244; // r5
  int64x2_t v245; // q8
  unsigned __int8 *v246; // r2
  unsigned int v247; // r6
  bool v248; // zf
  int v249; // r2
  char v250; // r1
  unsigned int v251; // r3
  unsigned int v252; // r6
  unsigned int v253; // r2
  unsigned int v254; // r5
  unsigned __int8 *v255; // r2
  int v256; // r2
  unsigned __int8 *v257; // r2
  int v258; // r6
  unsigned int v259; // r4
  int v260; // r2
  unsigned __int8 *v261; // r12
  int v262; // r6
  unsigned int v263; // r2
  unsigned int v264; // r2
  int v265; // r3
  int v266; // r3
  int v267; // r2
  unsigned int v268; // r2
  int v269; // r2
  unsigned __int8 *v270; // r1
  int v271; // r2
  unsigned int v272; // r2
  __int16 v273; // r4
  __int16 v274; // r12
  int v275; // r3
  int v276; // r3
  int v277; // r2
  unsigned __int8 *v278; // r1
  int v279; // r3
  png_uint_16 v280; // r3
  unsigned int v281; // r3
  unsigned int v282; // r3
  png_structrp_5 i; // r1
  unsigned __int8 *v284; // r3
  int v285; // r6
  unsigned int v286; // r6
  int v287; // r8
  int v288; // r9
  int v289; // r12
  int v290; // lr
  unsigned int v291; // r2
  unsigned int v292; // r2
  unsigned int v293; // r2
  unsigned int v294; // r2
  int v295; // r2
  unsigned int v296; // r2
  int v297; // r2
  _BYTE *v298; // r2
  int v299; // r1
  png_uint_16 v300; // r3
  png_uint_16 v301; // r3
  png_uint_16 blue; // r3
  int v303; // r6
  int v304; // r2
  unsigned int v305; // r4
  int v306; // r5
  unsigned int v307; // r4
  int v308; // r3
  int v309; // r6
  int v310; // r2
  unsigned int v311; // r4
  int v312; // r5
  unsigned int v313; // r4
  int v314; // r3
  int v315; // r3
  int v316; // r6
  unsigned __int8 v317; // r6
  int v318; // r2
  int v319; // r6
  unsigned int v320; // r4
  png_uint_16 *p_gray; // r3
  png_uint_16 v322; // r3
  unsigned int v323; // r12
  int64x2_t v324; // q8
  unsigned int v325; // r4
  uint32x4_t v326; // q9
  int16x8_t v327; // q11
  uint16x8_t v328; // q10
  int16x8_t v329; // q12
  _BYTE *v330; // r1
  int v331; // r4
  int v332; // r2
  png_uint_16 v333; // r6
  unsigned int v334; // r6
  png_uint_16 v335; // r2
  int v336; // r1
  unsigned __int8 *v337; // r2
  int v338; // r4
  int v339; // r3
  png_uint_16 v340; // r6
  unsigned int v341; // r6
  int v342; // r3
  int v343; // r2
  unsigned int v344; // r6
  int v345; // r3
  int v346; // r2
  unsigned int v347; // r6
  int v348; // r2
  int v349; // r2
  png_uint_16 v350; // r3
  unsigned int v351; // r0
  png_bytep v352; // r1
  png_uint_32 v353; // r6
  png_bytep v354; // r2
  int v355; // r3
  unsigned __int8 *v356; // r2
  png_uint_32 v357; // r0
  int v358; // r4
  int v359; // r3
  unsigned __int8 *v360; // r2
  png_uint_32 v361; // r0
  int v362; // r4
  int v363; // r3
  unsigned __int8 *v364; // r2
  png_uint_32 v365; // r0
  int v366; // r4
  int v367; // r0
  png_uint_32 v368; // r0
  png_bytep v369; // r3
  png_uint_16 filler; // r1
  png_bytep v371; // r6
  png_uint_32 v372; // r5
  unsigned int v373; // lr
  int v374; // r0
  png_uint_32 v375; // r0
  png_byte *v376; // r2
  int v377; // r0
  int v378; // r0
  png_byte *v379; // r2
  png_byte *v380; // r0
  png_uint_32 v381; // r3
  png_byte v382; // r6
  int v383; // r12
  png_byte *v384; // r0
  png_byte *v385; // r3
  png_uint_32 v386; // r4
  png_byte v387; // r6
  int v388; // r0
  png_byte *v389; // r6
  png_byte *v390; // r3
  png_byte *v391; // r6
  png_uint_32 v392; // r0
  png_byte v393; // r5
  unsigned int k; // r2
  int v395; // r0
  png_byte *v396; // r2
  png_byte *v397; // r3
  unsigned int v398; // r0
  png_byte v399; // r6
  __int16 v400; // r0
  int v401; // r0
  png_byte *v402; // r6
  png_byte *v403; // r0
  unsigned int v404; // r3
  png_byte v405; // r5
  int v406; // r6
  png_byte *v407; // r6
  png_byte *v408; // r3
  unsigned int v409; // r5
  png_byte v410; // r0
  png_bytep v411; // r2
  int v412; // r3
  unsigned int v413; // r0
  png_bytep v414; // r1
  png_size_t v415; // r5
  png_byte *v416; // r1
  int v417; // r3
  char *v418; // r4
  int v419; // r2
  const char *v420; // r5
  char *v421; // r5
  __int128 v422; // q12 OVERLAPPED
  __int128 v423; // q13
  __int128 v424; // q14
  __int128 v425; // q15
  char *v426; // r4
  png_size_t v427; // r5
  png_byte *v428; // r1
  int v429; // r4
  char *v430; // r2
  int v431; // r3
  __int128 v432; // q10
  int v433; // r1
  __int16 v434; // r2
  __int16 v435; // r6
  int v436; // r3
  char *v437; // r4
  int v438; // r2
  const char *v439; // r5
  char *v440; // r5
  __int128 v441; // q12 OVERLAPPED
  __int128 v442; // q13
  __int128 v443; // q14
  __int128 v444; // q15
  char *v445; // r4
  unsigned int v446; // r0
  png_byte *v447; // r1
  png_byte v448; // r2
  png_byte v449; // r3
  png_byte v450; // r5
  unsigned int v451; // r0
  char *v452; // r1
  char v453; // r3
  unsigned int v454; // r0
  __int16 *v455; // r1
  __int16 v456; // r2
  png_uint_32 v457; // r0
  void (__fastcall *read_user_transform_fn)(png_struct *, png_row_info *, png_bytep); // r3
  png_byte user_transform_channels; // r0
  png_byte v460; // r1
  png_uint_32 v461; // r0
  unsigned int v462; // r0
  unsigned int j; // r2
  png_uint_32 v464; // [sp+4h] [bp-54h]
  png_uint_16pp gamma_16_from_1; // [sp+8h] [bp-50h]
  png_uint_16pp gamma_16_to_1; // [sp+Ch] [bp-4Ch]
  int v467; // [sp+10h] [bp-48h]
  png_row_infop v468; // [sp+14h] [bp-44h]
  int v469; // [sp+18h] [bp-40h]
  png_bytep v470; // [sp+18h] [bp-40h]
  int rgb_to_gray_green_coeff; // [sp+1Ch] [bp-3Ch]
  png_uint_16pp v472; // [sp+1Ch] [bp-3Ch]
  int rgb_to_gray_red_coeff; // [sp+20h] [bp-38h]
  png_uint_16pp v474; // [sp+20h] [bp-38h]
  int v475; // [sp+24h] [bp-34h]
  png_uint_16pp v476; // [sp+24h] [bp-34h]
  png_struct *v477; // [sp+28h] [bp-30h]
  unsigned int v478[11]; // [sp+2Ch] [bp-2Ch]
  int8x8x4_t v479; // 0:d16.8,8:d17.8,16:d18.8,24:d19.8 OVERLAPPED
  int8x8x4_t v480; // 0:d16.8,8:d18.8,16:d20.8,24:d22.8 OVERLAPPED
  int8x8x4_t v481; // 0:d16.8,8:d18.8,16:d20.8,24:d22.8 OVERLAPPED
  int8x8x4_t v482; // 0:d17.8,8:d19.8,16:d21.8,24:d23.8
  int8x8x4_t v483; // 0:d17.8,8:d19.8,16:d21.8,24:d23.8

  v4 = png_ptr;
  v5 = row_info;
  row_buf = png_ptr->row_buf;
  if ( !row_buf )
  {
    j_png_error(v4, (png_const_charp)"NULL row buffer");
    goto LABEL_670;
  }
  if ( (v4->flags & 0x4040) == 0x4000 )
  {
LABEL_670:
    j_png_error(v4, (png_const_charp)"Uninitialized row");
LABEL_671:
    j_png_error(num_trans, (png_const_charp)"png_do_quantize returned rowbytes=0");
    goto LABEL_672;
  }
  transformations = v4->transformations;
  v477 = v4;
  if ( (transformations & 0x1000) != 0 )
  {
    if ( row_info->color_type == 3 )
    {
      bit_depth = row_info->bit_depth;
      palette = v4->palette;
      trans_alpha = v4->trans_alpha;
      width = row_info->width;
      num_trans = (const png_struct *)v4->num_trans;
      if ( bit_depth <= 7 )
      {
        flags = (unsigned int)(row_buf + 1);
        if ( bit_depth == 4 )
        {
          if ( width )
          {
            v26 = (4 * width) & 4;
            v27 = row_info->width;
            flags += (width - 1) >> 1;
            do
            {
              v40 = v26 == 4;
              v28 = *(unsigned __int8 *)flags >> v26;
              v26 += 4;
              row_buf[v27] = v28 & 0xF;
              if ( v40 )
              {
                --flags;
                v26 = 0;
              }
              --v27;
            }
            while ( v27 );
          }
        }
        else if ( bit_depth == 2 )
        {
          if ( width )
          {
            v29 = ~(2 * width + 6) & 6;
            v30 = row_info->width;
            flags += (width - 1) >> 2;
            do
            {
              v40 = v29 == 6;
              v31 = *(unsigned __int8 *)flags >> v29;
              v29 += 2;
              row_buf[v30] = v31 & 3;
              if ( v40 )
              {
                --flags;
                v29 = 0;
              }
              --v30;
            }
            while ( v30 );
          }
        }
        else if ( bit_depth == 1 && width )
        {
          v12 = ~(width + 7) & 7;
          flags += (width - 1) >> 3;
          v13 = row_info->width;
          do
          {
            v14 = (1 << v12) & *(unsigned __int8 *)flags;
            if ( v14 )
              LOBYTE(v14) = 1;
            v40 = v12++ == 7;
            row_buf[v13] = v14;
            if ( v40 )
            {
              --flags;
              v12 = 0;
            }
            --v13;
          }
          while ( v13 );
        }
        v5->pixel_depth = 8;
        v5->bit_depth = 8;
        v5->rowbytes = width;
        if ( !num_trans )
          goto LABEL_43;
        goto LABEL_22;
      }
      if ( bit_depth == 8 )
      {
        if ( !v4->num_trans )
        {
LABEL_43:
          v18 = 3 * width;
          if ( width )
          {
            v32 = v18 - 1;
            do
            {
              v33 = &row_buf[v32];
              v33[1] = palette[row_buf[width]].blue;
              row_buf[v32] = palette[row_buf[width]].green;
              v32 -= 3;
              v34 = row_buf[width--];
              *(v33 - 1) = palette[v34].red;
            }
            while ( width );
          }
          v23 = 3;
          v24 = 2;
          v25 = 24;
LABEL_47:
          v5->pixel_depth = v25;
          v5->bit_depth = 8;
          v5->rowbytes = v18;
          v5->color_type = v24;
          v5->channels = v23;
          goto LABEL_48;
        }
LABEL_22:
        v18 = 4 * width;
        if ( width )
        {
          flags = v18 - 1;
          do
          {
            v19 = row_buf[width];
            v20 = &row_buf[flags];
            if ( v19 >= (unsigned int)num_trans )
              v21 = -1;
            else
              v21 = trans_alpha[v19];
            v20[1] = v21;
            row_buf[flags] = palette[row_buf[width]].blue;
            flags -= 4;
            *(v20 - 1) = palette[row_buf[width]].green;
            v22 = row_buf[width--];
            *(v20 - 2) = palette[v22].red;
          }
          while ( width );
        }
        v23 = 4;
        v24 = 6;
        v25 = 32;
        goto LABEL_47;
      }
    }
    else
    {
      v15 = row_buf + 1;
      if ( (transformations & 0x2000000) != 0 && v4->num_trans )
      {
        p_trans_color = &v4->trans_color;
        v17 = v5;
      }
      else
      {
        v17 = v5;
        p_trans_color = 0;
      }
      png_do_expand(v17, v15, p_trans_color);
    }
  }
LABEL_48:
  v35 = v4->transformations;
  if ( ((unsigned int)&stru_4007C.st_value & v35) == 0x40000 && (v5->color_type | 2) == 6 )
  {
    j_png_do_strip_channel(v5, v4->row_buf + 1, 0);
    v35 = v4->transformations;
  }
  v468 = v5;
  if ( (v35 & 0x600000) == 0 )
    goto LABEL_114;
  color_type = v5->color_type;
  if ( (color_type & 3) != 2 )
    goto LABEL_114;
  v37 = v4->row_buf + 1;
  v38 = v5->width;
  rgb_to_gray_red_coeff = v4->rgb_to_gray_red_coeff;
  rgb_to_gray_green_coeff = v4->rgb_to_gray_green_coeff;
  v469 = 0x8000 - rgb_to_gray_red_coeff - rgb_to_gray_green_coeff;
  v475 = color_type & 4;
  v464 = v5->width;
  if ( v5->bit_depth == 8 )
  {
    gamma_from_1 = v4->gamma_from_1;
    v40 = gamma_from_1 == 0;
    if ( gamma_from_1 )
    {
      num_trans = (const png_struct *)v4->gamma_to_1;
      v40 = num_trans == 0;
    }
    if ( v40 )
    {
      v41 = 0;
      if ( v38 )
      {
        v42 = v5->width;
        v43 = v4->row_buf + 1;
        do
        {
          v44 = *v37;
          flags = v37[1];
          v45 = v37[2];
          v46 = v44 == flags;
          if ( v44 == flags )
            v46 = v44 == v45;
          if ( !v46 )
          {
            v41 |= 1u;
            v44 = (v44 * rgb_to_gray_red_coeff + flags * rgb_to_gray_green_coeff + v469 * v45) >> 15;
          }
          *v43 = v44;
          if ( v475 )
          {
            v47 = v37[3];
            v37 += 4;
            v43[1] = v47;
            v43 += 2;
          }
          else
          {
            v37 += 3;
            ++v43;
          }
          --v42;
        }
        while ( v42 );
      }
    }
    else
    {
      v41 = 0;
      if ( v38 )
      {
        flags = v5->width;
        v55 = v4->row_buf + 1;
        while ( 1 )
        {
          v56 = *v37;
          v57 = v37[1];
          v58 = v37[2];
          v59 = v56 == v57;
          if ( v56 == v57 )
            v59 = v56 == v58;
          if ( !v59 )
            break;
          gamma_table = v4->gamma_table;
          if ( gamma_table )
          {
            v60 = &gamma_table[v56];
            goto LABEL_88;
          }
LABEL_89:
          *v55 = v56;
          if ( v475 )
          {
            v62 = v37[3];
            v37 += 4;
            v55[1] = v62;
            v55 += 2;
          }
          else
          {
            v37 += 3;
            ++v55;
          }
          if ( !--flags )
            goto LABEL_107;
        }
        v41 |= 1u;
        v60 = &gamma_from_1[(*((unsigned __int8 *)num_trans->jmp_buf_local + v57) * rgb_to_gray_green_coeff
                           + *((unsigned __int8 *)num_trans->jmp_buf_local + v56) * rgb_to_gray_red_coeff
                           + v469 * (unsigned int)*((unsigned __int8 *)num_trans->jmp_buf_local + v58)
                           + 0x4000) >> 15];
LABEL_88:
        LOBYTE(v56) = *v60;
        goto LABEL_89;
      }
    }
    goto LABEL_107;
  }
  gamma_16_to_1 = v4->gamma_16_to_1;
  v48 = gamma_16_to_1 == 0;
  if ( gamma_16_to_1 )
  {
    gamma_16_from_1 = v4->gamma_16_from_1;
    v48 = gamma_16_from_1 == 0;
  }
  if ( v48 )
  {
    v41 = 0;
    if ( v38 )
    {
      v49 = v5->width;
      v50 = v4->row_buf + 1;
      do
      {
        while ( 1 )
        {
          flags = v50[3] | (v50[2] << 8);
          v51 = v50[1] | (*v50 << 8);
          v52 = v50[5] | (v50[4] << 8);
          v53 = flags * rgb_to_gray_green_coeff + v51 * rgb_to_gray_red_coeff + v52 * v469 + 0x4000;
          v37[1] = v53 >> 15;
          *v37 = v53 >> 23;
          v41 |= (v52 ^ v51 | v51 ^ flags) != 0;
          if ( !v475 )
            break;
          v37[2] = v50[6];
          v54 = v50[7];
          v50 += 8;
          v37[3] = v54;
          v37 += 4;
          if ( !--v49 )
            goto LABEL_107;
        }
        v37 += 2;
        v50 += 6;
        --v49;
      }
      while ( v49 );
    }
  }
  else
  {
    v41 = 0;
    if ( v38 )
    {
      v63 = v5->width;
      flags = (unsigned int)(v4->row_buf + 1);
      while ( 1 )
      {
        v467 = v41;
        v64 = *v37;
        v65 = v37[2];
        v66 = v37[1];
        v67 = v37[3];
        v68 = v37[4];
        v69 = v66 | (v64 << 8);
        v70 = v67 | (v65 << 8);
        v71 = v37[5];
        v72 = v69 == v70;
        if ( v69 == v70 )
          v72 = v69 == (v71 | (v68 << 8));
        if ( !v72 )
          break;
        gamma_16_table = v477->gamma_16_table;
        if ( gamma_16_table )
        {
          v66 = gamma_16_table[v66 >> v477->gamma_shift][v64];
          goto LABEL_102;
        }
LABEL_103:
        v5 = v468;
        *(_BYTE *)(flags + 1) = v66;
        *(_BYTE *)flags = v64;
        if ( v475 )
        {
          *(_BYTE *)(flags + 2) = v37[6];
          v76 = v37[7];
          v37 += 8;
          *(_BYTE *)(flags + 3) = v76;
          flags += 4;
        }
        else
        {
          v37 += 6;
          flags += 2;
        }
        v4 = v477;
        --v63;
        v41 = v467;
        if ( !v63 )
          goto LABEL_107;
      }
      gamma_shift = v477->gamma_shift;
      v74 = gamma_16_to_1[v67 >> gamma_shift][v65] * rgb_to_gray_green_coeff
          + gamma_16_to_1[v66 >> gamma_shift][v64] * rgb_to_gray_red_coeff
          + v469 * gamma_16_to_1[v71 >> gamma_shift][v68]
          + 0x4000;
      v66 = gamma_16_from_1[(unsigned __int8)(v74 >> 15) >> gamma_shift][(unsigned __int8)(v74 >> 23)];
      v467 |= 1u;
LABEL_102:
      v64 = v66 >> 8;
      goto LABEL_103;
    }
  }
LABEL_107:
  channels = v5->channels;
  v78 = v5->bit_depth;
  v79 = v5->color_type;
  v5->channels = channels - 2;
  v80 = v78 * (channels - 2);
  v5->color_type = v79 & 0xFD;
  v5->pixel_depth = v80;
  if ( v80 < 8u )
    v81 = (v80 * v464 + 7) >> 3;
  else
    v81 = (v80 >> 3) * v464;
  v5->rowbytes = v81;
  if ( !v41 )
  {
    v35 = v4->transformations;
    if ( (v35 & 0x4000) == 0 )
      goto LABEL_117;
    goto LABEL_115;
  }
  v35 = v4->transformations;
  v4->rgb_to_gray_status = 1;
  if ( (v35 & 0x600000) == 0x400000 )
  {
    j_png_warning(v4, (png_const_charp)"png_do_rgb_to_gray found nongray pixel");
    v35 = v4->transformations;
  }
  if ( (v35 & 0x600000) == 0x200000 )
  {
LABEL_672:
    j_png_error(v4, (png_const_charp)"png_do_rgb_to_gray found nongray pixel");
    JUMPOUT(0x1FCFDC);
  }
LABEL_114:
  if ( (v35 & 0x4000) == 0 )
    goto LABEL_117;
LABEL_115:
  if ( (v4->mode & 0x800) == 0 )
  {
    png_do_gray_to_rgb(v5, v4->row_buf + 1);
    v35 = v4->transformations;
  }
LABEL_117:
  if ( (v35 & 0x80) == 0 )
    goto LABEL_118;
  flags = v477->flags;
  v94 = (flags >> 13) & 1;
  v95 = v477->gamma_table;
  v476 = v477->gamma_16_table;
  v470 = v477->gamma_from_1;
  gamma_to_1 = v477->gamma_to_1;
  v97 = v477->row_buf;
  v472 = v477->gamma_16_from_1;
  v98 = v477->gamma_shift;
  v474 = v477->gamma_16_to_1;
  v99 = v97 + 1;
  v4 = (png_structrp_5)v468->width;
  switch ( v468->color_type )
  {
    case 0u:
      switch ( v468->bit_depth )
      {
        case 1u:
          if ( v4 )
          {
            v100 = 7;
            gray = v477->trans_color.gray;
            do
            {
              flags = *v99;
              if ( ((flags >> v100) & 1) == gray )
              {
                v102 = (0x7F7Fu >> (7 - v100)) & flags;
                flags = v477->background.gray << v100;
                *v99 = v102 | flags;
              }
              v40 = v100-- == 0;
              if ( v40 )
              {
                ++v99;
                v100 = 7;
              }
              v4 = (png_structrp_5)((char *)v4 - 1);
            }
            while ( v4 );
          }
          break;
        case 2u:
          if ( v95 )
          {
            if ( v4 )
            {
              v303 = 6;
              v304 = v477->trans_color.gray;
              do
              {
                v305 = *v99;
                v306 = (v305 >> v303) & 3;
                if ( v306 == v304 )
                {
                  flags = v477->background.gray;
                  v307 = (unsigned __int8)(flags << v303) | (0x3F3Fu >> (6 - v303)) & v305;
                }
                else
                {
                  v308 = v306 | (4 * v306) | (16 * v306) | (v306 << 6);
                  flags = 0x3F3Fu >> (6 - v303);
                  v307 = v305 & flags | (v95[v308] >> 6 << v303);
                }
                v40 = v303 == 0;
                *v99 = v307;
                v303 -= 2;
                if ( v40 )
                {
                  ++v99;
                  v303 = 6;
                }
                v4 = (png_structrp_5)((char *)v4 - 1);
              }
              while ( v4 );
            }
          }
          else if ( v4 )
          {
            v342 = 6;
            v343 = v477->trans_color.gray;
            do
            {
              flags = *v99;
              if ( ((flags >> v342) & 3) == v343 )
              {
                v344 = (0x3F3Fu >> (6 - v342)) & flags;
                flags = v477->background.gray << v342;
                *v99 = v344 | flags;
              }
              v40 = v342 == 0;
              v342 -= 2;
              if ( v40 )
              {
                ++v99;
                v342 = 6;
              }
              v4 = (png_structrp_5)((char *)v4 - 1);
            }
            while ( v4 );
          }
          break;
        case 4u:
          if ( v95 )
          {
            if ( v4 )
            {
              v309 = 4;
              v310 = v477->trans_color.gray;
              do
              {
                v311 = *v99;
                v312 = (v311 >> v309) & 0xF;
                if ( v312 == v310 )
                {
                  flags = v477->background.gray;
                  v313 = (unsigned __int8)(flags << v309) | (0xF0Fu >> (4 - v309)) & v311;
                }
                else
                {
                  v314 = v312 | (16 * v312);
                  flags = 0xF0Fu >> (4 - v309);
                  v313 = v311 & flags | (v95[v314] >> 4 << v309);
                }
                v40 = v309 == 0;
                *v99 = v313;
                v309 -= 4;
                if ( v40 )
                {
                  ++v99;
                  v309 = 4;
                }
                v4 = (png_structrp_5)((char *)v4 - 1);
              }
              while ( v4 );
            }
          }
          else if ( v4 )
          {
            v345 = 4;
            v346 = v477->trans_color.gray;
            do
            {
              flags = *v99;
              if ( ((flags >> v345) & 0xF) == v346 )
              {
                v347 = (0xF0Fu >> (4 - v345)) & flags;
                flags = v477->background.gray << v345;
                *v99 = v347 | flags;
              }
              v40 = v345 == 0;
              v345 -= 4;
              if ( v40 )
              {
                ++v99;
                v345 = 4;
              }
              v4 = (png_structrp_5)((char *)v4 - 1);
            }
            while ( v4 );
          }
          break;
        case 8u:
          if ( v95 )
          {
            if ( v4 )
            {
              v315 = v477->trans_color.gray;
              do
              {
                v316 = *v99;
                if ( v316 == v315 )
                  v317 = v477->background.gray;
                else
                  v317 = v95[v316];
                v4 = (png_structrp_5)((char *)v4 - 1);
                *v99++ = v317;
              }
              while ( v4 );
            }
          }
          else if ( v4 )
          {
            v348 = v477->trans_color.gray;
            do
            {
              if ( *v99 == v348 )
                *v99 = v477->background.gray;
              v4 = (png_structrp_5)((char *)v4 - 1);
              ++v99;
            }
            while ( v4 );
          }
          break;
        case 0x10u:
          if ( v476 )
          {
            if ( v4 )
            {
              LOBYTE(flags) = (_BYTE)v477 + 40;
              v318 = v477->trans_color.gray;
              do
              {
                v319 = *v99;
                v320 = v99[1];
                p_gray = &v477->background.gray;
                if ( (v320 | (v319 << 8)) != v318 )
                  p_gray = &v476[v320 >> v98][v319];
                v4 = (png_structrp_5)((char *)v4 - 1);
                v322 = *p_gray;
                v99[1] = v322;
                *v99 = HIBYTE(v322);
                v99 += 2;
              }
              while ( v4 );
            }
          }
          else if ( v4 )
          {
            v349 = v477->trans_color.gray;
            do
            {
              if ( (v99[1] | (*v99 << 8)) == v349 )
              {
                v350 = v477->background.gray;
                v99[1] = v350;
                *v99 = HIBYTE(v350);
              }
              v4 = (png_structrp_5)((char *)v4 - 1);
              v99 += 2;
            }
            while ( v4 );
          }
          break;
        default:
          goto LABEL_118;
      }
      goto LABEL_118;
    case 2u:
      if ( v468->bit_depth == 8 )
      {
        if ( v95 )
        {
          if ( v4 )
          {
            v111 = v97 + 3;
            red = v477->trans_color.red;
            do
            {
              v113 = *(v111 - 2);
              flags = *(v111 - 1);
              v114 = v113 == red;
              if ( v113 == red )
                v114 = flags == v477->trans_color.green;
              if ( v114 && *v111 == v477->trans_color.blue )
              {
                v115 = v111;
                *(v111 - 2) = v477->background.red;
                *(v111 - 1) = v477->background.green;
                LOBYTE(flags) = v477->background.blue;
              }
              else
              {
                v116 = v95[v113];
                v115 = v99 + 2;
                v117 = *v111;
                *(v111 - 2) = v116;
                *(v111 - 1) = v95[flags];
                LOBYTE(flags) = v95[v117];
              }
              v4 = (png_structrp_5)((char *)v4 - 1);
              v111 += 3;
              v99 += 3;
              *v115 = flags;
            }
            while ( v4 );
          }
        }
        else if ( v4 )
        {
          v297 = v477->trans_color.red;
          do
          {
            if ( *v99 == v297 && v99[1] == v477->trans_color.green && v99[2] == v477->trans_color.blue )
            {
              *v99 = v477->background.red;
              v99[1] = v477->background.green;
              v99[2] = v477->background.blue;
            }
            v4 = (png_structrp_5)((char *)v4 - 1);
            v99 += 3;
          }
          while ( v4 );
        }
        goto LABEL_118;
      }
      if ( v476 )
      {
        if ( !v4 )
          goto LABEL_118;
        v133 = v97 + 6;
        v134 = v477->trans_color.red;
        while ( 1 )
        {
          v135 = (unsigned __int8)*(v133 - 5);
          v136 = (unsigned __int8)*(v133 - 4);
          v137 = (unsigned __int8)*(v133 - 1);
          v138 = (unsigned __int8)*v133;
          if ( (v136 | (v135 << 8)) != v134 )
            break;
          v139 = (unsigned __int8)*(v133 - 3);
          v140 = (unsigned __int8)*(v133 - 2);
          flags = v477->trans_color.green;
          if ( (v140 | (v139 << 8)) != flags )
            goto LABEL_218;
          flags = v477->trans_color.blue;
          if ( (v138 | (v137 << 8)) != flags )
            goto LABEL_218;
          v141 = v477->background.red;
          *(v133 - 4) = v141;
          *(v133 - 5) = HIBYTE(v141);
          green = v477->background.green;
          *(v133 - 2) = green;
          *(v133 - 3) = HIBYTE(green);
          p_blue = &v477->background.blue;
LABEL_219:
          v146 = *p_blue;
          v4 = (png_structrp_5)((char *)v4 - 1);
          *v133 = v146;
          *(v133 - 1) = HIBYTE(v146);
          v133 += 6;
          if ( !v4 )
            goto LABEL_118;
        }
        v139 = (unsigned __int8)*(v133 - 3);
        v140 = (unsigned __int8)*(v133 - 2);
LABEL_218:
        v144 = v476[v136 >> v98][v135];
        *(v133 - 4) = v144;
        *(v133 - 5) = HIBYTE(v144);
        v145 = v476[v140 >> v98][v139];
        *(v133 - 2) = v145;
        *(v133 - 3) = HIBYTE(v145);
        p_blue = &v476[v138 >> v98][v137];
        goto LABEL_219;
      }
      if ( v4 )
      {
        v298 = v97 + 6;
        v299 = v477->trans_color.red;
        do
        {
          if ( ((unsigned __int8)*(v298 - 4) | ((unsigned __int8)*(v298 - 5) << 8)) == v299 )
          {
            flags = v477->trans_color.green;
            if ( ((unsigned __int8)*(v298 - 2) | ((unsigned __int8)*(v298 - 3) << 8)) == flags
              && ((unsigned __int8)*v298 | ((unsigned __int8)*(v298 - 1) << 8)) == v477->trans_color.blue )
            {
              v300 = v477->background.red;
              *(v298 - 4) = v300;
              *(v298 - 5) = HIBYTE(v300);
              v301 = v477->background.green;
              *(v298 - 2) = v301;
              *(v298 - 3) = HIBYTE(v301);
              blue = v477->background.blue;
              *v298 = blue;
              *(v298 - 1) = HIBYTE(blue);
            }
          }
          v4 = (png_structrp_5)((char *)v4 - 1);
          v298 += 6;
        }
        while ( v4 );
      }
      goto LABEL_118;
    case 4u:
      if ( v468->bit_depth == 8 )
      {
        v118 = v95 == 0;
        if ( v95 )
          v118 = v470 == 0;
        if ( v118 || !gamma_to_1 )
        {
          for ( ; v4; v99 += 2 )
          {
            v267 = v99[1];
            if ( v267 != 255 )
            {
              if ( v99[1] )
              {
                LOBYTE(flags) = ~(_BYTE)v267;
                v269 = *v99 * v99[1] + v477->background.gray * (v267 ^ 0xFF);
                v268 = (v269 + 128 + (unsigned int)(unsigned __int8)__ROR4__(v269 + 128, 8)) >> 8;
              }
              else
              {
                LOBYTE(v268) = v477->background.gray;
              }
              *v99 = v268;
            }
            v4 = (png_structrp_5)((char *)v4 - 1);
          }
        }
        else
        {
          for ( ; v4; v4 = (png_structrp_5)((char *)v4 - 1) )
          {
            v119 = v99[1];
            if ( v99[1] )
            {
              if ( v119 == 255 )
              {
                LOBYTE(v120) = v95[*v99];
              }
              else
              {
                flags = (v119 ^ 0xFF) * v477->background_1.gray;
                v121 = gamma_to_1[*v99] * v99[1] + flags + 128;
                v120 = (v121 + (unsigned int)(unsigned __int8)__ROR4__(v121, 8)) >> 8;
                if ( !v94 )
                  LOBYTE(v120) = v470[(unsigned __int8)v120];
              }
            }
            else
            {
              LOBYTE(v120) = v477->background.gray;
            }
            *v99 = v120;
            v99 += 2;
          }
        }
        goto LABEL_118;
      }
      v147 = v476 == 0;
      if ( v476 )
        v147 = v472 == 0;
      if ( !v147 && v474 )
      {
        if ( !v4 )
          goto LABEL_118;
        v148 = v477->flags & 0x2000;
        v149 = v97 + 2;
        LOBYTE(flags) = -1;
        while ( 1 )
        {
          v150 = v149[2] | (v149[1] << 8);
          if ( v150 )
          {
            if ( v150 != 0xFFFF )
            {
              v152 = (v150 ^ 0xFFFF) * v477->background_1.gray + v150 * v474[*v149 >> v98][*(v149 - 1)] + 0x8000;
              v153 = v152 + HIWORD(v152);
              v154 = HIWORD(v153);
              if ( v148 )
              {
                v155 = HIBYTE(v153);
              }
              else
              {
                v154 = v472[BYTE2(v153) >> v98][HIBYTE(v153)];
                v155 = v154 >> 8;
              }
              *v149 = v154;
              *(v149 - 1) = v155;
              goto LABEL_236;
            }
            v151 = v476[*v149 >> v98][*(v149 - 1)];
          }
          else
          {
            v151 = v477->background.gray;
          }
          *v149 = v151;
          *(v149 - 1) = HIBYTE(v151);
LABEL_236:
          v4 = (png_structrp_5)((char *)v4 - 1);
          v149 += 4;
          if ( !v4 )
            goto LABEL_118;
        }
      }
      if ( v4 )
      {
        v278 = v97 + 2;
        do
        {
          v279 = v278[2] | (v278[1] << 8);
          if ( v279 != 0xFFFF )
          {
            if ( v279 )
            {
              flags = v477->background.gray;
              v281 = (*v278 | (*(v278 - 1) << 8)) * v279 + (v279 ^ 0xFFFF) * flags + 0x8000;
              v282 = v281 + HIWORD(v281);
              *(v278 - 1) = HIBYTE(v282);
              *v278 = BYTE2(v282);
            }
            else
            {
              v280 = v477->background.gray;
              *v278 = v280;
              *(v278 - 1) = HIBYTE(v280);
            }
          }
          v4 = (png_structrp_5)((char *)v4 - 1);
          v278 += 4;
        }
        while ( v4 );
      }
      goto LABEL_118;
    case 6u:
      if ( v468->bit_depth == 8 )
      {
        v122 = v95 == 0;
        if ( v95 )
          v122 = v470 == 0;
        if ( v122 || !gamma_to_1 )
        {
          if ( v4 )
          {
            v270 = v97 + 2;
            do
            {
              v271 = v270[2];
              if ( v271 != 255 )
              {
                if ( v270[2] )
                {
                  LOBYTE(flags) = *(v270 - 1);
                  v273 = *v270;
                  v274 = v270[1];
                  v275 = (unsigned __int8)flags * v270[2] + v477->background.red * (v270[2] ^ 0xFF) + 128;
                  *(v270 - 1) = (unsigned __int16)(v275 + (unsigned __int8)__ROR4__(v275, 8)) >> 8;
                  v276 = v273 * (__int16)v271 + v477->background.green * (v271 ^ 0xFF) + 128;
                  *v270 = (unsigned __int16)(v276 + (unsigned __int8)__ROR4__(v276, 8)) >> 8;
                  v277 = v274 * (__int16)v271 + v477->background.blue * (v271 ^ 0xFF);
                  v272 = (v277 + 128 + (unsigned int)(unsigned __int8)__ROR4__(v277 + 128, 8)) >> 8;
                }
                else
                {
                  *(v270 - 1) = v477->background.red;
                  *v270 = v477->background.green;
                  LOBYTE(v272) = v477->background.blue;
                }
                v270[1] = v272;
              }
              v4 = (png_structrp_5)((char *)v4 - 1);
              v270 += 4;
            }
            while ( v4 );
          }
        }
        else if ( v4 )
        {
          v123 = v97 + 2;
          do
          {
            v124 = v123[2];
            if ( v123[2] )
            {
              if ( v124 == 255 )
              {
                v125 = *v123;
                flags = v123[1];
                *(v123 - 1) = v95[*(v123 - 1)];
                *v123 = v95[v125];
                LOBYTE(v126) = v95[flags];
              }
              else
              {
                v127 = v124 ^ 0xFF;
                v128 = gamma_to_1[*(v123 - 1)] * v123[2] + (v124 ^ 0xFF) * v477->background_1.red + 128;
                v129 = (v128 + (unsigned int)(unsigned __int8)__ROR4__(v128, 8)) >> 8;
                if ( !v94 )
                  LOBYTE(v129) = v470[(unsigned __int8)v129];
                *(v123 - 1) = v129;
                v130 = gamma_to_1[*v123] * (__int16)v124 + v127 * v477->background_1.green + 128;
                v131 = (v130 + (unsigned int)(unsigned __int8)__ROR4__(v130, 8)) >> 8;
                if ( !v94 )
                  LOBYTE(v131) = v470[(unsigned __int8)v131];
                *v123 = v131;
                flags = v127 * v477->background_1.blue;
                v132 = gamma_to_1[v123[1]] * (__int16)v124 + flags + 128;
                v126 = (v132 + (unsigned int)(unsigned __int8)__ROR4__(v132, 8)) >> 8;
                if ( !v94 )
                  LOBYTE(v126) = v470[(unsigned __int8)v126];
              }
            }
            else
            {
              *(v123 - 1) = v477->background.red;
              *v123 = v477->background.green;
              LOBYTE(v126) = v477->background.blue;
            }
            v123[1] = v126;
            v4 = (png_structrp_5)((char *)v4 - 1);
            v123 += 4;
          }
          while ( v4 );
        }
        goto LABEL_118;
      }
      v156 = v476 == 0;
      if ( v476 )
        v156 = v472 == 0;
      if ( !v156 && v474 )
      {
        if ( !v4 )
          goto LABEL_118;
        v157 = 0;
        while ( 1 )
        {
          v158 = &v97[8 * v157];
          flags = v158[8] | (v158[7] << 8);
          if ( flags )
          {
            if ( flags != 0xFFFF )
            {
              v167 = flags ^ 0xFFFF;
              v168 = (flags ^ 0xFFFF) * v477->background_1.red + flags * v474[v158[2] >> v98][v158[1]] + 0x8000;
              v169 = v168 + HIWORD(v168);
              v170 = HIBYTE(v169);
              v171 = HIWORD(v169);
              if ( !v94 )
              {
                v171 = v472[(unsigned __int8)v171 >> v98][v170];
                v170 = v171 >> 8;
              }
              v158[1] = v170;
              v158[2] = v171;
              v172 = v167 * v477->background_1.green + flags * v474[v158[4] >> v98][v158[3]] + 0x8000;
              v173 = v172 + HIWORD(v172);
              v174 = HIBYTE(v173);
              v175 = HIWORD(v173);
              if ( !v94 )
              {
                v175 = v472[(unsigned __int8)v175 >> v98][v174];
                v174 = v175 >> 8;
              }
              v158[3] = v174;
              v158[4] = v175;
              v176 = v167 * v477->background_1.blue + flags * v474[v158[6] >> v98][v158[5]] + 0x8000;
              v177 = v176 + HIWORD(v176);
              v178 = HIBYTE(v177);
              v179 = HIWORD(v177);
              if ( !v94 )
              {
                v179 = v472[(unsigned __int8)v179 >> v98][v178];
                v178 = v179 >> 8;
              }
              v158[5] = v178;
              v158[6] = v179;
              goto LABEL_256;
            }
            v159 = v476[v158[2] >> v98][v158[1]];
            v158[1] = HIBYTE(v159);
            flags = v158[4];
            v160 = v158[3];
            v161 = v158[5];
            v162 = v158[6];
            v158[2] = v159;
            v163 = v476[flags >> v98][v160];
            v158[4] = v163;
            v158[3] = HIBYTE(v163);
            v164 = v476[v162 >> v98][v161];
          }
          else
          {
            v165 = v477->background.red;
            v158[1] = HIBYTE(v165);
            v158[2] = v165;
            v166 = v477->background.green;
            v158[4] = v166;
            v158[3] = HIBYTE(v166);
            v164 = v477->background.blue;
          }
          v158[6] = v164;
          v158[5] = HIBYTE(v164);
LABEL_256:
          if ( v4 == (png_structrp_5)++v157 )
            goto LABEL_118;
        }
      }
      if ( v4 )
      {
        for ( i = 0; i != v4; i = (png_structrp_5)((char *)i + 1) )
        {
          v284 = &v97[8 * (_DWORD)i];
          flags = v284[8];
          v285 = flags | (v284[7] << 8);
          if ( v285 != 0xFFFF )
          {
            if ( v285 )
            {
              v287 = v284[3];
              v288 = v284[4];
              v289 = v284[5];
              v290 = v284[6];
              v291 = v477->background.red * (v285 ^ 0xFFFF) + (v284[2] | (v284[1] << 8)) * v285 + 0x8000;
              v292 = v291 + HIWORD(v291);
              v284[1] = HIBYTE(v292);
              v284[2] = BYTE2(v292);
              v293 = v477->background.green * (v285 ^ 0xFFFF) + (v288 | (v287 << 8)) * v285 + 0x8000;
              v294 = v293 + HIWORD(v293);
              v284[4] = BYTE2(v294);
              v284[3] = HIBYTE(v294);
              v295 = v477->background.blue * (v285 ^ 0xFFFF);
              flags = v290 | (v289 << 8);
              v296 = v295 + flags * v285 + 0x8000 + ((v295 + flags * v285 + 0x8000) >> 16);
              v284[6] = BYTE2(v296);
              v284[5] = HIBYTE(v296);
            }
            else
            {
              v286 = v477->background.red;
              flags = v286 >> 8;
              v284[1] = BYTE1(v286);
              v284[2] = v286;
              LOWORD(v286) = v477->background.green;
              v284[4] = v286;
              v284[3] = BYTE1(v286);
              LOWORD(v286) = v477->background.blue;
              v284[6] = v286;
              v284[5] = BYTE1(v286);
            }
          }
        }
      }
LABEL_118:
      v82 = v468;
      v83 = v477->transformations;
      if ( ((unsigned int)&defaultCoeffs[10177] & v83) != 0x2000 )
        goto LABEL_150;
      if ( (v83 & 0x80) != 0 )
      {
        if ( v477->num_trans )
          goto LABEL_150;
        v84 = v477->color_type;
        if ( (v84 & 4) != 0 )
          goto LABEL_150;
      }
      else
      {
        v84 = v477->color_type;
      }
      if ( v84 != 3 )
      {
        if ( (v85 = v477->row_buf,
              v86 = v477->gamma_shift,
              v87 = v477->gamma_16_table,
              v4 = (png_structrp_5)v477->gamma_table,
              v88 = v468->bit_depth,
              v89 = v468->width,
              v4)
          && v88 < 9
          || v87 && v88 == 16 )
        {
          LOBYTE(flags) = v468->color_type;
          v90 = v85 + 1;
          switch ( (char)flags )
          {
            case 0:
              if ( v88 != 2 )
                goto LABEL_132;
              if ( v89 )
              {
                flags = 0;
                v91 = v85 + 1;
                do
                {
                  v92 = *v91;
                  flags += 4;
                  *v91++ = (*((_BYTE *)v4->jmp_buf_local
                            + (v92 & 0x30 | (4 * (v92 & 0x30)) | ((unsigned __int8)(v92 & 0x30) >> 2) | ((unsigned __int8)(v92 & 0x30) >> 4))) >> 2) & 0x30 | *((_BYTE *)v4->jmp_buf_local + (v92 & 0xC0 | (v92 >> 6) | ((unsigned __int8)(v92 & 0xC0) >> 2) | ((unsigned __int8)(v92 & 0xC0) >> 4))) & 0xC0 | (*((_BYTE *)v4->jmp_buf_local + (v92 & 0xC | (4 * (v92 & 0xC)) | (16 * (v92 & 0xC)) | ((unsigned __int8)(v92 & 0xC) >> 2))) >> 4) & 0xC | (*((_BYTE *)v4->jmp_buf_local + (v92 & 3 | (16 * (v92 & 3)) | ((v92 & 3) << 6) | (4 * (v92 & 3)))) >> 6);
                }
                while ( flags < v89 );
                v82 = v468;
                v88 = v468->bit_depth;
LABEL_132:
                if ( v88 == 4 )
                {
                  if ( v89 )
                  {
                    for ( j = 0; j < v89; j += 2 )
                    {
                      *v90 = *((_BYTE *)v4->jmp_buf_local + (*v90 & 0xF0 | (*v90 >> 4))) & 0xF0 | (*((_BYTE *)v4->jmp_buf_local + (*v90 & 0xF | (16 * (*v90 & 0xF)))) >> 4);
                      ++v90;
                    }
                  }
                }
                else if ( v88 == 8 )
                {
                  for ( ; v89; ++v90 )
                  {
                    --v89;
                    *v90 = *((_BYTE *)v4->jmp_buf_local + *v90);
                  }
                }
                else if ( v88 == 16 && v89 )
                {
                  do
                  {
                    --v89;
                    v93 = v87[v90[1] >> v86][*v90];
                    v90[1] = v93;
                    *v90 = HIBYTE(v93);
                    v90 += 2;
                  }
                  while ( v89 );
                }
              }
              break;
            case 2:
              if ( v88 == 8 )
              {
                for ( ; v89; v90 += 3 )
                {
                  --v89;
                  v265 = v90[1];
                  flags = v90[2];
                  *v90 = *((_BYTE *)v4->jmp_buf_local + *v90);
                  v90[1] = *((_BYTE *)v4->jmp_buf_local + v265);
                  v90[2] = *((_BYTE *)v4->jmp_buf_local + flags);
                }
              }
              else if ( v89 )
              {
                v330 = v85 + 6;
                do
                {
                  --v89;
                  v331 = (unsigned __int8)*(v330 - 3);
                  v332 = (unsigned __int8)*(v330 - 2) >> v86;
                  v333 = v87[(unsigned __int8)*(v330 - 4) >> v86][(unsigned __int8)*(v330 - 5)];
                  *(v330 - 4) = v333;
                  *(v330 - 5) = HIBYTE(v333);
                  v334 = (unsigned __int8)*v330;
                  flags = (unsigned __int8)*(v330 - 1);
                  LOWORD(v332) = v87[v332][v331];
                  *(v330 - 2) = v332;
                  *(v330 - 3) = BYTE1(v332);
                  LOWORD(v332) = v87[v334 >> v86][flags];
                  *v330 = v332;
                  *(v330 - 1) = BYTE1(v332);
                  v330 += 6;
                }
                while ( v89 );
              }
              break;
            case 4:
              if ( v88 == 8 )
              {
                for ( ; v89; v90 += 2 )
                {
                  --v89;
                  *v90 = *((_BYTE *)v4->jmp_buf_local + *v90);
                }
              }
              else
              {
                for ( ; v89; v90 += 4 )
                {
                  --v89;
                  v335 = v87[v90[1] >> v86][*v90];
                  v90[1] = v335;
                  *v90 = HIBYTE(v335);
                }
              }
              break;
            case 6:
              if ( v88 == 8 )
              {
                for ( ; v89; v90 += 4 )
                {
                  --v89;
                  v266 = v90[1];
                  flags = v90[2];
                  *v90 = *((_BYTE *)v4->jmp_buf_local + *v90);
                  v90[1] = *((_BYTE *)v4->jmp_buf_local + v266);
                  v90[2] = *((_BYTE *)v4->jmp_buf_local + flags);
                }
              }
              else if ( v89 )
              {
                v336 = 0;
                do
                {
                  v337 = &v85[8 * v336++];
                  v338 = v337[3];
                  v339 = v337[4] >> v86;
                  v340 = v87[v337[2] >> v86][v337[1]];
                  v337[2] = v340;
                  v337[1] = HIBYTE(v340);
                  v341 = v337[6];
                  flags = v337[5];
                  LOWORD(v339) = v87[v339][v338];
                  v337[4] = v339;
                  v337[3] = BYTE1(v339);
                  LOWORD(v339) = v87[v341 >> v86][flags];
                  v337[6] = v339;
                  v337[5] = BYTE1(v339);
                }
                while ( v89 != v336 );
              }
              break;
            default:
              break;
          }
        }
      }
LABEL_150:
      num_trans = v477;
      v103 = v477->transformations;
      if ( (v103 & 0x40080) == 262272 && (v82->color_type | 2) == 6 )
      {
        j_png_do_strip_channel(v82, v477->row_buf + 1, 0);
        v103 = v477->transformations;
      }
      if ( (v103 & 0x800000) != 0 )
      {
        v104 = v82->color_type;
        if ( (v104 & 4) != 0 )
        {
          v105 = v82->bit_depth;
          v106 = v82->width;
          v107 = (int)(v477->row_buf + 1);
          if ( v105 != 16 )
          {
            if ( v105 == 8 )
            {
              v108 = v477->gamma_from_1;
              if ( v108 )
              {
                if ( v106 )
                {
                  v109 = v104 & 2;
                  v110 = (_BYTE *)(v107 + (v109 | 1));
                  do
                  {
                    --v106;
                    *v110 = v108[(unsigned __int8)*v110];
                    v110 += v109 + 2;
                  }
                  while ( v106 );
                }
                goto LABEL_264;
              }
            }
LABEL_263:
            j_png_warning(v477, (png_const_charp)"png_do_encode_alpha: unexpected call");
            goto LABEL_264;
          }
          v180 = v477->gamma_16_from_1;
          if ( !v180 )
            goto LABEL_263;
          if ( v106 )
          {
            v181 = v477->gamma_shift;
            v182 = (2 * v104) & 4;
            v183 = v182 + 4;
            v184 = (unsigned __int8 *)(v107 + (v182 | 2));
            do
            {
              --v106;
              v185 = v180[v184[1] >> v181][*v184];
              v184[1] = v185;
              flags = v185 >> 8;
              *v184 = flags;
              v184 += v183;
            }
            while ( v106 );
          }
        }
      }
LABEL_264:
      v186 = v477->transformations;
      if ( (v186 & 0x4000000) != 0 && v82->bit_depth == 16 )
      {
        rowbytes = v82->rowbytes;
        if ( rowbytes >= 1 )
        {
          v188 = 0;
          v189 = (int)(v477->row_buf + 1);
          v190 = rowbytes + v189;
          do
          {
            flags = v189 + 2 * v188;
            *(_BYTE *)(v189 + v188++) = *(_BYTE *)flags
                                      + ((unsigned int)&CTheScripts::ScriptSpace[0xFFFF
                                                                               * (*(unsigned __int8 *)(flags + 1)
                                                                                - *(unsigned __int8 *)flags)
                                                                               + 272364] >> 24);
          }
          while ( flags + 2 < v190 );
          v186 = v477->transformations;
        }
        v191 = v82->channels;
        v192 = v82->width;
        v82->bit_depth = 8;
        v82->pixel_depth = 8 * v191;
        v82->rowbytes = v192 * v191;
      }
      if ( (v186 & 0x400) != 0 && v82->bit_depth == 16 )
      {
        v193 = v82->rowbytes;
        if ( v193 >= 1 )
        {
          v194 = v477->row_buf + 1;
          v195 = &v194[v193];
          v196 = v194;
          do
          {
            v197 = *v194;
            v194 += 2;
            *v196++ = v197;
          }
          while ( v194 < v195 );
          v186 = v477->transformations;
        }
        v198 = v82->channels;
        v199 = v82->width;
        v82->bit_depth = 8;
        v82->pixel_depth = 8 * v198;
        v82->rowbytes = v199 * v198;
      }
      if ( (v186 & 0x40) != 0 )
      {
        if ( v82->bit_depth != 8 )
          goto LABEL_297;
        v200 = *(_QWORD *)&v477->palette_lookup;
        v201 = v82->width;
        v202 = v477->row_buf + 1;
        v203 = v82->color_type;
        if ( (_DWORD)v200 && v203 == 2 )
        {
          if ( v201 )
          {
            HIDWORD(v200) = 0;
            do
            {
              v204 = &v202[3 * HIDWORD(v200)];
              flags = (4 * v204[1]) & 0x3E0 | (*v204 << 7) & 0x7C00;
              v202[HIDWORD(v200)++] = *(_BYTE *)(v200 + (flags | (v204[2] >> 3)));
            }
            while ( v201 != HIDWORD(v200) );
LABEL_291:
            v206 = v82->bit_depth;
LABEL_293:
            v82->channels = 1;
            v82->color_type = 3;
            v82->pixel_depth = v206;
            if ( v206 < 8 )
              v207 = (v201 * v206 + 7) >> 3;
            else
              v207 = v201 * (v206 >> 3);
            v82->rowbytes = v207;
            goto LABEL_297;
          }
        }
        else
        {
          if ( !(_DWORD)v200 || v203 != 6 )
          {
            v248 = v201 == 0;
            if ( v201 )
              v248 = HIDWORD(v200) == 0;
            if ( !v248 && v203 == 3 )
            {
              do
              {
                --v201;
                *v202 = *(_BYTE *)(HIDWORD(v200) + (unsigned __int8)*v202);
                ++v202;
              }
              while ( v201 );
            }
LABEL_297:
            if ( v82->rowbytes )
            {
              v186 = v477->transformations;
              goto LABEL_299;
            }
            goto LABEL_671;
          }
          if ( v201 )
          {
            HIDWORD(v200) = 0;
            do
            {
              v205 = &v202[4 * HIDWORD(v200)];
              flags = (4 * v205[1]) & 0x3E0;
              v202[HIDWORD(v200)++] = *(_BYTE *)(v200 + ((*v205 << 7) & 0x7C00 | flags | (v205[2] >> 3)));
            }
            while ( v201 != HIDWORD(v200) );
            goto LABEL_291;
          }
        }
        v206 = 8;
        goto LABEL_293;
      }
LABEL_299:
      if ( (v186 & 0x200) != 0 && v82->bit_depth == 8 && v82->color_type != 3 )
      {
        v208 = v82->rowbytes;
        if ( v208 >= 1 )
        {
          v209 = v477->row_buf;
          v210 = v209 + 1;
          v211 = &v209[v208];
          v212 = (unsigned int)&v210[v208 + v208];
          v213 = v211;
          do
          {
            v214 = *v213--;
            *(_BYTE *)(v212 - 2) = v214;
            v212 -= 2;
            v215 = v212 > (unsigned int)v211;
            v211 = v213;
            *(_BYTE *)(v212 + 1) = v214;
          }
          while ( v215 );
          v186 = v477->transformations;
          v208 = v82->rowbytes;
        }
        v216 = v82->channels;
        v82->bit_depth = 16;
        v82->rowbytes = 2 * v208;
        v82->pixel_depth = 16 * v216;
      }
      v217 = (v186 & 0x4000) != 0;
      if ( (v186 & 0x4000) != 0 )
        v217 = (v477->mode & 0x800) != 0;
      if ( v217 )
      {
        png_do_gray_to_rgb(v82, v477->row_buf + 1);
        v186 = v477->transformations;
        if ( (v186 & 0x20) == 0 )
        {
LABEL_311:
          if ( (v186 & 0x80000) == 0 )
            goto LABEL_334;
          goto LABEL_315;
        }
      }
      else if ( (v186 & 0x20) == 0 )
      {
        goto LABEL_311;
      }
      j_png_do_invert(v82, v477->row_buf + 1);
      if ( (v477->transformations & 0x80000) == 0 )
        goto LABEL_334;
LABEL_315:
      v218 = v82->color_type;
      v219 = v82->width;
      v220 = v477->row_buf;
      if ( v218 == 4 )
      {
        v223 = v82->rowbytes;
        if ( v82->bit_depth == 8 )
        {
          if ( v219 )
          {
            v224 = &v220[v223];
            do
            {
              --v219;
              *v224 = ~*v224;
              v224 -= 2;
            }
            while ( v219 );
          }
        }
        else if ( v219 )
        {
          v227 = &v220[v223 - 1];
          do
          {
            --v219;
            v228 = ~*v227;
            v227[1] = ~v227[1];
            *v227 = v228;
            v227 -= 4;
          }
          while ( v219 );
        }
      }
      else if ( v218 == 6 )
      {
        v221 = v82->rowbytes;
        if ( v82->bit_depth == 8 )
        {
          if ( v219 )
          {
            v222 = &v220[v221];
            do
            {
              --v219;
              *v222 = ~*v222;
              v222 -= 4;
            }
            while ( v219 );
          }
        }
        else if ( v219 )
        {
          v225 = &v220[v221 - 1];
          do
          {
            --v219;
            v226 = ~*v225;
            v225[1] = ~v225[1];
            *v225 = v226;
            v225 -= 8;
          }
          while ( v219 );
        }
      }
LABEL_334:
      v229 = v477->transformations;
      v230 = (v229 & 8) == 0;
      if ( (v229 & 8) != 0 )
      {
        flags = v82->color_type;
        v230 = flags == 3;
      }
      if ( !v230 )
      {
        v231 = v477->row_buf;
        v232 = v82->bit_depth;
        if ( (flags & 2) != 0 )
        {
          v233 = &v477->shift.blue;
          v234 = 2;
          v235 = 3;
          v478[0] = v232 - v477->shift.red;
          v478[1] = v232 - v477->shift.green;
        }
        else
        {
          v233 = &v477->shift.gray;
          v234 = 0;
          v235 = 1;
        }
        v236 = (int8x8_t *)(v231 + 1);
        v478[v234] = v232 - *v233;
        if ( (flags & 4) != 0 )
          v478[v235++] = v232 - v477->shift.alpha;
        v237 = 0;
        v238 = 0;
        do
        {
          v239 = v478[v237];
          if ( v239 < 1 || v239 >= v232 )
            v478[v237] = 0;
          else
            v238 = 1;
          ++v237;
        }
        while ( v237 < v235 );
        if ( v238 )
        {
          switch ( __ROR4__(v232 - 2, 1) )
          {
            case 0:
              v240 = v82->rowbytes;
              if ( v240 < 1 )
                break;
              v241 = (unsigned int)v236 + v240;
              v242 = (unsigned int)(v231 + 2);
              if ( v241 > (unsigned int)(v231 + 2) )
                v242 = v241;
              v243 = ~(unsigned int)v231 + v242;
              if ( v243 >= 0x10 && (v244 = v243 & 0xFFFFFFF0, (v243 & 0xFFFFFFF0) != 0) )
              {
                v245.n128_u64[0] = 0x5555555555555555LL;
                v245.n128_u64[1] = 0x5555555555555555LL;
                v246 = (unsigned __int8 *)v236 + v244;
                v247 = v243 & 0xFFFFFFF0;
                do
                {
                  v247 -= 16;
                  *(int64x2_t *)v236->n64_u64 = vandq_s64(vshrq_n_u8(*(uint8x16_t *)v236->n64_u64, 1u), v245);
                  v236 += 2;
                }
                while ( v247 );
                if ( v244 == v243 )
                  break;
              }
              else
              {
                v246 = v231 + 1;
              }
              do
              {
                *v246 = (*v246 >> 1) & 0x55;
                ++v246;
              }
              while ( (unsigned int)v246 < v241 );
              break;
            case 1:
              v249 = v82->rowbytes;
              if ( v249 < 1 )
                break;
              v250 = v478[0];
              v251 = (unsigned int)v236 + v249;
              v252 = (0xFu >> SLOBYTE(v478[0])) | (16 * (0xFu >> SLOBYTE(v478[0])));
              v253 = (unsigned int)(v231 + 2);
              if ( v251 > (unsigned int)(v231 + 2) )
                v253 = v251;
              v254 = ~(unsigned int)v231 + v253;
              if ( v254 < 0x10 )
              {
                v255 = v231 + 1;
                goto LABEL_529;
              }
              v323 = v254 & 0xFFFFFFF0;
              if ( (v254 & 0xFFFFFFF0) == 0 )
              {
                v255 = (unsigned __int8 *)v236;
                do
                {
LABEL_529:
                  *v255 = (*v255 >> v250) & v252;
                  ++v255;
                }
                while ( (unsigned int)v255 < v251 );
                break;
              }
              v255 = (unsigned __int8 *)v236 + v323;
              v324 = vdupq_n_s32(v252);
              v325 = v254 & 0xFFFFFFF0;
              v326 = vnegq_s32(vdupq_n_s32(v478[0]));
              do
              {
                v325 -= 16;
                v327 = vmovl_u8(v236[1]);
                v328 = vmovl_u8((uint8x8_t)v236->n64_u64[0]);
                *(int16x4_t *)&v329.n128_i8[8] = vmovn_s32(
                                                   vandq_s64(
                                                     vshlq_u32(v326, vmovl_u16(*(uint16x4_t *)&v327.n128_i8[8])),
                                                     v324));
                v329.n128_u64[0] = vmovn_s32(vandq_s64(vshlq_u32(v326, vmovl_u16((uint16x4_t)v327.n128_u64[0])), v324)).n64_u64[0];
                *(int16x4_t *)&v327.n128_i8[8] = vmovn_s32(
                                                   vandq_s64(
                                                     vshlq_u32(v326, vmovl_u16(*(uint16x4_t *)&v328.n128_i8[8])),
                                                     v324));
                v327.n128_u64[0] = vmovn_s32(vandq_s64(vshlq_u32(v326, vmovl_u16((uint16x4_t)v328.n128_u64[0])), v324)).n64_u64[0];
                v236->n64_u64[0] = vmovn_s16(v327).n64_u64[0];
                v236[1].n64_u64[0] = vmovn_s16(v329).n64_u64[0];
                v236 += 2;
              }
              while ( v325 );
              if ( v323 != v254 )
                goto LABEL_529;
              break;
            case 3:
              v256 = v82->rowbytes;
              if ( v256 >= 1 )
              {
                v257 = (unsigned __int8 *)v236 + v256;
                v258 = 0;
                do
                {
                  v259 = v478[v258++];
                  if ( v258 >= v235 )
                    v258 = 0;
                  v236->n64_u8[0] >>= v259;
                  v236 = (int8x8_t *)((char *)v236 + 1);
                }
                while ( v236 < (int8x8_t *)v257 );
              }
              break;
            case 7:
              v260 = v82->rowbytes;
              if ( v260 >= 1 )
              {
                v261 = (unsigned __int8 *)v236 + v260;
                v262 = 0;
                do
                {
                  v263 = v478[v262++];
                  v264 = (unsigned int)(v236->n64_u8[1] | (v236->n64_u8[0] << 8)) >> v263;
                  v236->n64_u8[1] = v264;
                  v236->n64_u8[0] = BYTE1(v264);
                  v236 = (int8x8_t *)((char *)v236 + 2);
                  if ( v262 >= v235 )
                    v262 = 0;
                }
                while ( v236 < (int8x8_t *)v261 );
              }
              break;
            default:
              break;
          }
        }
        if ( (v477->transformations & 4) == 0 )
          goto LABEL_553;
        goto LABEL_531;
      }
      if ( (v229 & 4) == 0 )
        goto LABEL_553;
LABEL_531:
      v351 = v82->bit_depth;
      if ( v351 <= 7 )
      {
        v352 = v477->row_buf;
        v353 = v82->width;
        v354 = v352 + 1;
        if ( v351 == 4 )
        {
          if ( v353 )
          {
            v359 = (4 * v353) & 4;
            v360 = &v354[(v353 - 1) >> 1];
            v361 = v82->width;
            do
            {
              v40 = v359 == 4;
              v362 = *v360 >> v359;
              v359 = 4;
              v352[v361] = v362 & 0xF;
              if ( v40 )
              {
                --v360;
                v359 = 0;
              }
              --v361;
            }
            while ( v361 );
          }
        }
        else if ( v351 == 2 )
        {
          if ( v353 )
          {
            v363 = ~(2 * v353 + 6) & 6;
            v364 = &v354[(v353 - 1) >> 2];
            v365 = v82->width;
            do
            {
              v40 = v363 == 6;
              v366 = *v364 >> v363;
              v363 += 2;
              v352[v365] = v366 & 3;
              if ( v40 )
              {
                --v364;
                v363 = 0;
              }
              --v365;
            }
            while ( v365 );
          }
        }
        else if ( v351 == 1 && v353 )
        {
          v355 = ~(v353 + 7) & 7;
          v356 = &v354[(v353 - 1) >> 3];
          v357 = v82->width;
          do
          {
            v40 = v355 == 7;
            v358 = *v356 >> v355++;
            v352[v357] = v358 & 1;
            if ( v40 )
            {
              --v356;
              v355 = 0;
            }
            --v357;
          }
          while ( v357 );
        }
        v367 = v82->channels;
        v82->bit_depth = 8;
        v82->pixel_depth = 8 * v367;
        v82->rowbytes = v353 * v367;
      }
LABEL_553:
      if ( v82->color_type == 3 && v477->num_palette_max >= 0 )
        j_png_do_check_palette_indexes(v477, v82);
      v368 = v477->transformations;
      if ( (v368 & 1) == 0 )
      {
        if ( (v368 & 0x10000) == 0 )
          goto LABEL_558;
LABEL_561:
        j_png_do_packswap(v82, v477->row_buf + 1);
        if ( (v477->transformations & 0x8000) == 0 )
          goto LABEL_606;
LABEL_562:
        v369 = v477->row_buf;
        filler = v477->filler;
        v371 = v369 + 1;
        v372 = v477->flags;
        v373 = v82->width;
        if ( v82->color_type == 2 )
        {
          v377 = v82->bit_depth;
          if ( v377 == 16 )
          {
            v388 = 6 * v373;
            if ( (v372 & 0x80) != 0 )
            {
              v406 = (int)&v371[6 * v373 + 2 * v373];
              *(_BYTE *)(v406 - 2) = HIBYTE(filler);
              *(_BYTE *)(v406 - 1) = filler;
              if ( v373 >= 2 )
              {
                v407 = &v369[8 * v373 - 4];
                v408 = &v369[v388 - 2];
                v409 = v373 - 1;
                do
                {
                  --v409;
                  v407[2] = v408[2];
                  v407[1] = v408[1];
                  *v407 = *v408;
                  *(v407 - 1) = *(v408 - 1);
                  *(v407 - 2) = *(v408 - 2);
                  v410 = *(v408 - 3);
                  v408 -= 6;
                  *(v407 - 4) = filler;
                  *(v407 - 3) = v410;
                  *(v407 - 5) = HIBYTE(filler);
                  v407 -= 8;
                }
                while ( v409 );
              }
            }
            else if ( v373 )
            {
              v389 = &v369[8 * v373];
              v390 = &v369[v388 - 2];
              v391 = v389 - 3;
              v392 = v82->width;
              do
              {
                --v392;
                v391[3] = v390[2];
                v391[2] = v390[1];
                v391[1] = *v390;
                *v391 = *(v390 - 1);
                *(v391 - 1) = *(v390 - 2);
                v393 = *(v390 - 3);
                v390 -= 6;
                *(v391 - 3) = filler;
                *(v391 - 2) = v393;
                *(v391 - 4) = HIBYTE(filler);
                v391 -= 8;
              }
              while ( v392 );
            }
            *(_WORD *)&v82->channels = 16388;
            v395 = 8 * v373;
            goto LABEL_605;
          }
          if ( v377 != 8 )
            goto LABEL_606;
          v378 = 3 * v373;
          if ( (v372 & 0x80) != 0 )
          {
            v369[v378 + v373] = filler;
            if ( v373 >= 2 )
            {
              v396 = &v369[v378];
              v397 = &v369[4 * v373 - 2];
              v398 = v373 - 1;
              do
              {
                --v398;
                v397[1] = *v396;
                *v397 = *(v396 - 1);
                v399 = *(v396 - 2);
                v396 -= 3;
                *(v397 - 2) = filler;
                *(v397 - 1) = v399;
                v397 -= 4;
              }
              while ( v398 );
            }
          }
          else if ( v373 )
          {
            v379 = &v369[v378];
            v380 = &v369[4 * v373 - 1];
            v381 = v82->width;
            do
            {
              --v381;
              v380[1] = *v379;
              *v380 = *(v379 - 1);
              v382 = *(v379 - 2);
              v379 -= 3;
              *(v380 - 2) = filler;
              *(v380 - 1) = v382;
              v380 -= 4;
            }
            while ( v381 );
          }
          v400 = 8196;
        }
        else
        {
          if ( v82->color_type )
            goto LABEL_606;
          v374 = v82->bit_depth;
          if ( v374 != 16 )
          {
            if ( v374 != 8 )
              goto LABEL_606;
            if ( (v372 & 0x80) != 0 )
            {
              v369[v373 + v373] = filler;
              if ( v373 >= 2 )
              {
                for ( k = v373; k != 1; --k )
                {
                  v369[2 * k - 1] = v369[k];
                  v369[2 * k - 2] = filler;
                }
              }
            }
            else if ( v373 )
            {
              v375 = v82->width;
              do
              {
                v369[2 * v375] = v369[v375];
                v376 = &v369[2 * v375--];
                *(v376 - 1) = filler;
              }
              while ( v375 );
            }
            *(_WORD *)&v82->channels = 4098;
            v395 = 2 * v373;
            goto LABEL_605;
          }
          v383 = 2 * v373;
          if ( (v372 & 0x80) != 0 )
          {
            v401 = (int)&v371[2 * v373 + 2 * v373];
            *(_BYTE *)(v401 - 2) = HIBYTE(filler);
            *(_BYTE *)(v401 - 1) = filler;
            if ( v373 >= 2 )
            {
              v402 = &v369[4 * v373 - 2];
              v403 = &v369[v383 - 1];
              v404 = v373 - 1;
              do
              {
                --v404;
                *v402 = v403[1];
                v405 = *v403;
                v403 -= 2;
                *(v402 - 2) = filler;
                *(v402 - 1) = v405;
                *(v402 - 3) = HIBYTE(filler);
                v402 -= 4;
              }
              while ( v404 );
            }
          }
          else if ( v373 )
          {
            v384 = &v369[4 * v373 - 1];
            v385 = &v369[v383 - 1];
            v386 = v82->width;
            do
            {
              --v386;
              v384[1] = v385[1];
              v387 = *v385;
              v385 -= 2;
              *(v384 - 1) = filler;
              *v384 = v387;
              *(v384 - 2) = HIBYTE(filler);
              v384 -= 4;
            }
            while ( v386 );
          }
          v400 = 8194;
        }
        *(_WORD *)&v82->channels = v400;
        v395 = 4 * v373;
LABEL_605:
        v82->rowbytes = v395;
        goto LABEL_606;
      }
      j_png_do_bgr(v82, v477->row_buf + 1);
      v368 = v477->transformations;
      if ( (v368 & 0x10000) != 0 )
        goto LABEL_561;
LABEL_558:
      if ( (v368 & 0x8000) != 0 )
        goto LABEL_562;
LABEL_606:
      if ( (v477->transformations & 0x20000) == 0 )
        goto LABEL_647;
      v411 = v477->row_buf;
      v412 = v82->color_type;
      v413 = v82->width;
      v414 = v411 + 1;
      if ( v412 == 4 )
      {
        v427 = v82->rowbytes;
        v428 = &v414[v427];
        if ( v82->bit_depth == 8 )
        {
          if ( !v413 )
            goto LABEL_647;
          if ( v413 < 0x10 || (v429 = v82->width - (v82->width & 0xF), v82->width == (v82->width & 0xF)) )
          {
            v429 = 0;
          }
          else
          {
            v430 = (char *)&v411[v427 - 31];
            v428 += 2 * ((v82->width & 0xF) - v413);
            v431 = v82->width - (v82->width & 0xF);
            do
            {
              v479 = vld2q_s8(v430);
              v431 -= 16;
              v432 = *(_OWORD *)v479.val[0].n64_u64;
              vst2q_s8(v430, *(int8x8x4_t *)((char *)&v479 + 16));
              v430 -= 32;
            }
            while ( v431 );
            if ( (v413 & 0xF) == 0 )
              goto LABEL_647;
          }
          v451 = v413 - v429;
          v452 = (char *)(v428 - 1);
          do
          {
            --v451;
            v453 = *v452;
            *v452 = *(v452 - 1);
            *(v452 - 1) = v453;
            v452 -= 2;
          }
          while ( v451 );
          goto LABEL_647;
        }
        if ( !v413 )
          goto LABEL_647;
        if ( v413 <= 0xF || (v436 = v82->width - (v82->width & 0xF), v82->width == (v82->width & 0xF)) )
        {
          v436 = 0;
        }
        else
        {
          v428 += 4 * ((v82->width & 0xF) - v413);
          v437 = (char *)&v411[v427 - 63];
          v438 = v82->width - (v82->width & 0xF);
          do
          {
            v439 = v437;
            v438 -= 16;
            v481 = vld4_s8(v439);
            v439 += 32;
            v483 = vld4_s8(v439);
            v440 = v437 - 64;
            v441 = *(_OWORD *)v481.val[2].n64_u64;
            v442 = *(_OWORD *)v481.val[3].n64_u64;
            v443 = *(_OWORD *)v481.val[0].n64_u64;
            v444 = *(_OWORD *)v481.val[1].n64_u64;
            vst4_s8(v437, *(int8x8x4_t *)&v441);
            v445 = v437 + 32;
            vst4_s8(v445, *(int8x8x4_t *)((char *)&v441 + 8));
            v437 = v440;
          }
          while ( v438 );
          if ( (v413 & 0xF) == 0 )
            goto LABEL_647;
        }
        v454 = v413 - v436;
        v455 = (__int16 *)(v428 - 2);
        do
        {
          v456 = *v455;
          --v454;
          *v455 = *(v455 - 1);
          *(v455 - 1) = v456;
          v455 -= 2;
        }
        while ( v454 );
        goto LABEL_647;
      }
      if ( v412 != 6 )
        goto LABEL_647;
      v415 = v82->rowbytes;
      if ( v82->bit_depth == 8 )
      {
        if ( !v413 )
          goto LABEL_647;
        v416 = &v414[v415];
        if ( v413 < 0x10 || (v417 = v82->width - (v82->width & 0xF), v82->width == (v82->width & 0xF)) )
        {
          v417 = 0;
        }
        else
        {
          v416 += 4 * ((v82->width & 0xF) - v413);
          v418 = (char *)&v411[v415 - 63];
          v419 = v82->width - (v82->width & 0xF);
          do
          {
            v420 = v418;
            v419 -= 16;
            v480 = vld4_s8(v420);
            v420 += 32;
            v482 = vld4_s8(v420);
            v421 = v418 - 64;
            v422 = *(_OWORD *)v480.val[3].n64_u64;
            v423 = *(_OWORD *)v480.val[0].n64_u64;
            v424 = *(_OWORD *)v480.val[1].n64_u64;
            v425 = *(_OWORD *)v480.val[2].n64_u64;
            vst4_s8(v418, *(int8x8x4_t *)&v422);
            v426 = v418 + 32;
            vst4_s8(v426, *(int8x8x4_t *)((char *)&v422 + 8));
            v418 = v421;
          }
          while ( v419 );
          if ( (v413 & 0xF) == 0 )
            goto LABEL_647;
        }
        v446 = v413 - v417;
        v447 = v416 - 2;
        do
        {
          v448 = *(v447 - 2);
          --v446;
          v449 = *(v447 - 1);
          v450 = v447[1];
          v447[1] = *v447;
          *(v447 - 1) = v448;
          *v447 = v449;
          *(v447 - 2) = v450;
          v447 -= 4;
        }
        while ( v446 );
        goto LABEL_647;
      }
      if ( v413 )
      {
        v433 = (int)&v411[v415 - 3];
        do
        {
          v434 = *(_WORD *)(v433 + 2);
          --v413;
          v435 = *(_WORD *)(v433 - 4);
          *(_DWORD *)v433 = *(_DWORD *)(v433 - 2);
          *(_WORD *)(v433 - 2) = v435;
          *(_WORD *)(v433 - 4) = v434;
          v433 -= 8;
        }
        while ( v413 );
      }
LABEL_647:
      v457 = v477->transformations;
      if ( (v457 & 0x10) != 0 )
      {
        j_png_do_swap(v82, v477->row_buf + 1);
        v457 = v477->transformations;
      }
      if ( (v457 & 0x100000) != 0 )
      {
        read_user_transform_fn = v477->read_user_transform_fn;
        if ( read_user_transform_fn )
          read_user_transform_fn(v477, v82, v477->row_buf + 1);
        if ( v477->user_transform_depth )
          v82->bit_depth = v477->user_transform_depth;
        user_transform_channels = v477->user_transform_channels;
        if ( user_transform_channels )
          v82->channels = user_transform_channels;
        else
          user_transform_channels = v82->channels;
        v460 = user_transform_channels * v82->bit_depth;
        v461 = v82->width;
        v82->pixel_depth = v460;
        if ( v460 < 8u )
          v462 = (v461 * v460 + 7) >> 3;
        else
          v462 = v461 * (v460 >> 3);
        v82->rowbytes = v462;
      }
      return;
    default:
      goto LABEL_118;
  }
}
// 1FCFDA: control flows out of bounds to 1FCFDC
// 1FCDA9: failed to expand linear variable 0:d16.8,8:d18.8,16:d20.8,24:d22.8
// 1FCDB5: failed to expand linear variable q12.16
// 1FCE03: failed to expand linear variable 0:d16.8,8:d17.8,16:d18.8,24:d19.8
// 1FCE65: failed to expand linear variable 0:d16.8,8:d18.8,16:d20.8,24:d22.8
// 1FCE71: failed to expand linear variable q12.16
// 4007C: using guessed type Elf32_Sym stru_4007C;

//----- (001FD040) --------------------------------------------------------
void __fastcall png_do_expand(png_row_infop row_info, png_bytep row, png_const_color_16p trans_color)
{
  png_uint_32 width; // r12
  int bit_depth; // r3
  int red_low; // r3
  int green_low; // r6
  int blue_low; // lr
  png_byte *v8; // r5
  png_byte *v9; // r1
  png_uint_32 v10; // r4
  unsigned int gray; // r8
  unsigned int v12; // r6
  int v13; // r6
  png_uint_32 v14; // r5
  png_byte *v15; // r4
  int v16; // r3
  char v17; // r2
  int v18; // r2
  bool v19; // zf
  png_byte v20; // r2
  unsigned int green; // r5
  png_byte *v22; // r4
  unsigned int blue; // r3
  unsigned int red; // r6
  png_byte *v25; // r1
  unsigned int v26; // r10
  int v27; // r9
  unsigned int v28; // lr
  int v29; // r8
  unsigned int v30; // r2
  int v31; // r5
  png_uint_32 v32; // r6
  char v33; // r3
  png_byte v34; // r3
  png_byte v35; // r1
  png_byte v36; // r1
  png_uint_32 v37; // r6
  int v38; // r4
  png_byte *v39; // r5
  int v40; // r3
  png_uint_32 v41; // r5
  int v42; // r6
  png_byte *v43; // r9
  int v44; // r3
  png_uint_32 v45; // r6
  png_byte v46; // r5
  png_size_t rowbytes; // r3
  png_uint_32 v48; // r5
  png_byte *v49; // r2
  png_byte *v50; // r1
  char v51; // r4
  png_byte v52; // r3
  png_byte v53; // r1
  unsigned int v54; // r1

  width = row_info->width;
  if ( row_info->color_type )
  {
    if ( !trans_color || row_info->color_type != 2 )
      return;
    bit_depth = row_info->bit_depth;
    if ( bit_depth == 16 )
    {
      if ( width )
      {
        green = trans_color->green;
        v22 = &row[8 * width - 4];
        blue = trans_color->blue;
        red = trans_color->red;
        v25 = &row[row_info->rowbytes - 3];
        v26 = green >> 8;
        v27 = (unsigned __int8)green;
        v28 = blue >> 8;
        v29 = (unsigned __int8)blue;
        v30 = red >> 8;
        v31 = (unsigned __int8)red;
        v32 = row_info->width;
        do
        {
          if ( *(v25 - 3) == v30 && *(v25 - 2) == v31 && *(v25 - 1) == v26 && *v25 == v27 && v25[1] == v28 )
          {
            v33 = 0;
            if ( v25[2] != v29 )
              v33 = -1;
          }
          else
          {
            v33 = -1;
          }
          v22[2] = v33;
          --v32;
          v22[3] = v33;
          v22[1] = v25[2];
          *v22 = v25[1];
          *(v22 - 1) = *v25;
          *(v22 - 2) = *(v25 - 1);
          *(v22 - 3) = *(v25 - 2);
          v34 = *(v25 - 3);
          v25 -= 6;
          *(v22 - 4) = v34;
          v22 -= 8;
        }
        while ( v32 );
      }
    }
    else if ( bit_depth == 8 && width )
    {
      red_low = LOBYTE(trans_color->red);
      green_low = LOBYTE(trans_color->green);
      blue_low = LOBYTE(trans_color->blue);
      v8 = &row[4 * width - 2];
      v9 = &row[row_info->rowbytes - 2];
      v10 = row_info->width;
      do
      {
        if ( *(v9 - 1) != red_low )
          goto LABEL_28;
        v18 = *v9;
        v19 = v18 == green_low;
        if ( v18 == green_low )
          v19 = v9[1] == blue_low;
        if ( v19 )
          v17 = 0;
        else
LABEL_28:
          v17 = -1;
        v8[1] = v17;
        --v10;
        *v8 = v9[1];
        *(v8 - 1) = *v9;
        v20 = *(v9 - 1);
        v9 -= 3;
        *(v8 - 2) = v20;
        v8 -= 4;
      }
      while ( v10 );
    }
    v35 = row_info->bit_depth;
    row_info->channels = 4;
    row_info->color_type = 6;
    v36 = 4 * v35;
    goto LABEL_74;
  }
  if ( trans_color )
    gray = trans_color->gray;
  else
    gray = 0;
  v12 = row_info->bit_depth;
  if ( v12 <= 7 )
  {
    switch ( v12 )
    {
      case 4u:
        gray = 17 * (gray & 0xF);
        if ( width )
        {
          v37 = width - 1;
          v38 = (4 * width) & 4;
          v39 = &row[(width - 1) >> 1];
          do
          {
            v19 = v38 == 4;
            v40 = *v39 >> v38;
            v38 = 4;
            row[v37--] = v40 & 0xF | (16 * (v40 & 0xF));
            if ( v19 )
            {
              --v39;
              v38 = 0;
            }
          }
          while ( v37 != -1 );
        }
        break;
      case 2u:
        gray = 85 * (gray & 3);
        if ( width )
        {
          v41 = width - 1;
          v42 = ~(2 * width + 6) & 6;
          v43 = &row[(width - 1) >> 2];
          do
          {
            v19 = v42 == 6;
            v44 = *v43 >> v42;
            v42 += 2;
            row[v41--] = v44 & 3 | (4 * (v44 & 3)) | (16 * (v44 & 3)) | ((v44 & 3) << 6);
            if ( v19 )
            {
              --v43;
              v42 = 0;
            }
          }
          while ( v41 != -1 );
        }
        break;
      case 1u:
        gray = (unsigned __int8)-(gray & 1);
        if ( width )
        {
          v13 = ~(width + 7) & 7;
          v14 = width - 1;
          v15 = &row[(width - 1) >> 3];
          do
          {
            v16 = (1 << v13) & *v15;
            if ( v16 )
              LOBYTE(v16) = -1;
            v19 = v13 == 7;
            row[v14] = v16;
            ++v13;
            --v14;
            if ( v19 )
            {
              --v15;
              v13 = 0;
            }
          }
          while ( v14 != -1 );
        }
        break;
    }
    v12 = 8;
    row_info->pixel_depth = 8;
    row_info->bit_depth = 8;
    row_info->rowbytes = width;
  }
  if ( trans_color )
  {
    if ( v12 == 16 )
    {
      if ( width )
      {
        rowbytes = row_info->rowbytes;
        v48 = width;
        v49 = &row[2 * rowbytes - 2];
        v50 = &row[rowbytes - 1];
        do
        {
          if ( *(v50 - 1) == gray >> 8 )
          {
            v51 = 0;
            if ( *v50 != (unsigned __int8)gray )
              v51 = -1;
          }
          else
          {
            v51 = -1;
          }
          *v49 = v51;
          --v48;
          v49[1] = v51;
          *(v49 - 1) = *v50;
          v52 = *(v50 - 1);
          v50 -= 2;
          *(v49 - 2) = v52;
          v49 -= 4;
        }
        while ( v48 );
      }
    }
    else if ( v12 == 8 && width )
    {
      v45 = width;
      do
      {
        v46 = 0;
        if ( row[v45 - 1] != (unsigned __int8)gray )
          v46 = -1;
        row[2 * v45 - 1] = v46;
        row[2 * v45 - 2] = row[v45 - 1];
        --v45;
      }
      while ( v45 );
    }
    v53 = row_info->bit_depth;
    row_info->channels = 2;
    row_info->color_type = 4;
    v36 = 2 * v53;
LABEL_74:
    row_info->pixel_depth = v36;
    if ( v36 < 8u )
      v54 = (v36 * width + 7) >> 3;
    else
      v54 = (v36 >> 3) * width;
    row_info->rowbytes = v54;
  }
}

//----- (001FD354) --------------------------------------------------------
void __fastcall png_do_gray_to_rgb(png_row_infop row_info, png_bytep row)
{
  unsigned int bit_depth; // r2
  int color_type; // r3
  png_uint_32 width; // r12
  png_uint_32 v5; // r2
  png_byte *v6; // r3
  png_byte *v7; // r4
  png_uint_32 v8; // r2
  png_byte *v9; // r3
  png_byte *v10; // r4
  png_byte *v11; // r3
  png_uint_32 v12; // r2
  png_byte *v13; // r5
  png_uint_32 v14; // r2
  png_byte *v15; // r3
  png_byte *v16; // r4
  png_byte v17; // r2
  png_byte v18; // r3
  png_byte v19; // r1
  png_byte v20; // r2
  unsigned int v21; // r1

  bit_depth = row_info->bit_depth;
  if ( bit_depth >= 8 )
  {
    color_type = row_info->color_type;
    if ( (color_type & 2) == 0 )
    {
      width = row_info->width;
      if ( color_type == 4 )
      {
        if ( bit_depth == 8 )
        {
          if ( width )
          {
            v8 = row_info->width;
            do
            {
              v9 = &row[2 * v8];
              v10 = &row[4 * v8--];
              *(v10 - 1) = *(v9 - 1);
              *(v10 - 2) = *(v9 - 2);
              *(v10 - 3) = *(v9 - 2);
              *(v10 - 4) = *(v9 - 2);
            }
            while ( v8 );
          }
        }
        else if ( width )
        {
          v14 = row_info->width;
          do
          {
            v15 = &row[4 * v14];
            v16 = &row[8 * v14--];
            *(v16 - 1) = *(v15 - 1);
            *(v16 - 2) = *(v15 - 2);
            *(v16 - 3) = *(v15 - 3);
            *(v16 - 4) = *(v15 - 4);
            *(v16 - 5) = *(v15 - 3);
            *(v16 - 6) = *(v15 - 4);
            *(v16 - 7) = *(v15 - 3);
            *(v16 - 8) = *(v15 - 4);
          }
          while ( v14 );
        }
      }
      else if ( !row_info->color_type )
      {
        if ( bit_depth == 8 )
        {
          if ( width )
          {
            v5 = row_info->width;
            do
            {
              v6 = &row[v5];
              v7 = &row[3 * v5--];
              *(v7 - 1) = *(v6 - 1);
              *(v7 - 2) = *(v6 - 1);
              *(v7 - 3) = *(v6 - 1);
            }
            while ( v5 );
          }
        }
        else if ( width )
        {
          v11 = &row[4 * width - 1 + 2 * width];
          v12 = row_info->width;
          do
          {
            v13 = &row[2 * v12--];
            *v11 = *(v13 - 1);
            *(v11 - 1) = *(v13 - 2);
            *(v11 - 2) = *(v13 - 1);
            *(v11 - 3) = *(v13 - 2);
            *(v11 - 4) = *(v13 - 1);
            *(v11 - 5) = *(v13 - 2);
            v11 -= 6;
          }
          while ( v12 );
        }
      }
      v17 = row_info->bit_depth;
      v18 = row_info->channels + 2;
      v19 = row_info->color_type;
      row_info->channels = v18;
      v20 = v17 * v18;
      row_info->color_type = v19 | 2;
      row_info->pixel_depth = v20;
      if ( v20 < 8u )
        v21 = (v20 * width + 7) >> 3;
      else
        v21 = (v20 >> 3) * width;
      row_info->rowbytes = v21;
    }
  }
}

//----- (001FD4C0) --------------------------------------------------------
png_uint_32 __fastcall png_get_uint_31(png_const_structrp_4 png_ptr, png_const_bytep buf)
{
  signed int v2; // r1

  v2 = bswap32(*(_DWORD *)buf);
  if ( v2 <= -1 )
  {
    j_png_error(png_ptr, (png_const_charp)"PNG unsigned integer out of range");
    JUMPOUT(0x1FD4DC);
  }
  return v2;
}
// 1FD4DA: control flows out of bounds to 1FD4DC

//----- (001FD4E0) --------------------------------------------------------
png_uint_32 __fastcall png_get_uint_32(png_const_bytep buf)
{
  return bswap32(*(_DWORD *)buf);
}

//----- (001FD4E6) --------------------------------------------------------
png_int_32 __fastcall png_get_int_32(png_const_bytep buf)
{
  int v1; // r1
  png_int_32 result; // r0

  v1 = *buf;
  result = _byteswap_ulong(*(_DWORD *)buf);
  if ( v1 << 24 <= -1 && (-result < -1 || result == 1) )
    return 0;
  return result;
}

//----- (001FD512) --------------------------------------------------------
png_uint_16 __fastcall png_get_uint_16(png_const_bytep buf)
{
  return _byteswap_ushort(*(_WORD *)buf);
}

//----- (001FD51C) --------------------------------------------------------
void __fastcall png_read_sig(png_structrp_6 png_ptr, png_inforp_4 info_ptr)
{
  png_size_t sig_bytes; // r5
  png_byte *signature; // r8

  sig_bytes = png_ptr->sig_bytes;
  if ( sig_bytes <= 7 )
  {
    signature = info_ptr->signature;
    png_ptr->io_state = 17;
    j_png_read_data(png_ptr, &info_ptr->signature[sig_bytes], 8 - sig_bytes);
    png_ptr->sig_bytes = 8;
    if ( j_png_sig_cmp(signature, sig_bytes, 8 - sig_bytes) )
    {
      if ( sig_bytes > 3 || !j_png_sig_cmp(signature, sig_bytes, 4 - sig_bytes) )
        j_png_error(png_ptr, (png_const_charp)"PNG file corrupted by ASCII conversion");
      j_png_error(png_ptr, (png_const_charp)"Not a PNG file");
      JUMPOUT(0x1FD590);
    }
    if ( sig_bytes <= 2 )
      png_ptr->mode |= 0x1000u;
  }
}
// 1FD58C: control flows out of bounds to 1FD590

//----- (001FD5C8) --------------------------------------------------------
png_uint_32 __fastcall png_read_chunk_header(png_structrp_6 png_ptr)
{
  signed int v2; // r8
  png_uint_32 chunk_name; // r0
  png_alloc_size_t user_chunk_malloc_max; // r4
  unsigned int v5; // r10
  int v6; // r1
  __int64 v7; // kr00_8
  int v8; // r2
  int v9; // r0
  unsigned int v10; // r5
  unsigned int v11; // r1
  unsigned int v13; // [sp+0h] [bp-28h] BYREF
  unsigned int v14; // [sp+4h] [bp-24h] BYREF

  png_ptr->io_state = 33;
  j_png_read_data(png_ptr, (png_bytep)&v13, 8u);
  v2 = bswap32(v13);
  if ( v2 <= -1 )
    goto LABEL_28;
  png_ptr->chunk_name = bswap32(v14);
  j_png_reset_crc(png_ptr);
  j_png_calculate_crc(png_ptr, (png_const_bytep)&v14, 4u);
  chunk_name = png_ptr->chunk_name;
  if ( (unsigned int)(unsigned __int8)chunk_name - 65 > 0x39
    || (unsigned int)(unsigned __int8)chunk_name - 91 <= 5
    || (unsigned int)(unsigned __int8)__ROR4__(chunk_name, 8) - 65 > 0x39
    || (unsigned int)(unsigned __int8)__ROR4__(chunk_name, 8) - 91 < 6
    || (unsigned int)(unsigned __int8)__ROR4__(chunk_name, 16) - 65 > 0x39
    || (unsigned int)(unsigned __int8)__ROR4__(chunk_name, 16) - 91 < 6
    || HIBYTE(chunk_name) - 65 > 0x39u
    || HIBYTE(chunk_name) - 91 < 6u )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"invalid chunk type");
LABEL_28:
    j_png_error(png_ptr, (png_const_charp)"PNG unsigned integer out of range");
    goto LABEL_29;
  }
  user_chunk_malloc_max = png_ptr->user_chunk_malloc_max;
  v5 = 0x7FFFFFFF;
  LOWORD(v6) = 16724;
  if ( user_chunk_malloc_max - 1 >= 0x7FFFFFFE )
    user_chunk_malloc_max = 0x7FFFFFFF;
  HIWORD(v6) = 18756;
  if ( chunk_name == v6 )
  {
    v7 = *(_QWORD *)&png_ptr->width;
    v8 = 1;
    if ( png_ptr->bit_depth > 8u )
      v8 = 2;
    v9 = v8 * v7 * png_ptr->channels;
    if ( png_ptr->interlaced )
      v9 += 6;
    v10 = (v9 + 1) * HIDWORD(v7);
    if ( HIDWORD(v7) > 0xFFFFFFFF / (v9 + 1) )
      v10 = 0x7FFFFFFF;
    v11 = 32566;
    if ( (unsigned int)(v9 + 1) < 0x7F36 )
      v11 = v9 + 1;
    if ( 5 * (v10 / v11) + v10 + 11 < 0x7FFFFFFF )
      v5 = 5 * (v10 / v11) + v10 + 11;
    if ( user_chunk_malloc_max < v5 )
      user_chunk_malloc_max = v5;
  }
  if ( user_chunk_malloc_max < v2 )
  {
LABEL_29:
    j_png_chunk_error(png_ptr, (png_const_charp)"chunk data is too large");
    JUMPOUT(0x1FD744);
  }
  png_ptr->io_state = 65;
  return v2;
}
// 1FD742: control flows out of bounds to 1FD744

//----- (001FD758) --------------------------------------------------------
void __fastcall png_check_chunk_name(png_const_structrp_4 png_ptr, const png_uint_32 chunk_name)
{
  if ( (unsigned int)(unsigned __int8)chunk_name - 65 > 0x39
    || (unsigned int)(unsigned __int8)chunk_name - 91 <= 5
    || (unsigned int)(unsigned __int8)__ROR4__(chunk_name, 8) - 65 > 0x39
    || (unsigned int)(unsigned __int8)__ROR4__(chunk_name, 8) - 91 < 6
    || (unsigned int)(unsigned __int8)__ROR4__(chunk_name, 16) - 65 > 0x39
    || (unsigned int)(unsigned __int8)__ROR4__(chunk_name, 16) - 91 < 6
    || HIBYTE(chunk_name) - 65 > 0x39u
    || HIBYTE(chunk_name) - 91 < 6u )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"invalid chunk type");
    JUMPOUT(0x1FD7C8);
  }
}
// 1FD7C6: control flows out of bounds to 1FD7C8

//----- (001FD7CC) --------------------------------------------------------
void __fastcall png_check_chunk_length(png_const_structrp_4 png_ptr, const png_uint_32 length)
{
  png_alloc_size_t user_chunk_malloc_max; // r4
  png_uint_32 v4; // r8
  png_uint_32 chunk_name; // r0
  unsigned int v6; // r10
  __int64 v7; // kr00_8
  int v8; // r2
  int v9; // r0
  unsigned int v10; // r5
  unsigned int v11; // r1

  user_chunk_malloc_max = png_ptr->user_chunk_malloc_max;
  v4 = length;
  chunk_name = png_ptr->chunk_name;
  v6 = 0x7FFFFFFF;
  LOWORD(length) = 16724;
  if ( user_chunk_malloc_max - 1 >= 0x7FFFFFFE )
    user_chunk_malloc_max = 0x7FFFFFFF;
  HIWORD(length) = 18756;
  if ( chunk_name == length )
  {
    v7 = *(_QWORD *)&png_ptr->width;
    v8 = 1;
    if ( png_ptr->bit_depth > 8u )
      v8 = 2;
    v9 = v8 * v7 * png_ptr->channels;
    if ( png_ptr->interlaced )
      v9 += 6;
    v10 = (v9 + 1) * HIDWORD(v7);
    if ( HIDWORD(v7) > 0xFFFFFFFF / (v9 + 1) )
      v10 = 0x7FFFFFFF;
    v11 = 32566;
    if ( (unsigned int)(v9 + 1) < 0x7F36 )
      v11 = v9 + 1;
    if ( 5 * (v10 / v11) + v10 + 11 < 0x7FFFFFFF )
      v6 = 5 * (v10 / v11) + v10 + 11;
    if ( user_chunk_malloc_max < v6 )
      user_chunk_malloc_max = v6;
  }
  if ( user_chunk_malloc_max < v4 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"chunk data is too large");
    JUMPOUT(0x1FD878);
  }
}
// 1FD874: control flows out of bounds to 1FD878

//----- (001FD87C) --------------------------------------------------------
void __fastcall png_crc_read(png_structrp_6 png_ptr, png_bytep buf, png_uint_32 length)
{
  if ( png_ptr )
  {
    j_png_read_data(png_ptr, buf, length);
    sub_19AB60(png_ptr, buf, length);
  }
}

//----- (001FD8B0) --------------------------------------------------------
int __fastcall png_crc_finish(png_structrp_6 png_ptr, png_uint_32 skip)
{
  png_uint_32 v3; // r5
  png_size_t v4; // r6
  png_uint_32 flags; // r5
  png_uint_32 v7; // r0
  unsigned int data[256]; // [sp+4h] [bp-414h] BYREF

  v3 = skip;
  while ( v3 )
  {
    v4 = v3;
    if ( v3 >= 0x400 )
      v4 = 1024;
    v3 -= v4;
    if ( png_ptr )
    {
      j_png_read_data(png_ptr, (png_bytep)data, v4);
      j_png_calculate_crc(png_ptr, (png_const_bytep)data, v4);
    }
  }
  flags = png_ptr->flags;
  if ( (png_ptr->chunk_name & 0x20000000) != 0 )
  {
    png_ptr->io_state = 129;
    j_png_read_data(png_ptr, (png_bytep)data, 4u);
    if ( (flags & 0x300) == 768 )
      return 0;
  }
  else
  {
    png_ptr->io_state = 129;
    j_png_read_data(png_ptr, (png_bytep)data, 4u);
    if ( (flags & 0x800) != 0 )
      return 0;
  }
  if ( bswap32(data[0]) == png_ptr->crc )
    return 0;
  v7 = png_ptr->flags;
  if ( (png_ptr->chunk_name & 0x20000000) != 0 )
  {
    if ( (v7 & 0x200) == 0 )
      goto LABEL_15;
LABEL_17:
    j_png_chunk_error(png_ptr, (png_const_charp)"CRC error");
    JUMPOUT(0x1FD990);
  }
  if ( (v7 & 0x400) == 0 )
    goto LABEL_17;
LABEL_15:
  j_png_chunk_warning(png_ptr, (png_const_charp)"CRC error");
  return 1;
}
// 1FD98C: control flows out of bounds to 1FD990
// 1FD8B0: using guessed type unsigned int data[256];

//----- (001FD9A4) --------------------------------------------------------
int __fastcall png_crc_error(png_structrp_6 png_ptr)
{
  png_uint_32 flags; // r5
  unsigned int data[3]; // [sp+4h] [bp-Ch] BYREF

  flags = png_ptr->flags;
  if ( (png_ptr->chunk_name & 0x20000000) != 0 )
  {
    png_ptr->io_state = 129;
    j_png_read_data(png_ptr, (png_bytep)data, 4u);
    if ( (flags & 0x300) == 768 )
      return 0;
  }
  else
  {
    png_ptr->io_state = 129;
    j_png_read_data(png_ptr, (png_bytep)data, 4u);
    if ( (flags & 0x800) != 0 )
      return 0;
  }
  return bswap32(data[0]) != png_ptr->crc;
}
// 1FD9A4: using guessed type unsigned int data[3];

//----- (001FDA00) --------------------------------------------------------
void __fastcall png_handle_IHDR(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  png_uint_32 mode; // r0
  __int64 v6; // r2
  int v7; // r5
  int v8; // r6
  int v9; // r12
  bool v10; // zf
  int v11; // lr
  int v12; // r9
  png_byte v13; // r1
  unsigned __int8 v14; // r0
  unsigned int v15; // r1
  png_byte data[4]; // [sp+17h] [bp-29h] BYREF
  unsigned int v17; // [sp+1Bh] [bp-25h]
  png_byte buf[13]; // [sp+1Fh] [bp-21h]

  mode = png_ptr->mode;
  if ( (mode & 1) != 0 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"out of place");
    goto LABEL_17;
  }
  if ( length != 13 )
  {
LABEL_17:
    j_png_chunk_error(png_ptr, (png_const_charp)"invalid");
    goto LABEL_18;
  }
  png_ptr->mode = mode | 1;
  j_png_read_data(png_ptr, data, 0xDu);
  j_png_calculate_crc(png_ptr, data, 0xDu);
  j_png_crc_finish(png_ptr, 0);
  LODWORD(v6) = bswap32(*(unsigned int *)data);
  if ( (int)v6 <= -1 )
  {
LABEL_18:
    j_png_error(png_ptr, (png_const_charp)"PNG unsigned integer out of range");
    goto LABEL_19;
  }
  HIDWORD(v6) = bswap32(v17);
  if ( SHIDWORD(v6) <= -1 )
  {
LABEL_19:
    j_png_error(png_ptr, (png_const_charp)"PNG unsigned integer out of range");
    JUMPOUT(0x1FDB28);
  }
  v7 = buf[1];
  v8 = buf[0];
  v9 = buf[2];
  v10 = buf[1] == 6;
  v11 = buf[3];
  v12 = buf[4];
  *(_QWORD *)&png_ptr->width = v6;
  png_ptr->bit_depth = v8;
  png_ptr->interlaced = v12;
  png_ptr->color_type = v7;
  png_ptr->filter_type = v11;
  png_ptr->compression_type = v9;
  if ( v10 )
  {
    v13 = 4;
  }
  else if ( v7 == 4 )
  {
    v13 = 2;
  }
  else if ( v7 == 2 )
  {
    v13 = 3;
  }
  else
  {
    v13 = 1;
  }
  png_ptr->channels = v13;
  v14 = v8 * v13;
  png_ptr->pixel_depth = v8 * v13;
  if ( (unsigned __int8)(v8 * v13) < 8u )
    v15 = (v14 * (unsigned int)v6 + 7) >> 3;
  else
    v15 = (v14 >> 3) * v6;
  png_ptr->rowbytes = v15;
  j_png_set_IHDR(png_ptr, info_ptr, v6, HIDWORD(v6), v8, v7, v12, v9, v11);
}
// 1FDB26: control flows out of bounds to 1FDB28

//----- (001FDB40) --------------------------------------------------------
void __fastcall png_handle_PLTE(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  png_uint_32 mode; // r1
  int color_type; // r0
  const char *v8; // r1
  int v9; // r10
  int v10; // r0
  int v11; // r5
  int v12; // r0
  png_color *v13; // r0
  png_uint_32 *p_valid; // r5
  png_uint_32 valid; // r0
  png_byte data[3]; // [sp+1h] [bp-31Fh] BYREF
  png_color palette[265]; // [sp+4h] [bp-31Ch] BYREF

  mode = png_ptr->mode;
  if ( (mode & 1) == 0 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"missing IHDR");
    goto LABEL_34;
  }
  if ( (mode & 2) != 0 )
  {
LABEL_34:
    j_png_chunk_error(png_ptr, (png_const_charp)"duplicate");
    goto LABEL_35;
  }
  if ( (mode & 4) != 0 )
  {
    j_png_crc_finish(png_ptr, length);
    v8 = "out of place";
    goto LABEL_7;
  }
  color_type = png_ptr->color_type;
  png_ptr->mode = mode | 2;
  if ( (color_type & 2) == 0 )
  {
    j_png_crc_finish(png_ptr, length);
    v8 = "ignored in grayscale PNG";
LABEL_7:
    j_png_chunk_benign_error(png_ptr, (png_const_charp)v8);
    return;
  }
  if ( length > 0x300 || (v9 = length / 3, length % 3) )
  {
    j_png_crc_finish(png_ptr, length);
    if ( png_ptr->color_type != 3 )
    {
      v8 = "invalid";
      goto LABEL_7;
    }
LABEL_35:
    j_png_chunk_error(png_ptr, (png_const_charp)"invalid");
    JUMPOUT(0x1FDCC8);
  }
  if ( color_type == 3 )
    v10 = 1 << png_ptr->bit_depth;
  else
    v10 = 256;
  if ( v9 > v10 )
    v9 = v10;
  if ( v9 >= 1 )
  {
    v11 = 0;
    do
    {
      j_png_read_data(png_ptr, data, 3u);
      j_png_calculate_crc(png_ptr, data, 3u);
      v12 = v11++;
      palette[v12].red = data[0];
      v13 = &palette[v12];
      v13->green = data[1];
      v13->blue = data[2];
    }
    while ( v11 < v9 );
  }
  j_png_crc_finish(png_ptr, -3 * v9 + length);
  j_png_set_PLTE(png_ptr, info_ptr, palette, v9);
  if ( png_ptr->num_trans )
  {
    png_ptr->num_trans = 0;
    if ( !info_ptr )
    {
      v8 = "tRNS must be after";
      goto LABEL_7;
    }
    p_valid = &info_ptr->valid;
    goto LABEL_27;
  }
  if ( !info_ptr )
    return;
  p_valid = &info_ptr->valid;
  valid = info_ptr->valid;
  if ( (valid & 0x10) != 0 )
  {
    png_ptr->num_trans = 0;
LABEL_27:
    info_ptr->num_trans = 0;
    j_png_chunk_benign_error(png_ptr, (png_const_charp)"tRNS must be after");
    valid = info_ptr->valid;
  }
  if ( (valid & 0x40) != 0 )
    j_png_chunk_benign_error(png_ptr, (png_const_charp)"hIST must be after");
  if ( (*(_BYTE *)p_valid & 0x20) != 0 )
  {
    v8 = "bKGD must be after";
    goto LABEL_7;
  }
}
// 1FDCC4: control flows out of bounds to 1FDCC8
// 1FDB40: using guessed type png_color palette[265];

//----- (001FDD34) --------------------------------------------------------
void __fastcall png_handle_IEND(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  png_uint_32 mode; // r0

  mode = png_ptr->mode;
  if ( (mode & 5) != 5 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"out of place");
    JUMPOUT(0x1FDD78);
  }
  png_ptr->mode = mode | 0x18;
  j_png_crc_finish(png_ptr, length);
  if ( length )
    sub_191A28(png_ptr, (png_const_charp)"invalid");
}
// 1FDD76: control flows out of bounds to 1FDD78

//----- (001FDD80) --------------------------------------------------------
void __fastcall png_handle_gAMA(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  png_uint_32 mode; // r0
  const char *v6; // r1
  png_fixed_point v7; // r2
  unsigned int data[5]; // [sp+4h] [bp-14h] BYREF

  mode = png_ptr->mode;
  if ( (mode & 1) == 0 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"missing IHDR");
    JUMPOUT(0x1FDE18);
  }
  if ( (mode & 6) != 0 )
  {
    j_png_crc_finish(png_ptr, length);
    v6 = "out of place";
LABEL_10:
    j_png_chunk_benign_error(png_ptr, (png_const_charp)v6);
    return;
  }
  if ( length != 4 )
  {
    j_png_crc_finish(png_ptr, length);
    v6 = "invalid";
    goto LABEL_10;
  }
  j_png_read_data(png_ptr, (png_bytep)data, 4u);
  j_png_calculate_crc(png_ptr, (png_const_bytep)data, 4u);
  if ( !j_png_crc_finish(png_ptr, 0) )
  {
    v7 = bswap32(data[0]);
    if ( v7 <= -1 )
      v7 = -1;
    j_png_colorspace_set_gamma(png_ptr, &png_ptr->colorspace, v7);
    j_png_colorspace_sync(png_ptr, info_ptr);
  }
}
// 1FDE16: control flows out of bounds to 1FDE18
// 1FDD80: using guessed type unsigned int data[5];

//----- (001FDE24) --------------------------------------------------------
void __fastcall png_handle_sBIT(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  png_uint_32 mode; // r0
  const char *v7; // r1
  unsigned int bit_depth; // r9
  int channels; // r0
  int v10; // r0
  png_byte v11; // r0
  png_byte *v12; // r1
  png_byte v13; // r3
  png_byte v14; // r6
  png_byte data[4]; // [sp+4h] [bp-1Ch] BYREF

  mode = png_ptr->mode;
  if ( (mode & 1) == 0 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"missing IHDR");
    JUMPOUT(0x1FDF44);
  }
  if ( (mode & 6) != 0 )
  {
    j_png_crc_finish(png_ptr, length);
    v7 = "out of place";
LABEL_4:
    j_png_chunk_benign_error(png_ptr, (png_const_charp)v7);
    return;
  }
  if ( info_ptr && (info_ptr->valid & 2) != 0 )
  {
    j_png_crc_finish(png_ptr, length);
    v7 = "duplicate";
    goto LABEL_4;
  }
  if ( png_ptr->color_type == 3 )
  {
    bit_depth = 8;
    channels = 3;
    if ( length > 4 )
    {
LABEL_19:
      j_png_chunk_benign_error(png_ptr, (png_const_charp)"invalid");
      j_png_crc_finish(png_ptr, length);
      return;
    }
  }
  else
  {
    bit_depth = png_ptr->bit_depth;
    channels = png_ptr->channels;
    if ( length > 4 )
      goto LABEL_19;
  }
  if ( channels != length )
    goto LABEL_19;
  *(_DWORD *)data = 16843009 * bit_depth;
  j_png_read_data(png_ptr, data, length);
  j_png_calculate_crc(png_ptr, data, length);
  if ( !j_png_crc_finish(png_ptr, 0) )
  {
    if ( length )
    {
      v10 = 0;
      while ( (unsigned __int8)(data[v10] - 1) < bit_depth )
      {
        if ( ++v10 >= length )
          goto LABEL_16;
      }
      v7 = "invalid";
      goto LABEL_4;
    }
LABEL_16:
    v11 = data[0];
    if ( (png_ptr->color_type & 2) != 0 )
    {
      v12 = &data[3];
      v13 = data[1];
      v14 = data[2];
    }
    else
    {
      v12 = &data[1];
      v13 = data[0];
      v14 = data[0];
      png_ptr->sig_bit.gray = data[0];
    }
    png_ptr->sig_bit.blue = v14;
    png_ptr->sig_bit.green = v13;
    png_ptr->sig_bit.red = v11;
    png_ptr->sig_bit.alpha = *v12;
    j_png_set_sBIT(png_ptr, info_ptr, &png_ptr->sig_bit);
  }
}
// 1FDF40: control flows out of bounds to 1FDF44

//----- (001FDF58) --------------------------------------------------------
void __fastcall png_handle_cHRM(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  png_uint_32 mode; // r0
  const char *v6; // r1
  png_fixed_point v7; // r6
  png_fixed_point v8; // r0
  png_fixed_point v9; // r2
  png_fixed_point v10; // r6
  png_fixed_point v11; // r3
  png_fixed_point v12; // r1
  png_fixed_point v13; // r1
  png_fixed_point v14; // r2
  int v15; // r1
  bool v16; // zf
  png_uint_16 flags; // r0
  png_xy_0 xy; // [sp+4h] [bp-5Ch] BYREF
  png_byte data[4]; // [sp+24h] [bp-3Ch] BYREF
  unsigned int v20; // [sp+28h] [bp-38h]
  unsigned int v21; // [sp+2Ch] [bp-34h]
  unsigned int v22; // [sp+30h] [bp-30h]
  unsigned int v23; // [sp+34h] [bp-2Ch]
  unsigned int v24; // [sp+38h] [bp-28h]
  unsigned int v25; // [sp+3Ch] [bp-24h]
  unsigned int v26; // [sp+40h] [bp-20h]

  mode = png_ptr->mode;
  if ( (mode & 1) == 0 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"missing IHDR");
    JUMPOUT(0x1FE150);
  }
  if ( (mode & 6) != 0 )
  {
    j_png_crc_finish(png_ptr, length);
    v6 = "out of place";
  }
  else if ( length == 32 )
  {
    j_png_read_data(png_ptr, data, 0x20u);
    j_png_calculate_crc(png_ptr, data, 0x20u);
    if ( j_png_crc_finish(png_ptr, 0) )
      return;
    v7 = bswap32(*(unsigned int *)data);
    v8 = -1;
    v9 = bswap32(v21);
    if ( v7 <= -1 )
      v7 = -1;
    xy.whitex = v7;
    v10 = bswap32(v20);
    if ( v10 <= -1 )
      v10 = -1;
    xy.whitey = v10;
    if ( v9 <= -1 )
      v9 = -1;
    xy.redx = v9;
    v11 = _byteswap_ulong(v22);
    if ( v11 <= -1 )
      v11 = -1;
    xy.redy = v11;
    v12 = _byteswap_ulong(v23);
    if ( v12 <= -1 )
      v12 = -1;
    xy.greenx = v12;
    v13 = _byteswap_ulong(v24);
    if ( v13 <= -1 )
      v13 = -1;
    xy.greeny = v13;
    v14 = _byteswap_ulong(v25);
    if ( v14 <= -1 )
      v14 = -1;
    xy.bluex = v14;
    v15 = _byteswap_ulong(v26);
    if ( v15 > -1 )
      v8 = v15;
    xy.bluey = v8;
    if ( (((unsigned __int8)(v22 | v23 | v24 | v25) | (unsigned __int8)v26) & 0x80) != 0 )
      goto LABEL_33;
    v16 = xy.whitex == -1;
    if ( xy.whitex != -1 )
      v16 = xy.whitey == -1;
    if ( v16 || xy.redx == -1 )
    {
LABEL_33:
      v6 = "invalid values";
    }
    else
    {
      flags = png_ptr->colorspace.flags;
      if ( (flags & 0x8000) != 0 )
        return;
      if ( (flags & 0x10) == 0 )
      {
        png_ptr->colorspace.flags = flags | 0x10;
        j_png_colorspace_set_chromaticities(png_ptr, &png_ptr->colorspace, &xy, 1);
        j_png_colorspace_sync(png_ptr, info_ptr);
        return;
      }
      png_ptr->colorspace.flags = flags | 0x8000;
      j_png_colorspace_sync(png_ptr, info_ptr);
      v6 = "duplicate";
    }
  }
  else
  {
    j_png_crc_finish(png_ptr, length);
    v6 = "invalid";
  }
  j_png_chunk_benign_error(png_ptr, (png_const_charp)v6);
}
// 1FE14C: control flows out of bounds to 1FE150

//----- (001FE178) --------------------------------------------------------
void __fastcall png_handle_sRGB(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  png_uint_32 mode; // r0
  const char *v6; // r1
  int v7; // r0
  bool v8; // zf
  png_byte data[17]; // [sp+7h] [bp-11h] BYREF

  mode = png_ptr->mode;
  if ( (mode & 1) == 0 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"missing IHDR");
    JUMPOUT(0x1FE22C);
  }
  if ( (mode & 6) != 0 )
  {
    j_png_crc_finish(png_ptr, length);
    v6 = "out of place";
LABEL_12:
    j_png_chunk_benign_error(png_ptr, (png_const_charp)v6);
    return;
  }
  if ( length != 1 )
  {
    j_png_crc_finish(png_ptr, length);
    v6 = "invalid";
    goto LABEL_12;
  }
  j_png_read_data(png_ptr, data, 1u);
  j_png_calculate_crc(png_ptr, data, 1u);
  v7 = j_png_crc_finish(png_ptr, 0);
  v8 = v7 == 0;
  if ( !v7 )
  {
    LOWORD(v7) = png_ptr->colorspace.flags;
    v8 = (v7 & 0x8000) == 0;
  }
  if ( v8 )
  {
    if ( (v7 & 4) == 0 )
    {
      j_png_colorspace_set_sRGB(png_ptr, &png_ptr->colorspace, data[0]);
      j_png_colorspace_sync(png_ptr, info_ptr);
      return;
    }
    png_ptr->colorspace.flags = v7 | 0x8000;
    j_png_colorspace_sync(png_ptr, info_ptr);
    v6 = "too many profiles";
    goto LABEL_12;
  }
}
// 1FE228: control flows out of bounds to 1FE22C

//----- (001FE23C) --------------------------------------------------------
void __fastcall png_handle_iCCP(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  png_uint_32 v4; // r6
  png_uint_32 mode; // r0
  const char *v7; // r1
  png_uint_16 flags; // r0
  png_uint_32 v9; // r5
  const png_struct *v10; // r0
  const unsigned __int8 *v11; // r1
  const char *msg; // r8
  unsigned int v13; // r8
  bool v14; // cf
  png_alloc_size_t v15; // r11
  int v16; // r0
  int v17; // r6
  png_uint_32 v18; // r9
  int v19; // r8
  png_bytep v20; // r6
  png_bytep v21; // r1
  png_byte *v22; // r0
  int v23; // r8
  int v24; // r0
  png_uint_32 v25; // r5
  unsigned __int8 *v26; // r0
  png_uint_32 free_me; // r1
  png_uint_32 v28; // r0
  int finish; // [sp+8h] [bp-518h]
  int finisha; // [sp+8h] [bp-518h]
  int finishb; // [sp+8h] [bp-518h]
  png_const_bytep profile; // [sp+Ch] [bp-514h]
  png_byte *profilea; // [sp+Ch] [bp-514h]
  int v34; // [sp+10h] [bp-510h]
  png_bytep v35; // [sp+10h] [bp-510h]
  png_colorspace_0 *colorspace; // [sp+14h] [bp-50Ch]
  png_byte next_out[4]; // [sp+18h] [bp-508h] BYREF
  png_uint_32 skip; // [sp+1Ch] [bp-504h] BYREF
  png_byte read_buffer[1024]; // [sp+20h] [bp-500h] BYREF
  png_uint_32 v40[34]; // [sp+420h] [bp-100h] BYREF
  png_byte data[8]; // [sp+4A8h] [bp-78h] BYREF

  v4 = length;
  mode = png_ptr->mode;
  skip = length;
  if ( (mode & 1) == 0 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"missing IHDR");
    JUMPOUT(0x1FE618);
  }
  if ( (mode & 6) != 0 )
  {
    j_png_crc_finish(png_ptr, length);
    v7 = "out of place";
LABEL_6:
    sub_191A28(png_ptr, (png_const_charp)v7);
    return;
  }
  if ( length <= 0xD )
  {
    j_png_crc_finish(png_ptr, length);
    v7 = "too short";
    goto LABEL_6;
  }
  flags = png_ptr->colorspace.flags;
  if ( (flags & 0x8000) != 0 )
  {
    png_crc_finish(png_ptr, length);
    return;
  }
  if ( (flags & 4) != 0 )
  {
    msg = "too many profiles";
    goto LABEL_15;
  }
  v9 = length;
  if ( length >= 0x51 )
    v9 = 81;
  j_png_read_data(png_ptr, data, v9);
  j_png_calculate_crc(png_ptr, data, v9);
  v4 -= v9;
  skip = v4;
  if ( v4 < 0xB )
  {
    j_png_crc_finish(png_ptr, v4);
    v10 = png_ptr;
    v11 = "too short";
LABEL_18:
    j_png_chunk_benign_error(v10, v11);
    return;
  }
  v13 = 0;
  do
  {
    if ( !data[v13] )
      break;
    v14 = ++v13 >= 0x4F;
    if ( v13 <= 0x4F )
      v14 = v13 >= v9;
  }
  while ( !v14 );
  if ( v13 - 1 > 0x4E )
  {
    msg = "bad keyword";
    goto LABEL_15;
  }
  v15 = v13 + 1;
  if ( v13 + 1 >= v9 || data[v15] )
  {
    msg = "bad compression method";
    goto LABEL_15;
  }
  colorspace = &png_ptr->colorspace;
  if ( png_inflate_claim(png_ptr, 0x69434350u) )
  {
    msg = (const char *)png_ptr->zstream.msg;
    goto LABEL_15;
  }
  memset(v40, 0, 0x84u);
  *(_DWORD *)next_out = 132;
  png_ptr->zstream.next_in = &data[v13 + 2];
  png_ptr->zstream.avail_in = v9 - (v13 + 2);
  png_inflate_read(png_ptr, read_buffer, (uInt)&skip, v40, next_out, 0, finish);
  if ( *(_DWORD *)next_out )
    goto LABEL_34;
  v18 = bswap32(v40[0]);
  if ( !j_png_icc_check_length(png_ptr, colorspace, data, v18)
    || !j_png_icc_check_header(png_ptr, colorspace, data, v18, (png_const_bytep)v40, png_ptr->color_type) )
  {
    v16 = 0;
    v17 = 1;
LABEL_49:
    msg = 0;
    goto LABEL_50;
  }
  v34 = LOBYTE(v40[32]);
  v19 = BYTE1(v40[32]);
  profile = (png_const_bytep)BYTE2(v40[32]);
  finisha = HIBYTE(v40[32]);
  v20 = png_ptr->read_buffer;
  if ( !v20 )
    goto LABEL_41;
  if ( png_ptr->read_buffer_size < v18 )
  {
    v21 = png_ptr->read_buffer;
    png_ptr->read_buffer = 0;
    png_ptr->read_buffer_size = 0;
    j_png_free(png_ptr, v21);
LABEL_41:
    v22 = (png_byte *)j_png_malloc_base(png_ptr, v18);
    if ( !v22 )
    {
      v16 = 0;
      msg = "out of memory";
      goto LABEL_35;
    }
    v20 = v22;
    memset(v22, 0, v18);
    png_ptr->read_buffer = v20;
    png_ptr->read_buffer_size = v18;
  }
  qmemcpy(v20, v40, 0x84u);
  v23 = 12 * ((v19 << 16) | (v34 << 24) | ((_DWORD)profile << 8) | finisha);
  *(_DWORD *)next_out = v23;
  v35 = v20 + 132;
  png_inflate_read(png_ptr, read_buffer, (uInt)&skip, (png_uint_32p)v20 + 33, next_out, 0, finisha);
  if ( *(_DWORD *)next_out )
    goto LABEL_34;
  profilea = v20;
  v24 = j_png_icc_check_tag_table(png_ptr, colorspace, data, v18, v20);
  v17 = 1;
  if ( !v24 )
  {
    v16 = 0;
    goto LABEL_49;
  }
  *(_DWORD *)next_out = v18 - 132 - v23;
  png_inflate_read(
    png_ptr,
    read_buffer,
    (uInt)&skip,
    (png_uint_32p)&v35[v23],
    next_out,
    (png_alloc_size_t *)((char *)&dword_0 + 1),
    finishb);
  v25 = skip;
  if ( skip && (png_ptr->flags & 0x100000) == 0 )
  {
    v16 = 0;
    msg = "extra compressed data";
    goto LABEL_35;
  }
  if ( *(_DWORD *)next_out )
  {
LABEL_34:
    msg = (const char *)png_ptr->zstream.msg;
    v16 = 0;
LABEL_35:
    v17 = 1;
    goto LABEL_50;
  }
  if ( skip )
    j_png_chunk_warning(png_ptr, (png_const_charp)"extra compressed data");
  j_png_crc_finish(png_ptr, v25);
  j_png_icc_set_sRGB(png_ptr, colorspace, profilea, png_ptr->zstream.adler);
  v17 = 0;
  if ( !info_ptr )
    goto LABEL_60;
  j_png_free_data(png_ptr, info_ptr, 0x10u, 0);
  v26 = (unsigned __int8 *)j_png_malloc_base(png_ptr, v15);
  info_ptr->iccp_name = v26;
  if ( v26 )
  {
    qmemcpy(v26, data, v15);
    info_ptr->iccp_profile = profilea;
    info_ptr->iccp_proflen = v18;
    free_me = info_ptr->free_me;
    v28 = info_ptr->valid | 0x1000;
    png_ptr->read_buffer = 0;
    info_ptr->free_me = free_me | 0x10;
    info_ptr->valid = v28;
    j_png_colorspace_sync(png_ptr, info_ptr);
LABEL_60:
    v16 = 1;
    goto LABEL_49;
  }
  png_ptr->colorspace.flags |= 0x8000u;
  j_png_colorspace_sync(png_ptr, info_ptr);
  v17 = 1;
  v16 = 1;
  msg = "out of memory";
LABEL_50:
  png_ptr->zowner = 0;
  if ( v17 )
  {
    if ( v16 )
      goto LABEL_16;
    v4 = skip;
LABEL_15:
    j_png_crc_finish(png_ptr, v4);
LABEL_16:
    png_ptr->colorspace.flags |= 0x8000u;
    j_png_colorspace_sync(png_ptr, info_ptr);
    if ( !msg )
      return;
    v10 = png_ptr;
    v11 = (const unsigned __int8 *)msg;
    goto LABEL_18;
  }
}
// 1FE614: control flows out of bounds to 1FE618
// 1FE412: variable 'finish' is possibly undefined
// 1FE522: variable 'finishb' is possibly undefined
// 0: using guessed type int dword_0;
// 1FE23C: using guessed type png_byte data[8];

//----- (001FE66C) --------------------------------------------------------
int __fastcall png_inflate_claim(png_structrp_6 png_ptr, png_uint_32 owner)
{
  png_uint_32 zowner; // r0
  char flags; // r1
  z_stream *p_zstream; // r0
  int v7; // r6
  unsigned __int8 buffer[64]; // [sp+4h] [bp-54h] BYREF

  zowner = png_ptr->zowner;
  if ( zowner )
  {
    buffer[3] = zowner;
    buffer[1] = BYTE2(zowner);
    buffer[0] = HIBYTE(zowner);
    buffer[2] = BYTE1(zowner);
    j_png_safecat(buffer, 0x40u, 4u, (png_const_charp)" using zstream");
    j_png_chunk_warning(png_ptr, buffer);
    png_ptr->zowner = 0;
  }
  flags = png_ptr->flags;
  png_ptr->zstream.next_out = 0;
  png_ptr->zstream.avail_out = 0;
  png_ptr->zstream.next_in = 0;
  png_ptr->zstream.avail_in = 0;
  p_zstream = &png_ptr->zstream;
  if ( (flags & 2) != 0 )
  {
    v7 = j_inflateReset((z_streamp_1)p_zstream);
    if ( !v7 )
      goto LABEL_8;
  }
  else
  {
    v7 = j_inflateInit_((z_streamp_1)p_zstream, "1.1.3", 56);
    if ( !v7 )
    {
      png_ptr->flags |= 2u;
LABEL_8:
      png_ptr->zowner = owner;
      return 0;
    }
  }
  j_png_zstream_error(png_ptr, v7);
  return v7;
}

//----- (001FE740) --------------------------------------------------------
void __fastcall png_inflate_read(
        png_structrp_6 png_ptr,
        png_bytep read_buffer,
        uInt read_size,
        png_uint_32p chunk_bytes,
        png_bytep next_out,
        png_alloc_size_t *out_size,
        int finish)
{
  int v10; // r11
  png_size_t v11; // r6
  uInt v12; // r0
  int v13; // r1
  int v14; // r1
  bool v15; // zf
  uInt v16; // r0
  uInt avail_out; // r2

  if ( png_ptr->zowner == png_ptr->chunk_name )
  {
    v10 = 2;
    png_ptr->zstream.next_out = (Bytef *)chunk_bytes;
    png_ptr->zstream.avail_out = 0;
    if ( out_size )
      v10 = 4;
    v11 = 1024;
    while ( 1 )
    {
      if ( !png_ptr->zstream.avail_in )
      {
        if ( v11 > *(_DWORD *)read_size )
          v11 = *(_DWORD *)read_size;
        *(_DWORD *)read_size -= v11;
        if ( v11 )
        {
          j_png_read_data(png_ptr, read_buffer, v11);
          j_png_calculate_crc(png_ptr, read_buffer, v11);
        }
        png_ptr->zstream.next_in = read_buffer;
        png_ptr->zstream.avail_in = v11;
      }
      if ( !png_ptr->zstream.avail_out )
      {
        v12 = *(_DWORD *)next_out;
        *(_DWORD *)next_out = 0;
        png_ptr->zstream.avail_out = v12;
      }
      v13 = 0;
      if ( !*(_DWORD *)read_size )
        v13 = v10;
      v14 = j_inflate((z_streamp_1)&png_ptr->zstream, v13);
      if ( v14 )
        break;
      v15 = *(_DWORD *)next_out == 0;
      if ( !*(_DWORD *)next_out )
        v15 = png_ptr->zstream.avail_out == 0;
      if ( v15 )
      {
        v16 = 0;
        avail_out = 0;
        v14 = 0;
        goto LABEL_23;
      }
    }
    v16 = *(_DWORD *)next_out;
    avail_out = png_ptr->zstream.avail_out;
LABEL_23:
    *(_DWORD *)next_out = v16 + avail_out;
    png_ptr->zstream.avail_out = 0;
    sub_1A0304(png_ptr, v14);
  }
  else
  {
    png_ptr->zstream.msg = "zstream unclaimed";
  }
}

//----- (001FE824) --------------------------------------------------------
void __fastcall png_handle_sPLT(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  png_uint_32 user_chunk_cache_max; // r0
  png_uint_32 v7; // r0
  png_uint_32 mode; // r0
  png_byte *read_buffer; // r10
  png_alloc_size_t v10; // r6
  png_bytep v11; // r1
  png_byte *v12; // r0
  png_byte *v13; // r6
  const char *v15; // r1
  const char *v16; // r1
  unsigned __int8 *v17; // r6
  png_byte depth; // r11
  int v19; // t1
  unsigned int v20; // r9
  png_uint_32 v21; // r5
  png_sPLT_entry *v22; // r0
  int v23; // r1
  png_int_32 v24; // r12
  png_sPLT_entry *v25; // r5
  unsigned __int16 *v26; // r3
  unsigned __int16 v27; // r5
  png_sPLT_entry *v28; // r2
  png_sPLT_entry *v29; // r0
  png_sPLT_t entries; // [sp+4h] [bp-2Ch] BYREF

  user_chunk_cache_max = png_ptr->user_chunk_cache_max;
  if ( user_chunk_cache_max )
  {
    if ( user_chunk_cache_max == 1 )
    {
LABEL_5:
      j_png_crc_finish(png_ptr, length);
      return;
    }
    v7 = user_chunk_cache_max - 1;
    png_ptr->user_chunk_cache_max = v7;
    if ( v7 == 1 )
    {
      j_png_warning(png_ptr, (png_const_charp)"No space in chunk cache for sPLT");
      goto LABEL_5;
    }
  }
  mode = png_ptr->mode;
  if ( (mode & 1) == 0 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"missing IHDR");
    JUMPOUT(0x1FEA0C);
  }
  if ( (mode & 4) != 0 )
  {
    j_png_crc_finish(png_ptr, length);
    v16 = "out of place";
LABEL_22:
    j_png_chunk_benign_error(png_ptr, (png_const_charp)v16);
    return;
  }
  read_buffer = png_ptr->read_buffer;
  v10 = length + 1;
  if ( read_buffer )
  {
    if ( png_ptr->read_buffer_size >= v10 )
      goto LABEL_13;
    v11 = png_ptr->read_buffer;
    png_ptr->read_buffer = 0;
    png_ptr->read_buffer_size = 0;
    j_png_free(png_ptr, v11);
  }
  v12 = (png_byte *)j_png_malloc_base(png_ptr, length + 1);
  read_buffer = v12;
  if ( !v12 )
  {
    j_png_crc_finish(png_ptr, length);
    v16 = "out of memory";
    goto LABEL_22;
  }
  memset(v12, 0, length + 1);
  png_ptr->read_buffer = read_buffer;
  png_ptr->read_buffer_size = v10;
LABEL_13:
  j_png_read_data(png_ptr, read_buffer, length);
  j_png_calculate_crc(png_ptr, read_buffer, length);
  if ( !j_png_crc_finish(png_ptr, 0) )
  {
    read_buffer[length] = 0;
    v13 = read_buffer;
    while ( *v13++ )
      ;
    if ( length < 2 || v13 > &read_buffer[length - 2] )
    {
      v15 = "malformed sPLT chunk";
LABEL_19:
      j_png_warning(png_ptr, (png_const_charp)v15);
      return;
    }
    v19 = *v13;
    v17 = v13 + 1;
    depth = v19;
    v20 = 10;
    entries.depth = v19;
    v21 = length + read_buffer - v17;
    if ( v19 == 8 )
      v20 = 6;
    if ( v21 % v20 )
    {
      v15 = "sPLT chunk has bad length";
      goto LABEL_19;
    }
    if ( v21 / v20 >= 0x1999999A )
    {
      v15 = "sPLT chunk too long";
      goto LABEL_19;
    }
    entries.nentries = v21 / v20;
    v22 = (png_sPLT_entry *)j_png_malloc_warn(png_ptr, 10 * (v21 / v20));
    entries.entries = v22;
    if ( !v22 )
    {
      v15 = "sPLT chunk requires too much memory";
      goto LABEL_19;
    }
    if ( v20 <= v21 )
    {
      v23 = 0;
      v24 = 1;
      while ( 1 )
      {
        if ( depth == 8 )
        {
          v25 = &v22[v23];
          v22[v23].red = *v17;
          v25->green = v17[1];
          v25->blue = v17[2];
          v26 = (unsigned __int16 *)(v17 + 4);
          v27 = v17[3];
        }
        else
        {
          v28 = &v22[v23];
          v22[v23].red = _byteswap_ushort(*(_WORD *)v17);
          v28->green = _byteswap_ushort(*((_WORD *)v17 + 1));
          v28->blue = _byteswap_ushort(*((_WORD *)v17 + 2));
          v26 = (unsigned __int16 *)(v17 + 8);
          v27 = _byteswap_ushort(*((_WORD *)v17 + 3));
        }
        v29 = &v22[v23];
        v29->alpha = v27;
        v29->frequency = _byteswap_ushort(*v26);
        if ( v24 >= entries.nentries )
          break;
        depth = entries.depth;
        ++v24;
        v22 = entries.entries;
        ++v23;
        v17 = (unsigned __int8 *)(v26 + 1);
      }
    }
    entries.name = read_buffer;
    j_png_set_sPLT(png_ptr, info_ptr, &entries, 1);
    j_png_free(png_ptr, entries.entries);
  }
}
// 1FEA0A: control flows out of bounds to 1FEA0C

//----- (001FEAA8) --------------------------------------------------------
void __fastcall png_handle_tRNS(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  png_uint_32 mode; // r0
  int color_type; // r1
  __int16 v8; // r1
  const char *v9; // r1
  __int16 v10; // r1
  bool v11; // cf
  png_byte data; // [sp+4h] [bp-114h] BYREF
  unsigned __int8 v13; // [sp+5h] [bp-113h]
  unsigned __int16 v14; // [sp+6h] [bp-112h]
  unsigned __int16 v15; // [sp+8h] [bp-110h]

  mode = png_ptr->mode;
  if ( (mode & 1) == 0 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"missing IHDR");
    JUMPOUT(0x1FEC54);
  }
  if ( (mode & 4) != 0 )
    goto LABEL_13;
  if ( info_ptr && (info_ptr->valid & 0x10) != 0 )
  {
    j_png_crc_finish(png_ptr, length);
    v9 = "duplicate";
    goto LABEL_23;
  }
  color_type = png_ptr->color_type;
  if ( color_type != 3 )
  {
    if ( color_type != 2 )
    {
      if ( !png_ptr->color_type )
      {
        if ( length == 2 )
        {
          j_png_read_data(png_ptr, &data, 2u);
          j_png_calculate_crc(png_ptr, &data, 2u);
          v8 = v13;
          png_ptr->num_trans = 1;
          png_ptr->trans_color.gray = v8 | (data << 8);
          goto LABEL_24;
        }
        goto LABEL_22;
      }
      j_png_crc_finish(png_ptr, length);
      v9 = "invalid with alpha channel";
LABEL_23:
      j_png_chunk_benign_error(png_ptr, (png_const_charp)v9);
      return;
    }
    if ( length == 6 )
    {
      j_png_read_data(png_ptr, &data, 6u);
      j_png_calculate_crc(png_ptr, &data, 6u);
      v10 = v13;
      png_ptr->num_trans = 1;
      png_ptr->trans_color.red = v10 | (data << 8);
      png_ptr->trans_color.green = _byteswap_ushort(v14);
      png_ptr->trans_color.blue = _byteswap_ushort(v15);
      goto LABEL_24;
    }
LABEL_22:
    j_png_crc_finish(png_ptr, length);
    v9 = "invalid";
    goto LABEL_23;
  }
  if ( (mode & 2) == 0 )
  {
LABEL_13:
    j_png_crc_finish(png_ptr, length);
    v9 = "out of place";
    goto LABEL_23;
  }
  v11 = length >= 0x100;
  if ( length <= 0x100 )
    v11 = length - 1 >= png_ptr->num_palette;
  if ( v11 )
    goto LABEL_22;
  j_png_read_data(png_ptr, &data, length);
  j_png_calculate_crc(png_ptr, &data, length);
  png_ptr->num_trans = length;
LABEL_24:
  if ( j_png_crc_finish(png_ptr, 0) )
    png_ptr->num_trans = 0;
  else
    j_png_set_tRNS(png_ptr, info_ptr, &data, png_ptr->num_trans, (__int64 *)&png_ptr->trans_color);
}
// 1FEC50: control flows out of bounds to 1FEC54

//----- (001FEC94) --------------------------------------------------------
void __fastcall png_handle_bKGD(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  png_uint_32 mode; // r1
  int color_type; // r0
  const char *v8; // r1
  unsigned int num_palette; // r1
  bool v10; // zf
  png_colorp palette; // r1
  int v12; // r0
  png_uint_16 red; // r2
  png_color *v14; // r0
  png_uint_16 v15; // r2
  png_color_16 v16; // [sp+0h] [bp-20h] BYREF
  unsigned __int16 data[4]; // [sp+Ah] [bp-16h] BYREF

  mode = png_ptr->mode;
  if ( (mode & 1) == 0 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"missing IHDR");
    JUMPOUT(0x1FEDF4);
  }
  if ( (mode & 4) != 0 || (color_type = png_ptr->color_type, (mode & 2) == 0) && color_type == 3 )
  {
    j_png_crc_finish(png_ptr, length);
    v8 = "out of place";
LABEL_6:
    j_png_chunk_benign_error(png_ptr, (png_const_charp)v8);
    return;
  }
  if ( info_ptr && (info_ptr->valid & 0x20) != 0 )
  {
    j_png_crc_finish(png_ptr, length);
    v8 = "duplicate";
    goto LABEL_6;
  }
  if ( color_type == 3 )
  {
    if ( length != 1 )
    {
LABEL_12:
      j_png_crc_finish(png_ptr, length);
      v8 = "invalid";
      goto LABEL_6;
    }
  }
  else if ( ((2 * color_type) & 4 | 2) != length )
  {
    goto LABEL_12;
  }
  j_png_read_data(png_ptr, (png_bytep)data, length);
  j_png_calculate_crc(png_ptr, (png_const_bytep)data, length);
  if ( !j_png_crc_finish(png_ptr, 0) )
  {
    num_palette = png_ptr->color_type;
    if ( num_palette == 3 )
    {
      v10 = info_ptr == 0;
      v16.index = data[0];
      if ( info_ptr )
      {
        num_palette = info_ptr->num_palette;
        v10 = num_palette == 0;
      }
      if ( v10 )
      {
        v16.blue = 0;
        *(_DWORD *)&v16.red = 0;
      }
      else
      {
        if ( LOBYTE(data[0]) >= num_palette )
        {
          v8 = "invalid index";
          goto LABEL_6;
        }
        palette = png_ptr->palette;
        v12 = LOBYTE(data[0]);
        red = palette[v12].red;
        v14 = &palette[v12];
        v16.red = red;
        v16.green = v14->green;
        v16.blue = v14->blue;
      }
      v16.gray = 0;
    }
    else
    {
      v16.index = 0;
      v15 = _byteswap_ushort(data[0]);
      if ( (num_palette & 2) != 0 )
      {
        v16.red = v15;
        v16.green = _byteswap_ushort(data[1]);
        v16.gray = 0;
        v16.blue = _byteswap_ushort(data[2]);
      }
      else
      {
        v16.blue = v15;
        v16.gray = v15;
        v16.green = v15;
        v16.red = v15;
      }
    }
    j_png_set_bKGD(png_ptr, info_ptr, &v16);
  }
}
// 1FEDF2: control flows out of bounds to 1FEDF4

//----- (001FEE14) --------------------------------------------------------
void __fastcall png_handle_eXIf(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  const char *v6; // r1
  png_byte *v7; // r0
  png_uint_32 v8; // r5
  png_byte data[8]; // [sp+7h] [bp-19h] BYREF

  if ( !(LOBYTE(png_ptr->mode) << 31) )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"missing IHDR");
    JUMPOUT(0x1FEF34);
  }
  if ( length <= 1 )
  {
    j_png_crc_finish(png_ptr, length);
    v6 = "too short";
LABEL_15:
    sub_191A28(png_ptr, (png_const_charp)v6);
    return;
  }
  if ( !info_ptr || BYTE2(info_ptr->valid) << 31 )
  {
    j_png_crc_finish(png_ptr, length);
    v6 = "duplicate";
    goto LABEL_15;
  }
  info_ptr->free_me |= 0x8000u;
  v7 = (png_byte *)j_png_malloc_warn(png_ptr, length);
  info_ptr->eXIf_buf = v7;
  if ( !v7 )
  {
    j_png_crc_finish(png_ptr, length);
    v6 = "out of memory";
    goto LABEL_15;
  }
  v8 = 0;
  do
  {
    j_png_read_data(png_ptr, data, 1u);
    j_png_calculate_crc(png_ptr, data, 1u);
    info_ptr->eXIf_buf[v8] = data[0];
    if ( v8 == 1 && (data[0] | 4) != 77 && *info_ptr->eXIf_buf != data[0] )
    {
      j_png_crc_finish(png_ptr, length);
      j_png_chunk_benign_error(png_ptr, (png_const_charp)"incorrect byte-order specifier");
      j_png_free(png_ptr, info_ptr->eXIf_buf);
      info_ptr->eXIf_buf = 0;
      return;
    }
    ++v8;
  }
  while ( v8 < length );
  if ( !j_png_crc_finish(png_ptr, 0) )
  {
    j_png_set_eXIf_1(png_ptr, info_ptr, length, info_ptr->eXIf_buf);
    j_png_free(png_ptr, info_ptr->eXIf_buf);
    info_ptr->eXIf_buf = 0;
  }
}
// 1FEF32: control flows out of bounds to 1FEF34

//----- (001FEF64) --------------------------------------------------------
void __fastcall png_handle_hIST(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  png_uint_32 mode; // r0
  png_uint_32 v6; // r5
  png_uint_16 *v7; // r6
  const char *v8; // r1
  unsigned __int16 data; // [sp+6h] [bp-21Ah] BYREF
  png_uint_16 hist[268]; // [sp+8h] [bp-218h] BYREF

  mode = png_ptr->mode;
  if ( (mode & 1) == 0 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"missing IHDR");
    JUMPOUT(0x1FF030);
  }
  if ( (mode & 6) != 2 )
  {
    j_png_crc_finish(png_ptr, length);
    v8 = "out of place";
LABEL_15:
    j_png_chunk_benign_error(png_ptr, (png_const_charp)v8);
    return;
  }
  if ( info_ptr && (info_ptr->valid & 0x40) != 0 )
  {
    j_png_crc_finish(png_ptr, length);
    v8 = "duplicate";
    goto LABEL_15;
  }
  if ( length > 0x201 || (v6 = length >> 1, length >> 1 != png_ptr->num_palette) )
  {
    j_png_crc_finish(png_ptr, length);
    v8 = "invalid";
    goto LABEL_15;
  }
  if ( v6 )
  {
    v7 = hist;
    do
    {
      j_png_read_data(png_ptr, (png_bytep)&data, 2u);
      j_png_calculate_crc(png_ptr, (png_const_bytep)&data, 2u);
      --v6;
      *v7++ = _byteswap_ushort(data);
    }
    while ( v6 );
  }
  if ( !j_png_crc_finish(png_ptr, 0) )
    j_png_set_hIST(png_ptr, info_ptr, hist);
}
// 1FF02E: control flows out of bounds to 1FF030

//----- (001FF040) --------------------------------------------------------
void __fastcall png_handle_pHYs(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  png_uint_32 mode; // r0
  const char *v6; // r1
  png_byte data[4]; // [sp+Bh] [bp-1Dh] BYREF
  unsigned int v8; // [sp+Fh] [bp-19h]
  png_byte buf[9]; // [sp+13h] [bp-15h]

  mode = png_ptr->mode;
  if ( (mode & 1) == 0 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"missing IHDR");
    JUMPOUT(0x1FF104);
  }
  if ( (mode & 4) != 0 )
  {
    j_png_crc_finish(png_ptr, length);
    v6 = "out of place";
LABEL_11:
    j_png_chunk_benign_error(png_ptr, (png_const_charp)v6);
    return;
  }
  if ( info_ptr && (info_ptr->valid & 0x80) != 0 )
  {
    j_png_crc_finish(png_ptr, length);
    v6 = "duplicate";
    goto LABEL_11;
  }
  if ( length != 9 )
  {
    j_png_crc_finish(png_ptr, length);
    v6 = "invalid";
    goto LABEL_11;
  }
  j_png_read_data(png_ptr, data, 9u);
  j_png_calculate_crc(png_ptr, data, 9u);
  if ( !j_png_crc_finish(png_ptr, 0) )
    j_png_set_pHYs(png_ptr, info_ptr, _byteswap_uint64(__PAIR64__(*(unsigned int *)data, v8)), buf[0]);
}
// 1FF102: control flows out of bounds to 1FF104

//----- (001FF11C) --------------------------------------------------------
void __fastcall png_handle_oFFs(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  png_uint_32 mode; // r0
  bool v6; // zf
  __int64 v7; // r2
  const char *v8; // r1
  unsigned int data; // [sp+Bh] [bp-1Dh] BYREF
  unsigned int v10; // [sp+Fh] [bp-19h]
  png_byte buf[9]; // [sp+13h] [bp-15h]

  mode = png_ptr->mode;
  if ( (mode & 1) == 0 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"missing IHDR");
    JUMPOUT(0x1FF230);
  }
  if ( (mode & 4) != 0 )
  {
    j_png_crc_finish(png_ptr, length);
    v8 = "out of place";
    goto LABEL_16;
  }
  v6 = info_ptr == 0;
  if ( info_ptr )
    v6 = BYTE1(info_ptr->valid) << 31 == 0;
  if ( !v6 )
  {
    j_png_crc_finish(png_ptr, length);
    v8 = "duplicate";
LABEL_16:
    j_png_chunk_benign_error(png_ptr, (png_const_charp)v8);
    return;
  }
  if ( length != 9 )
  {
    j_png_crc_finish(png_ptr, length);
    v8 = "invalid";
    goto LABEL_16;
  }
  j_png_read_data(png_ptr, (png_bytep)&data, 9u);
  j_png_calculate_crc(png_ptr, (png_const_bytep)&data, 9u);
  if ( !j_png_crc_finish(png_ptr, 0) )
  {
    LODWORD(v7) = _byteswap_ulong(data);
    if ( (data & 0x80) != 0 )
      LODWORD(v7) = -(-(int)v7 & 0x7FFFFFFF);
    HIDWORD(v7) = _byteswap_ulong(v10);
    if ( (v10 & 0x80) != 0 )
      HIDWORD(v7) = -(-HIDWORD(v7) & 0x7FFFFFFF);
    j_png_set_oFFs(png_ptr, info_ptr, v7, buf[0]);
  }
}
// 1FF22C: control flows out of bounds to 1FF230

//----- (001FF248) --------------------------------------------------------
void __fastcall png_handle_pCAL(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  png_uint_32 mode; // r0
  png_byte *read_buffer; // r6
  png_alloc_size_t v8; // r4
  png_bytep v9; // r1
  png_byte *v10; // r0
  int v11; // r4
  png_byte *v12; // r8
  png_byte *v14; // r0
  const char *v15; // r1
  int v16; // r4
  int v17; // r2
  unsigned int v18; // r11
  int v19; // r3
  const unsigned __int8 *v20; // r5
  int v21; // r4
  int v23; // r4
  _DWORD *v24; // r12
  unsigned __int8 *v25; // r0
  int v26; // r1
  void *v27; // r4
  int nparams; // [sp+8h] [bp-38h]
  const unsigned __int8 *units; // [sp+18h] [bp-28h]
  png_int_32 X1; // [sp+1Ch] [bp-24h]
  png_int_32 v31; // [sp+20h] [bp-20h]

  mode = png_ptr->mode;
  if ( (mode & 1) == 0 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"missing IHDR");
    JUMPOUT(0x1FF448);
  }
  if ( (mode & 4) != 0 )
  {
    j_png_crc_finish(png_ptr, length);
    v15 = "out of place";
    goto LABEL_29;
  }
  if ( info_ptr && (info_ptr->valid & 0x400) != 0 )
  {
    j_png_crc_finish(png_ptr, length);
    v15 = "duplicate";
    goto LABEL_29;
  }
  read_buffer = png_ptr->read_buffer;
  v8 = length + 1;
  if ( read_buffer )
  {
    if ( png_ptr->read_buffer_size >= v8 )
      goto LABEL_10;
    v9 = png_ptr->read_buffer;
    png_ptr->read_buffer = 0;
    png_ptr->read_buffer_size = 0;
    j_png_free(png_ptr, v9);
  }
  v10 = (png_byte *)j_png_malloc_base(png_ptr, length + 1);
  read_buffer = v10;
  if ( !v10 )
  {
    j_png_crc_finish(png_ptr, length);
    v15 = "out of memory";
    goto LABEL_29;
  }
  memset(v10, 0, length + 1);
  png_ptr->read_buffer = read_buffer;
  png_ptr->read_buffer_size = v8;
LABEL_10:
  j_png_read_data(png_ptr, read_buffer, length);
  j_png_calculate_crc(png_ptr, read_buffer, length);
  v11 = 0;
  if ( j_png_crc_finish(png_ptr, 0) )
    return;
  v12 = &read_buffer[length];
  read_buffer[length] = 0;
  while ( read_buffer[v11++] )
    ;
  v14 = &read_buffer[v11];
  if ( (int)(length - (v11 - 1)) <= 12 )
  {
    v15 = "invalid";
LABEL_29:
    sub_191A28(png_ptr, (png_const_charp)v15);
    return;
  }
  v16 = _byteswap_ulong(*(_DWORD *)v14);
  if ( (*v14 & 0x80) != 0 )
    v16 = -(-v16 & 0x7FFFFFFF);
  v17 = _byteswap_ulong(*((_DWORD *)v14 + 1));
  if ( (v14[4] & 0x80) != 0 )
    v17 = -(-v17 & 0x7FFFFFFF);
  v18 = v14[8];
  v19 = v14[9];
  if ( !v14[8] && v19 != 2 || (unsigned __int8)(v18 - 1) <= 1u && v19 != 3 || v18 == 3 && v19 != 4 )
  {
    v15 = "invalid parameter count";
    goto LABEL_29;
  }
  v20 = v14 + 10;
  X1 = v17;
  v31 = v16;
  if ( v18 >= 4 )
  {
    v21 = v14[9];
    j_png_chunk_benign_error(png_ptr, (png_const_charp)"unrecognized equation type");
    v19 = v21;
  }
  units = v20;
  while ( *v20++ )
    ;
  v23 = v19;
  v24 = j_png_malloc_warn(png_ptr, 4 * v19);
  if ( !v24 )
  {
    v15 = "out of memory";
    goto LABEL_29;
  }
  if ( v23 )
  {
    v25 = (unsigned __int8 *)(v20 - 1);
    v26 = 0;
    while ( 1 )
    {
      v24[v26] = ++v25;
      if ( v25 > v12 )
        break;
      while ( *v25 )
      {
        if ( ++v25 > v12 )
          goto LABEL_43;
      }
      if ( ++v26 >= v23 )
        goto LABEL_42;
    }
LABEL_43:
    j_png_free(png_ptr, v24);
    v15 = "invalid data";
    goto LABEL_29;
  }
LABEL_42:
  nparams = v23;
  v27 = v24;
  j_png_set_pCAL(png_ptr, info_ptr, read_buffer, v31, X1, v18, nparams, units, (png_charpp)v24);
  sub_19CD58(png_ptr, v27);
}
// 1FF444: control flows out of bounds to 1FF448

//----- (001FF4A4) --------------------------------------------------------
void __fastcall png_handle_sCAL(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  png_uint_32 mode; // r0
  const char *v7; // r1
  __int64 v8; // r8
  png_bytep read_buffer; // r1
  png_voidp v10; // r0
  png_size_t v11; // r0
  int statep; // [sp+8h] [bp-20h] BYREF
  png_size_t whereami[7]; // [sp+Ch] [bp-1Ch] BYREF

  mode = png_ptr->mode;
  if ( (mode & 1) == 0 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"missing IHDR");
    JUMPOUT(0x1FF618);
  }
  if ( (mode & 4) != 0 )
  {
    j_png_crc_finish(png_ptr, length);
    v7 = "out of place";
    goto LABEL_20;
  }
  if ( info_ptr && (info_ptr->valid & 0x4000) != 0 )
  {
    j_png_crc_finish(png_ptr, length);
    v7 = "duplicate";
    goto LABEL_20;
  }
  if ( length <= 3 )
  {
    j_png_crc_finish(png_ptr, length);
    v7 = "invalid";
    goto LABEL_20;
  }
  LODWORD(v8) = png_ptr->read_buffer;
  HIDWORD(v8) = length + 1;
  if ( !(_DWORD)v8 )
    goto LABEL_11;
  if ( png_ptr->read_buffer_size < HIDWORD(v8) )
  {
    read_buffer = png_ptr->read_buffer;
    png_ptr->read_buffer = 0;
    png_ptr->read_buffer_size = 0;
    j_png_free(png_ptr, read_buffer);
LABEL_11:
    v10 = j_png_malloc_base(png_ptr, length + 1);
    LODWORD(v8) = v10;
    if ( !v10 )
    {
      j_png_chunk_benign_error(png_ptr, (png_const_charp)"out of memory");
      j_png_crc_finish(png_ptr, length);
      return;
    }
    memset(v10, 0, length + 1);
    *(_QWORD *)&png_ptr->read_buffer = v8;
  }
  j_png_read_data(png_ptr, (png_bytep)v8, length);
  j_png_calculate_crc(png_ptr, (png_const_bytep)v8, length);
  *(_BYTE *)(v8 + length) = 0;
  if ( j_png_crc_finish(png_ptr, 0) )
    return;
  if ( (unsigned __int8)(*(_BYTE *)v8 - 1) >= 2u )
  {
    v7 = "invalid unit";
  }
  else
  {
    whereami[0] = 1;
    statep = 0;
    if ( j_png_check_fp_number((png_const_charp)v8, length, &statep, whereami)
      && (v11 = whereami[0], whereami[0] < length)
      && (HIDWORD(v8) = whereami[0] + 1, ++whereami[0], !*(_BYTE *)(v8 + v11)) )
    {
      if ( (statep & 0x188) == 264 )
      {
        statep = 0;
        if ( j_png_check_fp_number((png_const_charp)v8, length, &statep, whereami) && whereami[0] == length )
        {
          if ( (statep & 0x188) == 264 )
          {
            j_png_set_sCAL_s(
              png_ptr,
              info_ptr,
              *(unsigned __int8 *)v8,
              (png_const_charp)(v8 + 1),
              (const char *)(v8 + HIDWORD(v8)));
            return;
          }
          v7 = "non-positive height";
        }
        else
        {
          v7 = "bad height format";
        }
      }
      else
      {
        v7 = "non-positive width";
      }
    }
    else
    {
      v7 = "bad width format";
    }
  }
LABEL_20:
  j_png_chunk_benign_error(png_ptr, (png_const_charp)v7);
}
// 1FF614: control flows out of bounds to 1FF618

//----- (001FF68C) --------------------------------------------------------
void __fastcall png_handle_tIME(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  png_uint_32 mode; // r0
  const char *v6; // r1
  png_time v7; // [sp+0h] [bp-20h] BYREF
  unsigned __int16 data; // [sp+9h] [bp-17h] BYREF
  png_byte v9; // [sp+Bh] [bp-15h]
  __int16 v10; // [sp+Ch] [bp-14h]
  png_byte v11; // [sp+Eh] [bp-12h]
  png_byte v12; // [sp+Fh] [bp-11h]

  mode = png_ptr->mode;
  if ( (mode & 1) == 0 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"missing IHDR");
    JUMPOUT(0x1FF754);
  }
  if ( info_ptr && (info_ptr->valid & 0x200) != 0 )
  {
    j_png_crc_finish(png_ptr, length);
    v6 = "duplicate";
    goto LABEL_11;
  }
  if ( (mode & 4) != 0 )
    png_ptr->mode = mode | 8;
  if ( length != 7 )
  {
    j_png_crc_finish(png_ptr, length);
    v6 = "invalid";
LABEL_11:
    j_png_chunk_benign_error(png_ptr, (png_const_charp)v6);
    return;
  }
  j_png_read_data(png_ptr, (png_bytep)&data, 7u);
  j_png_calculate_crc(png_ptr, (png_const_bytep)&data, 7u);
  if ( !j_png_crc_finish(png_ptr, 0) )
  {
    v7.second = v12;
    v7.minute = v11;
    *(_WORD *)&v7.day = v10;
    v7.month = v9;
    v7.year = _byteswap_ushort(data);
    j_png_set_tIME(png_ptr, info_ptr, &v7);
  }
}
// 1FF750: control flows out of bounds to 1FF754

//----- (001FF760) --------------------------------------------------------
void __fastcall png_handle_tEXt(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  png_uint_32 user_chunk_cache_max; // r0
  png_uint_32 v7; // r0
  const char *v8; // r1
  png_uint_32 mode; // r0
  png_alloc_size_t v10; // r9
  png_byte *read_buffer; // r5
  png_bytep v12; // r1
  png_byte *v13; // r0
  int v14; // r6
  unsigned __int8 *v16; // r0
  png_text text_ptr; // [sp+4h] [bp-34h] BYREF

  user_chunk_cache_max = png_ptr->user_chunk_cache_max;
  if ( user_chunk_cache_max )
  {
    if ( user_chunk_cache_max == 1 )
    {
      j_png_crc_finish(png_ptr, length);
      return;
    }
    v7 = user_chunk_cache_max - 1;
    png_ptr->user_chunk_cache_max = v7;
    if ( v7 == 1 )
    {
      j_png_crc_finish(png_ptr, length);
      v8 = "no space in chunk cache";
LABEL_23:
      j_png_chunk_benign_error(png_ptr, (png_const_charp)v8);
      return;
    }
  }
  mode = png_ptr->mode;
  if ( (mode & 1) == 0 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"missing IHDR");
    JUMPOUT(0x1FF878);
  }
  v10 = length + 1;
  if ( (mode & 4) != 0 )
    png_ptr->mode = mode | 8;
  read_buffer = png_ptr->read_buffer;
  if ( read_buffer )
  {
    if ( png_ptr->read_buffer_size >= v10 )
      goto LABEL_14;
    v12 = png_ptr->read_buffer;
    png_ptr->read_buffer = 0;
    png_ptr->read_buffer_size = 0;
    j_png_free(png_ptr, v12);
  }
  v13 = (png_byte *)j_png_malloc_base(png_ptr, length + 1);
  read_buffer = v13;
  if ( !v13 )
  {
    j_png_chunk_warning(png_ptr, (png_const_charp)"insufficient memory to read chunk");
    v8 = "out of memory";
    goto LABEL_23;
  }
  memset(v13, 0, length + 1);
  png_ptr->read_buffer = read_buffer;
  png_ptr->read_buffer_size = v10;
LABEL_14:
  j_png_read_data(png_ptr, read_buffer, length);
  j_png_calculate_crc(png_ptr, read_buffer, length);
  v14 = 0;
  if ( !j_png_crc_finish(png_ptr, 0) )
  {
    read_buffer[length] = 0;
    while ( read_buffer[v14++] )
      ;
    text_ptr.key = read_buffer;
    text_ptr.compression = -1;
    memset(&text_ptr.itxt_length, 0, 12);
    v16 = &read_buffer[v14];
    if ( v10 == v14 )
      --v16;
    text_ptr.text = v16;
    text_ptr.text_length = strlen((const char *)v16);
    if ( j_png_set_text_2(png_ptr, info_ptr, &text_ptr, 1) )
      j_png_warning(png_ptr, (png_const_charp)"Insufficient memory to process text chunk");
  }
}
// 1FF874: control flows out of bounds to 1FF878

//----- (001FF8B4) --------------------------------------------------------
void __fastcall png_handle_zTXt(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  png_uint_32 user_chunk_cache_max; // r0
  png_uint_32 v7; // r0
  const char *v8; // r1
  png_uint_32 mode; // r0
  png_byte *read_buffer; // r5
  png_bytep v11; // r1
  png_byte *v12; // r0
  png_uint_32 v13; // r4
  const char *msg; // r1
  unsigned __int8 *v15; // r0
  png_alloc_size_t v16; // r1
  int v17; // r0
  png_text v18; // [sp+0h] [bp-38h] BYREF
  png_alloc_size_t newlength[7]; // [sp+1Ch] [bp-1Ch] BYREF

  user_chunk_cache_max = png_ptr->user_chunk_cache_max;
  if ( user_chunk_cache_max )
  {
    if ( user_chunk_cache_max == 1 )
    {
      png_crc_finish(png_ptr, length);
      return;
    }
    v7 = user_chunk_cache_max - 1;
    png_ptr->user_chunk_cache_max = v7;
    if ( v7 == 1 )
    {
      j_png_crc_finish(png_ptr, length);
      v8 = "no space in chunk cache";
LABEL_22:
      sub_191A28(png_ptr, (png_const_charp)v8);
      return;
    }
  }
  mode = png_ptr->mode;
  if ( (mode & 1) == 0 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"missing IHDR");
    JUMPOUT(0x1FFA2C);
  }
  if ( (mode & 4) != 0 )
    png_ptr->mode = mode | 8;
  read_buffer = png_ptr->read_buffer;
  if ( read_buffer )
  {
    if ( png_ptr->read_buffer_size >= length )
      goto LABEL_14;
    v11 = png_ptr->read_buffer;
    png_ptr->read_buffer = 0;
    png_ptr->read_buffer_size = 0;
    j_png_free(png_ptr, v11);
  }
  v12 = (png_byte *)j_png_malloc_base(png_ptr, length);
  read_buffer = v12;
  if ( !v12 )
  {
    j_png_crc_finish(png_ptr, length);
    v8 = "out of memory";
    goto LABEL_22;
  }
  memset(v12, 0, length);
  png_ptr->read_buffer = read_buffer;
  png_ptr->read_buffer_size = length;
LABEL_14:
  j_png_read_data(png_ptr, read_buffer, length);
  j_png_calculate_crc(png_ptr, read_buffer, length);
  if ( j_png_crc_finish(png_ptr, 0) )
    return;
  if ( !length )
  {
    msg = "bad keyword";
    goto LABEL_37;
  }
  v13 = 0;
  do
  {
    if ( !read_buffer[v13] )
      break;
    ++v13;
  }
  while ( v13 < length );
  if ( v13 - 1 > 0x4E )
  {
    msg = "bad keyword";
    goto LABEL_37;
  }
  if ( v13 + 3 > length )
  {
    msg = "truncated";
    goto LABEL_37;
  }
  if ( read_buffer[v13 + 1] )
  {
    msg = "unknown compression type";
    goto LABEL_37;
  }
  newlength[0] = -1;
  if ( png_decompress_chunk(png_ptr, length, v13 + 2, newlength, v18.compression) != 1 )
  {
    msg = (const char *)png_ptr->zstream.msg;
    if ( !msg )
      return;
    goto LABEL_37;
  }
  v15 = png_ptr->read_buffer;
  if ( !v15 )
  {
    msg = "Read failure in png_handle_zTXt";
    if ( !"Read failure in png_handle_zTXt" )
      return;
    goto LABEL_37;
  }
  v16 = newlength[0];
  v15[newlength[0] + 2 + v13] = 0;
  v18.compression = 0;
  v18.key = v15;
  v18.text = &v15[v13 + 2];
  v18.text_length = v16;
  memset(&v18.itxt_length, 0, 12);
  v17 = j_png_set_text_2(png_ptr, info_ptr, &v18, 1);
  msg = "insufficient memory";
  if ( !v17 )
    msg = 0;
  if ( msg )
LABEL_37:
    j_png_chunk_benign_error(png_ptr, (png_const_charp)msg);
}
// 1FFA2A: control flows out of bounds to 1FFA2C
// 1FF8B4: using guessed type png_alloc_size_t newlength[7];

//----- (001FFA84) --------------------------------------------------------
int __fastcall png_decompress_chunk(
        png_structrp_6 png_ptr,
        png_uint_32 chunklength,
        png_uint_32 prefix_size,
        png_alloc_size_t *newlength,
        int terminate)
{
  png_alloc_size_t user_chunk_malloc_max; // r0
  png_uint_32 v10; // r1
  int v11; // r5
  png_alloc_size_t v12; // r0
  int v13; // r0
  png_bytep read_buffer; // r0
  png_uint_32 chunk_name; // r1
  png_uint_32 v16; // r6
  int v17; // r0
  png_alloc_size_t *v19; // r5
  size_t v20; // r10
  png_byte *v21; // r0
  png_byte *v22; // r9
  int v23; // r0
  png_bytep v24; // r11
  png_alloc_size_t *output_size_ptr; // [sp+8h] [bp-28h]
  png_alloc_size_t *output_size_ptra; // [sp+8h] [bp-28h]
  png_alloc_size_t v27; // [sp+Ch] [bp-24h]
  png_byte input[4]; // [sp+10h] [bp-20h] BYREF

  user_chunk_malloc_max = png_ptr->user_chunk_malloc_max;
  if ( user_chunk_malloc_max + 1 > 1 )
  {
    v10 = prefix_size + 1;
    if ( user_chunk_malloc_max < prefix_size + 1 )
    {
      v11 = -4;
      j_png_zstream_error(png_ptr, -4);
      return v11;
    }
  }
  else
  {
    v10 = prefix_size + 1;
    user_chunk_malloc_max = -1;
  }
  v12 = user_chunk_malloc_max - v10;
  if ( v12 < *newlength )
    *newlength = v12;
  v13 = png_inflate_claim(png_ptr, png_ptr->chunk_name);
  v11 = v13;
  if ( v13 == 1 )
    return -7;
  if ( !v13 )
  {
    read_buffer = png_ptr->read_buffer;
    chunk_name = png_ptr->chunk_name;
    v16 = chunklength - prefix_size;
    *(_DWORD *)input = v16;
    v17 = png_inflate(
            png_ptr,
            chunk_name,
            (int)&read_buffer[prefix_size],
            input,
            0,
            (png_bytep)newlength,
            output_size_ptr);
    v11 = v17;
    if ( !v17 )
    {
LABEL_13:
      v11 = -7;
      goto LABEL_14;
    }
    if ( v17 != 1 )
    {
LABEL_14:
      png_ptr->zowner = 0;
      return v11;
    }
    if ( j_inflateReset((z_streamp_1)&png_ptr->zstream) )
    {
      j_png_zstream_error(png_ptr, 1);
      goto LABEL_13;
    }
    v27 = *newlength;
    v19 = (png_alloc_size_t *)(prefix_size + *newlength);
    v20 = (size_t)v19 + 1;
    v21 = (png_byte *)j_png_malloc_base(png_ptr, (png_alloc_size_t)v19 + 1);
    v22 = v21;
    if ( !v21 )
    {
      v11 = -4;
      j_png_zstream_error(png_ptr, -4);
      goto LABEL_14;
    }
    memset(v21, 0, v20);
    v23 = png_inflate(
            png_ptr,
            png_ptr->chunk_name,
            (int)&png_ptr->read_buffer[prefix_size],
            input,
            (png_uint_32p)&v22[prefix_size],
            (png_bytep)newlength,
            v19);
    v11 = v23;
    if ( v23 )
    {
      if ( v23 != 1 )
      {
LABEL_26:
        v24 = v22;
LABEL_27:
        j_png_free(png_ptr, v24);
        if ( v11 == 1 && v16 != *(_DWORD *)input )
        {
          j_png_chunk_benign_error(png_ptr, (png_const_charp)"extra compressed data");
          v11 = 1;
        }
        goto LABEL_14;
      }
      if ( v27 == *newlength )
      {
        v24 = png_ptr->read_buffer;
        *((_BYTE *)output_size_ptra + (_DWORD)v22) = 0;
        if ( prefix_size )
          qmemcpy(v22, v24, prefix_size);
        png_ptr->read_buffer = v22;
        png_ptr->read_buffer_size = v20;
        v11 = 1;
        goto LABEL_27;
      }
    }
    v11 = -7;
    goto LABEL_26;
  }
  return v11;
}
// 1FFAFE: variable 'output_size_ptr' is possibly undefined
// 1FFB98: variable 'output_size_ptra' is possibly undefined

//----- (001FFBEC) --------------------------------------------------------
void __fastcall png_handle_iTXt(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length)
{
  png_uint_32 user_chunk_cache_max; // r0
  png_uint_32 v7; // r0
  const char *v8; // r1
  png_uint_32 mode; // r0
  png_alloc_size_t v10; // r6
  png_byte *read_buffer; // r5
  png_bytep v12; // r1
  png_byte *v13; // r0
  png_uint_32 v14; // r0
  const char *msg; // r1
  int v16; // r6
  int v17; // r2
  bool v18; // cf
  png_uint_32 v19; // r0
  png_uint_32 v20; // r11
  png_uint_32 i; // r0
  png_uint_32 v22; // r9
  int v23; // r0
  int terminate; // [sp+0h] [bp-40h]
  png_text text_ptr; // [sp+4h] [bp-3Ch] BYREF
  png_alloc_size_t newlength[8]; // [sp+20h] [bp-20h] BYREF

  user_chunk_cache_max = png_ptr->user_chunk_cache_max;
  if ( user_chunk_cache_max )
  {
    if ( user_chunk_cache_max == 1 )
    {
      png_crc_finish(png_ptr, length);
      return;
    }
    v7 = user_chunk_cache_max - 1;
    png_ptr->user_chunk_cache_max = v7;
    if ( v7 == 1 )
    {
      j_png_crc_finish(png_ptr, length);
      v8 = "no space in chunk cache";
LABEL_22:
      sub_191A28(png_ptr, (png_const_charp)v8);
      return;
    }
  }
  mode = png_ptr->mode;
  if ( (mode & 1) == 0 )
  {
    j_png_chunk_error(png_ptr, (png_const_charp)"missing IHDR");
    JUMPOUT(0x1FFDD4);
  }
  v10 = length + 1;
  if ( (mode & 4) != 0 )
    png_ptr->mode = mode | 8;
  read_buffer = png_ptr->read_buffer;
  if ( read_buffer )
  {
    if ( png_ptr->read_buffer_size >= v10 )
      goto LABEL_14;
    v12 = png_ptr->read_buffer;
    png_ptr->read_buffer = 0;
    png_ptr->read_buffer_size = 0;
    j_png_free(png_ptr, v12);
  }
  v13 = (png_byte *)j_png_malloc_base(png_ptr, length + 1);
  read_buffer = v13;
  if ( !v13 )
  {
    j_png_chunk_warning(png_ptr, (png_const_charp)"insufficient memory to read chunk");
    j_png_crc_finish(png_ptr, length);
    v8 = "out of memory";
    goto LABEL_22;
  }
  memset(v13, 0, length + 1);
  png_ptr->read_buffer = read_buffer;
  png_ptr->read_buffer_size = v10;
LABEL_14:
  j_png_read_data(png_ptr, read_buffer, length);
  j_png_calculate_crc(png_ptr, read_buffer, length);
  if ( j_png_crc_finish(png_ptr, 0) )
    return;
  if ( !length )
  {
    msg = "bad keyword";
    goto LABEL_48;
  }
  v14 = 0;
  do
  {
    if ( !read_buffer[v14] )
      break;
    ++v14;
  }
  while ( v14 < length );
  if ( v14 - 1 > 0x4E )
  {
    msg = "bad keyword";
LABEL_48:
    j_png_chunk_benign_error(png_ptr, (png_const_charp)msg);
    return;
  }
  if ( v14 + 5 > length )
  {
    msg = "truncated";
    goto LABEL_48;
  }
  v16 = read_buffer[v14 + 1];
  if ( read_buffer[v14 + 1] && (v16 != 1 || read_buffer[v14 + 2]) )
  {
    msg = "bad compression info";
    goto LABEL_48;
  }
  v17 = v14 + 3;
  v18 = v14 + 3 >= length;
  newlength[0] = 0;
  v19 = v14 + 3;
  if ( !v18 )
  {
    do
    {
      if ( !read_buffer[v19] )
        break;
      ++v19;
    }
    while ( v19 < length );
  }
  v20 = v19 + 1;
  for ( i = v19 + 1; i < length; ++i )
  {
    if ( !read_buffer[i] )
      break;
  }
  v22 = i + 1;
  if ( v16 || v22 > length )
  {
    msg = "truncated";
    if ( !v16 || v22 >= length )
      goto LABEL_48;
    newlength[0] = -1;
    if ( png_decompress_chunk(png_ptr, length, v22, newlength, v17) == 1 )
    {
      read_buffer = png_ptr->read_buffer;
      v17 = terminate;
    }
    else
    {
      msg = (const char *)png_ptr->zstream.msg;
      v17 = terminate;
      if ( msg )
        goto LABEL_48;
    }
  }
  else
  {
    newlength[0] = length - v22;
  }
  read_buffer[newlength[0] + v22] = 0;
  v23 = 1;
  if ( v16 )
    v23 = 2;
  text_ptr.compression = v23;
  text_ptr.key = read_buffer;
  text_ptr.lang = &read_buffer[v17];
  text_ptr.lang_key = &read_buffer[v20];
  text_ptr.text = &read_buffer[v22];
  text_ptr.text_length = 0;
  text_ptr.itxt_length = newlength[0];
  if ( j_png_set_text_2(png_ptr, info_ptr, &text_ptr, 1) )
  {
    msg = "insufficient memory";
    goto LABEL_48;
  }
}
// 1FFDD0: control flows out of bounds to 1FFDD4
// 1FFD6E: variable 'terminate' is possibly undefined
// 1FFBEC: using guessed type png_alloc_size_t newlength[8];

//----- (001FFE10) --------------------------------------------------------
void __fastcall png_handle_unknown(png_structrp_6 png_ptr, png_inforp_4 info_ptr, png_uint_32 length, int keep)
{
  int unknown_default; // r6
  int v7; // r0
  int v8; // r6
  png_uint_32 user_chunk_cache_max; // r0
  png_byte *data; // r1

  unknown_default = keep;
  if ( png_ptr->read_user_chunk_fn )
  {
    if ( !png_cache_unknown_chunk(png_ptr, length) )
      goto LABEL_25;
    v7 = png_ptr->read_user_chunk_fn(png_ptr, &png_ptr->unknown_chunk);
    if ( v7 <= -1 )
    {
      j_png_chunk_error(png_ptr, (png_const_charp)"error in user chunk");
      goto LABEL_34;
    }
    if ( v7 )
    {
      v8 = 1;
      goto LABEL_26;
    }
    if ( unknown_default <= 1 )
    {
      if ( png_ptr->unknown_default <= 1 )
      {
        j_png_chunk_warning(png_ptr, (png_const_charp)"Saving unknown chunk:");
        j_png_app_warning(
          png_ptr,
          (png_const_charp)"forcing save of an unhandled chunk; please call png_set_keep_unknown_chunks");
      }
      goto LABEL_20;
    }
  }
  else
  {
    if ( !keep )
      unknown_default = png_ptr->unknown_default;
    if ( unknown_default == 3 || unknown_default == 2 && (png_ptr->chunk_name & 0x20000000) != 0 )
    {
      if ( !png_cache_unknown_chunk(png_ptr, length) )
        unknown_default = 1;
    }
    else
    {
      j_png_crc_finish(png_ptr, length);
    }
  }
  if ( unknown_default == 3 )
    goto LABEL_21;
  if ( unknown_default != 2 )
    goto LABEL_25;
LABEL_20:
  if ( (png_ptr->chunk_name & 0x20000000) == 0 )
    goto LABEL_25;
LABEL_21:
  user_chunk_cache_max = png_ptr->user_chunk_cache_max;
  switch ( user_chunk_cache_max )
  {
    case 0u:
      goto LABEL_32;
    case 1u:
LABEL_25:
      v8 = 0;
      goto LABEL_26;
    case 2u:
      png_ptr->user_chunk_cache_max = 1;
      j_png_chunk_benign_error(png_ptr, (png_const_charp)"no space in chunk cache");
      goto LABEL_25;
  }
  png_ptr->user_chunk_cache_max = user_chunk_cache_max - 1;
LABEL_32:
  v8 = 1;
  j_png_set_unknown_chunks(png_ptr, info_ptr, &png_ptr->unknown_chunk, 1);
LABEL_26:
  data = png_ptr->unknown_chunk.data;
  if ( data )
    j_png_free(png_ptr, data);
  png_ptr->unknown_chunk.data = 0;
  if ( !v8 && (png_ptr->chunk_name & 0x20000000) == 0 )
  {
LABEL_34:
    j_png_chunk_error(png_ptr, (png_const_charp)"unhandled critical chunk");
    JUMPOUT(0x1FFF18);
  }
}
// 1FFF14: control flows out of bounds to 1FFF18

//----- (001FFF68) --------------------------------------------------------
int __fastcall png_cache_unknown_chunk(png_structrp_6 png_ptr, png_uint_32 length)
{
  png_byte *data; // r1
  png_uint_32 user_chunk_malloc_max; // r0
  png_byte *v6; // r6
  png_uint_32 chunk_name; // r1
  png_uint_32 mode; // r0

  data = png_ptr->unknown_chunk.data;
  if ( data )
  {
    j_png_free(png_ptr, data);
    png_ptr->unknown_chunk.data = 0;
  }
  user_chunk_malloc_max = png_ptr->user_chunk_malloc_max;
  if ( user_chunk_malloc_max + 1 < 2 || user_chunk_malloc_max >= length )
  {
    chunk_name = png_ptr->chunk_name;
    v6 = 0;
    mode = png_ptr->mode;
    png_ptr->unknown_chunk.name[4] = 0;
    png_ptr->unknown_chunk.size = length;
    png_ptr->unknown_chunk.name[3] = chunk_name;
    png_ptr->unknown_chunk.location = mode;
    png_ptr->unknown_chunk.name[0] = HIBYTE(chunk_name);
    png_ptr->unknown_chunk.name[1] = BYTE2(chunk_name);
    png_ptr->unknown_chunk.name[2] = BYTE1(chunk_name);
    if ( length )
      v6 = (png_byte *)j_png_malloc_warn(png_ptr, length);
    png_ptr->unknown_chunk.data = v6;
    if ( !length )
      goto LABEL_11;
  }
  else
  {
    v6 = 0;
    if ( !length )
      goto LABEL_11;
  }
  if ( !v6 )
  {
    j_png_crc_finish(png_ptr, length);
    j_png_chunk_benign_error(png_ptr, (png_const_charp)"unknown chunk exceeds memory limits");
    return 0;
  }
LABEL_11:
  if ( length )
  {
    j_png_read_data(png_ptr, v6, length);
    j_png_calculate_crc(png_ptr, v6, length);
  }
  j_png_crc_finish(png_ptr, 0);
  return 1;
}

//----- (00200044) --------------------------------------------------------
void __fastcall png_combine_row(png_const_structrp_4 png_ptr, png_bytep dp, int display)
{
  unsigned int transformed_pixel_depth; // r6
  png_size_t info_rowbytes; // r1
  png_uint_32 width; // r10
  unsigned int pass; // lr
  int v9; // r1
  png_byte *v10; // r8
  char v11; // r2
  unsigned int v12; // r4
  png_byte *v13; // r11
  unsigned int v14; // r5
  png_uint_32 transformations; // r4
  int v16; // r1
  unsigned int v17; // r2
  unsigned int v18; // r2
  unsigned int v19; // r0
  int v20; // r1
  const png_uint_32 *v21; // r1
  unsigned int v22; // r3
  unsigned int v23; // r1
  unsigned int v24; // r6
  unsigned int v25; // r0
  size_t v26; // r10
  int v27; // r1
  char *v28; // r2
  int v29; // r4
  unsigned int v30; // r5
  png_byte *v31; // r0
  png_byte *v32; // r12
  unsigned int v33; // r2
  png_byte *v34; // r3
  png_byte *v35; // r1
  int v36; // r2
  bool v37; // zf
  int v38; // r2
  png_byte *v39; // r8
  int v40; // r9
  int v41; // r4
  png_uint_32 v42; // r1
  png_byte v43; // r2
  unsigned int v44; // r4
  unsigned int v45; // r12
  _WORD *v46; // r2
  unsigned int v47; // r8
  __int16 *v48; // r3
  size_t v49; // r0
  __int16 v50; // t1
  unsigned int v51; // r5
  unsigned int v52; // r12
  _DWORD *v53; // r2
  unsigned int v54; // r8
  int *v55; // r3
  size_t v56; // r0
  int v57; // t1
  unsigned int v58; // r5
  unsigned int v59; // lr
  bool v60; // cc
  unsigned int v61; // lr
  bool v62; // cc
  unsigned int v63; // r8
  int v64; // r12
  __int64 v65; // d16
  __int64 v66; // d17
  _QWORD *v67; // r4
  char v68; // t1
  unsigned int v69; // r8
  int v70; // r12
  __int64 v71; // d16
  __int64 v72; // d17
  _QWORD *v73; // r4
  char v74; // t1
  int v75; // [sp+0h] [bp-28h]
  png_bytep row_buf; // [sp+4h] [bp-24h]
  png_byte v77; // [sp+8h] [bp-20h]

  transformed_pixel_depth = png_ptr->transformed_pixel_depth;
  if ( !png_ptr->transformed_pixel_depth )
  {
    j_png_error(png_ptr, (png_const_charp)"internal row logic error");
    goto LABEL_119;
  }
  info_rowbytes = png_ptr->info_rowbytes;
  width = png_ptr->width;
  pass = png_ptr->pass;
  if ( info_rowbytes )
  {
    if ( transformed_pixel_depth < 8 )
    {
      if ( info_rowbytes != (width * transformed_pixel_depth + 7) >> 3 )
      {
LABEL_120:
        j_png_error(png_ptr, (png_const_charp)"internal row size calculation error");
        goto LABEL_121;
      }
    }
    else if ( info_rowbytes != width * (transformed_pixel_depth >> 3) )
    {
      goto LABEL_120;
    }
  }
  if ( !width )
  {
LABEL_119:
    j_png_error(png_ptr, (png_const_charp)"internal row width error");
    goto LABEL_120;
  }
  v9 = width * transformed_pixel_depth;
  v10 = png_ptr->row_buf + 1;
  row_buf = png_ptr->row_buf;
  v11 = (width * transformed_pixel_depth) & 7;
  if ( ((width * transformed_pixel_depth) & 7) != 0 )
  {
    v12 = (unsigned int)(v9 + 7) >> 3;
    if ( transformed_pixel_depth > 7 )
      v12 = width * (transformed_pixel_depth >> 3);
    v13 = &dp[v12 - 1];
    v77 = *v13;
    if ( BYTE2(png_ptr->transformations) << 31 )
      v14 = 255 << v11;
    else
      v14 = 0xFFu >> v11;
  }
  else
  {
    LOBYTE(v14) = 0;
    v77 = 0;
    v13 = 0;
  }
  if ( !png_ptr->interlaced )
    goto LABEL_22;
  if ( pass > 5 )
    goto LABEL_22;
  transformations = png_ptr->transformations;
  if ( (transformations & 2) == 0 )
    goto LABEL_22;
  if ( display != 1 )
  {
    if ( !display )
    {
      v75 = 0;
      v16 = pass & 1;
      goto LABEL_29;
    }
LABEL_22:
    v17 = (unsigned int)(v9 + 7) >> 3;
    if ( transformed_pixel_depth > 7 )
      v17 = width * (transformed_pixel_depth >> 3);
    qmemcpy(dp, v10, v17);
    goto LABEL_25;
  }
  if ( !(pass << 31) )
    goto LABEL_22;
  v16 = 1;
  v75 = 1;
LABEL_29:
  v18 = (v16 << (3 - ((pass + 1) >> 1))) & 7;
  if ( width <= v18 )
    return;
  if ( transformed_pixel_depth <= 7 )
  {
    v19 = 8 / transformed_pixel_depth;
    v20 = 2;
    if ( transformed_pixel_depth == 2 )
      v20 = 1;
    if ( transformed_pixel_depth == 1 )
      v20 = 0;
    if ( (transformations & 0x10000) != 0 )
    {
      v27 = 3 * v20;
      v28 = (char *)png_combine_row_display_mask + 4 * v27;
      v21 = &png_combine_row_row_mask[0][v27 / 3u][pass];
      if ( v75 )
        v21 = (const png_uint_32 *)&v28[(2 * pass) & 0x1FC];
    }
    else if ( v75 )
    {
      v21 = (const png_uint_32 *)((char *)png_combine_row_display_mask[1][v20] + ((2 * pass) & 0x1FC));
    }
    else
    {
      v21 = &png_combine_row_row_mask[1][v20][pass];
    }
    v42 = *v21;
    while ( 1 )
    {
      if ( (_BYTE)v42 )
      {
        if ( (unsigned __int8)v42 == 255 )
          v43 = *v10;
        else
          v43 = *dp & ~(_BYTE)v42 | *v10 & v42;
        *dp = v43;
      }
      if ( width <= v19 )
        break;
      v42 = __ROR4__(v42, 8);
      width -= v19;
      ++v10;
      ++dp;
    }
LABEL_25:
    if ( v13 )
      *v13 = *v13 & ~(_BYTE)v14 | v77 & v14;
    return;
  }
  if ( transformed_pixel_depth << 29 )
  {
LABEL_121:
    j_png_error(png_ptr, (png_const_charp)"invalid user transform pixel depth");
    JUMPOUT(0x2004B0);
  }
  v22 = transformed_pixel_depth >> 3;
  v23 = (unsigned int)&v10[(__int16)v18 * (__int16)(transformed_pixel_depth >> 3)];
  v24 = width * (transformed_pixel_depth >> 3) - v18 * (transformed_pixel_depth >> 3);
  v25 = (unsigned int)&dp[(__int16)v18 * (__int16)v22];
  if ( v75 )
  {
    v26 = v22 << ((6 - pass) >> 1);
    if ( v26 > v24 )
      v26 = v24;
  }
  else
  {
    v26 = v22;
  }
  v29 = (__int16)v18 * (__int16)v22;
  v30 = v22 << ((7 - pass) >> 1);
  switch ( v26 )
  {
    case 1u:
      *(_BYTE *)v25 = *(_BYTE *)v23;
      if ( v24 > v30 )
      {
        v36 = 0;
        do
        {
          v24 -= v30;
          dp[v30 + v29 + v36] = row_buf[v30 + 1 + v29 + v36];
          v36 += v30;
        }
        while ( v24 > v30 );
      }
      break;
    case 3u:
      *(_BYTE *)v25 = *(_BYTE *)v23;
      *(_BYTE *)(v25 + 1) = *(_BYTE *)(v23 + 1);
      *(_BYTE *)(v25 + 2) = *(_BYTE *)(v23 + 2);
      if ( v24 > v30 )
      {
        v31 = &dp[v29];
        v32 = &row_buf[v29];
        v33 = v22 << ((7 - pass) >> 1);
        do
        {
          v34 = &v32[v33];
          v35 = &v31[v33];
          v24 -= v30;
          v31[v33] = v32[v33 + 1];
          v33 += v30;
          v35[1] = v34[2];
          v35[2] = v34[3];
        }
        while ( v24 > v30 );
      }
      break;
    case 2u:
      while ( 1 )
      {
        dp[v29] = row_buf[v29 + 1];
        dp[v29 + 1] = row_buf[v29 + 2];
        if ( v24 <= v30 )
          break;
        v24 -= v30;
        v29 += v30;
        if ( v24 <= 1 )
        {
          dp[v29] = row_buf[v29 + 1];
          return;
        }
      }
      break;
    default:
      if ( v26 < 0x10 )
      {
        v38 = v25 << 31;
        v37 = v25 << 31 == 0;
        if ( !(v25 << 31) )
        {
          v38 = v30 | v23;
          v37 = (v30 | v23 | v26) << 31 == 0;
        }
        if ( v37 )
        {
          v44 = v24 - v30;
          if ( (v38 | v25 | v26) << 30 )
          {
            v45 = (v30 - v26) >> 1;
            do
            {
              v46 = (_WORD *)v25;
              v47 = v44;
              v48 = (__int16 *)v23;
              v49 = v26;
              do
              {
                v50 = *v48++;
                v49 -= 2;
                *v46++ = v50;
              }
              while ( v49 );
              if ( v24 <= v30 )
                return;
              v24 -= v30;
              v44 -= v30;
              v23 = (unsigned int)&v48[v45];
              v25 = (unsigned int)&v46[v45];
            }
            while ( v26 <= v24 );
            if ( v24 >= 0x10 )
            {
              v59 = v24 & 0xFFFFFFF0;
              if ( (v24 & 0xFFFFFFF0) != 0 )
              {
                v60 = v23 + v24 > v25;
                if ( v23 + v24 > v25 )
                  v60 = v25 + v24 > v23;
                if ( v60 )
                {
                  v51 = v24;
                }
                else
                {
                  v25 += v59;
                  v23 += v59;
                  v51 = v24 - v59;
                  v63 = v47 & 0xFFFFFFF0;
                  v64 = v45;
                  do
                  {
                    v63 -= 16;
                    v65 = *(_QWORD *)&v48[v64];
                    v66 = *(_QWORD *)&v48[v64 + 4];
                    v67 = &v46[v64];
                    v64 += 8;
                    *v67 = v65;
                    v67[1] = v66;
                  }
                  while ( v63 );
                  if ( v24 == v59 )
                    return;
                }
              }
              else
              {
                v51 = v24;
              }
            }
            else
            {
              v51 = v24;
            }
            do
            {
              v68 = *(_BYTE *)v23++;
              --v51;
              *(_BYTE *)v25++ = v68;
            }
            while ( v51 );
            return;
          }
          v52 = (v30 - v26) >> 2;
          do
          {
            v53 = (_DWORD *)v25;
            v54 = v44;
            v55 = (int *)v23;
            v56 = v26;
            do
            {
              v57 = *v55++;
              v56 -= 4;
              *v53++ = v57;
            }
            while ( v56 );
            if ( v24 <= v30 )
              return;
            v24 -= v30;
            v44 -= v30;
            v23 = (unsigned int)&v55[v52];
            v25 = (unsigned int)&v53[v52];
          }
          while ( v26 <= v24 );
          if ( v24 >= 0x10 )
          {
            v61 = v24 & 0xFFFFFFF0;
            if ( (v24 & 0xFFFFFFF0) != 0 )
            {
              v62 = v23 + v24 > v25;
              if ( v23 + v24 > v25 )
                v62 = v25 + v24 > v23;
              if ( v62 )
              {
                v58 = v24;
              }
              else
              {
                v25 += v61;
                v23 += v61;
                v58 = v24 - v61;
                v69 = v54 & 0xFFFFFFF0;
                v70 = v52;
                do
                {
                  v69 -= 16;
                  v71 = *(_QWORD *)&v55[v70];
                  v72 = *(_QWORD *)&v55[v70 + 2];
                  v73 = &v53[v70];
                  v70 += 4;
                  *v73 = v71;
                  v73[1] = v72;
                }
                while ( v69 );
                if ( v24 == v61 )
                  return;
              }
            }
            else
            {
              v58 = v24;
            }
          }
          else
          {
            v58 = v24;
          }
          do
          {
            v74 = *(_BYTE *)v23++;
            --v58;
            *(_BYTE *)v25++ = v74;
          }
          while ( v58 );
          return;
        }
      }
      qmemcpy((void *)v25, (const void *)v23, v26);
      if ( v24 > v30 )
      {
        v39 = &dp[v30 + v29];
        v40 = (int)&row_buf[v30 + 1 + v29];
        v41 = 0;
        do
        {
          if ( v26 > v24 - v30 )
            v26 = v24 - v30;
          qmemcpy(&v39[v41], (const void *)(v40 + v41), v26);
          v24 -= v30;
          v41 += v30;
        }
        while ( v24 > v30 );
      }
      break;
  }
}
// 2004AC: control flows out of bounds to 2004B0
// 2004A0: variable 'png_ptr' is possibly undefined

//----- (00200540) --------------------------------------------------------
void __fastcall png_do_read_interlace(png_row_infop row_info, png_bytep row, int pass, png_uint_32 transformations)
{
  png_row_infop v4; // r5
  bool v5; // zf
  png_uint_32 width; // r12
  signed int v7; // r6
  unsigned int pixel_depth; // r0
  int v9; // r2
  int v10; // r4
  int v11; // r10
  int v12; // r0
  int v13; // r11
  int v14; // r9
  int v15; // lr
  int v16; // r4
  int v17; // r10
  int v18; // r11
  int v19; // r8
  int v20; // r10
  int v21; // r4
  int v22; // r0
  int v23; // r11
  int v24; // r9
  size_t v25; // r5
  int v26; // r10
  png_byte *v27; // r3
  png_uint_32 v28; // r8
  png_byte *v29; // r4
  signed int v30; // r9
  png_byte *v31; // r3
  png_byte *v32; // r8
  int v33; // r2
  unsigned int v34; // r1
  signed int v35; // r3
  int v36; // r1
  int v37; // r5
  int v38; // r1
  int v39; // r4
  int v40; // r5
  png_byte *v41; // r2
  png_byte *v42; // r9
  int v43; // r0
  unsigned int v44; // r1
  signed int v45; // r2
  int v46; // r1
  int v47; // r3
  int v48; // r1
  png_byte *v49; // r5
  png_byte *v50; // r8
  int v51; // r2
  signed int v52; // r2
  int v53; // r1
  int v54; // r3
  int v55; // r1
  unsigned int v56; // r0
  int v57; // [sp+4h] [bp-3Ch]
  int v58; // [sp+8h] [bp-38h]
  int v59; // [sp+8h] [bp-38h]
  png_byte *v60; // [sp+Ch] [bp-34h]
  int v61; // [sp+Ch] [bp-34h]
  png_byte *v62; // [sp+10h] [bp-30h]
  png_byte *v63; // [sp+10h] [bp-30h]
  png_row_infop v64; // [sp+14h] [bp-2Ch]
  char v65[8]; // [sp+18h] [bp-28h] BYREF

  v4 = row_info;
  v5 = row_info == 0;
  if ( row_info )
    v5 = row == 0;
  if ( !v5 )
  {
    width = row_info->width;
    v7 = png_do_read_interlace_png_pass_inc[pass];
    pixel_depth = row_info->pixel_depth;
    v64 = v4;
    v9 = v7 * v4->width;
    v57 = v9;
    if ( pixel_depth != 4 )
    {
      if ( pixel_depth == 2 )
      {
        v20 = 6;
        v21 = (2 * (_BYTE)width + 6) & 6;
        if ( (transformations & 0x10000) != 0 )
        {
          v23 = -2;
          v22 = (2 * (_BYTE)v9 + 6) & 6;
          v24 = 0;
          if ( !width )
            goto LABEL_57;
        }
        else
        {
          v21 ^= 6u;
          v22 = ~(2 * v9 + 6) & 6;
          v23 = 2;
          v24 = 6;
          v20 = 0;
          if ( !width )
            goto LABEL_57;
        }
        v49 = &row[(width - 1) >> 2];
        v50 = &row[(unsigned int)(v9 - 1) >> 2];
        v51 = 0;
        do
        {
          v59 = v51;
          v52 = 0;
          v53 = (*v49 >> v21) & 3;
          do
          {
            *v50 = (v53 << v22) | (0x3F3Fu >> (6 - v22)) & *v50;
            v54 = v20;
            ++v52;
            if ( v22 == v24 )
              --v50;
            else
              v54 = v22 + v23;
            v22 = v54;
          }
          while ( v52 < v7 );
          v55 = v20;
          if ( v21 == v24 )
            --v49;
          else
            v55 = v21 + v23;
          v51 = v59 + 1;
          v21 = v55;
          v22 = v54;
        }
        while ( v59 + 1 < v64->width );
        goto LABEL_57;
      }
      if ( pixel_depth == 1 )
      {
        v10 = ((_BYTE)width + 7) & 7;
        if ( (transformations & 0x10000) == 0 )
        {
          v11 = 7;
          v12 = ~(v9 + 7) & 7;
          v10 ^= 7u;
          v13 = 0;
          v14 = 1;
          if ( !width )
            goto LABEL_57;
LABEL_23:
          v31 = &row[(width - 1) >> 3];
          v32 = &row[(unsigned int)(v9 - 1) >> 3];
          v33 = 0;
          do
          {
            v58 = v33;
            v60 = v31;
            v34 = *v31;
            v35 = 0;
            v36 = (v34 >> v10) & 1;
            do
            {
              *v32 = (v36 << v12) | (0x7F7Fu >> (7 - v12)) & *v32;
              v37 = v13;
              ++v35;
              if ( v12 == v11 )
                --v32;
              else
                v37 = v12 + v14;
              v12 = v37;
            }
            while ( v35 < v7 );
            v38 = v13;
            v31 = v60;
            if ( v10 == v11 )
              v31 = v60 - 1;
            else
              v38 = v10 + v14;
            ++v33;
            v10 = v38;
            v12 = v37;
          }
          while ( v58 + 1 < v64->width );
          goto LABEL_57;
        }
        v13 = 7;
        v12 = ((_BYTE)v9 + 7) & 7;
        v11 = 0;
        v14 = -1;
        if ( width )
          goto LABEL_23;
      }
      else
      {
        if ( !width )
        {
LABEL_58:
          v4->width = v9;
          if ( pixel_depth < 8 )
            v56 = (pixel_depth * v9 + 7) >> 3;
          else
            v56 = (pixel_depth >> 3) * v9;
          v4->rowbytes = v56;
          return;
        }
        v25 = pixel_depth >> 3;
        v26 = -(pixel_depth >> 3);
        v27 = &row[(pixel_depth >> 3) * (width - 1)];
        v28 = 0;
        v29 = &row[(pixel_depth >> 3) * (v9 - 1)];
        do
        {
          v62 = v27;
          qmemcpy(v65, v27, v25);
          v30 = 0;
          do
          {
            qmemcpy(v29, v65, v25);
            ++v30;
            v29 += v26;
          }
          while ( v30 < v7 );
          ++v28;
          v27 = &v62[v26];
        }
        while ( v28 < v64->width );
      }
LABEL_57:
      v4 = v64;
      v9 = v57;
      pixel_depth = v64->pixel_depth;
      goto LABEL_58;
    }
    v15 = width & 1;
    if ( (transformations & 0x10000) != 0 )
    {
      v16 = (v9 & 1) == 0;
      v15 = !(width & 1);
      v19 = -4;
      v17 = 0;
      v18 = 4;
      if ( !width )
        goto LABEL_57;
    }
    else
    {
      v16 = v9 & 1;
      v17 = 4;
      v18 = 0;
      v19 = 4;
      if ( !width )
        goto LABEL_57;
    }
    v39 = 4 * v16;
    v40 = 0;
    v41 = &row[(width - 1) >> 1];
    v42 = &row[(unsigned int)(v57 - 1) >> 1];
    v43 = 4 * v15;
    do
    {
      v61 = v40;
      v63 = v41;
      v44 = *v41;
      v45 = 0;
      v46 = (v44 >> v43) & 0xF;
      do
      {
        *v42 = (v46 << v39) | (0xF0Fu >> (4 - v39)) & *v42;
        v47 = v18;
        ++v45;
        if ( v39 == v17 )
          --v42;
        else
          v47 = v39 + v19;
        v39 = v47;
      }
      while ( v45 < v7 );
      v48 = v18;
      v39 = v47;
      v41 = v63;
      if ( v43 == v17 )
        v41 = v63 - 1;
      else
        v48 = v43 + v19;
      ++v40;
      v43 = v48;
    }
    while ( v61 + 1 < v64->width );
    goto LABEL_57;
  }
}

//----- (0020087C) --------------------------------------------------------
void __fastcall png_read_filter_row(
        png_structrp_6 pp,
        png_row_infop row_info,
        png_bytep row,
        png_const_bytep prev_row,
        int filter)
{
  void (*v5)(png_row_infop, png_bytep, png_const_bytep); // r4

  if ( (unsigned int)(filter - 1) <= 3 )
  {
    if ( !pp->read_filter[0] )
    {
      v5 = png_read_filter_row_paeth_1byte_pixel;
      if ( ((pp->pixel_depth + 7) & 0x1F8) != 8 )
        v5 = png_read_filter_row_paeth_multibyte_pixel;
      pp->read_filter[0] = png_read_filter_row_sub;
      pp->read_filter[1] = png_read_filter_row_up;
      pp->read_filter[2] = png_read_filter_row_avg;
      pp->read_filter[3] = v5;
    }
    pp->read_filter[filter - 1](row_info, row, prev_row);
  }
}

//----- (00200904) --------------------------------------------------------
void __fastcall png_read_IDAT_data(png_structrp_6 png_ptr, png_bytep output, png_alloc_size_t avail_out)
{
  z_stream *p_zstream; // r8
  png_alloc_size_t v7; // r5
  png_alloc_size_t v8; // r0
  png_uint_32 idat_size; // r0
  png_uint_32 chunk_name; // r1
  size_t IDAT_read_size; // r5
  png_byte *read_buffer; // r6
  png_bytep v13; // r1
  png_byte *v14; // r0
  png_uint_32 v15; // r0
  int v16; // r1
  uInt v17; // r0
  __int64 v18; // r0
  uInt avail_in; // r2
  bool v20; // zf
  unsigned __int8 *msg; // r1
  int v22; // [sp+0h] [bp-420h] BYREF

  p_zstream = &png_ptr->zstream;
  png_ptr->zstream.next_out = output;
  png_ptr->zstream.avail_out = 0;
  if ( !output )
    avail_out = 0;
  while ( 1 )
  {
    if ( png_ptr->zstream.avail_in )
    {
      if ( output )
        goto LABEL_5;
      goto LABEL_18;
    }
    idat_size = png_ptr->idat_size;
    while ( !idat_size )
    {
      j_png_crc_finish(png_ptr, 0);
      idat_size = j_png_read_chunk_header(png_ptr);
      chunk_name = png_ptr->chunk_name;
      png_ptr->idat_size = idat_size;
      if ( chunk_name != 1229209940 )
        goto LABEL_35;
    }
    IDAT_read_size = png_ptr->IDAT_read_size;
    read_buffer = png_ptr->read_buffer;
    if ( IDAT_read_size > idat_size )
      IDAT_read_size = idat_size;
    if ( read_buffer )
    {
      if ( png_ptr->read_buffer_size >= IDAT_read_size )
        goto LABEL_17;
      v13 = png_ptr->read_buffer;
      png_ptr->read_buffer = 0;
      png_ptr->read_buffer_size = 0;
      j_png_free(png_ptr, v13);
    }
    v14 = (png_byte *)j_png_malloc_base(png_ptr, IDAT_read_size);
    read_buffer = v14;
    if ( !v14 )
      goto LABEL_36;
    memset(v14, 0, IDAT_read_size);
    png_ptr->read_buffer = read_buffer;
    png_ptr->read_buffer_size = IDAT_read_size;
LABEL_17:
    j_png_read_data(png_ptr, read_buffer, IDAT_read_size);
    j_png_calculate_crc(png_ptr, read_buffer, IDAT_read_size);
    v15 = png_ptr->idat_size;
    png_ptr->zstream.next_in = read_buffer;
    png_ptr->zstream.avail_in = IDAT_read_size;
    png_ptr->idat_size = v15 - IDAT_read_size;
    if ( output )
    {
LABEL_5:
      v7 = 0;
      v8 = avail_out;
      goto LABEL_19;
    }
LABEL_18:
    v7 = avail_out;
    png_ptr->zstream.next_out = (Bytef *)&v22;
    v8 = 1024;
LABEL_19:
    png_ptr->zstream.avail_out = v8;
    v16 = j_inflate((z_streamp_1)p_zstream, 0);
    v17 = png_ptr->zstream.avail_out;
    png_ptr->zstream.avail_out = 0;
    if ( !output )
      v17 = 1024 - v17;
    avail_out = v17 + v7;
    if ( v16 )
      break;
    if ( !avail_out )
      return;
  }
  if ( v16 == 1 )
  {
    v18 = *(_QWORD *)&png_ptr->mode;
    avail_in = png_ptr->zstream.avail_in;
    png_ptr->zstream.next_out = 0;
    *(_QWORD *)&png_ptr->mode = v18 | 0x800000008LL;
    v20 = avail_in == 0;
    if ( !avail_in )
      v20 = png_ptr->idat_size == 0;
    if ( !v20 )
      j_png_chunk_benign_error(png_ptr, (png_const_charp)"Extra compressed data");
    if ( avail_out )
    {
      if ( !output )
      {
        msg = "Too much image data";
        goto LABEL_33;
      }
LABEL_35:
      j_png_error(png_ptr, (png_const_charp)"Not enough image data");
LABEL_36:
      j_png_chunk_error(png_ptr, (png_const_charp)"insufficient memory to read chunk");
LABEL_37:
      j_png_chunk_error(png_ptr, msg);
      JUMPOUT(0x200AA8);
    }
  }
  else
  {
    j_png_zstream_error(png_ptr, v16);
    msg = png_ptr->zstream.msg;
    if ( output )
      goto LABEL_37;
LABEL_33:
    j_png_chunk_benign_error(png_ptr, msg);
  }
}
// 200AA4: control flows out of bounds to 200AA8
// 200AA4: variable 'msg' is possibly undefined

//----- (00200AF8) --------------------------------------------------------
void __fastcall png_read_finish_IDAT(png_structrp_6 png_ptr)
{
  png_uint_32 flags; // r0
  png_uint_32 idat_size; // r1

  if ( (png_ptr->flags & 8) == 0 )
  {
    j_png_read_IDAT_data(png_ptr, 0, 0);
    flags = png_ptr->flags;
    png_ptr->zstream.next_out = 0;
    if ( (flags & 8) == 0 )
    {
      png_ptr->mode |= 8u;
      png_ptr->flags = flags | 8;
    }
  }
  if ( png_ptr->zowner == 1229209940 )
  {
    idat_size = png_ptr->idat_size;
    png_ptr->zowner = 0;
    png_ptr->zstream.next_in = 0;
    png_ptr->zstream.avail_in = 0;
    png_crc_finish(png_ptr, idat_size);
  }
}

//----- (00200B5C) --------------------------------------------------------
void __fastcall png_read_finish_row(png_structrp_6 png_ptr)
{
  png_uint_32 row_number; // r1
  png_uint_32 num_rows; // r0
  png_bytep prev_row; // r0
  size_t v5; // r1
  png_byte v6; // r5
  int v7; // r0
  png_uint_32 v8; // r11
  unsigned int v9; // r10
  unsigned int v10; // r9
  unsigned int v11; // r4
  png_uint_32 v12; // r6
  bool v13; // cf
  png_uint_32 flags; // r0
  png_uint_32 idat_size; // r1
  png_uint_32 v16; // [sp+0h] [bp-20h]

  row_number = png_ptr->row_number;
  num_rows = png_ptr->num_rows;
  png_ptr->row_number = ++row_number;
  if ( row_number >= num_rows )
  {
    if ( png_ptr->interlaced
      && (prev_row = png_ptr->prev_row,
          v5 = png_ptr->rowbytes + 1,
          png_ptr->row_number = 0,
          memset(prev_row, 0, v5),
          v6 = png_ptr->pass + 1,
          png_ptr->pass = v6,
          v7 = v6,
          v6 <= 6u) )
    {
      v8 = png_ptr->width - 1;
      v16 = png_ptr->transformations & 2;
      while ( 1 )
      {
        v9 = png_read_start_row_png_pass_inc[v7];
        v10 = v8 + v9 - png_read_start_row_png_pass_start[v7];
        if ( v16 )
          break;
        v11 = png_read_finish_row_png_pass_yinc[v6];
        v12 = png_ptr->height + v11 - 1 - png_read_finish_row_png_pass_ystart[v6];
        v13 = v12 >= v11;
        png_ptr->num_rows = v12 / v11;
        if ( v12 >= v11 )
          v13 = v10 >= v9;
        if ( v13 )
          break;
        png_ptr->pass = ++v6;
        v7 = v6;
        if ( v6 > 6u )
        {
          png_ptr->iwidth = v10 / v9;
          goto LABEL_11;
        }
      }
      png_ptr->iwidth = v10 / v9;
    }
    else
    {
LABEL_11:
      if ( (png_ptr->flags & 8) == 0 )
      {
        j_png_read_IDAT_data(png_ptr, 0, 0);
        flags = png_ptr->flags;
        png_ptr->zstream.next_out = 0;
        if ( (flags & 8) == 0 )
        {
          png_ptr->mode |= 8u;
          png_ptr->flags = flags | 8;
        }
      }
      if ( png_ptr->zowner == 1229209940 )
      {
        idat_size = png_ptr->idat_size;
        png_ptr->zowner = 0;
        png_ptr->zstream.next_in = 0;
        png_ptr->zstream.avail_in = 0;
        png_crc_finish(png_ptr, idat_size);
      }
    }
  }
}

//----- (00200CA4) --------------------------------------------------------
void __fastcall png_read_start_row(png_structrp_6 png_ptr)
{
  png_uint_32 transformations; // r6
  png_uint_32 height; // r5
  png_uint_32 width; // r8
  unsigned int v5; // r0
  png_uint_32 *p_transformations; // r2
  unsigned int pixel_depth; // r1
  png_uint_32 v8; // r0
  int v9; // r3
  unsigned int v10; // r2
  unsigned int v11; // r1
  unsigned int v12; // r0
  unsigned int v13; // r2
  png_alloc_size_t v14; // r5
  png_byte *v15; // r0
  int color_type; // r6
  int v17; // r6
  int v18; // r1
  bool v19; // zf
  int v20; // r3
  png_byte *v21; // r0
  __int64 v22; // r0
  png_size_t rowbytes; // r0
  png_bytep read_buffer; // r1

  j_png_init_read_transformations(png_ptr);
  if ( png_ptr->interlaced )
  {
    transformations = png_ptr->transformations;
    height = png_ptr->height;
    width = png_ptr->width;
    v5 = (width + png_read_start_row_png_pass_inc[png_ptr->pass] - 1 - png_read_start_row_png_pass_start[png_ptr->pass])
       / png_read_start_row_png_pass_inc[png_ptr->pass];
    p_transformations = &png_ptr->transformations;
    if ( (transformations & 2) == 0 )
      height = (height + 7) >> 3;
  }
  else
  {
    transformations = png_ptr->transformations;
    p_transformations = &png_ptr->transformations;
    height = png_ptr->height;
    width = png_ptr->width;
    v5 = width;
  }
  png_ptr->iwidth = v5;
  png_ptr->num_rows = height;
  pixel_depth = png_ptr->pixel_depth;
  if ( (transformations & 4) != 0 && png_ptr->bit_depth < 8u )
    pixel_depth = 8;
  v8 = *p_transformations;
  if ( (*p_transformations & 0x1000) != 0 )
  {
    color_type = png_ptr->color_type;
    if ( png_ptr->color_type )
    {
      if ( color_type == 2 )
      {
        if ( !png_ptr->num_trans )
          goto LABEL_10;
        pixel_depth = 4 * pixel_depth / 3;
        if ( (v8 & 0x200) != 0 )
          goto LABEL_27;
      }
      else
      {
        if ( color_type != 3 )
          goto LABEL_10;
        pixel_depth = 32;
        if ( !png_ptr->num_trans )
          pixel_depth = 24;
        if ( (v8 & 0x200) != 0 )
          goto LABEL_27;
      }
    }
    else
    {
      if ( pixel_depth <= 8 )
        pixel_depth = 8;
      pixel_depth <<= png_ptr->num_trans != 0;
      if ( (v8 & 0x200) != 0 )
        goto LABEL_27;
    }
LABEL_11:
    v9 = *p_transformations & 0x8000;
    if ( (v8 & 0x8000) == 0 )
      goto LABEL_12;
    goto LABEL_31;
  }
LABEL_10:
  if ( (v8 & 0x200) == 0 )
    goto LABEL_11;
LABEL_27:
  if ( (*p_transformations & 0x1000) != 0 )
  {
    pixel_depth <<= png_ptr->bit_depth < 0x10u;
    v9 = *p_transformations & 0x8000;
    if ( (v8 & 0x8000) == 0 )
      goto LABEL_12;
  }
  else
  {
    v8 &= ~0x200u;
    *p_transformations = v8;
    v9 = v8 & 0x8000;
    if ( (v8 & 0x8000) == 0 )
      goto LABEL_12;
  }
LABEL_31:
  if ( (unsigned int)png_ptr->color_type - 2 < 2 )
  {
    v10 = 64;
    if ( pixel_depth < 0x21 )
      v10 = 32;
    if ( (v8 & 0x4000) != 0 )
      goto LABEL_35;
    goto LABEL_13;
  }
  if ( !png_ptr->color_type )
  {
    v10 = 32;
    if ( pixel_depth < 9 )
      v10 = 16;
    if ( (v8 & 0x4000) != 0 )
      goto LABEL_35;
LABEL_13:
    v11 = v10;
    if ( (v8 & 0x100000) == 0 )
      goto LABEL_16;
    goto LABEL_14;
  }
LABEL_12:
  v10 = pixel_depth;
  if ( (v8 & 0x4000) == 0 )
    goto LABEL_13;
LABEL_35:
  v17 = 0;
  v18 = 0;
  if ( (v8 & 0x1000) == 0 )
    v17 = 1;
  if ( !png_ptr->num_trans )
    v18 = 1;
  v19 = v9 == 0;
  if ( !v9 )
    v19 = (v18 | v17) == 1;
  if ( v19 )
  {
    v20 = png_ptr->color_type;
    if ( v20 != 4 )
      goto LABEL_61;
  }
  v11 = 64;
  if ( v10 < 0x11 )
    v11 = 32;
  if ( (v8 & 0x100000) != 0 )
  {
LABEL_14:
    if ( png_ptr->user_transform_channels * (unsigned int)png_ptr->user_transform_depth > v11 )
      v11 = png_ptr->user_transform_channels * png_ptr->user_transform_depth;
    goto LABEL_16;
  }
  while ( 1 )
  {
LABEL_16:
    v12 = (width + 7) & 0xFFFFFFF8;
    png_ptr->transformed_pixel_depth = 0;
    png_ptr->maximum_pixel_depth = v11;
    v13 = (v12 * v11) >> 3;
    if ( v11 > 7 )
      v13 = v12 * (v11 >> 3);
    v14 = v13 + ((v11 + 7) >> 3) + 49;
    if ( v14 > png_ptr->old_big_row_buf_size )
    {
      j_png_free(png_ptr, png_ptr->big_row_buf);
      j_png_free(png_ptr, png_ptr->big_prev_row);
      if ( png_ptr->interlaced )
        v15 = (png_byte *)j_png_calloc(png_ptr, v14);
      else
        v15 = (png_byte *)j_png_malloc(png_ptr, v14);
      png_ptr->big_row_buf = v15;
      v21 = (png_byte *)j_png_malloc(png_ptr, v14);
      png_ptr->big_prev_row = v21;
      png_ptr->old_big_row_buf_size = v14;
      LODWORD(v22) = &v21[-((unsigned int)(v21 + 32) & 0xF) + 31];
      HIDWORD(v22) = &png_ptr->big_row_buf[-((int)(png_ptr->big_row_buf + 32) & 0xF) + 31];
      *(_QWORD *)&png_ptr->prev_row = v22;
    }
    rowbytes = png_ptr->rowbytes;
    if ( rowbytes == -1 )
    {
      j_png_error(png_ptr, (png_const_charp)"Row has too many bytes to allocate in memory");
      JUMPOUT(0x200F44);
    }
    memset(png_ptr->prev_row, 0, rowbytes + 1);
    read_buffer = png_ptr->read_buffer;
    if ( read_buffer )
    {
      png_ptr->read_buffer = 0;
      png_ptr->read_buffer_size = 0;
      j_png_free(png_ptr, read_buffer);
    }
    if ( !png_inflate_claim(png_ptr, 0x49444154u) )
      break;
    j_png_error(png_ptr, png_ptr->zstream.msg);
LABEL_61:
    if ( v10 > 8 )
    {
      v11 = 48;
      if ( v20 == 6 )
        v11 = 64;
      if ( (v8 & 0x100000) != 0 )
        goto LABEL_14;
    }
    else
    {
      v11 = 24;
      if ( v20 == 6 )
        v11 = 32;
      if ( (v8 & 0x100000) != 0 )
        goto LABEL_14;
    }
  }
  png_ptr->flags |= 0x40u;
}
// 200F42: control flows out of bounds to 200F44
// 200EDC: variable 'v10' is possibly undefined
// 200EE2: variable 'v20' is possibly undefined
// 200EE6: variable 'v8' is possibly undefined

//----- (00200F7C) --------------------------------------------------------
int __fastcall png_inflate(
        png_structrp_6 png_ptr,
        png_uint_32 owner,
        int finish,
        png_const_bytep input,
        png_uint_32p input_size_ptr,
        png_bytep output,
        png_alloc_size_t *output_size_ptr)
{
  uInt v9; // r1
  uInt v10; // r0
  uInt v11; // r1
  int v12; // r5
  bool v13; // zf
  uInt v14; // r9
  int v15; // r1
  uInt avail_in; // r0
  uInt v17; // r1
  _BYTE v19[1024]; // [sp+0h] [bp-420h] BYREF

  if ( png_ptr->zowner == owner )
  {
    v9 = *(_DWORD *)input;
    v10 = *(_DWORD *)output;
    png_ptr->zstream.avail_out = 0;
    *(_QWORD *)&png_ptr->zstream.next_in = (unsigned int)finish;
    if ( !input_size_ptr )
    {
      png_ptr->zstream.next_out = v19;
      png_ptr->zstream.avail_in = v9;
      goto LABEL_6;
    }
    png_ptr->zstream.next_out = (Bytef *)input_size_ptr;
    png_ptr->zstream.avail_in = v9;
    v11 = -1;
    while ( 1 )
    {
      if ( v10 < v11 )
        v11 = v10;
      v14 = v10 - v11;
      v13 = v10 == v11;
      png_ptr->zstream.avail_out = v11;
      v15 = 0;
      if ( v13 )
        v15 = 4;
      v12 = j_inflate((z_streamp_1)&png_ptr->zstream, v15);
      if ( v12 )
        break;
      v10 = png_ptr->zstream.avail_out + v14;
      if ( input_size_ptr )
      {
        v11 = -1;
      }
      else
      {
        png_ptr->zstream.next_out = v19;
LABEL_6:
        v11 = 1024;
      }
    }
    if ( !input_size_ptr )
      png_ptr->zstream.next_out = 0;
    avail_in = png_ptr->zstream.avail_in;
    v17 = png_ptr->zstream.avail_out + v14;
    if ( v17 )
      *(_DWORD *)output -= v17;
    if ( avail_in )
      *(_DWORD *)input -= avail_in;
    j_png_zstream_error(png_ptr, v12);
  }
  else
  {
    v12 = -2;
    png_ptr->zstream.msg = "zstream unclaimed";
  }
  return v12;
}

//----- (00201090) --------------------------------------------------------
void __fastcall png_read_filter_row_sub(png_row_infop row_info, png_bytep row, png_const_bytep prev_row)
{
  png_size_t rowbytes; // r2
  unsigned int v4; // r0
  unsigned int v5; // r3
  unsigned int v6; // r12
  png_byte *v7; // r0
  unsigned int v8; // lr
  unsigned int v9; // r4
  unsigned int v10; // r5
  int8x16_t *v11; // r6
  int8x16_t v12; // q8
  png_size_t v13; // r2

  rowbytes = row_info->rowbytes;
  v4 = row_info->pixel_depth + 7;
  if ( rowbytes <= v4 >> 3 )
    return;
  v5 = v4 >> 3;
  v6 = rowbytes - (v4 >> 3);
  v7 = &row[v4 >> 3];
  if ( v6 < 0x10 || (v8 = v6 & 0xFFFFFFF0, (v6 & 0xFFFFFFF0) == 0) )
  {
    v9 = v5;
LABEL_11:
    v13 = rowbytes - v9;
    do
    {
      --v13;
      *v7 += v7[-v5];
      ++v7;
    }
    while ( v13 );
    return;
  }
  if ( v7 < &row[v6] )
  {
    v9 = v5;
    if ( &row[rowbytes] > row )
      goto LABEL_11;
  }
  v9 = v5 + v8;
  v7 += v8;
  v10 = v6 & 0xFFFFFFF0;
  do
  {
    v11 = (int8x16_t *)&row[v5];
    v12 = *(int8x16_t *)row;
    row += 16;
    v10 -= 16;
    *v11 = vaddq_s8(v12, *v11);
  }
  while ( v10 );
  if ( v6 != v8 )
    goto LABEL_11;
}

//----- (0020110C) --------------------------------------------------------
void __fastcall png_read_filter_row_up(png_row_infop row_info, png_bytep row, png_const_bytep prev_row)
{
  png_size_t rowbytes; // lr
  unsigned int v4; // r12
  bool v5; // cc
  png_bytep v6; // r0
  png_const_bytep v7; // r3
  unsigned int v8; // r4
  int8x16_t v9; // q9
  png_size_t v10; // r1
  char v11; // t1

  rowbytes = row_info->rowbytes;
  if ( rowbytes )
  {
    if ( rowbytes < 0x10 )
      goto LABEL_11;
    v4 = rowbytes & 0xFFFFFFF0;
    if ( (rowbytes & 0xFFFFFFF0) == 0 )
      goto LABEL_11;
    v5 = &prev_row[rowbytes] > row;
    if ( &prev_row[rowbytes] > row )
      v5 = &row[rowbytes] > prev_row;
    if ( v5 )
    {
LABEL_11:
      v4 = 0;
      v7 = prev_row;
      v6 = row;
LABEL_12:
      v10 = rowbytes - v4;
      do
      {
        --v10;
        v11 = *v7++;
        *v6++ += v11;
      }
      while ( v10 );
      return;
    }
    v6 = &row[v4];
    v7 = &prev_row[v4];
    v8 = rowbytes & 0xFFFFFFF0;
    do
    {
      v8 -= 16;
      v9 = *(int8x16_t *)prev_row;
      prev_row += 16;
      *(int8x16_t *)row = vaddq_s8(v9, *(int8x16_t *)row);
      row += 16;
    }
    while ( v8 );
    if ( rowbytes != v4 )
      goto LABEL_12;
  }
}

//----- (0020117E) --------------------------------------------------------
void __fastcall png_read_filter_row_avg(png_row_infop row_info, png_bytep row, png_const_bytep prev_row)
{
  png_size_t rowbytes; // r12
  unsigned int v4; // r3
  unsigned int v5; // lr
  unsigned int v6; // r10
  png_const_bytep v7; // r0
  int v8; // r8
  bool v9; // cc
  png_const_bytep v10; // r6
  png_bytep v11; // r4
  int v12; // r5
  uint8x16_t *v13; // r3
  uint8x16_t v14; // q8
  unsigned int v15; // r2
  unsigned int v16; // t1
  unsigned int v17; // r9
  unsigned int v18; // r8
  _BOOL4 v19; // r5
  _BOOL4 v20; // r6
  bool v21; // zf
  unsigned __int8 *v22; // r6
  png_bytep v23; // r5
  unsigned int v24; // r4
  uint8x8_t v25; // d18
  uint8x8_t v26; // d19
  uint16x8_t v27; // q11
  int16x8_t v28; // q9
  uint16x8_t v29; // q13
  uint16x8_t v30; // q8
  uint16x8_t v31; // q12
  int16x8_t v32; // q10
  uint32x4_t v33; // q15
  uint32x4_t v34; // q0
  uint32x4_t v35; // q14
  uint32x4_t v36; // q11
  uint32x4_t v37; // q12
  uint32x4_t v38; // q13
  int32x4_t v39; // q8
  png_size_t v40; // r0
  int v41; // t1

  rowbytes = row_info->rowbytes;
  v4 = row_info->pixel_depth + 7;
  v5 = rowbytes - (v4 >> 3);
  v6 = v4 >> 3;
  if ( !(v4 >> 3) )
  {
    v7 = prev_row;
    if ( !v5 )
      return;
    goto LABEL_17;
  }
  v7 = &prev_row[v6];
  if ( v4 <= 0x7F )
    goto LABEL_11;
  v8 = (v4 >> 3) & 0x30;
  if ( (v6 & 0x30) == 0 )
    goto LABEL_11;
  v9 = v7 > row;
  if ( v7 > row )
    v9 = &row[v6] > prev_row;
  if ( v9 )
  {
LABEL_11:
    v8 = 0;
    v11 = row;
    v10 = prev_row;
LABEL_12:
    v15 = v6 - v8;
    do
    {
      v16 = *v10++;
      --v15;
      *v11++ += v16 >> 1;
    }
    while ( v15 );
    goto LABEL_14;
  }
  v10 = &prev_row[v8];
  v11 = &row[v8];
  v12 = (v4 >> 3) & 0x30;
  v13 = (uint8x16_t *)row;
  do
  {
    v14 = *(uint8x16_t *)prev_row;
    prev_row += 16;
    v12 -= 16;
    *v13 = vsraq_n_u8(*v13, v14, 1u);
    ++v13;
  }
  while ( v12 );
  if ( v6 != v8 )
    goto LABEL_12;
LABEL_14:
  row += v6;
  if ( !v5 )
    return;
LABEL_17:
  if ( v5 <= 0xF )
  {
    v17 = 0;
LABEL_28:
    v23 = row;
    v22 = (unsigned __int8 *)v7;
LABEL_29:
    v40 = rowbytes - v17 - v6;
    do
    {
      --v40;
      v41 = *v22++;
      *v23 += ((unsigned int)v23[-v6] + v41) >> 1;
      ++v23;
    }
    while ( v40 );
    return;
  }
  v18 = v5 & 0xFFFFFFF0;
  v17 = 0;
  if ( (v5 & 0xFFFFFFF0) == 0 )
    goto LABEL_28;
  v19 = v7 < &row[v5];
  v20 = row < &v7[v5];
  v21 = !v20 || !v19;
  if ( !v20 || !v19 )
    v21 = &row[-v6] >= &row[v5] || row >= &row[rowbytes - 2 * v6];
  if ( !v21 )
    goto LABEL_28;
  v17 = v5 & 0xFFFFFFF0;
  v22 = (unsigned __int8 *)&v7[v18];
  v23 = &row[v18];
  v24 = v5 & 0xFFFFFFF0;
  do
  {
    v25.n64_u64[0] = *(unsigned __int64 *)v7;
    v26.n64_u64[0] = (unsigned __int64)*((uint8x8_t *)v7 + 1);
    v7 += 16;
    v24 -= 16;
    v27 = vmovl_u8(v26);
    v28 = vmovl_u8(v25);
    v29 = vmovl_u8(*((uint8x8_t *)row + 1));
    v30 = vmovl_u8(*(uint8x8_t *)row);
    v31 = vmovl_u8(*(uint8x8_t *)&row[-v6 + 8]);
    v32 = vmovl_u8(*(uint8x8_t *)&row[-v6]);
    v33 = vmovl_u16(*(uint16x4_t *)&v29.n128_i8[8]);
    v34 = vmovl_u16(*(uint16x4_t *)&v30.n128_i8[8]);
    v35 = vaddl_u16(*(uint16x4_t *)&v31.n128_i8[8], *(uint16x4_t *)&v27.n128_i8[8]);
    v36 = vaddl_u16((uint16x4_t)v31.n128_u64[0], (uint16x4_t)v27.n128_u64[0]);
    v37 = vmovl_u16((uint16x4_t)v29.n128_u64[0]);
    v38 = vaddl_u16(*(uint16x4_t *)&v32.n128_i8[8], *(uint16x4_t *)&v28.n128_i8[8]);
    v39 = vsraq_n_u32(
            vmovl_u16((uint16x4_t)v30.n128_u64[0]),
            vaddl_u16((uint16x4_t)v32.n128_u64[0], (uint16x4_t)v28.n128_u64[0]),
            1u);
    *(int16x4_t *)&v28.n128_i8[8] = vmovn_s32(vsraq_n_u32(v33, v35, 1u));
    *(int16x4_t *)&v32.n128_i8[8] = vmovn_s32(vsraq_n_u32(v34, v38, 1u));
    v28.n128_u64[0] = vmovn_s32(vsraq_n_u32(v37, v36, 1u)).n64_u64[0];
    v32.n128_u64[0] = vmovn_s32(v39).n64_u64[0];
    *(int8x8_t *)row = vmovn_s16(v32);
    *((int8x8_t *)row + 1) = vmovn_s16(v28);
    row += 16;
  }
  while ( v24 );
  if ( v5 != v18 )
    goto LABEL_29;
}

//----- (00201322) --------------------------------------------------------
void __fastcall png_read_filter_row_paeth_1byte_pixel(png_row_infop row_info, png_bytep row, png_const_bytep prev_row)
{
  int v3; // r3
  signed int rowbytes; // r6
  png_byte v5; // r0
  png_byte *v6; // r12
  png_const_bytep v7; // lr
  png_bytep v8; // r1
  int v9; // r8
  int v10; // t1
  int v11; // r2
  int v12; // r4
  int v13; // r6
  int v14; // r5
  int v15; // r2

  v3 = *prev_row;
  rowbytes = row_info->rowbytes;
  v5 = *row + v3;
  *row = v5;
  if ( rowbytes >= 2 )
  {
    v6 = &row[rowbytes];
    v7 = prev_row + 1;
    v8 = row + 1;
    do
    {
      v10 = *v7++;
      v9 = v10;
      v11 = v5 - v3;
      v12 = v10 - v3;
      v13 = v11;
      if ( v11 < 0 )
        v13 = v3 - v5;
      v14 = v12;
      if ( v12 < 0 )
        v14 = -v12;
      if ( v13 < v14 )
      {
        v5 = v9;
        v14 = v13;
      }
      v15 = v11 + v12;
      if ( v15 < 0 )
        v15 = -v15;
      if ( v15 < v14 )
        v5 = v3;
      v3 = v9;
      v5 += *v8;
      *v8++ = v5;
    }
    while ( v8 < v6 );
  }
}

//----- (00201384) --------------------------------------------------------
void __fastcall png_read_filter_row_paeth_multibyte_pixel(
        png_row_infop row_info,
        png_bytep row,
        png_const_bytep prev_row)
{
  unsigned int v3; // r8
  png_bytep v4; // r5
  png_byte *v5; // r6
  png_bytep v6; // r3
  int v7; // r9
  unsigned int v8; // lr
  const png_byte *v9; // r3
  bool v10; // cc
  int64x2_t *v11; // r12
  int8x16_t *v12; // r3
  unsigned int v13; // r4
  int8x16_t *v14; // r5
  int8x16_t v15; // q9
  unsigned __int8 v16; // t1
  png_size_t rowbytes; // r5
  png_byte *v18; // lr
  png_size_t v19; // r6
  unsigned int v20; // r0
  unsigned int v21; // r4
  int v22; // r11
  char v23; // r10
  _BOOL4 v24; // r5
  png_byte *v25; // r0
  char v26; // r4
  int8x16_t *v27; // r0
  bool v28; // zf
  int64x2_t *v29; // r10
  int8x16_t *v30; // r8
  unsigned int v31; // r6
  int64x2_t v32; // q10
  int64x2_t v33; // q9
  int64x2_t v34; // q13
  uint16x8_t v35; // q4
  int64x2_t v36; // q11
  uint16x8_t v37; // q12
  uint16x8_t v38; // q3
  uint16x8_t v39; // q15
  uint16x8_t v40; // q5
  int32x4_t v41; // q1
  int32x4_t v42; // q2
  int32x4_t v43; // q0
  int32x4_t v44; // q7
  int16x8_t v45; // q1
  int32x4_t v46; // q6
  int32x4_t v47; // q2
  int32x4_t v48; // q0
  int32x4_t v49; // q8
  int16x8_t v50; // q14
  int32x4_t v51; // q3
  int16x8_t v52; // q8
  int32x4_t v53; // q4
  int32x4_t v54; // q12
  int v55; // r3
  int v56; // r6
  int v57; // r2
  int v58; // r0
  int v59; // r5
  int v60; // r4
  int v61; // r0
  unsigned int v62; // [sp+8h] [bp-90h]
  unsigned int v63; // [sp+Ch] [bp-8Ch]
  int32x4_t v64; // [sp+10h] [bp-88h]
  _BOOL4 v65; // [sp+20h] [bp-78h]

  v3 = row_info->pixel_depth + 7;
  if ( !(v3 >> 3) )
  {
    v11 = (int64x2_t *)prev_row;
    v12 = (int8x16_t *)row;
    goto LABEL_19;
  }
  v4 = row + 1;
  v5 = &row[v3 >> 3];
  v6 = row + 1;
  if ( v5 > row + 1 )
    v6 = &row[v3 >> 3];
  v7 = v6 - row;
  if ( (unsigned int)(v6 - row) < 0x10 )
    goto LABEL_15;
  v8 = v7 & 0xFFFFFFF0;
  if ( (v7 & 0xFFFFFFF0) == 0 )
    goto LABEL_15;
  if ( v5 > v4 )
    v4 = &row[v3 >> 3];
  v9 = &prev_row[v4 - row];
  v10 = v9 > row;
  if ( v9 > row )
    v10 = v4 > prev_row;
  if ( v10 )
  {
LABEL_15:
    v12 = (int8x16_t *)row;
    v11 = (int64x2_t *)prev_row;
    do
    {
LABEL_16:
      v16 = v11->n128_u8[0];
      v11 = (int64x2_t *)((char *)v11 + 1);
      v12->n128_u8[0] += v16;
      v12 = (int8x16_t *)((char *)v12 + 1);
    }
    while ( v12 < (int8x16_t *)v5 );
    goto LABEL_19;
  }
  v11 = (int64x2_t *)&prev_row[v8];
  v12 = (int8x16_t *)&row[v8];
  v13 = v7 & 0xFFFFFFF0;
  v14 = (int8x16_t *)row;
  do
  {
    v13 -= 16;
    v15 = *(int8x16_t *)prev_row;
    prev_row += 16;
    *v14 = vaddq_s8(v15, *v14);
    ++v14;
  }
  while ( v13 );
  if ( v7 != v8 )
    goto LABEL_16;
LABEL_19:
  rowbytes = row_info->rowbytes;
  v18 = &row[rowbytes];
  if ( v12 >= (int8x16_t *)&row[rowbytes] )
    return;
  v19 = rowbytes - (_DWORD)v12;
  v20 = v3 >> 3;
  v21 = (unsigned int)&row[rowbytes - (_DWORD)v12];
  v22 = -(v3 >> 3);
  if ( v21 < 0x10 || (v21 & 0xFFFFFFF0) == 0 )
    goto LABEL_35;
  v62 = v21 & 0xFFFFFFF0;
  v23 = 0;
  v65 = (char *)v12 - (v3 >> 3) < (char *)v18;
  v24 = v12 < (int8x16_t *)&row[rowbytes - v20];
  v63 = v21;
  v25 = &row[v19 - v20];
  if ( v12 < (int64x2_t *)((char *)v11 + v21) )
    v23 = 1;
  v26 = 0;
  v27 = (int64x2_t *)((char *)v11 + (_DWORD)v25);
  if ( (char *)v11 - (v3 >> 3) < (char *)v18 )
    v26 = 1;
  if ( ((v12 < v27) & (unsigned __int8)v26) != 0 )
    goto LABEL_35;
  v28 = !v65 || !v24;
  if ( !v65 || !v24 )
    v28 = ((unsigned __int8)v23 & (v11 < (int64x2_t *)v18)) == 0;
  if ( v28 )
  {
    v29 = (int64x2_t *)((char *)v11 + v62);
    v30 = (int8x16_t *)((char *)v12 + v62);
    v31 = v62;
    do
    {
      v31 -= 16;
      v32 = *(int8x16_t *)((char *)v12 + v22);
      v33 = *(int64x2_t *)((char *)v11 + v22);
      v34 = vmovl_u8((uint8x8_t)v32.n128_u64[0]);
      v35 = vmovl_u8(*(uint8x8_t *)&v32.n128_i8[8]);
      v36 = *v11++;
      v37 = vmovl_u8((uint8x8_t)v33.n128_u64[0]);
      v38 = vmovl_u8(*(uint8x8_t *)&v33.n128_i8[8]);
      v39 = vmovl_u8((uint8x8_t)v36.n128_u64[0]);
      v40 = vmovl_u8(*(uint8x8_t *)&v36.n128_i8[8]);
      v41 = vabdl_u16(*(uint16x4_t *)&v39.n128_i8[8], *(uint16x4_t *)&v37.n128_i8[8]);
      v42 = vabdl_u16(*(uint16x4_t *)&v34.n128_i8[8], *(uint16x4_t *)&v37.n128_i8[8]);
      v43 = vminq_s32(v42, v41);
      v44 = vabdl_u16((uint16x4_t)v40.n128_u64[0], (uint16x4_t)v38.n128_u64[0]);
      v45 = vcgtq_s32(v41, v42);
      v46 = vabdl_u16((uint16x4_t)v35.n128_u64[0], (uint16x4_t)v38.n128_u64[0]);
      v64 = vcgtq_s32(
              v43,
              vabsq_s32(
                vaddq_s32(
                  vsubl_u16(*(uint16x4_t *)&v39.n128_i8[8], *(uint16x4_t *)&v37.n128_i8[8]),
                  vsubl_u16(*(uint16x4_t *)&v34.n128_i8[8], *(uint16x4_t *)&v37.n128_i8[8]))));
      v47 = vabdl_u16((uint16x4_t)v34.n128_u64[0], (uint16x4_t)v37.n128_u64[0]);
      *(int16x4_t *)&v45.n128_i8[8] = vmovn_s32(v45);
      v48 = vcgtq_s32(
              vminq_s32(v46, v44),
              vabsq_s32(
                vaddq_s32(
                  vsubl_u16((uint16x4_t)v40.n128_u64[0], (uint16x4_t)v38.n128_u64[0]),
                  vsubl_u16((uint16x4_t)v35.n128_u64[0], (uint16x4_t)v38.n128_u64[0]))));
      v49 = vaddq_s32(
              vsubl_u16(*(uint16x4_t *)&v40.n128_i8[8], *(uint16x4_t *)&v38.n128_i8[8]),
              vsubl_u16(*(uint16x4_t *)&v35.n128_i8[8], *(uint16x4_t *)&v38.n128_i8[8]));
      v50 = vabdl_u16(*(uint16x4_t *)&v35.n128_i8[8], *(uint16x4_t *)&v38.n128_i8[8]);
      v51 = vabdl_u16(*(uint16x4_t *)&v40.n128_i8[8], *(uint16x4_t *)&v38.n128_i8[8]);
      v52 = vcgtq_s32(vminq_s32(v50, v51), vabsq_s32(v49));
      v53 = vabdl_u16((uint16x4_t)v39.n128_u64[0], (uint16x4_t)v37.n128_u64[0]);
      *(int16x4_t *)&v50.n128_i8[8] = vmovn_s32(vcgtq_s32(v51, v50));
      v50.n128_u64[0] = vmovn_s32(vcgtq_s32(v44, v46)).n64_u64[0];
      *(int16x4_t *)&v52.n128_i8[8] = vmovn_s32(v52);
      v54 = vcgtq_s32(
              vminq_s32(v47, v53),
              vabsq_s32(
                vaddq_s32(
                  vsubl_u16((uint16x4_t)v39.n128_u64[0], (uint16x4_t)v37.n128_u64[0]),
                  vsubl_u16((uint16x4_t)v34.n128_u64[0], (uint16x4_t)v37.n128_u64[0]))));
      *(int8x8_t *)&v34.n128_i8[8] = vmovn_s16(v50);
      v45.n128_u64[0] = vmovn_s32(vcgtq_s32(v53, v47)).n64_u64[0];
      v52.n128_u64[0] = vmovn_s32(v48).n64_u64[0];
      *(int16x4_t *)&v50.n128_i8[8] = vmovn_s32(v64);
      v34.n128_u64[0] = vmovn_s16(v45).n64_u64[0];
      v50.n128_u64[0] = vmovn_s32(v54).n64_u64[0];
      *(int8x8_t *)&v52.n128_i8[8] = vmovn_s16(v52);
      v52.n128_u64[0] = vmovn_s16(v50).n64_u64[0];
      *v12 = vaddq_s8(vbslq_s64(v52, v33, vbslq_s64(v34, v36, v32)), *v12);
      ++v12;
    }
    while ( v31 );
    if ( v62 == v63 )
      return;
  }
  else
  {
LABEL_35:
    v30 = v12;
    v29 = v11;
  }
  do
  {
    v55 = v29->n128_u8[v22];
    v56 = v30->n128_u8[v22];
    v57 = v29->n128_u8[0];
    v58 = v56 - v55;
    v29 = (int64x2_t *)((char *)v29 + 1);
    v59 = v56 - v55;
    if ( v56 - v55 < 0 )
      v59 = v55 - v56;
    v60 = v57 - v55;
    if ( v57 - v55 < 0 )
      v60 = v55 - v57;
    if ( v59 < v60 )
    {
      LOBYTE(v56) = v57;
      v60 = v59;
    }
    v61 = v58 + v57 - v55;
    if ( v61 < 0 )
      v61 = -v61;
    if ( v61 < v60 )
      LOBYTE(v56) = v55;
    v30->n128_u8[0] += v56;
    v30 = (int8x16_t *)((char *)v30 + 1);
  }
  while ( v18 != (png_byte *)v30 );
}

//----- (00201644) --------------------------------------------------------
void __fastcall png_set_bKGD(png_const_structrp_5 png_ptr, png_inforp_5 info_ptr, png_const_color_16p background)
{
  bool v3; // zf
  __int64 v4; // d16
  png_uint_32 v5; // r0
  png_uint_16 gray; // r2

  if ( png_ptr )
  {
    v3 = info_ptr == 0;
    if ( info_ptr )
      v3 = background == 0;
    if ( !v3 )
    {
      v4 = *(_QWORD *)&background->index;
      v5 = info_ptr->valid | 0x20;
      gray = background->gray;
      *(_QWORD *)&info_ptr->background.index = v4;
      info_ptr->background.gray = gray;
      info_ptr->valid = v5;
    }
  }
}

//----- (0020166E) --------------------------------------------------------
void __fastcall png_set_cHRM_fixed(
        png_const_structrp_5 png_ptr,
        png_inforp_5 info_ptr,
        png_fixed_point white_x,
        png_fixed_point white_y,
        __int64 red_x,
        png_fixed_point green_x,
        png_fixed_point green_y,
        png_fixed_point blue_x,
        png_fixed_point blue_y)
{
  bool v10; // zf
  png_xy_0 v12; // [sp+0h] [bp-30h] BYREF

  v10 = png_ptr == 0;
  if ( png_ptr )
    v10 = info_ptr == 0;
  if ( !v10 )
  {
    *(_QWORD *)&v12.redx = red_x;
    v12.greenx = green_x;
    v12.greeny = green_y;
    v12.bluex = blue_x;
    v12.bluey = blue_y;
    v12.whitex = white_x;
    v12.whitey = white_y;
    if ( j_png_colorspace_set_chromaticities(png_ptr, &info_ptr->colorspace, &v12, 2) )
      info_ptr->colorspace.flags |= 0x10u;
    j_png_colorspace_sync_info(png_ptr, info_ptr);
  }
}

//----- (002016D2) --------------------------------------------------------
void __fastcall png_set_cHRM_XYZ_fixed(
        png_const_structrp_5 png_ptr,
        png_inforp_5 info_ptr,
        png_fixed_point int_red_X,
        png_fixed_point int_red_Y,
        __int64 int_red_Z,
        __int64 int_green_Y,
        __int64 int_blue_X,
        png_fixed_point int_blue_Z)
{
  bool v9; // zf
  png_XYZ_0 XYZ_in; // [sp+4h] [bp-3Ch] BYREF

  v9 = png_ptr == 0;
  if ( png_ptr )
    v9 = info_ptr == 0;
  if ( !v9 )
  {
    XYZ_in.red_X = int_red_X;
    XYZ_in.red_Y = int_red_Y;
    *(_QWORD *)&XYZ_in.red_Z = int_red_Z;
    *(_QWORD *)&XYZ_in.green_Y = int_green_Y;
    *(_QWORD *)&XYZ_in.blue_X = int_blue_X;
    XYZ_in.blue_Z = int_blue_Z;
    if ( j_png_colorspace_set_endpoints(png_ptr, &info_ptr->colorspace, &XYZ_in, 2) )
      info_ptr->colorspace.flags |= 0x10u;
    j_png_colorspace_sync_info(png_ptr, info_ptr);
  }
}

//----- (0020173C) --------------------------------------------------------
void __fastcall png_set_cHRM(
        png_const_structrp_5 png_ptr,
        png_inforp_5 info_ptr,
        double white_x,
        double white_y,
        double red_x,
        double red_y,
        double green_x,
        double green_y,
        double blue_x,
        double blue_y)
{
  png_fixed_point v12; // r10
  png_fixed_point v13; // r11
  png_fixed_point v14; // r6
  png_fixed_point v15; // r8
  png_fixed_point v16; // r9
  png_fixed_point v17; // r0
  bool v18; // zf
  png_fixed_point v19; // [sp+4h] [bp-44h]
  png_fixed_point v20; // [sp+8h] [bp-40h]
  png_xy_0 xy; // [sp+Ch] [bp-3Ch] BYREF

  v20 = j_png_fixed(png_ptr, white_x, (png_const_charp)"cHRM White X");
  v19 = j_png_fixed(png_ptr, white_y, (png_const_charp)"cHRM White Y");
  v12 = j_png_fixed(png_ptr, red_x, (png_const_charp)"cHRM Red X");
  v13 = j_png_fixed(png_ptr, red_y, (png_const_charp)"cHRM Red Y");
  v14 = j_png_fixed(png_ptr, green_x, (png_const_charp)"cHRM Green X");
  v15 = j_png_fixed(png_ptr, green_y, (png_const_charp)"cHRM Green Y");
  v16 = j_png_fixed(png_ptr, blue_x, (png_const_charp)"cHRM Blue X");
  v17 = j_png_fixed(png_ptr, blue_y, (png_const_charp)"cHRM Blue Y");
  v18 = png_ptr == 0;
  if ( png_ptr )
    v18 = info_ptr == 0;
  if ( !v18 )
  {
    xy.redx = v12;
    xy.redy = v13;
    xy.greenx = v14;
    xy.greeny = v15;
    xy.bluex = v16;
    xy.bluey = v17;
    xy.whitex = v20;
    xy.whitey = v19;
    if ( j_png_colorspace_set_chromaticities(png_ptr, &info_ptr->colorspace, &xy, 2) )
      info_ptr->colorspace.flags |= 0x10u;
    j_png_colorspace_sync_info(png_ptr, info_ptr);
  }
}
// 20173C: using guessed type double arg_0;

//----- (00201854) --------------------------------------------------------
void __fastcall png_set_cHRM_XYZ(
        png_const_structrp_5 png_ptr,
        png_inforp_5 info_ptr,
        double red_X,
        double red_Y,
        double red_Z,
        double green_X,
        double green_Y,
        double green_Z,
        double blue_X,
        double blue_Y,
        double blue_Z)
{
  png_fixed_point v13; // r11
  png_fixed_point v14; // r6
  png_fixed_point v15; // r8
  png_fixed_point v16; // r9
  png_fixed_point v17; // r10
  png_fixed_point v18; // r0
  bool v19; // zf
  png_fixed_point v20; // [sp+4h] [bp-4Ch]
  png_fixed_point v21; // [sp+8h] [bp-48h]
  png_fixed_point v22; // [sp+Ch] [bp-44h]
  png_XYZ_0 XYZ_in; // [sp+10h] [bp-40h] BYREF

  v22 = j_png_fixed(png_ptr, red_X, (png_const_charp)"cHRM Red X");
  v21 = j_png_fixed(png_ptr, red_Y, (png_const_charp)"cHRM Red Y");
  v20 = j_png_fixed(png_ptr, red_Z, (png_const_charp)"cHRM Red Z");
  v13 = j_png_fixed(png_ptr, green_X, (png_const_charp)"cHRM Green X");
  v14 = j_png_fixed(png_ptr, green_Y, (png_const_charp)"cHRM Green Y");
  v15 = j_png_fixed(png_ptr, green_Z, (png_const_charp)"cHRM Green Z");
  v16 = j_png_fixed(png_ptr, blue_X, (png_const_charp)"cHRM Blue X");
  v17 = j_png_fixed(png_ptr, blue_Y, (png_const_charp)"cHRM Blue Y");
  v18 = j_png_fixed(png_ptr, blue_Z, (png_const_charp)"cHRM Blue Z");
  v19 = png_ptr == 0;
  if ( png_ptr )
    v19 = info_ptr == 0;
  if ( !v19 )
  {
    XYZ_in.red_Y = v21;
    XYZ_in.red_X = v22;
    XYZ_in.red_Z = v20;
    XYZ_in.green_X = v13;
    XYZ_in.green_Y = v14;
    XYZ_in.green_Z = v15;
    XYZ_in.blue_X = v16;
    XYZ_in.blue_Y = v17;
    XYZ_in.blue_Z = v18;
    if ( j_png_colorspace_set_endpoints(png_ptr, &info_ptr->colorspace, &XYZ_in, 2) )
      info_ptr->colorspace.flags |= 0x10u;
    j_png_colorspace_sync_info(png_ptr, info_ptr);
  }
}
// 201854: using guessed type double arg_0;

//----- (00201984) --------------------------------------------------------
void __fastcall png_set_eXIf(png_const_structrp_5 png_ptr, png_inforp_5 info_ptr, const png_bytep eXIf_buf)
{
  sub_194634(png_ptr, (png_const_charp)"png_set_eXIf does not work; use png_set_eXIf_1");
}

//----- (002019BC) --------------------------------------------------------
void __fastcall png_set_eXIf_1(
        png_const_structrp_5 png_ptr,
        png_inforp_5 info_ptr,
        const png_uint_32 num_exif,
        const png_bytep eXIf_buf)
{
  bool v5; // zf
  png_bytep exif; // r1
  png_byte *v10; // r0
  int v11; // r1
  int v12; // r0

  v5 = png_ptr == 0;
  if ( png_ptr )
    v5 = info_ptr == 0;
  if ( !v5 )
  {
    exif = info_ptr->exif;
    if ( exif )
    {
      j_png_free(png_ptr, exif);
      info_ptr->exif = 0;
    }
    info_ptr->num_exif = num_exif;
    v10 = (png_byte *)j_png_malloc_warn(png_ptr, num_exif);
    info_ptr->exif = v10;
    if ( v10 )
    {
      v11 = info_ptr->num_exif;
      info_ptr->free_me |= 0x8000u;
      if ( v11 >= 1 )
      {
        *v10 = *eXIf_buf;
        if ( info_ptr->num_exif >= 2 )
        {
          v12 = 1;
          do
          {
            info_ptr->exif[v12] = eXIf_buf[v12];
            ++v12;
          }
          while ( v12 < info_ptr->num_exif );
        }
      }
      info_ptr->valid |= 0x10000u;
    }
    else
    {
      sub_194634(png_ptr, (png_const_charp)"Insufficient memory for eXIf chunk data");
    }
  }
}

//----- (00201A74) --------------------------------------------------------
void __fastcall png_set_gAMA_fixed(png_const_structrp_5 png_ptr, png_inforp_5 info_ptr, png_fixed_point file_gamma)
{
  bool v4; // zf

  v4 = png_ptr == 0;
  if ( png_ptr )
    v4 = info_ptr == 0;
  if ( !v4 )
  {
    j_png_colorspace_set_gamma(png_ptr, &info_ptr->colorspace, file_gamma);
    sub_192360(png_ptr, info_ptr);
  }
}

//----- (00201A9C) --------------------------------------------------------
void __fastcall png_set_gAMA(png_const_structrp_5 png_ptr, png_inforp_5 info_ptr, double file_gamma)
{
  png_fixed_point v5; // r0
  bool v6; // zf

  v5 = j_png_fixed(png_ptr, file_gamma, (png_const_charp)"png_set_gAMA");
  v6 = png_ptr == 0;
  if ( png_ptr )
    v6 = info_ptr == 0;
  if ( !v6 )
  {
    j_png_colorspace_set_gamma(png_ptr, &info_ptr->colorspace, v5);
    sub_192360(png_ptr, info_ptr);
  }
}

//----- (00201AE8) --------------------------------------------------------
void __fastcall png_set_hIST(png_const_structrp_5 png_ptr, png_inforp_5 info_ptr, png_const_uint_16p hist)
{
  bool v4; // zf
  const char *v7; // r1
  png_uint_16 *v8; // r0
  int num_palette; // r2
  int v10; // r0

  v4 = png_ptr == 0;
  if ( png_ptr )
    v4 = info_ptr == 0;
  if ( !v4 )
  {
    if ( (unsigned __int16)(info_ptr->num_palette - 1) >= 0x100u )
    {
      v7 = "Invalid palette size, hIST allocation skipped";
LABEL_14:
      sub_194634(png_ptr, (png_const_charp)v7);
      return;
    }
    j_png_free_data(png_ptr, info_ptr, 8u, 0);
    v8 = (png_uint_16 *)j_png_malloc_warn(png_ptr, 0x200u);
    info_ptr->hist = v8;
    if ( !v8 )
    {
      v7 = "Insufficient memory for hIST chunk data";
      goto LABEL_14;
    }
    num_palette = info_ptr->num_palette;
    info_ptr->free_me |= 8u;
    if ( num_palette )
    {
      *v8 = *hist;
      if ( info_ptr->num_palette >= 2u )
      {
        v10 = 1;
        do
        {
          info_ptr->hist[v10] = hist[v10];
          ++v10;
        }
        while ( v10 < info_ptr->num_palette );
      }
    }
    info_ptr->valid |= 0x40u;
  }
}

//----- (00201BD4) --------------------------------------------------------
void __fastcall png_set_IHDR(
        png_const_structrp_5 png_ptr,
        png_inforp_5 info_ptr,
        png_uint_32 width,
        png_uint_32 height,
        int bit_depth,
        int color_type,
        int interlace_type,
        int compression_type,
        int filter_type)
{
  bool v9; // zf
  int v12; // r1
  png_byte v13; // r0
  png_byte v14; // r1
  png_byte v15; // r1
  png_uint_32 v16; // r0

  v9 = png_ptr == 0;
  if ( png_ptr )
    v9 = info_ptr == 0;
  if ( !v9 )
  {
    info_ptr->width = width;
    info_ptr->height = height;
    info_ptr->bit_depth = bit_depth;
    info_ptr->color_type = color_type;
    info_ptr->compression_type = compression_type;
    info_ptr->filter_type = filter_type;
    info_ptr->interlace_type = interlace_type;
    j_png_check_IHDR(
      png_ptr,
      width,
      height,
      (unsigned __int8)bit_depth,
      (unsigned __int8)color_type,
      (unsigned __int8)interlace_type,
      (unsigned __int8)compression_type,
      (unsigned __int8)filter_type);
    v12 = info_ptr->color_type;
    if ( v12 == 3 )
    {
      v13 = 1;
    }
    else
    {
      v13 = v12 & 2 | 1;
      if ( (v12 & 4) != 0 )
        ++v13;
    }
    v14 = info_ptr->bit_depth;
    info_ptr->channels = v13;
    v15 = v14 * v13;
    info_ptr->pixel_depth = v15;
    if ( v15 < 8u )
      v16 = (v15 * width + 7) >> 3;
    else
      v16 = (v15 >> 3) * width;
    info_ptr->rowbytes = v16;
  }
}

//----- (00201C6C) --------------------------------------------------------
void __fastcall png_set_oFFs(png_const_structrp_5 png_ptr, png_inforp_5 info_ptr, __int64 offset_x, int unit_type)
{
  png_uint_32 valid; // r2

  if ( png_ptr )
  {
    if ( info_ptr )
    {
      *(_QWORD *)&info_ptr->x_offset = offset_x;
      valid = info_ptr->valid;
      info_ptr->offset_unit_type = unit_type;
      info_ptr->valid = valid | 0x100;
    }
  }
}

//----- (00201C8C) --------------------------------------------------------
void __fastcall png_set_pCAL(
        png_const_structrp_5 png_ptr,
        png_inforp_5 info_ptr,
        png_const_charp purpose,
        png_int_32 X0,
        png_int_32 X1,
        int type,
        int nparams,
        png_const_charp units,
        png_charpp params)
{
  const char *v9; // r10
  bool v11; // zf
  bool v15; // zf
  size_t v16; // r1
  const char *v17; // r1
  size_t v18; // r6
  int v19; // r8
  const unsigned __int8 *v20; // r5
  size_t v21; // r0
  unsigned __int8 *v22; // r0
  png_alloc_size_t v23; // r4
  unsigned __int8 *v24; // r0
  unsigned __int8 **v25; // r0
  int v26; // r5
  png_alloc_size_t v27; // r4
  unsigned __int8 *v28; // r0
  png_uint_32 free_me; // r1
  const char *v30; // r1
  png_int_32 v31; // [sp+0h] [bp-30h]

  v11 = png_ptr == 0;
  if ( png_ptr )
    v11 = info_ptr == 0;
  if ( v11 )
    return;
  v15 = purpose == 0;
  if ( purpose )
  {
    v9 = (const char *)units;
    v15 = units == 0;
  }
  if ( v15 || nparams >= 1 && !params )
    return;
  v16 = strlen((const char *)purpose);
  if ( (unsigned int)type >= 4 )
  {
    v17 = "Invalid pCAL equation type";
LABEL_29:
    sub_18A980(png_ptr, (png_const_charp)v17, 1);
    return;
  }
  if ( (unsigned int)nparams > 0xFF )
  {
    v17 = "Invalid pCAL parameter count";
    goto LABEL_29;
  }
  v18 = v16;
  v31 = X0;
  if ( nparams )
  {
    v19 = 0;
    while ( 1 )
    {
      v20 = params[v19];
      if ( !v20 )
        break;
      v21 = strlen((const char *)params[v19]);
      if ( !j_png_check_fp_string(v20, v21) )
        break;
      if ( ++v19 >= nparams )
        goto LABEL_19;
    }
    v17 = "Invalid format for pCAL parameter";
    goto LABEL_29;
  }
LABEL_19:
  v22 = (unsigned __int8 *)j_png_malloc_warn(png_ptr, v18 + 1);
  info_ptr->pcal_purpose = v22;
  if ( !v22 )
  {
    v17 = "Insufficient memory for pCAL purpose";
    goto LABEL_29;
  }
  qmemcpy(v22, purpose, v18 + 1);
  info_ptr->pcal_X0 = v31;
  info_ptr->pcal_X1 = X1;
  info_ptr->pcal_type = type;
  info_ptr->pcal_nparams = nparams;
  v23 = strlen(v9) + 1;
  v24 = (unsigned __int8 *)j_png_malloc_warn(png_ptr, v23);
  info_ptr->pcal_units = v24;
  if ( v24 )
  {
    qmemcpy(v24, v9, v23);
    v25 = (unsigned __int8 **)j_png_malloc_warn(png_ptr, 4 * nparams + 4);
    info_ptr->pcal_params = v25;
    if ( v25 )
    {
      memset(v25, 0, 4 * nparams + 4);
      if ( nparams < 1 )
      {
LABEL_26:
        free_me = info_ptr->free_me;
        info_ptr->valid |= 0x400u;
        info_ptr->free_me = free_me | 0x80;
        return;
      }
      v26 = 0;
      while ( 1 )
      {
        v27 = strlen((const char *)params[v26]) + 1;
        info_ptr->pcal_params[v26] = (unsigned __int8 *)j_png_malloc_warn(png_ptr, v27);
        v28 = info_ptr->pcal_params[v26];
        if ( !v28 )
          break;
        qmemcpy(v28, params[v26++], v27);
        if ( v26 >= nparams )
          goto LABEL_26;
      }
      v30 = "Insufficient memory for pCAL parameter";
    }
    else
    {
      v30 = "Insufficient memory for pCAL params";
    }
  }
  else
  {
    v30 = "Insufficient memory for pCAL units";
  }
  sub_194634(png_ptr, (png_const_charp)v30);
}
// 201D5E: variable 'v9' is possibly undefined

//----- (00201EC0) --------------------------------------------------------
void __fastcall png_set_sCAL_s(
        png_const_structrp_5 png_ptr,
        png_inforp_5 info_ptr,
        int unit,
        png_const_charp swidth,
        const char *a5)
{
  bool v6; // zf
  png_byte v9; // r4
  size_t v10; // r11
  bool v11; // zf
  size_t v12; // r5
  bool v13; // zf
  unsigned __int8 *v14; // r0
  unsigned __int8 *v15; // r0
  png_uint_32 free_me; // r1

  v6 = png_ptr == 0;
  v9 = unit;
  if ( png_ptr )
    v6 = info_ptr == 0;
  if ( !v6 )
  {
    if ( (unsigned int)(unit - 1) < 2 )
    {
      if ( !swidth )
        goto LABEL_21;
      v10 = strlen((const char *)swidth);
      v11 = v10 == 0;
      if ( v10 )
        v11 = *swidth == 45;
      if ( !v11 && j_png_check_fp_string(swidth, v10) )
      {
        if ( a5 )
        {
          v12 = strlen(a5);
          v13 = v12 == 0;
          if ( v12 )
            v13 = *a5 == 45;
          if ( !v13 && j_png_check_fp_string((png_const_charp)a5, v12) )
          {
            info_ptr->scal_unit = v9;
            v14 = (unsigned __int8 *)j_png_malloc_warn(png_ptr, v10 + 1);
            info_ptr->scal_s_width = v14;
            if ( v14 )
            {
              qmemcpy(v14, swidth, v10 + 1);
              v15 = (unsigned __int8 *)j_png_malloc_warn(png_ptr, v12 + 1);
              info_ptr->scal_s_height = v15;
              if ( v15 )
              {
                qmemcpy(v15, a5, v12 + 1);
                free_me = info_ptr->free_me;
                info_ptr->valid |= 0x4000u;
                info_ptr->free_me = free_me | 0x100;
                return;
              }
              j_png_free(png_ptr, info_ptr->scal_s_width);
              info_ptr->scal_s_width = 0;
            }
            sub_194634(png_ptr, (png_const_charp)"Memory allocation failed while processing sCAL");
            return;
          }
        }
      }
      else
      {
LABEL_21:
        j_png_error(png_ptr, (png_const_charp)"Invalid sCAL width");
      }
      j_png_error(png_ptr, (png_const_charp)"Invalid sCAL height");
    }
    j_png_error(png_ptr, (png_const_charp)"Invalid sCAL unit");
    JUMPOUT(0x201FC8);
  }
}
// 201FC6: control flows out of bounds to 201FC8

//----- (00202034) --------------------------------------------------------
void __fastcall png_set_sCAL(
        png_const_structrp_5 png_ptr,
        png_inforp_5 info_ptr,
        int unit,
        int a4,
        double width,
        double height)
{
  int v9; // r3
  const char *v10; // r1
  unsigned __int8 v11[18]; // [sp+10h] [bp-48h] BYREF
  unsigned __int8 ascii[8]; // [sp+22h] [bp-36h] BYREF

  if ( width <= 0.0 )
  {
    v10 = "Invalid sCAL width ignored";
  }
  else
  {
    if ( height > 0.0 )
    {
      j_png_ascii_from_fp(png_ptr, ascii, 0x12u, a4, width, 5u);
      j_png_ascii_from_fp(png_ptr, v11, 0x12u, v9, height, 5u);
      j_png_set_sCAL_s(png_ptr, info_ptr, unit, ascii, (const char *)v11);
      return;
    }
    v10 = "Invalid sCAL height ignored";
  }
  sub_194634(png_ptr, (png_const_charp)v10);
}
// 20209A: variable 'v9' is possibly undefined

//----- (00202120) --------------------------------------------------------
void __fastcall png_set_sCAL_fixed(
        png_const_structrp_5 png_ptr,
        png_inforp_5 info_ptr,
        int unit,
        png_fixed_point width,
        png_fixed_point a5)
{
  const char *v8; // r1
  unsigned __int8 v9[18]; // [sp+8h] [bp-40h] BYREF
  unsigned __int8 ascii[8]; // [sp+1Ah] [bp-2Eh] BYREF

  if ( width <= 0 )
  {
    v8 = "Invalid sCAL width ignored";
  }
  else
  {
    if ( a5 > 0 )
    {
      j_png_ascii_from_fixed(png_ptr, ascii, 0x12u, width);
      j_png_ascii_from_fixed(png_ptr, v9, 0x12u, a5);
      j_png_set_sCAL_s(png_ptr, info_ptr, unit, ascii, (const char *)v9);
      return;
    }
    v8 = "Invalid sCAL height ignored";
  }
  sub_194634(png_ptr, (png_const_charp)v8);
}

//----- (002021DC) --------------------------------------------------------
void __fastcall png_set_pHYs(png_const_structrp_5 png_ptr, png_inforp_5 info_ptr, __int64 res_x, int unit_type)
{
  png_uint_32 valid; // r2

  if ( png_ptr )
  {
    if ( info_ptr )
    {
      *(_QWORD *)&info_ptr->x_pixels_per_unit = res_x;
      valid = info_ptr->valid;
      info_ptr->phys_unit_type = unit_type;
      info_ptr->valid = valid | 0x80;
    }
  }
}

//----- (002021FC) --------------------------------------------------------
void __fastcall png_set_PLTE(png_structrp_7 png_ptr, png_inforp_5 info_ptr, png_const_colorp palette, int num_palette)
{
  bool v5; // zf
  int color_type; // r0
  int v10; // r1
  bool v11; // cc
  bool v12; // zf
  png_color *v13; // r0
  png_color *v14; // r9
  png_uint_32 valid; // r0
  png_uint_32 free_me; // r1

  v5 = png_ptr == 0;
  if ( png_ptr )
    v5 = info_ptr == 0;
  if ( !v5 )
  {
    color_type = info_ptr->color_type;
    if ( color_type == 3 )
      v10 = 1 << info_ptr->bit_depth;
    else
      v10 = 256;
    v11 = num_palette < 0;
    if ( num_palette >= 0 )
      v11 = v10 < num_palette;
    if ( v11 )
    {
      if ( color_type != 3 )
      {
        sub_194634(png_ptr, (png_const_charp)"Invalid palette length");
        return;
      }
      j_png_error(png_ptr, (png_const_charp)"Invalid palette length");
    }
    if ( !palette && num_palette > 0 )
      goto LABEL_23;
    v12 = num_palette == 0;
    if ( !num_palette )
      v12 = LOBYTE(png_ptr->mng_features_permitted) << 31 == 0;
    if ( v12 )
    {
LABEL_23:
      j_png_error(png_ptr, (png_const_charp)"Invalid palette");
      JUMPOUT(0x2022BC);
    }
    j_png_free_data(png_ptr, info_ptr, 0x1000u, 0);
    v13 = (png_color *)j_png_calloc(png_ptr, 0x300u);
    v14 = v13;
    png_ptr->palette = v13;
    if ( num_palette >= 1 )
      qmemcpy(v13, palette, 3 * num_palette);
    info_ptr->palette = v14;
    valid = info_ptr->valid;
    free_me = info_ptr->free_me;
    png_ptr->num_palette = num_palette;
    info_ptr->num_palette = num_palette;
    info_ptr->free_me = free_me | 0x1000;
    info_ptr->valid = valid | 8;
  }
}
// 2022B8: control flows out of bounds to 2022BC

//----- (002022E4) --------------------------------------------------------
void __fastcall png_set_sBIT(png_const_structrp_5 png_ptr, png_inforp_5 info_ptr, png_const_color_8p sig_bit)
{
  bool v3; // zf
  png_uint_32 valid; // r3
  png_byte alpha; // r0
  int v6; // r2

  if ( png_ptr )
  {
    v3 = info_ptr == 0;
    if ( info_ptr )
      v3 = sig_bit == 0;
    if ( !v3 )
    {
      valid = info_ptr->valid;
      alpha = sig_bit->alpha;
      v6 = *(_DWORD *)&sig_bit->red;
      info_ptr->sig_bit.alpha = alpha;
      *(_DWORD *)&info_ptr->sig_bit.red = v6;
      info_ptr->valid = valid | 2;
    }
  }
}

//----- (00202308) --------------------------------------------------------
void __fastcall png_set_sRGB(png_const_structrp_5 png_ptr, png_inforp_5 info_ptr, int srgb_intent)
{
  bool v4; // zf

  v4 = png_ptr == 0;
  if ( png_ptr )
    v4 = info_ptr == 0;
  if ( !v4 )
  {
    j_png_colorspace_set_sRGB(png_ptr, &info_ptr->colorspace, srgb_intent);
    sub_192360(png_ptr, info_ptr);
  }
}

//----- (00202330) --------------------------------------------------------
void __fastcall png_set_sRGB_gAMA_and_cHRM(png_const_structrp_5 png_ptr, png_inforp_5 info_ptr, int srgb_intent)
{
  bool v4; // zf

  v4 = png_ptr == 0;
  if ( png_ptr )
    v4 = info_ptr == 0;
  if ( !v4 )
  {
    if ( j_png_colorspace_set_sRGB(png_ptr, &info_ptr->colorspace, srgb_intent) )
      info_ptr->colorspace.flags |= 0x18u;
    sub_192360(png_ptr, info_ptr);
  }
}

//----- (00202368) --------------------------------------------------------
void __fastcall png_set_iCCP(
        png_const_structrp_5 png_ptr,
        png_inforp_5 info_ptr,
        png_const_charp name,
        int compression_type,
        const png_byte *a5,
        png_uint_32 a6)
{
  const png_byte *v6; // r9
  bool v8; // zf
  bool v11; // zf
  int v12; // r6
  png_alloc_size_t v13; // r11
  unsigned __int8 *v14; // r0
  unsigned __int8 *v15; // r10
  png_byte *v16; // r0
  png_byte *v17; // r6
  png_uint_32 valid; // r0
  png_uint_32 free_me; // r1
  const char *v20; // r1

  v8 = png_ptr == 0;
  if ( png_ptr )
    v8 = info_ptr == 0;
  if ( !v8 )
  {
    v11 = name == 0;
    if ( name )
    {
      v6 = a5;
      v11 = a5 == 0;
    }
    if ( !v11 )
    {
      if ( compression_type )
        j_png_app_error(png_ptr, (png_const_charp)"Invalid iCCP compression method");
      v12 = j_png_colorspace_set_ICC(png_ptr, &info_ptr->colorspace, name, a6, v6, info_ptr->color_type);
      j_png_colorspace_sync_info(png_ptr, info_ptr);
      if ( v12 )
      {
        info_ptr->colorspace.flags |= 0x18u;
        v13 = strlen((const char *)name) + 1;
        v14 = (unsigned __int8 *)j_png_malloc_warn(png_ptr, v13);
        v15 = v14;
        if ( v14 )
        {
          qmemcpy(v14, name, v13);
          v16 = (png_byte *)j_png_malloc_warn(png_ptr, a6);
          v17 = v16;
          if ( v16 )
          {
            qmemcpy(v16, v6, a6);
            j_png_free_data(png_ptr, info_ptr, 0x10u, 0);
            valid = info_ptr->valid;
            free_me = info_ptr->free_me;
            info_ptr->iccp_name = v15;
            info_ptr->iccp_profile = v17;
            info_ptr->iccp_proflen = a6;
            info_ptr->free_me = free_me | 0x10;
            info_ptr->valid = valid | 0x1000;
            return;
          }
          j_png_free(png_ptr, v15);
          v20 = "Insufficient memory to process iCCP profile";
        }
        else
        {
          v20 = "Insufficient memory to process iCCP chunk";
        }
        sub_197EE8(png_ptr, (png_const_charp)v20);
      }
    }
  }
}
// 2023B0: variable 'v6' is possibly undefined

//----- (002024D0) --------------------------------------------------------
void __fastcall png_set_text(
        png_const_structrp_5 png_ptr,
        png_inforp_5 info_ptr,
        png_const_textp text_ptr,
        int num_text)
{
  if ( j_png_set_text_2(png_ptr, info_ptr, text_ptr, num_text) )
  {
    j_png_error(png_ptr, (png_const_charp)"Insufficient memory to store text");
    JUMPOUT(0x2024E8);
  }
}
// 2024E4: control flows out of bounds to 2024E8

//----- (0020250C) --------------------------------------------------------
int __fastcall png_set_text_2(
        png_const_structrp_5 png_ptr,
        png_inforp_5 info_ptr,
        png_const_textp text_ptr,
        int num_text)
{
  int v5; // r4
  png_inforp_5 v6; // r5
  const png_struct *v7; // r6
  int v8; // r10
  bool v9; // zf
  __int64 v10; // kr00_8
  int v12; // r6
  png_textp text; // r1
  char *v15; // r5
  png_uint_32 free_me; // r0
  const char **p_lang_key; // r10
  int v18; // r11
  const char *v19; // r0
  int v20; // r8
  png_text *v21; // r9
  size_t v22; // r5
  const char *v23; // r0
  size_t v24; // r0
  size_t v25; // r2
  const char *v26; // r0
  bool v27; // zf
  int v28; // r0
  size_t v29; // r4
  size_t v30; // r0
  size_t v31; // r4
  size_t v32; // r8
  unsigned __int8 *v33; // r0
  png_charp *p_key; // r6
  unsigned __int8 *v35; // r0
  unsigned __int8 *v36; // r0
  unsigned __int8 *v37; // r0
  size_t v38; // r0
  const char *v39; // r1
  const png_struct *v40; // r0
  png_inforp_5 v42; // [sp+4h] [bp-2Ch]
  int v43; // [sp+8h] [bp-28h]
  png_const_structrp_0 v44; // [sp+Ch] [bp-24h]
  size_t v45; // [sp+10h] [bp-20h]

  v5 = num_text;
  v6 = info_ptr;
  v7 = png_ptr;
  v8 = 0;
  if ( text_ptr )
  {
    v9 = png_ptr == 0;
    if ( png_ptr )
      v9 = info_ptr == 0;
    if ( !v9 && num_text >= 1 )
    {
      v10 = *(_QWORD *)&info_ptr->num_text;
      if ( HIDWORD(v10) - (int)v10 < num_text )
      {
        v12 = 0x7FFFFFFF;
        if ( 0x7FFFFFFF - (int)v10 < num_text )
          goto LABEL_43;
        text = info_ptr->text;
        if ( (int)v10 + num_text < 2147483639 )
          v12 = (v10 + num_text + 8) & 0xFFFFFFF8;
        v15 = j_png_realloc_array(png_ptr, text, v10, v12 - v10, 0x1Cu);
        if ( !v15 )
        {
LABEL_43:
          v39 = "too many text chunks";
          v8 = 1;
          v40 = png_ptr;
          goto LABEL_45;
        }
        j_png_free(png_ptr, info_ptr->text);
        free_me = info_ptr->free_me;
        info_ptr->max_text = v12;
        v7 = png_ptr;
        info_ptr->text = (png_textp)v15;
        v6 = info_ptr;
        info_ptr->free_me = free_me | 0x4000;
      }
      v8 = 0;
      if ( v5 >= 1 )
      {
        p_lang_key = (const char **)&text_ptr->lang_key;
        v18 = 0;
        v42 = v6;
        v43 = v5;
        v44 = v7;
        while ( 1 )
        {
          v19 = *(p_lang_key - 5);
          if ( v19 )
          {
            v20 = (int)*(p_lang_key - 6);
            if ( (unsigned int)(v20 + 1) < 4 )
            {
              v21 = &v6->text[v6->num_text];
              v22 = strlen(v19);
              if ( v20 < 1 )
              {
                v25 = 0;
                v45 = 0;
              }
              else
              {
                v23 = *(p_lang_key - 1);
                if ( v23 )
                  v24 = strlen(v23);
                else
                  v24 = 0;
                v45 = v24;
                if ( *p_lang_key )
                  v25 = strlen(*p_lang_key);
                else
                  v25 = 0;
              }
              v26 = *(p_lang_key - 4);
              v27 = v26 == 0;
              if ( v26 )
                v27 = *v26 == 0;
              if ( v27 )
              {
                v28 = -1;
                if ( v20 > 0 )
                  v28 = 1;
                v31 = 0;
                v21->compression = v28;
              }
              else
              {
                v29 = v25;
                v30 = strlen(v26);
                v25 = v29;
                v31 = v30;
                v21->compression = v20;
              }
              v32 = v25;
              v33 = (unsigned __int8 *)j_png_malloc_base(v7, v45 + v22 + v25 + v31 + 4);
              v21->key = v33;
              p_key = &v21->key;
              if ( !v33 )
              {
                v39 = "text chunk: out of memory";
                v8 = 1;
                v40 = v44;
LABEL_45:
                j_png_chunk_report(v40, (png_const_charp)v39, 1);
                return v8;
              }
              qmemcpy(v33, *(p_lang_key - 5), v22);
              (*p_key)[v22] = 0;
              if ( (int)*(p_lang_key - 6) < 1 )
              {
                v32 = v22;
                v21->lang = 0;
                v21->lang_key = 0;
              }
              else
              {
                v35 = &(*p_key)[v22 + 1];
                v21->lang = v35;
                qmemcpy(v35, *(p_lang_key - 1), v45);
                v21->lang[v45] = 0;
                v36 = &v21->lang[v45 + 1];
                v21->lang_key = v36;
                qmemcpy(v36, *p_lang_key, v32);
                v21->lang_key[v32] = 0;
                p_key = &v21->lang_key;
              }
              v37 = &(*p_key)[v32 + 1];
              v21->text = v37;
              if ( v31 )
              {
                qmemcpy(v37, *(p_lang_key - 4), v31);
                v37 = v21->text;
              }
              v7 = v44;
              v37[v31] = 0;
              v38 = 0;
              if ( v21->compression > 0 )
              {
                v38 = v31;
                v31 = 0;
              }
              v21->text_length = v31;
              v21->itxt_length = v38;
              v6 = v42;
              v5 = v43;
              ++v42->num_text;
            }
            else
            {
              j_png_chunk_report(v7, (png_const_charp)"text compression mode is out of range", 1);
            }
          }
          ++v18;
          p_lang_key += 7;
          if ( v18 >= v5 )
            return 0;
        }
      }
    }
  }
  return v8;
}

//----- (002027A8) --------------------------------------------------------
void __fastcall png_set_tIME(png_const_structrp_5 png_ptr, png_inforp_5 info_ptr, png_const_timep mod_time)
{
  bool v3; // zf
  unsigned int v4; // r3
  bool v5; // cc
  unsigned int minute; // r3
  bool v7; // cf
  png_uint_32 valid; // r3
  int v9; // r0

  if ( png_ptr )
  {
    v3 = info_ptr == 0;
    if ( info_ptr )
      v3 = mod_time == 0;
    if ( !v3 && (png_ptr->mode & 0x200) == 0 )
    {
      if ( (unsigned __int8)(mod_time->month - 1) > 0xBu )
        goto LABEL_14;
      v4 = (unsigned __int8)(mod_time->day - 1);
      v5 = v4 > 0x1E;
      if ( v4 <= 0x1E )
        v5 = mod_time->hour > 0x17u;
      if ( v5 )
        goto LABEL_14;
      minute = mod_time->minute;
      v7 = minute >= 0x3B;
      if ( minute <= 0x3B )
        v7 = mod_time->second >= 0x3Du;
      if ( v7 )
      {
LABEL_14:
        sub_194634(png_ptr, (png_const_charp)"Ignoring invalid time value");
      }
      else
      {
        valid = info_ptr->valid;
        v9 = *(_DWORD *)&mod_time->year;
        *(_DWORD *)&info_ptr->mod_time.hour = *(_DWORD *)&mod_time->hour;
        *(_DWORD *)&info_ptr->mod_time.year = v9;
        info_ptr->valid = valid | 0x200;
      }
    }
  }
}

//----- (0020281C) --------------------------------------------------------
void __fastcall png_set_tRNS(
        png_structrp_7 png_ptr,
        png_inforp_5 info_ptr,
        png_const_bytep trans_alpha,
        int num_trans,
        __int64 *a5)
{
  bool v6; // zf
  png_byte *v10; // r9
  unsigned int bit_depth; // r0
  int v12; // r0
  int v13; // r1
  bool v14; // cc
  __int64 v15; // d16
  png_uint_32 free_me; // r1

  v6 = png_ptr == 0;
  if ( png_ptr )
    v6 = info_ptr == 0;
  if ( !v6 )
  {
    if ( trans_alpha )
    {
      j_png_free_data(png_ptr, info_ptr, 0x2000u, 0);
      if ( (unsigned int)(num_trans - 1) >= 0x100 )
      {
        v10 = info_ptr->trans_alpha;
      }
      else
      {
        v10 = (png_byte *)j_png_malloc(png_ptr, 0x100u);
        info_ptr->trans_alpha = v10;
        qmemcpy(v10, trans_alpha, num_trans);
      }
      png_ptr->trans_alpha = v10;
    }
    if ( a5 )
    {
      bit_depth = info_ptr->bit_depth;
      if ( bit_depth > 0xF )
        goto LABEL_22;
      v12 = 1 << bit_depth;
      if ( info_ptr->color_type == 2 )
      {
        v13 = *((unsigned __int16 *)a5 + 1);
        v14 = v12 <= v13;
        if ( v12 > v13 )
          v14 = v12 <= *((unsigned __int16 *)a5 + 2);
        if ( !v14 && v12 > *((unsigned __int16 *)a5 + 3) )
          goto LABEL_22;
      }
      else if ( info_ptr->color_type || v12 > *((unsigned __int16 *)a5 + 4) )
      {
LABEL_22:
        v15 = *a5;
        info_ptr->trans_color.gray = *((_WORD *)a5 + 4);
        if ( !num_trans )
          LOWORD(num_trans) = 1;
        info_ptr->num_trans = num_trans;
        *(_QWORD *)&info_ptr->trans_color.index = v15;
        goto LABEL_25;
      }
      j_png_warning(png_ptr, (png_const_charp)"tRNS chunk has out-of-range samples for bit_depth");
      goto LABEL_22;
    }
    info_ptr->num_trans = num_trans;
    if ( num_trans )
    {
LABEL_25:
      free_me = info_ptr->free_me;
      info_ptr->valid |= 0x10u;
      info_ptr->free_me = free_me | 0x2000;
    }
  }
}

//----- (0020293C) ------------------------------------------